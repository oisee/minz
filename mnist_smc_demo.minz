// SMC Work Area Demo for MNIST Editor
// Demonstrates TRUE SMC optimization for array access

// Canvas work area - SMC will optimize all access
let mut canvas: [32]u8;
let mut cursor_x: u8;
let mut cursor_y: u8;

// Initialize work area
fun init_work_area() -> void {
    cursor_x = 8;
    cursor_y = 8;
    
    // Clear work area - SMC optimizes each array access
    let mut i: u8 = 0;
    while i < 32 {
        canvas[i] = 0;  // SMC patches to direct memory store
        i = i + 1;
    }
}

// Toggle pixel using SMC work area
fun toggle_pixel() -> void {
    let x: u8 = cursor_x;
    let y: u8 = cursor_y;
    
    let byte_idx: u8 = (y * 2) + (x / 8);
    let bit_idx: u8 = x & 7;
    let mask: u8 = 128 >> bit_idx;
    
    // SMC optimizes this to direct memory XOR
    canvas[byte_idx] = canvas[byte_idx] ^ mask;
}

// Set pixel using SMC
fun set_pixel(x: u8, y: u8) -> void {
    let byte_idx: u8 = (y * 2) + (x / 8);
    let bit_idx: u8 = x & 7;
    let mask: u8 = 128 >> bit_idx;
    
    // SMC direct memory OR operation
    canvas[byte_idx] = canvas[byte_idx] | mask;
}

// Clear pixel using SMC
fun clear_pixel(x: u8, y: u8) -> void {
    let byte_idx: u8 = (y * 2) + (x / 8);
    let bit_idx: u8 = x & 7;
    let inv_mask: u8 = ~(128 >> bit_idx);
    
    // SMC direct memory AND operation
    canvas[byte_idx] = canvas[byte_idx] & inv_mask;
}

// Check pixel using SMC work area
fun is_pixel_set(x: u8, y: u8) -> bool {
    let byte_idx: u8 = (y * 2) + (x / 8);
    let bit_idx: u8 = x & 7;
    let mask: u8 = 128 >> bit_idx;
    
    // SMC optimized memory read
    return (canvas[byte_idx] & mask) != 0;
}

// Move cursor functions
fun move_up() -> void {
    if cursor_y > 0 {
        cursor_y = cursor_y - 1;
    }
}

fun move_down() -> void {
    if cursor_y < 15 {
        cursor_y = cursor_y + 1;
    }
}

fun move_left() -> void {
    if cursor_x > 0 {
        cursor_x = cursor_x - 1;
    }
}

fun move_right() -> void {
    if cursor_x < 15 {
        cursor_x = cursor_x + 1;
    }
}

// Clear entire work area using SMC
fun clear_all() -> void {
    // Use modern do times syntax - SMC optimizes array access
    let mut i: u8 = 0;
    do 32 times {
        canvas[i] = 0;  // SMC direct store
        i = i + 1;
    }
}

// Count set pixels using SMC work area
fun count_pixels() -> u16 {
    let mut count: u16 = 0;
    
    let mut i: u8 = 0;
    while i < 32 {
        let byte_val: u8 = canvas[i];  // SMC optimized read
        
        // Count bits in byte
        let mut temp: u8 = byte_val;
        while temp != 0 {
            if (temp & 1) != 0 {
                count = count + 1;
            }
            temp = temp >> 1;
        }
        
        i = i + 1;
    }
    
    return count;
}

// Draw a pattern using SMC work area
fun draw_pattern() -> void {
    // Draw diagonal line
    let mut i: u8 = 0;
    while i < 16 {
        set_pixel(i, i);
        i = i + 1;
    }
    
    // Draw border
    let mut edge: u8 = 0;
    while edge < 16 {
        set_pixel(edge, 0);     // Top
        set_pixel(edge, 15);    // Bottom
        set_pixel(0, edge);     // Left
        set_pixel(15, edge);    // Right
        edge = edge + 1;
    }
}

// Simulate editing session
fun simulate_editing() -> void {
    // Move around and toggle pixels
    let mut step: u8 = 0;
    while step < 20 {
        let action: u8 = step & 3;
        
        if action == 0 {
            move_right();
            toggle_pixel();
        } else if action == 1 {
            move_down();
            toggle_pixel();
        } else if action == 2 {
            move_left();
            toggle_pixel();
        } else {
            move_up();
            toggle_pixel();
        }
        
        step = step + 1;
    }
}

// Main demonstration of SMC work areas
fun main() -> void {
    // Initialize SMC work area
    init_work_area();
    
    // Demonstrate SMC-optimized operations
    draw_pattern();
    
    let pixel_count: u16 = count_pixels();
    
    // Simulate user interaction
    simulate_editing();
    
    let new_count: u16 = count_pixels();
    
    // More SMC operations
    clear_pixel(5, 5);
    set_pixel(10, 10);
    
    let final_count: u16 = count_pixels();
    
    // Test cursor at different positions
    cursor_x = 0;
    cursor_y = 0;
    toggle_pixel();
    
    cursor_x = 15;
    cursor_y = 15;
    toggle_pixel();
    
    cursor_x = 8;
    cursor_y = 8;
    toggle_pixel();
    
    // Final clear using SMC
    clear_all();
}