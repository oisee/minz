// Test error type validation with new syntax

// Define error enums
enum MathError {
    DivideByZero,
    Overflow,
}

enum ParseError {
    InvalidFormat,
    OutOfRange,
}

// Function with strict error type - can only return MathError
fun strict_divide?(a: u8, b: u8) -> u8 ? MathError {
    if b == 0 {
        @error(MathError.DivideByZero);  // ✅ Correct error type
    }
    // @error(ParseError.InvalidFormat);  // ❌ This should cause compile error
    return a / b;
}

// Function without declared error type - can return any error
fun loose_operation?(input: u8) -> u8 {
    @error(MathError.Overflow);         // ✅ Any error allowed
    @error(ParseError.InvalidFormat);   // ✅ Any error allowed  
    @error(42);                         // ✅ Raw value allowed
    return input;
}

fun main() -> void {
    let result1 = strict_divide?(10, 2) ?? 99;
    let result2 = strict_divide?(10, 0) ?? 99;  // This will trigger error
    let result3 = loose_operation?(0) ?? 42;
    
    @print("Results: {} {} {}", result1, result2, result3);
}