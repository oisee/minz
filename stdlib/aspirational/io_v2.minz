// MinZ Standard I/O Library v2 - Zero-Cost Metafunction Implementation
// Uses compile-time string processing and interface monomorphization

// Printable interface - anything that can be converted to string
pub interface Printable {
    fun to_string(self) -> *u8;
}

// Basic type implementations of Printable
impl Printable for u8 {
    fun to_string(self) -> *u8 {
        @static_buffer(4);  // Compile-time allocated buffer
        @format_u8(self);   // Metafunction generates optimal code
    }
}

impl Printable for u16 {
    fun to_string(self) -> *u8 {
        @static_buffer(6);
        @format_u16(self);
    }
}

impl Printable for i8 {
    fun to_string(self) -> *u8 {
        @static_buffer(5);  // Including sign
        @format_i8(self);
    }
}

impl Printable for i16 {
    fun to_string(self) -> *u8 {
        @static_buffer(7);  // Including sign
        @format_i16(self);
    }
}

impl Printable for bool {
    fun to_string(self) -> *u8 {
        if self { "true" } else { "false" }
    }
}

// Compile-time format string processing
@lua {
    -- Parse format string at compile time
    function parse_format_string(fmt)
        local parts = {}
        local args = {}
        local i = 1
        
        while i <= #fmt do
            local start = i
            -- Find next placeholder
            while i <= #fmt and fmt:sub(i, i) ~= '{' do
                i = i + 1
            end
            
            if i > start then
                -- Add literal part
                table.insert(parts, {type = "literal", value = fmt:sub(start, i-1)})
            end
            
            if i <= #fmt and fmt:sub(i, i) == '{' then
                i = i + 1
                if i <= #fmt and fmt:sub(i, i) == '{' then
                    -- Escaped {
                    table.insert(parts, {type = "literal", value = "{"})
                    i = i + 1
                else
                    -- Parse placeholder
                    local end_pos = fmt:find('}', i)
                    if end_pos then
                        local placeholder = fmt:sub(i, end_pos-1)
                        table.insert(parts, {type = "arg", index = #args + 1})
                        table.insert(args, placeholder)
                        i = end_pos + 1
                    else
                        error("Unclosed placeholder in format string")
                    end
                end
            end
        end
        
        return parts, args
    end
    
    -- Generate optimized print code
    function generate_print_code(fmt, ...)
        local parts, arg_names = parse_format_string(fmt)
        local args = {...}
        local code = {}
        
        for _, part in ipairs(parts) do
            if part.type == "literal" then
                -- Inline literal strings
                table.insert(code, string.format('_print_literal("%s");', part.value))
            else
                -- Call to_string on argument
                local arg = args[part.index]
                table.insert(code, string.format('%s.to_string().print();', arg))
            end
        end
        
        return table.concat(code, '\n')
    end
}

// Zero-cost print! macro - all formatting happens at compile time
@macro print!(fmt: string_literal, args...) {
    @lua {
        emit_code(generate_print_code(fmt, unpack(args)))
    }
}

// Examples of zero-cost printing:
// print!("Hello, {}!", name)
// Compiles to:
//   _print_literal("Hello, ");
//   name.to_string().print();
//   _print_literal("!");

// print!("x = {}, y = {}", x, y)
// Compiles to:
//   _print_literal("x = ");
//   x.to_string().print();
//   _print_literal(", y = ");
//   y.to_string().print();

// Optimal number formatting metafunctions
@metafun format_u8(value: u8) -> void {
    @lua {
        -- Generate optimal code for u8 formatting
        -- For single digit: direct conversion
        -- For two digits: one division
        -- For three digits: two divisions
        emit_asm([[
            ; Optimized u8 to string
            LD A, {value}
            CP 10
            JR NC, .two_digits
            ; Single digit
            ADD A, '0'
            LD (buffer), A
            XOR A
            LD (buffer+1), A
            RET
        .two_digits:
            CP 100
            JR NC, .three_digits
            ; Two digits - divide by 10 once
            LD B, 10
            CALL div_u8_u8
            ADD A, '0'
            LD (buffer), A
            LD A, C  ; Remainder
            ADD A, '0'
            LD (buffer+1), A
            XOR A
            LD (buffer+2), A
            RET
        .three_digits:
            ; Three digits - full conversion
            CALL convert_u8_full
            RET
        ]])
    }
}

// String builder with compile-time capacity
pub struct StringBuilder<const N: u16> {
    buffer: [u8; N],
    pos: u16,
}

impl<const N: u16> StringBuilder<N> {
    pub fun new() -> StringBuilder<N> {
        StringBuilder {
            buffer: [0; N],
            pos: 0,
        }
    }
    
    pub fun append(mut self, str: *u8) -> void {
        @unroll {  // Compile-time loop unrolling
            while *str != 0 && self.pos < N - 1 {
                self.buffer[self.pos] = *str;
                self.pos += 1;
                str += 1;
            }
        }
    }
    
    pub fun append_char(mut self, ch: u8) -> void {
        if self.pos < N - 1 {
            self.buffer[self.pos] = ch;
            self.pos += 1;
        }
    }
    
    pub fun to_string(self) -> *u8 {
        self.buffer[self.pos] = 0;  // Null terminate
        &self.buffer[0]
    }
}

// Platform-agnostic output trait
pub trait Output {
    fun write_byte(byte: u8) -> void;
    fun write_string(str: *u8) -> void;
}

// Select output implementation at compile time
@compile_time_select {
    @if(platform == "zx_spectrum") {
        use zx.screen.Output;
    }
    @if(platform == "cpm") {
        use cpm.console.Output;
    }
    @if(platform == "msx") {
        use msx.bios.Output;
    }
}

// Internal helpers
fun _print_literal(str: string_literal) -> void {
    @compile_time {
        // For string literals, we can optimize even further
        if len(str) == 1 {
            // Single character - inline
            Output.write_byte(str[0]);
        } else if len(str) <= 4 {
            // Short string - unroll
            @unroll for ch in str {
                Output.write_byte(ch);
            }
        } else {
            // Longer string - use write_string
            Output.write_string(str);
        }
    }
}

// Advanced formatting with zero runtime cost
pub struct Formatter {
    width: u8,
    precision: u8,
    flags: u8,
}

const FLAG_LEFT_ALIGN: u8 = 0x01;
const FLAG_ZERO_PAD: u8 = 0x02;
const FLAG_SIGN: u8 = 0x04;
const FLAG_SPACE: u8 = 0x08;
const FLAG_HASH: u8 = 0x10;

impl Formatter {
    @compile_time
    pub fun parse(fmt: string_literal) -> Formatter {
        @lua {
            -- Parse format specifier like "%08x" at compile time
            local width = 0
            local precision = 0
            local flags = 0
            
            -- Parsing logic here...
            
            return Formatter {
                width = width,
                precision = precision,
                flags = flags
            }
        }
    }
    
    pub fun format_u16_hex(self, value: u16) -> void {
        @compile_time_if(self.flags & FLAG_ZERO_PAD) {
            // Generate zero-padding code
            @emit_hex_with_padding(value, self.width);
        } else {
            // Generate space-padding code
            @emit_hex_with_spaces(value, self.width);
        }
    }
}

// Usage example showing zero runtime overhead:
pub fun debug_print_registers(a: u8, bc: u16, de: u16, hl: u16) -> void {
    // This entire function call is optimized at compile time!
    print!("A={:02x} BC={:04x} DE={:04x} HL={:04x}\n", a, bc, de, hl);
    
    // Compiles to approximately:
    // _print_literal("A=");
    // print_hex_u8_padded(a, 2);
    // _print_literal(" BC=");
    // print_hex_u16_padded(bc, 4);
    // _print_literal(" DE=");
    // print_hex_u16_padded(de, 4);
    // _print_literal(" HL=");
    // print_hex_u16_padded(hl, 4);
    // Output.write_byte('\n');
}

// Compile-time string interpolation
@macro s!(fmt: string_literal, args...) -> *u8 {
    @compile_time {
        // Build string at compile time
        let builder = StringBuilder<256>.new();
        @lua {
            generate_string_building_code(fmt, args, builder)
        }
        builder.to_string()
    }
}

// Example: let msg = s!("Error at line {}: {}", line_no, error_msg);
// Generates optimal string building code with no runtime parsing