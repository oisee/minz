// MinZ Standard Library - Collections Module
// Zero-allocation collections for embedded systems

import std.core.*;

// Fixed-size vector with stack allocation
struct FixedVec<T, const N: u16> {
    data: [T; N],
    len: u16
}

impl<T, const N: u16> FixedVec<T, N> {
    fun new() -> Self {
        Self {
            data: @uninit(),  // Uninitialized array
            len: 0
        }
    }
    
    fun len(self) -> u16 {
        self.len
    }
    
    fun is_empty(self) -> bool {
        self.len == 0
    }
    
    fun is_full(self) -> bool {
        self.len == N
    }
    
    fun capacity(self) -> u16 {
        N
    }
    
    fun push(mut self, value: T) -> Result<void, void> {
        if self.len >= N {
            return Err(void);
        }
        self.data[self.len] = value;
        self.len += 1;
        Ok(void)
    }
    
    fun pop(mut self) -> Option<T> {
        if self.len == 0 {
            return None;
        }
        self.len -= 1;
        Some(self.data[self.len])
    }
    
    fun get(self, index: u16) -> Option<*T> {
        if index >= self.len {
            return None;
        }
        Some(&self.data[index])
    }
    
    fun get_mut(mut self, index: u16) -> Option<*mut T> {
        if index >= self.len {
            return None;
        }
        Some(&mut self.data[index])
    }
    
    fun clear(mut self) -> void {
        self.len = 0;
    }
    
    fun truncate(mut self, new_len: u16) -> void {
        if new_len < self.len {
            self.len = new_len;
        }
    }
    
    // Iterator support
    fun iter(self) -> FixedVecIter<T, N> {
        FixedVecIter {
            vec: &self,
            index: 0
        }
    }
    
    fun iter_mut(mut self) -> FixedVecIterMut<T, N> {
        FixedVecIterMut {
            vec: &mut self,
            index: 0
        }
    }
}

// Iterator for FixedVec
struct FixedVecIter<T, const N: u16> {
    vec: *FixedVec<T, N>,
    index: u16
}

impl<T, const N: u16> Iterator for FixedVecIter<T, N> {
    type Item = *T;
    
    fun next(mut self) -> Option<*T> {
        if self.index >= self.vec.len {
            return None;
        }
        let result = &self.vec.data[self.index];
        self.index += 1;
        Some(result)
    }
}

// Ring buffer for circular queues
struct RingBuffer<T, const N: u16> {
    data: [T; N],
    head: u16,  // Next write position
    tail: u16,  // Next read position
    full: bool
}

impl<T, const N: u16> RingBuffer<T, N> {
    fun new() -> Self {
        Self {
            data: @uninit(),
            head: 0,
            tail: 0,
            full: false
        }
    }
    
    fun len(self) -> u16 {
        if self.full {
            return N;
        }
        if self.head >= self.tail {
            return self.head - self.tail;
        }
        return N - self.tail + self.head;
    }
    
    fun is_empty(self) -> bool {
        !self.full && self.head == self.tail
    }
    
    fun is_full(self) -> bool {
        self.full
    }
    
    fun push(mut self, value: T) -> Result<void, T> {
        if self.full {
            return Err(value);  // Return the value that couldn't be inserted
        }
        
        self.data[self.head] = value;
        self.head = (self.head + 1) % N;
        
        if self.head == self.tail {
            self.full = true;
        }
        
        Ok(void)
    }
    
    fun pop(mut self) -> Option<T> {
        if self.is_empty() {
            return None;
        }
        
        let value = self.data[self.tail];
        self.tail = (self.tail + 1) % N;
        self.full = false;
        
        Some(value)
    }
    
    fun peek(self) -> Option<*T> {
        if self.is_empty() {
            return None;
        }
        Some(&self.data[self.tail])
    }
}

// Bit set for efficient flag storage
struct BitSet<const N: u16> {
    // Store bits in u8 array, N is number of bits
    data: [u8; (N + 7) / 8]
}

impl<const N: u16> BitSet<N> {
    fun new() -> Self {
        Self {
            data: [0; (N + 7) / 8]
        }
    }
    
    fun set(mut self, index: u16) -> void {
        if index >= N { return; }
        let byte_index = index / 8;
        let bit_index = index % 8;
        self.data[byte_index] |= 1 << bit_index;
    }
    
    fun clear(mut self, index: u16) -> void {
        if index >= N { return; }
        let byte_index = index / 8;
        let bit_index = index % 8;
        self.data[byte_index] &= ~(1 << bit_index);
    }
    
    fun toggle(mut self, index: u16) -> void {
        if index >= N { return; }
        let byte_index = index / 8;
        let bit_index = index % 8;
        self.data[byte_index] ^= 1 << bit_index;
    }
    
    fun get(self, index: u16) -> bool {
        if index >= N { return false; }
        let byte_index = index / 8;
        let bit_index = index % 8;
        (self.data[byte_index] & (1 << bit_index)) != 0
    }
    
    fun count_ones(self) -> u16 {
        let mut count = 0;
        for byte in self.data {
            count += bits.count_ones(byte) as u16;
        }
        count
    }
    
    fun clear_all(mut self) -> void {
        for i in 0..((N + 7) / 8) {
            self.data[i] = 0;
        }
    }
    
    fun set_all(mut self) -> void {
        // Set all full bytes
        let full_bytes = N / 8;
        for i in 0..full_bytes {
            self.data[i] = 0xFF;
        }
        
        // Set remaining bits
        let remaining_bits = N % 8;
        if remaining_bits > 0 {
            self.data[full_bytes] = (1 << remaining_bits) - 1;
        }
    }
}

// Static string with maximum size
struct FixedString<const N: u16> {
    data: [u8; N],
    len: u16
}

impl<const N: u16> FixedString<N> {
    fun new() -> Self {
        Self {
            data: [0; N],
            len: 0
        }
    }
    
    fun from_str(s: *str) -> Self {
        let mut result = Self.new();
        result.append_str(s);
        result
    }
    
    fun len(self) -> u16 {
        self.len
    }
    
    fun is_empty(self) -> bool {
        self.len == 0
    }
    
    fun capacity(self) -> u16 {
        N
    }
    
    fun as_str(self) -> *str {
        // Return as MinZ string (length-prefixed)
        // This is a bit tricky - need to ensure length byte is included
        @unsafe_cast(*str, &self.len)
    }
    
    fun clear(mut self) -> void {
        self.len = 0;
    }
    
    fun push(mut self, ch: u8) -> Result<void, void> {
        if self.len >= N {
            return Err(void);
        }
        self.data[self.len] = ch;
        self.len += 1;
        Ok(void)
    }
    
    fun append_str(mut self, s: *str) -> Result<void, void> {
        let str_len = str.len(s);
        if self.len + str_len > N {
            return Err(void);
        }
        
        // Copy string data
        mem.copy(&self.data[self.len], str.data(s), str_len);
        self.len += str_len;
        Ok(void)
    }
    
    fun append_u8(mut self, value: u8) -> Result<void, void> {
        // Convert to decimal and append
        if value == 0 {
            return self.push(48);  // '0'
        }
        
        // Extract digits in reverse
        let mut digits: [u8; 3] = [0; 3];
        let mut digit_count = 0;
        let mut v = value;
        
        while v > 0 {
            digits[digit_count] = 48 + (v % 10);  // '0' + digit
            v /= 10;
            digit_count += 1;
        }
        
        // Append digits in correct order
        for i in 0..digit_count {
            self.push(digits[digit_count - 1 - i])?;
        }
        
        Ok(void)
    }
}

// Small vector optimization - uses stack for small sizes, heap for large
// (Note: MinZ doesn't have heap allocation yet, so this is future-looking)
struct SmallVec<T, const INLINE_CAP: u16> {
    // If len <= INLINE_CAP, use inline storage
    // Otherwise, use heap allocation (when available)
    inline: [T; INLINE_CAP],
    len: u16,
    // Future: heap_ptr: *T
}

// Deque (double-ended queue) with fixed size
struct Deque<T, const N: u16> {
    data: [T; N],
    head: u16,
    len: u16
}

impl<T, const N: u16> Deque<T, N> {
    fun new() -> Self {
        Self {
            data: @uninit(),
            head: 0,
            len: 0
        }
    }
    
    fun push_front(mut self, value: T) -> Result<void, T> {
        if self.len >= N {
            return Err(value);
        }
        
        // Move head backwards (with wrapping)
        self.head = if self.head == 0 { N - 1 } else { self.head - 1 };
        self.data[self.head] = value;
        self.len += 1;
        Ok(void)
    }
    
    fun push_back(mut self, value: T) -> Result<void, T> {
        if self.len >= N {
            return Err(value);
        }
        
        let tail = (self.head + self.len) % N;
        self.data[tail] = value;
        self.len += 1;
        Ok(void)
    }
    
    fun pop_front(mut self) -> Option<T> {
        if self.len == 0 {
            return None;
        }
        
        let value = self.data[self.head];
        self.head = (self.head + 1) % N;
        self.len -= 1;
        Some(value)
    }
    
    fun pop_back(mut self) -> Option<T> {
        if self.len == 0 {
            return None;
        }
        
        self.len -= 1;
        let tail = (self.head + self.len) % N;
        Some(self.data[tail])
    }
}