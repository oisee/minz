// CP/M I/O Implementation
// Implements the standard I/O interfaces for CP/M systems

import std.io;

// CP/M BDOS function numbers
const BDOS: u16 = 0x0005;          // BDOS entry point
const BDOS_CONIN: u8 = 1;          // Console input
const BDOS_CONOUT: u8 = 2;         // Console output
const BDOS_READER_IN: u8 = 3;      // Reader input
const BDOS_PUNCH_OUT: u8 = 4;      // Punch output
const BDOS_LIST_OUT: u8 = 5;       // List output
const BDOS_DIRECT_IO: u8 = 6;      // Direct console I/O
const BDOS_GET_IO_BYTE: u8 = 7;    // Get I/O byte
const BDOS_SET_IO_BYTE: u8 = 8;    // Set I/O byte
const BDOS_PRINT_STRING: u8 = 9;   // Print string
const BDOS_READ_BUFFER: u8 = 10;   // Read console buffer
const BDOS_CONSOLE_STATUS: u8 = 11; // Console status

// CP/M implementation of Reader
struct CPMStdin {
    use_direct: bool,  // Use direct I/O for non-blocking
}

impl Reader for CPMStdin {
    fun read_byte(self) -> u8 {
        let result: u8;
        @asm {
            LD C, BDOS_CONIN
            CALL BDOS
            LD (result), A
        }
        result
    }
    
    fun read_bytes(self, buffer: *u8, len: u16) -> u16 {
        // For efficiency, use BDOS buffer read for longer inputs
        if len > 16 {
            return read_buffer_cpm(buffer, len);
        }
        
        // For short reads, use byte-by-byte
        let mut count: u16 = 0;
        while count < len {
            buffer[count] = self.read_byte();
            if buffer[count] == '\r' || buffer[count] == '\n' {
                buffer[count] = '\n';  // Normalize line endings
                count = count + 1;
                break;
            }
            count = count + 1;
        }
        count
    }
    
    fun available(self) -> bool {
        let status: u8;
        @asm {
            LD C, BDOS_CONSOLE_STATUS
            CALL BDOS
            LD (status), A
        }
        status != 0
    }
}

// CP/M implementation of Writer
struct CPMStdout {
    // No state needed
}

impl Writer for CPMStdout {
    fun write_byte(self, byte: u8) -> void {
        // Convert \n to \r\n for CP/M
        if byte == '\n' {
            @asm {
                LD C, BDOS_CONOUT
                LD E, 13        ; CR
                CALL BDOS
                LD C, BDOS_CONOUT
                LD E, 10        ; LF
                CALL BDOS
            }
        } else {
            @asm {
                LD C, BDOS_CONOUT
                LD E, (byte)
                CALL BDOS
            }
        }
    }
    
    fun write_bytes(self, buffer: *u8, len: u16) -> u16 {
        // For efficiency, could use BDOS print string for null-terminated strings
        if is_null_terminated(buffer, len) {
            print_string_cpm(buffer);
            return len;
        }
        
        // Otherwise, byte-by-byte
        let mut count: u16 = 0;
        while count < len {
            self.write_byte(buffer[count]);
            count = count + 1;
        }
        count
    }
    
    fun flush(self) -> void {
        // CP/M doesn't buffer console output
    }
}

// CP/M stderr goes to list device
struct CPMStderr {
    // No state needed
}

impl Writer for CPMStderr {
    fun write_byte(self, byte: u8) -> void {
        @asm {
            LD C, BDOS_LIST_OUT
            LD E, (byte)
            CALL BDOS
        }
    }
    
    fun write_bytes(self, buffer: *u8, len: u16) -> u16 {
        let mut count: u16 = 0;
        while count < len {
            self.write_byte(buffer[count]);
            count = count + 1;
        }
        count
    }
    
    fun flush(self) -> void {
        // No buffering
    }
}

// Global instances
pub let stdin = CPMStdin { use_direct: false };
pub let stdout = CPMStdout {};
pub let stderr = CPMStderr {};

// CP/M specific functions
fun read_buffer_cpm(buffer: *u8, max_len: u16) -> u16 {
    // CP/M buffer format: max_len, actual_len, data...
    let mut cpm_buffer: [u8; 258];  // Max 255 chars + overhead
    
    if max_len > 255 {
        max_len = 255;  // CP/M limit
    }
    
    cpm_buffer[0] = max_len as u8;
    
    @asm {
        LD C, BDOS_READ_BUFFER
        LD DE, cpm_buffer
        CALL BDOS
    }
    
    // Copy result to user buffer
    let actual_len = cpm_buffer[1];
    let mut i: u8 = 0;
    while i < actual_len {
        buffer[i] = cpm_buffer[i + 2];
        i = i + 1;
    }
    
    actual_len as u16
}

fun print_string_cpm(str: *u8) -> void {
    // CP/M requires $ terminator, but we use null termination
    // So we need to be careful or use byte-by-byte output
    let mut i: u16 = 0;
    while str[i] != 0 && str[i] != '$' {
        stdout.write_byte(str[i]);
        i = i + 1;
    }
}

fun is_null_terminated(buffer: *u8, len: u16) -> bool {
    let mut i: u16 = 0;
    while i < len {
        if buffer[i] == 0 {
            return true;
        }
        i = i + 1;
    }
    false
}

// File I/O support (basic)
pub struct File {
    fcb: [u8; 36],  // CP/M File Control Block
    is_open: bool,
}

const BDOS_OPEN_FILE: u8 = 15;
const BDOS_CLOSE_FILE: u8 = 16;
const BDOS_READ_SEQ: u8 = 20;
const BDOS_WRITE_SEQ: u8 = 21;
const BDOS_MAKE_FILE: u8 = 22;
const BDOS_DELETE_FILE: u8 = 19;

impl File {
    pub fun open(filename: *u8) -> File {
        let mut file = File {
            fcb: [0; 36],
            is_open: false,
        };
        
        // Parse filename into FCB format
        parse_filename(filename, &file.fcb);
        
        let result: u8;
        @asm {
            LD C, BDOS_OPEN_FILE
            LD DE, file.fcb
            CALL BDOS
            LD (result), A
        }
        
        if result != 0xFF {
            file.is_open = true;
        }
        
        file
    }
    
    pub fun create(filename: *u8) -> File {
        let mut file = File {
            fcb: [0; 36],
            is_open: false,
        };
        
        parse_filename(filename, &file.fcb);
        
        let result: u8;
        @asm {
            LD C, BDOS_MAKE_FILE
            LD DE, file.fcb
            CALL BDOS
            LD (result), A
        }
        
        if result != 0xFF {
            file.is_open = true;
        }
        
        file
    }
    
    pub fun close(self) -> void {
        if self.is_open {
            @asm {
                LD C, BDOS_CLOSE_FILE
                LD DE, self.fcb
                CALL BDOS
            }
            self.is_open = false;
        }
    }
    
    pub fun read(self, buffer: *u8, len: u16) -> u16 {
        if !self.is_open {
            return 0;
        }
        
        // CP/M reads 128-byte records
        let mut total: u16 = 0;
        let mut dma_addr = buffer;
        
        while total < len {
            // Set DMA address
            @asm {
                LD C, 26        ; Set DMA
                LD DE, (dma_addr)
                CALL BDOS
            }
            
            // Read record
            let result: u8;
            @asm {
                LD C, BDOS_READ_SEQ
                LD DE, self.fcb
                CALL BDOS
                LD (result), A
            }
            
            if result != 0 {
                break;  // EOF or error
            }
            
            total = total + 128;
            dma_addr = dma_addr + 128;
            
            if total >= len {
                total = len;  // Don't overrun buffer
                break;
            }
        }
        
        total
    }
    
    pub fun write(self, buffer: *u8, len: u16) -> u16 {
        if !self.is_open {
            return 0;
        }
        
        let mut total: u16 = 0;
        let mut dma_addr = buffer;
        
        while total < len {
            // Set DMA address
            @asm {
                LD C, 26        ; Set DMA
                LD DE, (dma_addr)
                CALL BDOS
            }
            
            // Write record
            let result: u8;
            @asm {
                LD C, BDOS_WRITE_SEQ
                LD DE, self.fcb
                CALL BDOS
                LD (result), A
            }
            
            if result != 0 {
                break;  // Error
            }
            
            total = total + 128;
            dma_addr = dma_addr + 128;
        }
        
        total
    }
}

// Parse filename into FCB format
fun parse_filename(filename: *u8, fcb: *u8) -> void {
    // Initialize FCB
    let mut i: u8 = 0;
    while i < 36 {
        fcb[i] = 0;
        i = i + 1;
    }
    
    // Default to current drive
    fcb[0] = 0;
    
    // Parse filename (8.3 format)
    let mut src_idx: u8 = 0;
    let mut name_idx: u8 = 1;
    let mut ext_idx: u8 = 9;
    let mut in_ext = false;
    
    // Check for drive letter
    if filename[1] == ':' {
        fcb[0] = filename[0] - 'A' + 1;
        src_idx = 2;
    }
    
    // Copy filename and extension
    while filename[src_idx] != 0 && src_idx < 13 {
        if filename[src_idx] == '.' {
            in_ext = true;
            src_idx = src_idx + 1;
            continue;
        }
        
        if in_ext {
            if ext_idx < 12 {
                fcb[ext_idx] = filename[src_idx];
                ext_idx = ext_idx + 1;
            }
        } else {
            if name_idx < 9 {
                fcb[name_idx] = filename[src_idx];
                name_idx = name_idx + 1;
            }
        }
        
        src_idx = src_idx + 1;
    }
    
    // Pad with spaces
    while name_idx < 9 {
        fcb[name_idx] = ' ';
        name_idx = name_idx + 1;
    }
    
    while ext_idx < 12 {
        fcb[ext_idx] = ' ';
        ext_idx = ext_idx + 1;
    }
}

// Get command line arguments (CP/M 2.x)
pub fun get_args() -> *u8 {
    // Command line is at 0x0080
    return 0x0081 as *u8;  // Skip length byte
}

// Exit to CP/M
pub fun exit(code: u8) -> void {
    @asm {
        LD C, 0         ; System reset
        CALL BDOS
    }
}