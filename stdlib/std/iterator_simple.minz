// MinZ Simple Iterator - No generics, just practical iteration

// Simple range iterator for u8 values
struct RangeU8 {
    current: u8,
    end: u8
}

fun range_u8(start: u8, end: u8) -> RangeU8 {
    return RangeU8 { current: start, end: end };
}

fun range_next(r: *RangeU8) -> u8 {
    if r.current < r.end {
        let val = r.current;
        r.current = r.current + 1;
        return val;
    }
    return 255; // Sentinel value for end
}

fun range_has_next(r: *RangeU8) -> bool {
    return r.current < r.end;
}

// Simple array iterator for u8 arrays
struct ArrayIterU8 {
    data: *u8,
    index: u8,
    size: u8
}

fun array_iter_u8(data: *u8, size: u8) -> ArrayIterU8 {
    return ArrayIterU8 { data: data, index: 0, size: size };
}

fun array_next(iter: *ArrayIterU8) -> u8 {
    if iter.index < iter.size {
        let val = iter.data[iter.index];
        iter.index = iter.index + 1;
        return val;
    }
    return 0; // Sentinel
}

fun array_has_next(iter: *ArrayIterU8) -> bool {
    return iter.index < iter.size;
}

// Practical iteration helpers
fun sum_array_u8(data: *u8, size: u8) -> u16 {
    let mut sum: u16 = 0;
    let mut i: u8 = 0;
    while i < size {
        sum = sum + (data[i] as u16);
        i = i + 1;
    }
    return sum;
}

fun find_u8(data: *u8, size: u8, value: u8) -> u8 {
    let mut i: u8 = 0;
    while i < size {
        if data[i] == value {
            return i; // Return index
        }
        i = i + 1;
    }
    return 255; // Not found
}

fun count_u8(data: *u8, size: u8, value: u8) -> u8 {
    let mut count: u8 = 0;
    let mut i: u8 = 0;
    while i < size {
        if data[i] == value {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}