// Interface Zero-Cost Verification Test
// This test verifies that interface method calls resolve to direct function calls at compile time

// Define interfaces
interface Drawable {
    fun draw(self) -> u8;
    fun get_area(self) -> u16;
}

interface Movable {
    fun move_to(self, x: u8, y: u8) -> bool;
}

// Define concrete types
struct Rectangle {
    width: u8,
    height: u8,
    x: u8,
    y: u8
}

struct Circle {
    radius: u8,
    x: u8,
    y: u8
}

// Implement interfaces for Rectangle
impl Drawable for Rectangle {
    fun draw(self) -> u8 {
        // Simple drawing logic
        self.width + self.height
    }
    
    fun get_area(self) -> u16 {
        (self.width as u16) * (self.height as u16)
    }
}

impl Movable for Rectangle {
    fun move_to(self, x: u8, y: u8) -> bool {
        // This would modify position in real implementation
        x < 100 && y < 100
    }
}

// Implement interfaces for Circle  
impl Drawable for Circle {
    fun draw(self) -> u8 {
        // Simple drawing logic
        self.radius * 2
    }
    
    fun get_area(self) -> u16 {
        // Approximate area: π * r²  ≈ 3.14 * r²  ≈ 3 * r²
        3 * (self.radius as u16) * (self.radius as u16)
    }
}

impl Movable for Circle {
    fun move_to(self, x: u8, y: u8) -> bool {
        // This would modify position in real implementation
        x < 150 && y < 150
    }
}

// Interface-based implementation (should resolve to direct calls)
fun interface_test() -> u16 {
    let rect = Rectangle { width: 10, height: 5, x: 0, y: 0 };
    let circle = Circle { radius: 3, x: 50, y: 50 };
    
    // These interface calls should resolve to direct function calls
    let rect_draw = rect.draw();           // Rectangle::draw -> 15
    let rect_area = rect.get_area();       // Rectangle::get_area -> 50
    let rect_move = rect.move_to(20, 30);  // Rectangle::move_to -> true (1)
    
    let circle_draw = circle.draw();           // Circle::draw -> 6
    let circle_area = circle.get_area();       // Circle::get_area -> 27
    let circle_move = circle.move_to(80, 90);  // Circle::move_to -> true (1)
    
    (rect_draw as u16) + rect_area + (rect_move as u16) +
    (circle_draw as u16) + circle_area + (circle_move as u16)
    // Expected: 15 + 50 + 1 + 6 + 27 + 1 = 100
}

// Direct function call implementation (for comparison)
fun direct_call_rectangle_draw(r: Rectangle) -> u8 {
    r.width + r.height
}

fun direct_call_rectangle_area(r: Rectangle) -> u16 {
    (r.width as u16) * (r.height as u16)
}

fun direct_call_rectangle_move(r: Rectangle, x: u8, y: u8) -> bool {
    x < 100 && y < 100
}

fun direct_call_circle_draw(c: Circle) -> u8 {
    c.radius * 2
}

fun direct_call_circle_area(c: Circle) -> u16 {
    3 * (c.radius as u16) * (c.radius as u16)
}

fun direct_call_circle_move(c: Circle, x: u8, y: u8) -> bool {
    x < 150 && y < 150
}

// Direct call implementation (should compile to identical code as interface version)
fun direct_call_test() -> u16 {
    let rect = Rectangle { width: 10, height: 5, x: 0, y: 0 };
    let circle = Circle { radius: 3, x: 50, y: 50 };
    
    // Direct function calls
    let rect_draw = direct_call_rectangle_draw(rect);     // 15
    let rect_area = direct_call_rectangle_area(rect);     // 50  
    let rect_move = direct_call_rectangle_move(rect, 20, 30);  // true (1)
    
    let circle_draw = direct_call_circle_draw(circle);         // 6
    let circle_area = direct_call_circle_area(circle);         // 27
    let circle_move = direct_call_circle_move(circle, 80, 90); // true (1)
    
    (rect_draw as u16) + rect_area + (rect_move as u16) +
    (circle_draw as u16) + circle_area + (circle_move as u16)
    // Expected: 15 + 50 + 1 + 6 + 27 + 1 = 100
}

// Generic interface test (should monomorphize)
interface Comparable<T> {
    fun compare(self, other: T) -> i8;
}

struct Point {
    x: u8,
    y: u8
}

impl Comparable<Point> for Point {
    fun compare(self, other: Point) -> i8 {
        if self.x > other.x {
            1
        } else if self.x < other.x {
            -1
        } else {
            0
        }
    }
}

// Generic interface usage (should monomorphize to specific Point comparison)
fun generic_interface_test() -> i8 {
    let p1 = Point { x: 10, y: 5 };
    let p2 = Point { x: 3, y: 8 };
    
    p1.compare(p2)  // Should be 1 (since 10 > 3)
}

// Direct equivalent of generic interface
fun direct_point_compare(p1: Point, p2: Point) -> i8 {
    if p1.x > p2.x {
        1
    } else if p1.x < p2.x {
        -1
    } else {
        0
    }
}

fun direct_generic_test() -> i8 {
    let p1 = Point { x: 10, y: 5 };
    let p2 = Point { x: 3, y: 8 };
    
    direct_point_compare(p1, p2)  // Should be 1
}

// Main function to verify interface zero-cost
fun main() -> u16 {
    let interface_result = interface_test();       // 100
    let direct_result = direct_call_test();        // 100 (should be identical)
    let generic_interface = generic_interface_test(); // 1
    let generic_direct = direct_generic_test();       // 1 (should be identical)
    
    // Results should be identical, proving zero-cost abstractions
    interface_result + direct_result + 
    (generic_interface as u16) + (generic_direct as u16)
    // Expected: 100 + 100 + 1 + 1 = 202
}