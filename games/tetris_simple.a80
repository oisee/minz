; MinZ generated code
; Generated: 2025-08-16 20:29:07


; Data section
    ORG $F000

games.tetris_simple.BOARD_WIDTH:
    DB 10
games.tetris_simple.BOARD_HEIGHT:
    DB 20

; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.tetris_simple.clear_screen
games.tetris_simple.clear_screen:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; Inline assembly from @asm block
    LD HL, 16384
    LD BC, 6144
    XOR A
clear_loop:
    LD (HL), A
    INC HL
    DEC BC
    LD A, B
    OR C
    JR NZ, clear_loop
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.tetris_simple.init_game
games.tetris_simple.init_game:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r3 = 0
    LD A, 0
    ; Register 3 already in A
    ; store y, r3
    ; Register 3 already in A
    LD ($F004), A
    ; loop_1:
games_tetris_simple_init_game_loop_1:
    ; r4 = load y
    LD A, ($F004)
    LD C, A         ; Store to physical register C
    ; r5 = load games.tetris_simple.BOARD_HEIGHT
    LD HL, ($F020)
    ; r6 = r4 < r5
    LD E, D        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, games_tetris_simple_init_game_lt_true_0
    LD HL, 0       ; False
    JP games_tetris_simple_init_game_lt_done_0
games_tetris_simple_init_game_lt_true_0:
    LD HL, 1       ; True
games_tetris_simple_init_game_lt_done_0:
    ; jump_if_not r6, end_loop_2
    LD A, E
    OR A
    JP Z, games_tetris_simple_init_game_end_loop_2
    ; r8 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; store x, r8
    LD A, H
    LD ($F00E), A
    ; loop_3:
games_tetris_simple_init_game_loop_3:
    ; r9 = load x
    LD A, ($F00E)
    EXX               ; Switch to shadow registers
    LD B, A         ; Store to shadow B' (now active)
    EXX               ; Switch back to main registers
    ; r10 = load games.tetris_simple.BOARD_WIDTH
    LD HL, ($F000)
    ; r11 = r9 < r10
    EXX               ; Switch to shadow registers
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, games_tetris_simple_init_game_lt_true_1
    LD HL, 0       ; False
    JP games_tetris_simple_init_game_lt_done_1
games_tetris_simple_init_game_lt_true_1:
    LD HL, 1       ; True
games_tetris_simple_init_game_lt_done_1:
    ; jump_if_not r11, end_loop_4
    EXX               ; Switch to shadow registers
    LD A, D         ; From shadow D' (now active)
    EXX               ; Switch back to main registers
    OR A
    JP Z, games_tetris_simple_init_game_end_loop_4
    ; r12 = 0
    LD A, 0
    EXX               ; Switch to shadow registers
    LD E, A         ; Store to shadow E' (now active)
    EXX               ; Switch back to main registers
    ; r13 = load game
    LD HL, ($F002)
    ; Load field board (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F01C), HL    ; Virtual register 14 to memory
    ; Load field grid (offset 0)
    LD HL, ($F01C)    ; Virtual register 14 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD D, H
    LD E, L
    ; r16 = load y
    LD A, ($F004)
    LD B, A         ; Store to physical register B
    ; Load array element ([10]u8)
    LD H, D
    LD L, E
    PUSH HL
    LD E, B        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD C, A         ; Store to BC (low byte)
    ; r18 = load x
    LD A, ($F00E)
    LD L, A         ; Store to HL (low byte)
    ; Calculate array element address
    LD H, B
    LD L, C
    LD D, H
    LD E, L
    ; Register 18 already in HL
    ADD HL, DE
    LD ($F026), HL    ; Virtual register 19 to memory
    ; Store to array[index] (u8)
    LD HL, ($F026)    ; Virtual register 19 from memory
    PUSH HL
    EXX               ; Switch to shadow registers
    LD A, E         ; From shadow E' (now active)
    EXX               ; Switch back to main registers
    POP HL
    LD (HL), A
    ; r20 = load x
    LD A, ($F00E)
    LD ($F028), A     ; Virtual register 20 to memory
    ; r21 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r22 = r20 + r21
    LD HL, ($F028)    ; Virtual register 20 from memory
    LD D, H
    LD E, L
    ADD HL, DE
    ; store x, r22
    LD A, L
    LD ($F00E), A
    ; jump loop_3
    JP games_tetris_simple_init_game_loop_3
    ; end_loop_4:
games_tetris_simple_init_game_end_loop_4:
    ; r23 = load y
    LD A, ($F004)
    LD ($F02E), A     ; Virtual register 23 to memory
    ; r24 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r25 = r23 + r24
    LD HL, ($F02E)    ; Virtual register 23 from memory
    LD D, H
    LD E, L
    ADD HL, DE
    ; store y, r25
    LD A, L
    LD ($F004), A
    ; jump loop_1
    JP games_tetris_simple_init_game_loop_1
    ; end_loop_2:
games_tetris_simple_init_game_end_loop_2:
    ; r26 = 2
    LD A, 2
    LD H, A         ; Store to physical register H
    ; r27 = load game
    LD HL, ($F002)
    ; Load field current_piece (offset 202)
    LD DE, 202
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F038), HL    ; Virtual register 28 to memory
    ; Store to field piece_type (offset 0)
    LD HL, ($F038)    ; Virtual register 28 from memory
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r29 = 5
    LD A, 5
    LD L, A         ; Store to HL (low byte)
    ; r30 = load game
    LD HL, ($F002)
    ; Load field current_piece (offset 202)
    LD DE, 202
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F03E), HL    ; Virtual register 31 to memory
    ; Load field position (offset 1)
    LD HL, ($F03E)    ; Virtual register 31 from memory
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    PUSH HL           ; Save current HL
    EXX               ; Switch to shadow registers
    POP HL            ; Load into shadow HL
    EXX               ; Switch back to main registers
    ; Store to field x (offset 0)
    EXX               ; Switch to shadow registers
    PUSH HL           ; Save shadow HL
    EXX               ; Switch back to main registers
    POP HL            ; Load shadow HL into main HL
    PUSH HL
    ; Register 29 already in HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r33 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; r34 = load game
    LD HL, ($F002)
    ; Load field current_piece (offset 202)
    LD DE, 202
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F046), HL    ; Virtual register 35 to memory
    ; Load field position (offset 1)
    LD HL, ($F046)    ; Virtual register 35 from memory
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 36 already in HL
    ; Store to field y (offset 1)
    ; Register 36 already in HL
    LD DE, 1
    ADD HL, DE
    PUSH HL
    ; Register 33 already in HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r37 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; r38 = load game
    LD HL, ($F002)
    ; Load field board (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F04E), HL    ; Virtual register 39 to memory
    ; Store to field score (offset 200)
    LD HL, ($F04E)    ; Virtual register 39 from memory
    LD DE, 200
    ADD HL, DE
    PUSH HL
    ; Register 37 already in HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r40 = load game
    LD HL, ($F002)
    ; Register 40 already in HL
    ; return r40
    ; Register 40 already in HL
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.tetris_simple.render_game$p_TetrisGame
games.tetris_simple.render_game$p_TetrisGame:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = call games.tetris_simple.clear_screen
    ; Call to games.tetris_simple.clear_screen (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL games.tetris_simple.clear_screen
; TSMC reference parameter game
game$immOP:
    LD HL, 0000      ; TSMC ref address for game
game$imm0 EQU game$immOP+1
    LD ($F006), HL    ; Virtual register 3 to memory
    ; Load field board (offset 0)
    LD HL, ($F006)    ; Virtual register 3 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 4 already in HL
    ; Load field score (offset 200)
    ; Register 4 already in HL
    LD DE, 200
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 5 already in HL
    ; Call runtime print_u16_decimal
    ; Call to print_u16_decimal (args: 1)
    ; Stack-based parameter passing
    ; Register 5 already in HL
    PUSH HL       ; Argument 0
    CALL print_u16_decimal
    LD ($F000), HL    ; Virtual register 0 to memory
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.tetris_simple.game_loop
games.tetris_simple.game_loop:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = call games.tetris_simple.init_game
    ; Call to games.tetris_simple.init_game (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL games.tetris_simple.init_game
    ; store game, r2
    LD ($F002), HL
    ; r4 = 0
    LD A, 0
    LD ($F008), A     ; Virtual register 4 to memory
    ; store frames, r4
    LD A, ($F008)     ; Virtual register 4 from memory
    LD ($F006), A
    ; loop_5:
games_tetris_simple_game_loop_loop_5:
    ; r5 = load frames
    LD A, ($F006)
    LD L, A         ; Store to physical register L
    ; r6 = 100
    LD A, 100
    LD ($F00C), A     ; Virtual register 6 to memory
    ; r7 = r5 < r6
    LD HL, ($F00C)    ; Virtual register 6 from memory
    EX DE, HL
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, games_tetris_simple_game_loop_lt_true_2
    LD HL, 0       ; False
    JP games_tetris_simple_game_loop_lt_done_2
games_tetris_simple_game_loop_lt_true_2:
    LD HL, 1       ; True
games_tetris_simple_game_loop_lt_done_2:
    ; jump_if_not r7, end_loop_6
    LD A, H
    OR A
    JP Z, games_tetris_simple_game_loop_end_loop_6
    ; r8 = load game
    LD HL, ($F002)
    ; r9 = &r8
    ; Address-of operation for register r8
    LD HL, $F010  ; Variable address
    LD ($F012), HL    ; Virtual register 9 to memory
    ; r10 = load game
    LD HL, ($F002)
    ; r11 = &r10
    ; Address-of operation for register r10
    LD HL, $F014  ; Variable address
    ; r12 = call games.tetris_simple.render_game$p_TetrisGame
    ; Call to games.tetris_simple.render_game$p_TetrisGame (args: 1)
    ; Found function, UsesTrueSMC=false
    CALL games.tetris_simple.render_game$p_TetrisGame
    LD ($F018), HL    ; Virtual register 12 to memory
    ; Inline assembly from @asm block
    ; r13 = load frames
    LD A, ($F006)
    LD H, A         ; Store to physical register H
    ; r14 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r15 = r13 + r14
    LD D, H
    LD E, L
    ADD HL, DE
    ; Register 15 already in HL
    ; store frames, r15
    LD A, L
    LD ($F006), A
    ; jump loop_5
    JP games_tetris_simple_game_loop_loop_5
    ; end_loop_6:
games_tetris_simple_game_loop_end_loop_6:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.tetris_simple.main
games.tetris_simple.main:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r1 = call games.tetris_simple.game_loop
    ; Call to games.tetris_simple.game_loop (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL games.tetris_simple.game_loop
    ; return
    RET

; Runtime print helper functions
print_u8_decimal:
    LD H, 0            ; HL = A (zero extend)
    LD L, A
    CALL print_u16_decimal
    RET

print_u16_decimal:
    LD BC, -10000
    LD DE, -1000
    CALL print_digit
    LD BC, -1000
    LD DE, -100
    CALL print_digit
    LD BC, -100
    LD DE, -10
    CALL print_digit
    LD BC, -10
    LD DE, -1
    CALL print_digit
    LD A, L
    ADD A, '0'         ; Convert to ASCII
    RST 16             ; Print last digit
    RET

print_digit:
    LD A, '0'-1
print_digit_loop:
    INC A
    ADD HL, BC         ; Subtract power of 10
    JR C, print_digit_loop
    ADD HL, DE         ; Add back one power of 10
    RST 16             ; Print digit
    RET


; Standard library routines

    END main
