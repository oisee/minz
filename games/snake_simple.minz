// Simplified Snake Game - testing basic features first
// This version avoids match statements and complex pointer access

// Game constants
global SCREEN_WIDTH: u8 = 32;
global SCREEN_HEIGHT: u8 = 24;

// Direction constants instead of enum for now
global DIR_UP: u8 = 0;
global DIR_DOWN: u8 = 1;
global DIR_LEFT: u8 = 2;
global DIR_RIGHT: u8 = 3;

// Point structure
struct Point {
    x: u8,
    y: u8
}

// Simple snake with fixed array
struct Snake {
    head_x: u8,
    head_y: u8,
    direction: u8,
    length: u8
}

// Initialize snake
fun init_snake() -> Snake {
    let snake = Snake {
        head_x: 16,
        head_y: 12,
        direction: DIR_RIGHT,
        length: 1
    };
    return snake;
}

// Move snake head based on direction
fun move_snake_head(snake: Snake) -> Snake {
    let new_snake = snake;
    
    if (snake.direction == DIR_UP) {
        new_snake.head_y = snake.head_y - 1;
    } else if (snake.direction == DIR_DOWN) {
        new_snake.head_y = snake.head_y + 1;
    } else if (snake.direction == DIR_LEFT) {
        new_snake.head_x = snake.head_x - 1;
    } else if (snake.direction == DIR_RIGHT) {
        new_snake.head_x = snake.head_x + 1;
    }
    
    return new_snake;
}

// Check wall collision
fun check_wall_collision(snake: Snake) -> bool {
    if (snake.head_x >= SCREEN_WIDTH) {
        return true;
    }
    if (snake.head_y >= SCREEN_HEIGHT) {
        return true;
    }
    return false;
}

// Simple input handling with if statements
fun update_direction(snake: Snake, input: u8) -> Snake {
    let new_snake = snake;
    
    if (input == 87) { // 'W' key - UP
        if (snake.direction != DIR_DOWN) {
            new_snake.direction = DIR_UP;
        }
    } else if (input == 83) { // 'S' key - DOWN
        if (snake.direction != DIR_UP) {
            new_snake.direction = DIR_DOWN;
        }
    } else if (input == 65) { // 'A' key - LEFT
        if (snake.direction != DIR_RIGHT) {
            new_snake.direction = DIR_LEFT;
        }
    } else if (input == 68) { // 'D' key - RIGHT
        if (snake.direction != DIR_LEFT) {
            new_snake.direction = DIR_RIGHT;
        }
    }
    
    return new_snake;
}

// Check if point matches food position
fun check_food_hit(snake: Snake, food_x: u8, food_y: u8) -> bool {
    return snake.head_x == food_x && snake.head_y == food_y;
}

// Game loop logic
fun run_game_step(snake: Snake, food_x: u8, food_y: u8) -> Snake {
    let updated_snake = move_snake_head(snake);
    
    if (check_wall_collision(updated_snake)) {
        // Game over - for now just return original
        return snake;
    }
    
    if (check_food_hit(updated_snake, food_x, food_y)) {
        // Grow snake
        updated_snake.length = updated_snake.length + 1;
    }
    
    return updated_snake;
}

// Simple render function
fun render_snake(snake: Snake) -> void {
    print_u8(snake.head_x);
    print_u8(snake.head_y);
    print_u8(snake.length);
}

// Main function to test basic game mechanics
fun main() -> void {
    let snake = init_snake();
    let food_x: u8 = 10;
    let food_y: u8 = 8;
    
    // Simulate a few game steps
    let step1 = run_game_step(snake, food_x, food_y);
    render_snake(step1);
    
    let step2 = run_game_step(step1, food_x, food_y);
    render_snake(step2);
    
    // Test direction change
    let turned = update_direction(step2, 87); // Press 'W'
    let step3 = run_game_step(turned, food_x, food_y);
    render_snake(step3);
}