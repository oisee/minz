// Snake Game for ZX Spectrum in MinZ
// This will test: arrays, structs, enums, functions, loops, conditionals

// Game constants
global SCREEN_WIDTH: u8 = 32;
global SCREEN_HEIGHT: u8 = 24;
global MAX_SNAKE_LENGTH: u8 = 100;

// ZX Spectrum memory addresses
global SCREEN_MEM: u16 = 16384;     // Screen bitmap start
global ATTR_MEM: u16 = 22528;       // Attributes start
global BORDER_REG: u16 = 254;       // Border color port

// ZX Spectrum screen routines
fun clear_screen() -> void {
    // Clear bitmap (6144 bytes)
    let addr: u16 = SCREEN_MEM;
    let end: u16 = SCREEN_MEM + 6144;
    while (addr < end) {
        @asm {
            LD HL, (addr)
            LD (HL), 0
        }
        addr = addr + 1;
    }
    
    // Set attributes (768 bytes) to white on black (7)
    addr = ATTR_MEM;
    end = ATTR_MEM + 768;
    while (addr < end) {
        @asm {
            LD HL, (addr)
            LD (HL), 7
        }
        addr = addr + 1;
    }
}

fun plot_pixel(x: u8, y: u8, color: u8) -> void {
    // Simplified ZX Spectrum pixel plotting
    @asm {
        LD A, (color)
        CP 0
        JR Z, clear_pixel
        ; Set pixel logic here
        RET
    clear_pixel:
        ; Clear pixel logic here
        RET
    }
}

fun set_border(color: u8) -> void {
    @asm {
        LD A, (color)
        OUT (BORDER_REG), A
    }
}

// ZX Spectrum keyboard routines
fun read_keyboard() -> u8 {
    // Read keyboard half-rows
    // Returns ASCII code of pressed key or 0 if none
    
    // Check QASDW keys for snake control
    @asm {
        LD BC, 0xFBFE    // Port for Q,W,E,R,T row
        IN A, (C)
        CPL              // Invert bits (0 = pressed)
        AND 0x1F         // Mask to 5 bits
    }
    
    let keys_qwert: u8 = 0;  // Will be set by inline asm
    @asm {
        LD (keys_qwert), A
    }
    
    if ((keys_qwert & 0x01) != 0) return 81;  // Q
    if ((keys_qwert & 0x02) != 0) return 87;  // W
    
    @asm {
        LD BC, 0xFDFE    // Port for A,S,D,F,G row  
        IN A, (C)
        CPL
        AND 0x1F
    }
    
    let keys_asdfg: u8 = 0;
    @asm {
        LD (keys_asdfg), A
    }
    
    if ((keys_asdfg & 0x01) != 0) return 65;  // A
    if ((keys_asdfg & 0x02) != 0) return 83;  // S
    if ((keys_asdfg & 0x04) != 0) return 68;  // D
    
    return 0;  // No key pressed
}

// Simple delay function
fun delay(frames: u16) -> void {
    let count: u16 = 0;
    while (count < frames) {
        // Wait for interrupt (about 50Hz on PAL Spectrum)
        @asm {
            HALT
        }
        count = count + 1;
    }
}

// Direction enum
enum Direction {
    UP,
    DOWN,
    LEFT,
    RIGHT
}

// Point structure for coordinates
struct Point {
    x: u8,
    y: u8
}

// Snake structure
struct Snake {
    body: [Point; 100],  // Array of points
    length: u8,
    direction: Direction,
    alive: u8  // 0 = false, 1 = true
}

// Game state structure
struct GameState {
    snake: Snake,
    food: Point,
    score: u16,
    game_over: u8  // 0 = false, 1 = true
}

// Initialize a new snake  
fun init_snake() -> Snake {
    let mut snake: Snake;
    snake.length = 1;
    snake.direction = Direction.RIGHT;
    snake.alive = 1;  // true
    
    // Set the head position
    let head: Point;
    head.x = 16;
    head.y = 12;
    snake.body[0] = head;
    return snake;
}

// Initialize game state
fun init_game() -> GameState {
    let mut game: GameState;
    game.snake = init_snake();
    let food: Point;
    food.x = 10;
    food.y = 10;
    game.food = food;
    game.score = 0;
    game.game_over = 0;  // false
    return game;
}

// Move snake in current direction
fun move_snake(snake: *Snake) -> void {
    // Move body segments
    let i: u8 = snake.length - 1;
    while (i > 0) {
        snake.body[i] = snake.body[i - 1];
        i = i - 1;
    }
    
    // Move head
    if (snake.direction == Direction.UP) {
        snake.body[0].y = snake.body[0].y - 1;
    } else if (snake.direction == Direction.DOWN) {
        snake.body[0].y = snake.body[0].y + 1;
    } else if (snake.direction == Direction.LEFT) {
        snake.body[0].x = snake.body[0].x - 1;
    } else if (snake.direction == Direction.RIGHT) {
        snake.body[0].x = snake.body[0].x + 1;
    }
}

// Check collision with walls or self
fun check_collision(snake: *Snake) -> u8 {
    let head = snake.body[0];
    
    // Wall collision
    if (head.x >= SCREEN_WIDTH || head.y >= SCREEN_HEIGHT) {
        return 1;  // true
    }
    
    // Self collision
    let i: u8 = 1;
    while (i < snake.length) {
        if (head.x == snake.body[i].x && head.y == snake.body[i].y) {
            return 1;  // true
        }
        i = i + 1;
    }
    
    return 0;  // false
}

// Check if snake ate food
fun check_food_collision(snake: *Snake, food: *Point) -> u8 {
    let head = snake.body[0];
    if (head.x == food.x && head.y == food.y) {
        return 1;  // true
    }
    return 0;  // false
}

// Grow snake by one segment
fun grow_snake(snake: *Snake) -> void {
    if (snake.length < MAX_SNAKE_LENGTH) {
        snake.length = snake.length + 1;
    }
}

// Generate new food position
fun generate_food(snake: *Snake) -> Point {
    // Simple random position (will improve with proper RNG)
    let food: Point;
    food.x = 15;
    food.y = 8;
    return food;
}

// Handle keyboard input
fun handle_input(snake: *Snake) -> void {
    let key: u8 = read_keyboard();
    
    if (key == 87) { // 'W' key - Direction.UP
        if (snake.direction != Direction.DOWN) {
            snake.direction = Direction.UP;
        }
    } else if (key == 83) { // 'S' key - Direction.DOWN
        if (snake.direction != Direction.UP) {
            snake.direction = Direction.DOWN;
        }
    } else if (key == 65) { // 'A' key - Direction.LEFT
        if (snake.direction != Direction.RIGHT) {
            snake.direction = Direction.LEFT;
        }
    } else if (key == 68) { // 'D' key - Direction.RIGHT
        if (snake.direction != Direction.LEFT) {
            snake.direction = Direction.RIGHT;
        }
    } else if (key == 81) { // 'Q' key - QUIT
        snake.alive = 0;  // false
    }
}

// Render the game
fun render_game(game: *GameState) -> void {
    // Clear screen using ZX Spectrum routines
    clear_screen();
    
    // Set green border for the game
    set_border(4);
    
    // Draw snake segments (white pixels)
    let i: u8 = 0;
    while (i < game.snake.length) {
        let segment = game.snake.body[i];
        plot_pixel(segment.x, segment.y, 1);
        i = i + 1;
    }
    
    // Draw food (different color - turn on pixel)
    plot_pixel(game.food.x, game.food.y, 1);
    
    // Draw score at top of screen using text
    print_u16(game.score);
}

// Main game loop
fun game_loop() -> void {
    let game = init_game();
    
    // Initial render
    render_game(&game);
    
    while (game.game_over == 0 && game.snake.alive == 1) {
        handle_input(&game.snake);
        
        if (game.snake.alive == 0) {
            break;  // Player quit with Q key
        }
        
        move_snake(&game.snake);
        
        if (check_collision(&game.snake) == 1) {
            game.game_over = 1;  // true
            break;
        }
        
        if (check_food_collision(&game.snake, &game.food) == 1) {
            grow_snake(&game.snake);
            game.food = generate_food(&game.snake);
            game.score = game.score + 10;
        }
        
        render_game(&game);
        
        // Game speed control (about 10 FPS)
        delay(5);
    }
    
    // Game over - flash border red
    set_border(2);
    delay(25);
    set_border(0);
    
    // Show final score
    clear_screen();
    print_u16(game.score);
}

// Entry point
fun main() -> void {
    game_loop();
}