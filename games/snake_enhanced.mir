; MinZ Intermediate Representation (MIR)
; Module: main

; Globals:
;   games.snake.SCREEN_WIDTH: u8
;   games.snake.SCREEN_HEIGHT: u8
;   games.snake.MAX_SNAKE_LENGTH: u8
;   games.snake.SCREEN_MEM: u16
;   games.snake.ATTR_MEM: u16
;   games.snake.BORDER_REG: u16

Function games.snake.clear_screen() -> void
  @smc
  Locals:
    r1 = addr: u16
    r3 = end: u16
  Instructions:
      0: r2 = load games.snake.SCREEN_MEM
      1: store addr, r2
      2: r4 = load games.snake.SCREEN_MEM
      3: r5 = 6144
      4: r6 = r4 + r5
      5: store end, r6
      6: loop_1:
      7: r7 = load addr
      8: r8 = load end
      9: r9 = r7 < r8
     10: jump_if_not r9, end_loop_2
     11: ASM ; Inline assembly from @asm block
     12: r10 = load addr
     13: r11 = 1
     14: r12 = r10 + r11
     15: store addr, r12
     16: jump loop_1
     17: end_loop_2:
     18: r13 = load games.snake.ATTR_MEM
     19: store addr, r13
     20: r14 = load games.snake.ATTR_MEM
     21: r15 = 768
     22: r16 = r14 + r15
     23: store end, r16
     24: loop_3:
     25: r17 = load addr
     26: r18 = load end
     27: r19 = r17 < r18
     28: jump_if_not r19, end_loop_4
     29: ASM ; Inline assembly from @asm block
     30: r20 = load addr
     31: r21 = 1
     32: r22 = r20 + r21
     33: store addr, r22
     34: jump loop_3
     35: end_loop_4:
     36: return

Function games.snake.plot_pixel$u8$u8$u8(x: u8, y: u8, color: u8) -> void
  @smc
  Instructions:
      0: ASM ; Inline assembly from @asm block
      1: return

Function games.snake.set_border$u8(color: u8) -> void
  @smc
  Instructions:
      0: ASM ; Inline assembly from @asm block
      1: return

Function games.snake.read_keyboard() -> u8
  @smc
  Locals:
    r1 = keys_qwert: u8
    r3 = keys_asdfg: u8
  Instructions:
      0: ASM ; Inline assembly from @asm block
      1: r2 = 0
      2: store keys_qwert, r2
      3: ASM ; Inline assembly from @asm block
      4: ASM ; Inline assembly from @asm block
      5: r4 = 0
      6: store keys_asdfg, r4
      7: ASM ; Inline assembly from @asm block
      8: return

Function games.snake.delay$u16(frames: u16) -> void
  @smc
  Locals:
    r2 = count: u16
  Instructions:
      0: r3 = 0
      1: store count, r3
      2: loop_5:
      3: r4 = load count
      4: LOAD_PARAM
      5: r6 = r4 < r5
      6: jump_if_not r6, end_loop_6
      7: ASM ; Inline assembly from @asm block
      8: r7 = load count
      9: r8 = 1
     10: r9 = r7 + r8
     11: store count, r9
     12: jump loop_5
     13: end_loop_6:
     14: return

Function games.snake.init_snake() -> games.snake.Snake
  @smc
  Locals:
    r1 = snake: games.snake.Snake
    r8 = head: games.snake.Point
  Instructions:
      0: r2 = 1
      1: r3 = load snake
      2: STORE_FIELD ; Store to field length (offset 200)
      3: r4 = 3
      4: r5 = load snake
      5: STORE_FIELD ; Store to field direction (offset 201)
      6: r6 = 1
      7: r7 = load snake
      8: STORE_FIELD ; Store to field alive (offset 202)
      9: r9 = 16
     10: r10 = load head
     11: STORE_FIELD ; Store to field x (offset 0)
     12: r11 = 12
     13: r12 = load head
     14: STORE_FIELD ; Store to field y (offset 1)
     15: r13 = load head
     16: r14 = load snake
     17: LOAD_FIELD ; Load field body (offset 0)
     18: r16 = 0
     19: r17 = r15 + r16 ; Calculate array element address
     20: STORE_PTR ; Store to array[index] (games.snake.Point)
     21: r18 = load snake
     22: return r18

Function games.snake.init_game() -> games.snake.GameState
  @smc
  Locals:
    r1 = game: games.snake.GameState
    r4 = food: games.snake.Point
  Instructions:
      0: r2 = call games.snake.init_snake
      1: r3 = load game
      2: STORE_FIELD ; Store to field snake (offset 0)
      3: r5 = 10
      4: r6 = load food
      5: STORE_FIELD ; Store to field x (offset 0)
      6: r7 = 10
      7: r8 = load food
      8: STORE_FIELD ; Store to field y (offset 1)
      9: r9 = load food
     10: r10 = load game
     11: STORE_FIELD ; Store to field food (offset 203)
     12: r11 = 0
     13: r12 = load game
     14: STORE_FIELD ; Store to field score (offset 205)
     15: r13 = 0
     16: r14 = load game
     17: STORE_FIELD ; Store to field game_over (offset 207)
     18: r15 = load game
     19: return r15

Function games.snake.move_snake$p_Snake(snake: *games.snake.Snake) -> void
  @smc
  Locals:
    r2 = i: u8
  Instructions:
      0: LOAD_PARAM
      1: LOAD_FIELD ; Load field length (offset 200)
      2: r5 = 1
      3: r6 = r4 - r5
      4: store i, r6
      5: loop_7:
      6: r7 = load i
      7: r8 = 0
      8: r9 = r7 > r8
      9: jump_if_not r9, end_loop_8
     10: LOAD_PARAM
     11: LOAD_FIELD ; Load field body (offset 0)
     12: r12 = load i
     13: r13 = 1
     14: r14 = r12 - r13
     15: LOAD_INDEX ; Load array element (games.snake.Point)
     16: LOAD_PARAM
     17: LOAD_FIELD ; Load field body (offset 0)
     18: r18 = load i
     19: r19 = r17 + r18 ; Calculate array element address
     20: STORE_PTR ; Store to array[index] (games.snake.Point)
     21: r20 = load i
     22: r21 = 1
     23: r22 = r20 - r21
     24: store i, r22
     25: jump loop_7
     26: end_loop_8:
     27: LOAD_PARAM
     28: LOAD_FIELD ; Load field direction (offset 201)
     29: r25 = 0
     30: r26 = r24 == r25
     31: jump_if_not r26, else_9
     32: LOAD_PARAM
     33: LOAD_FIELD ; Load field body (offset 0)
     34: r29 = 0
     35: LOAD_INDEX ; Load array element (games.snake.Point)
     36: LOAD_FIELD ; Load field y (offset 1)
     37: r32 = 1
     38: r33 = r31 - r32
     39: LOAD_PARAM
     40: LOAD_FIELD ; Load field body (offset 0)
     41: r36 = 0
     42: LOAD_INDEX ; Load array element (games.snake.Point)
     43: STORE_FIELD ; Store to field y (offset 1)
     44: jump end_if_10
     45: else_9:
     46: LOAD_PARAM
     47: LOAD_FIELD ; Load field direction (offset 201)
     48: r40 = 1
     49: r41 = r39 == r40
     50: jump_if_not r41, else_11
     51: LOAD_PARAM
     52: LOAD_FIELD ; Load field body (offset 0)
     53: r44 = 0
     54: LOAD_INDEX ; Load array element (games.snake.Point)
     55: LOAD_FIELD ; Load field y (offset 1)
     56: r47 = 1
     57: r48 = r46 + r47
     58: LOAD_PARAM
     59: LOAD_FIELD ; Load field body (offset 0)
     60: r51 = 0
     61: LOAD_INDEX ; Load array element (games.snake.Point)
     62: STORE_FIELD ; Store to field y (offset 1)
     63: jump end_if_12
     64: else_11:
     65: LOAD_PARAM
     66: LOAD_FIELD ; Load field direction (offset 201)
     67: r55 = 2
     68: r56 = r54 == r55
     69: jump_if_not r56, else_13
     70: LOAD_PARAM
     71: LOAD_FIELD ; Load field body (offset 0)
     72: r59 = 0
     73: LOAD_INDEX ; Load array element (games.snake.Point)
     74: LOAD_FIELD ; Load field x (offset 0)
     75: r62 = 1
     76: r63 = r61 - r62
     77: LOAD_PARAM
     78: LOAD_FIELD ; Load field body (offset 0)
     79: r66 = 0
     80: LOAD_INDEX ; Load array element (games.snake.Point)
     81: STORE_FIELD ; Store to field x (offset 0)
     82: jump end_if_14
     83: else_13:
     84: LOAD_PARAM
     85: LOAD_FIELD ; Load field direction (offset 201)
     86: r70 = 3
     87: r71 = r69 == r70
     88: jump_if_not r71, else_15
     89: LOAD_PARAM
     90: LOAD_FIELD ; Load field body (offset 0)
     91: r74 = 0
     92: LOAD_INDEX ; Load array element (games.snake.Point)
     93: LOAD_FIELD ; Load field x (offset 0)
     94: r77 = 1
     95: r78 = r76 + r77
     96: LOAD_PARAM
     97: LOAD_FIELD ; Load field body (offset 0)
     98: r81 = 0
     99: LOAD_INDEX ; Load array element (games.snake.Point)
    100: STORE_FIELD ; Store to field x (offset 0)
    101: jump end_if_16
    102: else_15:
    103: end_if_16:
    104: end_if_14:
    105: end_if_12:
    106: end_if_10:
    107: return

Function games.snake.check_collision$p_Snake(snake: *games.snake.Snake) -> u8
  @smc
  Locals:
    r2 = head: u16
    r17 = i: u8
  Instructions:
      0: LOAD_PARAM
      1: LOAD_FIELD ; Load field body (offset 0)
      2: r5 = 0
      3: LOAD_INDEX ; Load array element (games.snake.Point)
      4: store head, r6
      5: r7 = load head
      6: LOAD_FIELD ; Load field x (offset 0)
      7: r9 = load games.snake.SCREEN_WIDTH
      8: r10 = r8 >= r9
      9: r11 = load head
     10: LOAD_FIELD ; Load field y (offset 1)
     11: r13 = load games.snake.SCREEN_HEIGHT
     12: r14 = r12 >= r13
     13: UNKNOWN_OP_61
     14: jump_if_not r15, else_17
     15: r16 = 1
     16: return r16
     17: jump end_if_18
     18: else_17:
     19: end_if_18:
     20: r18 = 1
     21: store i, r18
     22: loop_19:
     23: r19 = load i
     24: LOAD_PARAM
     25: LOAD_FIELD ; Load field length (offset 200)
     26: r22 = r19 < r21
     27: jump_if_not r22, end_loop_20
     28: r23 = load head
     29: LOAD_FIELD ; Load field x (offset 0)
     30: LOAD_PARAM
     31: LOAD_FIELD ; Load field body (offset 0)
     32: r27 = load i
     33: LOAD_INDEX ; Load array element (games.snake.Point)
     34: LOAD_FIELD ; Load field x (offset 0)
     35: r30 = r24 == r29
     36: r31 = load head
     37: LOAD_FIELD ; Load field y (offset 1)
     38: LOAD_PARAM
     39: LOAD_FIELD ; Load field body (offset 0)
     40: r35 = load i
     41: LOAD_INDEX ; Load array element (games.snake.Point)
     42: LOAD_FIELD ; Load field y (offset 1)
     43: r38 = r32 == r37
     44: UNKNOWN_OP_60
     45: jump_if_not r39, else_21
     46: r40 = 1
     47: return r40
     48: jump end_if_22
     49: else_21:
     50: end_if_22:
     51: r41 = load i
     52: r42 = 1
     53: r43 = r41 + r42
     54: store i, r43
     55: jump loop_19
     56: end_loop_20:
     57: r44 = 0
     58: return r44

Function games.snake.check_food_collision$p_Snake$p_Point(snake: *games.snake.Snake, food: *games.snake.Point) -> u8
  @smc
  Locals:
    r3 = head: u16
  Instructions:
      0: LOAD_PARAM
      1: LOAD_FIELD ; Load field body (offset 0)
      2: r6 = 0
      3: LOAD_INDEX ; Load array element (games.snake.Point)
      4: store head, r7
      5: r8 = load head
      6: LOAD_FIELD ; Load field x (offset 0)
      7: LOAD_PARAM
      8: LOAD_FIELD ; Load field x (offset 0)
      9: r12 = r9 == r11
     10: r13 = load head
     11: LOAD_FIELD ; Load field y (offset 1)
     12: LOAD_PARAM
     13: LOAD_FIELD ; Load field y (offset 1)
     14: r17 = r14 == r16
     15: UNKNOWN_OP_60
     16: jump_if_not r18, else_23
     17: r19 = 1
     18: return r19
     19: jump end_if_24
     20: else_23:
     21: end_if_24:
     22: r20 = 0
     23: return r20

Function games.snake.grow_snake$p_Snake(snake: *games.snake.Snake) -> void
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_FIELD ; Load field length (offset 200)
      2: r4 = load games.snake.MAX_SNAKE_LENGTH
      3: r5 = r3 < r4
      4: jump_if_not r5, else_25
      5: LOAD_PARAM
      6: LOAD_FIELD ; Load field length (offset 200)
      7: r8 = 1
      8: r9 = r7 + r8
      9: LOAD_PARAM
     10: STORE_FIELD ; Store to field length (offset 200)
     11: jump end_if_26
     12: else_25:
     13: end_if_26:
     14: return

Function games.snake.generate_food$p_Snake(snake: *games.snake.Snake) -> games.snake.Point
  @smc
  Locals:
    r2 = food: games.snake.Point
  Instructions:
      0: r3 = 15
      1: r4 = load food
      2: STORE_FIELD ; Store to field x (offset 0)
      3: r5 = 8
      4: r6 = load food
      5: STORE_FIELD ; Store to field y (offset 1)
      6: r7 = load food
      7: return r7

Function games.snake.handle_input$p_Snake(snake: *games.snake.Snake) -> void
  @smc
  Locals:
    r2 = key: u8
  Instructions:
      0: PATCH_TEMPLATE
      1: PATCH_TARGET
      2: r3 = call games.snake.read_keyboard
      3: store key, r3
      4: r4 = load key
      5: r5 = 87
      6: r6 = r4 == r5
      7: jump_if_not r6, else_27
      8: LOAD_PARAM
      9: LOAD_FIELD ; Load field direction (offset 201)
     10: r9 = 1
     11: r10 = r8 != r9
     12: jump_if_not r10, else_29
     13: r11 = 0
     14: LOAD_PARAM
     15: STORE_FIELD ; Store to field direction (offset 201)
     16: jump end_if_30
     17: else_29:
     18: end_if_30:
     19: jump end_if_28
     20: else_27:
     21: r13 = load key
     22: r14 = 83
     23: r15 = r13 == r14
     24: jump_if_not r15, else_31
     25: LOAD_PARAM
     26: LOAD_FIELD ; Load field direction (offset 201)
     27: r18 = 0
     28: r19 = r17 != r18
     29: jump_if_not r19, else_33
     30: r20 = 1
     31: LOAD_PARAM
     32: STORE_FIELD ; Store to field direction (offset 201)
     33: jump end_if_34
     34: else_33:
     35: end_if_34:
     36: jump end_if_32
     37: else_31:
     38: r22 = load key
     39: r23 = 65
     40: r24 = r22 == r23
     41: jump_if_not r24, else_35
     42: LOAD_PARAM
     43: LOAD_FIELD ; Load field direction (offset 201)
     44: r27 = 3
     45: r28 = r26 != r27
     46: jump_if_not r28, else_37
     47: r29 = 2
     48: LOAD_PARAM
     49: STORE_FIELD ; Store to field direction (offset 201)
     50: jump end_if_38
     51: else_37:
     52: end_if_38:
     53: jump end_if_36
     54: else_35:
     55: r31 = load key
     56: r32 = 68
     57: r33 = r31 == r32
     58: jump_if_not r33, else_39
     59: LOAD_PARAM
     60: LOAD_FIELD ; Load field direction (offset 201)
     61: r36 = 2
     62: r37 = r35 != r36
     63: jump_if_not r37, else_41
     64: r38 = 3
     65: LOAD_PARAM
     66: STORE_FIELD ; Store to field direction (offset 201)
     67: jump end_if_42
     68: else_41:
     69: end_if_42:
     70: jump end_if_40
     71: else_39:
     72: r40 = load key
     73: r41 = 81
     74: r42 = r40 == r41
     75: jump_if_not r42, else_43
     76: r43 = 0
     77: LOAD_PARAM
     78: STORE_FIELD ; Store to field alive (offset 202)
     79: jump end_if_44
     80: else_43:
     81: end_if_44:
     82: end_if_40:
     83: end_if_36:
     84: end_if_32:
     85: end_if_28:
     86: return

Function games.snake.render_game$p_GameState(game: *games.snake.GameState) -> void
  @smc
  Locals:
    r6 = i: u8
    r13 = segment: u16
  Instructions:
      0: r2 = call games.snake.clear_screen
      1: r3 = 4
      2: r4 = 4
      3: r5 = call games.snake.set_border$u8
      4: r7 = 0
      5: store i, r7
      6: loop_45:
      7: r8 = load i
      8: LOAD_PARAM
      9: LOAD_FIELD ; Load field snake (offset 0)
     10: LOAD_FIELD ; Load field length (offset 200)
     11: r12 = r8 < r11
     12: jump_if_not r12, end_loop_46
     13: LOAD_PARAM
     14: LOAD_FIELD ; Load field snake (offset 0)
     15: LOAD_FIELD ; Load field body (offset 0)
     16: r17 = load i
     17: LOAD_INDEX ; Load array element (games.snake.Point)
     18: store segment, r18
     19: r19 = load segment
     20: LOAD_FIELD ; Load field x (offset 0)
     21: r21 = load segment
     22: LOAD_FIELD ; Load field y (offset 1)
     23: r23 = 1
     24: r24 = load segment
     25: LOAD_FIELD ; Load field x (offset 0)
     26: r26 = load segment
     27: LOAD_FIELD ; Load field y (offset 1)
     28: r28 = 1
     29: r29 = call games.snake.plot_pixel$u8$u8$u8
     30: r30 = load i
     31: r31 = 1
     32: r32 = r30 + r31
     33: store i, r32
     34: jump loop_45
     35: end_loop_46:
     36: LOAD_PARAM
     37: LOAD_FIELD ; Load field food (offset 203)
     38: LOAD_FIELD ; Load field x (offset 0)
     39: LOAD_PARAM
     40: LOAD_FIELD ; Load field food (offset 203)
     41: LOAD_FIELD ; Load field y (offset 1)
     42: r39 = 1
     43: LOAD_PARAM
     44: LOAD_FIELD ; Load field food (offset 203)
     45: LOAD_FIELD ; Load field x (offset 0)
     46: LOAD_PARAM
     47: LOAD_FIELD ; Load field food (offset 203)
     48: LOAD_FIELD ; Load field y (offset 1)
     49: r46 = 1
     50: r47 = call games.snake.plot_pixel$u8$u8$u8
     51: LOAD_PARAM
     52: LOAD_FIELD ; Load field score (offset 205)
     53: r0 = call print_u16_decimal ; Call runtime print_u16_decimal
     54: return

Function games.snake.game_loop() -> void
  @smc
  Locals:
    r1 = game: games.snake.GameState
  Instructions:
      0: r2 = call games.snake.init_game
      1: store game, r2
      2: r3 = load game
      3: ADDR
      4: r5 = load game
      5: ADDR
      6: r7 = call games.snake.render_game$p_GameState
      7: loop_47:
      8: r8 = load game
      9: LOAD_FIELD ; Load field game_over (offset 207)
     10: r10 = 0
     11: r11 = r9 == r10
     12: r12 = load game
     13: LOAD_FIELD ; Load field snake (offset 0)
     14: LOAD_FIELD ; Load field alive (offset 202)
     15: r15 = 1
     16: r16 = r14 == r15
     17: UNKNOWN_OP_60
     18: jump_if_not r17, end_loop_48
     19: r18 = load game
     20: LOAD_FIELD ; Load field snake (offset 0)
     21: ADDR
     22: r21 = load game
     23: LOAD_FIELD ; Load field snake (offset 0)
     24: ADDR
     25: r24 = call games.snake.handle_input$p_Snake
     26: r25 = load game
     27: LOAD_FIELD ; Load field snake (offset 0)
     28: LOAD_FIELD ; Load field alive (offset 202)
     29: r28 = 0
     30: r29 = r27 == r28
     31: jump_if_not r29, else_49
     32: jump end_if_50
     33: else_49:
     34: end_if_50:
     35: r30 = load game
     36: LOAD_FIELD ; Load field snake (offset 0)
     37: ADDR
     38: r33 = load game
     39: LOAD_FIELD ; Load field snake (offset 0)
     40: ADDR
     41: r36 = call games.snake.move_snake$p_Snake
     42: r37 = load game
     43: LOAD_FIELD ; Load field snake (offset 0)
     44: ADDR
     45: r40 = load game
     46: LOAD_FIELD ; Load field snake (offset 0)
     47: ADDR
     48: PATCH_TEMPLATE
     49: PATCH_TARGET
     50: PATCH_PARAM
     51: r43 = call games.snake.check_collision$p_Snake
     52: r44 = 1
     53: r45 = r43 == r44
     54: jump_if_not r45, else_51
     55: r46 = 1
     56: r47 = load game
     57: STORE_FIELD ; Store to field game_over (offset 207)
     58: jump end_if_52
     59: else_51:
     60: end_if_52:
     61: r48 = load game
     62: LOAD_FIELD ; Load field snake (offset 0)
     63: ADDR
     64: r51 = load game
     65: LOAD_FIELD ; Load field food (offset 203)
     66: ADDR
     67: r54 = load game
     68: LOAD_FIELD ; Load field snake (offset 0)
     69: ADDR
     70: r57 = load game
     71: LOAD_FIELD ; Load field food (offset 203)
     72: ADDR
     73: PATCH_TEMPLATE
     74: PATCH_TARGET
     75: PATCH_PARAM
     76: PATCH_PARAM
     77: r60 = call games.snake.check_food_collision$p_Snake$p_Point
     78: r61 = 1
     79: r62 = r60 == r61
     80: jump_if_not r62, else_53
     81: r63 = load game
     82: LOAD_FIELD ; Load field snake (offset 0)
     83: ADDR
     84: r66 = load game
     85: LOAD_FIELD ; Load field snake (offset 0)
     86: ADDR
     87: r69 = call games.snake.grow_snake$p_Snake
     88: r70 = load game
     89: LOAD_FIELD ; Load field snake (offset 0)
     90: ADDR
     91: r73 = load game
     92: LOAD_FIELD ; Load field snake (offset 0)
     93: ADDR
     94: r76 = call games.snake.generate_food$p_Snake
     95: r77 = load game
     96: STORE_FIELD ; Store to field food (offset 203)
     97: r78 = load game
     98: LOAD_FIELD ; Load field score (offset 205)
     99: r80 = 10
    100: r81 = r79 + r80
    101: r82 = load game
    102: STORE_FIELD ; Store to field score (offset 205)
    103: jump end_if_54
    104: else_53:
    105: end_if_54:
    106: r83 = load game
    107: ADDR
    108: r85 = load game
    109: ADDR
    110: r87 = call games.snake.render_game$p_GameState
    111: r88 = 5
    112: r89 = 5
    113: r90 = call games.snake.delay$u16
    114: jump loop_47
    115: end_loop_48:
    116: r91 = 2
    117: r92 = 2
    118: r93 = call games.snake.set_border$u8
    119: r94 = 25
    120: r95 = 25
    121: r96 = call games.snake.delay$u16
    122: r97 = 0
    123: r98 = 0
    124: r99 = call games.snake.set_border$u8
    125: r100 = call games.snake.clear_screen
    126: r101 = load game
    127: LOAD_FIELD ; Load field score (offset 205)
    128: r0 = call print_u16_decimal ; Call runtime print_u16_decimal
    129: return

Function games.snake.main() -> void
  @smc
  Instructions:
      0: r1 = call games.snake.game_loop
      1: return

