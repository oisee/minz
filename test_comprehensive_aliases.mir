; MinZ Intermediate Representation (MIR)
; Module: main

Function math.square$u8(x: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r4 = r2 * r3
      3: return r4

Function math.square$u16(x: u16) -> u16
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r4 = r2 * r3
      3: return r4

Function math.cube$u8(x: u8) -> u16
  @smc
  Locals:
    r2 = result: u16
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r5 = r3 * r4
      3: LOAD_PARAM
      4: r7 = r5 * r6
      5: store result, r7
      6: r8 = load result
      7: return r8

Function math.is_even$u8(x: u8) -> bool
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r3 = 1
      2: r4 = r2 & r3
      3: r5 = 0
      4: r6 = r4 == r5
      5: return r6

Function math.is_odd$u8(x: u8) -> bool
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r3 = 1
      2: r4 = r2 & r3
      3: r5 = 1
      4: r6 = r4 == r5
      5: return r6

Function math.clamp$u8$u8$u8(value: u8, min: u8, max: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r6 = r4 < r5
      3: jump_if_not r6, else_1
      4: LOAD_PARAM
      5: return r7
      6: jump end_if_2
      7: else_1:
      8: end_if_2:
      9: LOAD_PARAM
     10: LOAD_PARAM
     11: r10 = r8 > r9
     12: jump_if_not r10, else_3
     13: LOAD_PARAM
     14: return r11
     15: jump end_if_4
     16: else_3:
     17: end_if_4:
     18: LOAD_PARAM
     19: return r12

Function math.gcd$u8$u8(a: u8, b: u8) -> u8
  @smc
  Locals:
    r3 = x: u16
    r5 = y: u16
    r10 = temp: u16
  Instructions:
      0: LOAD_PARAM
      1: store x, r4
      2: LOAD_PARAM
      3: store y, r6
      4: loop_5:
      5: r7 = load y
      6: r8 = 0
      7: r9 = r7 != r8
      8: jump_if_not r9, end_loop_6
      9: r11 = load y
     10: store temp, r11
     11: r12 = load x
     12: r13 = load y
     13: MOD
     14: store y, r14
     15: r15 = load temp
     16: store x, r15
     17: jump loop_5
     18: end_loop_6:
     19: r16 = load x
     20: return r16

Function math.lcm$u8$u8(a: u8, b: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r4 = 0
      2: r5 = r3 == r4
      3: LOAD_PARAM
      4: r7 = 0
      5: r8 = r6 == r7
      6: UNKNOWN_OP_61
      7: jump_if_not r9, else_7
      8: r10 = 0
      9: return r10
     10: jump end_if_8
     11: else_7:
     12: end_if_8:
     13: LOAD_PARAM
     14: LOAD_PARAM
     15: r13 = r11 * r12
     16: LOAD_PARAM
     17: LOAD_PARAM
     18: PATCH_TEMPLATE
     19: PATCH_TARGET
     20: PATCH_PARAM
     21: PATCH_PARAM
     22: r16 = call math.gcd
     23: DIV
     24: return r17

Function math.square$u8(x: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r4 = r2 * r3
      3: return r4

Function math.square$u16(x: u16) -> u16
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r4 = r2 * r3
      3: return r4

Function math.cube$u8(x: u8) -> u16
  @smc
  Locals:
    r2 = result: u16
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r5 = r3 * r4
      3: LOAD_PARAM
      4: r7 = r5 * r6
      5: store result, r7
      6: r8 = load result
      7: return r8

Function math.is_even$u8(x: u8) -> bool
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r3 = 1
      2: r4 = r2 & r3
      3: r5 = 0
      4: r6 = r4 == r5
      5: return r6

Function math.is_odd$u8(x: u8) -> bool
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r3 = 1
      2: r4 = r2 & r3
      3: r5 = 1
      4: r6 = r4 == r5
      5: return r6

Function math.clamp$u8$u8$u8(value: u8, min: u8, max: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r6 = r4 < r5
      3: jump_if_not r6, else_9
      4: LOAD_PARAM
      5: return r7
      6: jump end_if_10
      7: else_9:
      8: end_if_10:
      9: LOAD_PARAM
     10: LOAD_PARAM
     11: r10 = r8 > r9
     12: jump_if_not r10, else_11
     13: LOAD_PARAM
     14: return r11
     15: jump end_if_12
     16: else_11:
     17: end_if_12:
     18: LOAD_PARAM
     19: return r12

Function math.gcd$u8$u8(a: u8, b: u8) -> u8
  @smc
  Locals:
    r3 = x: u16
    r5 = y: u16
    r10 = temp: u16
  Instructions:
      0: LOAD_PARAM
      1: store x, r4
      2: LOAD_PARAM
      3: store y, r6
      4: loop_13:
      5: r7 = load y
      6: r8 = 0
      7: r9 = r7 != r8
      8: jump_if_not r9, end_loop_14
      9: r11 = load y
     10: store temp, r11
     11: r12 = load x
     12: r13 = load y
     13: MOD
     14: store y, r14
     15: r15 = load temp
     16: store x, r15
     17: jump loop_13
     18: end_loop_14:
     19: r16 = load x
     20: return r16

Function math.lcm$u8$u8(a: u8, b: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r4 = 0
      2: r5 = r3 == r4
      3: LOAD_PARAM
      4: r7 = 0
      5: r8 = r6 == r7
      6: UNKNOWN_OP_61
      7: jump_if_not r9, else_15
      8: r10 = 0
      9: return r10
     10: jump end_if_16
     11: else_15:
     12: end_if_16:
     13: LOAD_PARAM
     14: LOAD_PARAM
     15: r13 = r11 * r12
     16: LOAD_PARAM
     17: LOAD_PARAM
     18: PATCH_TEMPLATE
     19: PATCH_TARGET
     20: PATCH_PARAM
     21: PATCH_PARAM
     22: r16 = call math.gcd
     23: DIV
     24: return r17

Function ...test_comprehensive_aliases.main() -> void
  @smc
  Locals:
    r2 = x: u8
    r4 = y: u8
    r17 = key: u16
    r21 = clamped: u16
  Instructions:
      0: r0 = call cls ; Clear screen
      1: LOAD_LABEL ; Load string "=== Module Alias Test ==="
      2: PRINT ; Print value
      3: r0 = call print_newline ; Print newline
      4: r3 = 12
      5: store x, r3
      6: r5 = 8
      7: store y, r5
      8: LOAD_LABEL ; Load string "GCD(12, 8) = "
      9: PRINT ; Built-in print function
     10: r7 = load x
     11: r8 = load y
     12: PATCH_TEMPLATE
     13: PATCH_TARGET
     14: PATCH_PARAM
     15: PATCH_PARAM
     16: r9 = call math.gcd
     17: PRINT ; Print value
     18: r0 = call print_newline ; Print newline
     19: r10 = 3
     20: r0 = call zx_set_border ; Set border color
     21: r11 = 7
     22: r0 = call zx_set_ink ; Set ink color
     23: r12 = 0
     24: r0 = call zx_set_paper ; Set paper color
     25: r13 = load x
     26: r14 = call math.is_even
     27: jump_if_not r14, else_17
     28: LOAD_LABEL ; Load string "12 is even"
     29: PRINT ; Print value
     30: r0 = call print_newline ; Print newline
     31: jump end_if_18
     32: else_17:
     33: end_if_18:
     34: LOAD_LABEL ; Load string "Press any key..."
     35: PRINT ; Built-in print function
     36: r18 = call zx_wait_key ; Wait for key press
     37: store key, r18
     38: LOAD_LABEL ; Load string "You pressed: "
     39: PRINT ; Built-in print function
     40: r20 = load key
     41: PRINT ; Print value
     42: r0 = call print_newline ; Print newline
     43: r22 = 200
     44: r23 = 0
     45: r24 = 100
     46: PATCH_TEMPLATE
     47: PATCH_TARGET
     48: PATCH_PARAM
     49: PATCH_PARAM
     50: PATCH_PARAM
     51: r25 = call math.clamp
     52: store clamped, r25
     53: LOAD_LABEL ; Load string "200 clamped to 0-100 = "
     54: PRINT ; Built-in print function
     55: r27 = load clamped
     56: PRINT ; Print value
     57: r0 = call print_newline ; Print newline
     58: return

