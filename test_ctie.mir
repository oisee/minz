; MinZ Intermediate Representation (MIR)
; Module: main

; Globals:
;   test_working_features.counter: u8

Function test_working_features.add$u8$u8(a: u8, b: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r5 = r3 + r4
      3: return r5

Function test_working_features.sum_array$a5_u8(arr: [5]u8) -> u8
  @smc
  Locals:
    r2 = sum: u8
  Instructions:
      0: r3 = 0
      1: store sum, r3
      2: r4 = 0
      3: r5 = 5
      4: r6 = r4 ; Initialize loop variable i
      5: for_loop_1:
      6: r7 = r6 < r5 ; Check i < end
      7: jump_if_not r7, for_end_2
      8: r8 = load sum
      9: LOAD_PARAM
     10: r10 = load i
     11: LOAD_INDEX ; Load array element (u8)
     12: r12 = r8 + r11
     13: store sum, r12
     14: r13 = 1
     15: r6 = r6 + r13 ; Increment i
     16: jump for_loop_1
     17: for_end_2:
     18: r14 = load sum
     19: return r14

Function test_working_features.print$u8(val: u8) -> void
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r0 = call print_u8_decimal ; Call runtime print_u8_decimal
      2: return

Function test_working_features.print$u16(val: u16) -> void
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r0 = call print_u16_decimal ; Call runtime print_u16_decimal
      2: return

Function test_working_features.main() -> void
  @smc
  Locals:
    r1 = result: u16
    r10 = p: u16
    r19 = arr: [5]u8
    r44 = total: u16
    r55 = big: u16
  Instructions:
      0: r2 = 5
      1: r3 = 3
      2: r4 = 5
      3: r5 = 3
      4: PATCH_TEMPLATE
      5: PATCH_TARGET
      6: PATCH_PARAM
      7: PATCH_PARAM
      8: r6 = 8 ; CTIE: Computed at compile-time (was CALL test_working_features.add$u8$u8)
      9: store result, r6
     10: r7 = load result
     11: r8 = load result
     12: r9 = call test_working_features.print$u16
     13: ALLOC ; Allocate struct Point
     14: r12 = 10
     15: STORE_FIELD ; Store to Point.x
     16: r13 = 20
     17: STORE_FIELD ; Store to Point.y
     18: store p, r11
     19: r14 = load p
     20: LOAD_FIELD ; Load field x (offset 0)
     21: r16 = load p
     22: LOAD_FIELD ; Load field x (offset 0)
     23: r18 = call test_working_features.print$u8
     24: r21 = 1
     25: r22 = 2
     26: r23 = 3
     27: r24 = 4
     28: r25 = 5
     29: ARRAY_INIT ; Array initializer with 5 elements
     30: ARRAY_ELEMENT ; Initialize array[0]
     31: ARRAY_ELEMENT ; Initialize array[1]
     32: ARRAY_ELEMENT ; Initialize array[2]
     33: ARRAY_ELEMENT ; Initialize array[3]
     34: ARRAY_ELEMENT ; Initialize array[4]
     35: r26 = 1
     36: r27 = load arr ; Load array arr base address
     37: STORE_INDEX ; Store element 0
     38: r28 = 2
     39: r29 = load arr ; Load array arr base address
     40: r30 = 1
     41: r31 = r29 + r30
     42: STORE_DIRECT ; Store element 1
     43: r32 = 3
     44: r33 = load arr ; Load array arr base address
     45: r34 = 2
     46: r35 = r33 + r34
     47: STORE_DIRECT ; Store element 2
     48: r36 = 4
     49: r37 = load arr ; Load array arr base address
     50: r38 = 3
     51: r39 = r37 + r38
     52: STORE_DIRECT ; Store element 3
     53: r40 = 5
     54: r41 = load arr ; Load array arr base address
     55: r42 = 4
     56: r43 = r41 + r42
     57: STORE_DIRECT ; Store element 4
     58: r45 = load arr
     59: r46 = load arr
     60: PATCH_TEMPLATE
     61: PATCH_TARGET
     62: PATCH_PARAM
     63: r47 = call test_working_features.sum_array$a5_u8
     64: store total, r47
     65: r48 = load total
     66: r49 = load total
     67: r50 = call test_working_features.print$u16
     68: r51 = 42
     69: store counter, r51
     70: r52 = load test_working_features.counter
     71: r53 = load test_working_features.counter
     72: r54 = call test_working_features.print$u8
     73: r56 = 1000
     74: store big, r56
     75: r57 = load big
     76: r58 = load big
     77: r59 = call test_working_features.print$u16
     78: return

