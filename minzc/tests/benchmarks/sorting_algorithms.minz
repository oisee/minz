// Sorting Algorithms Benchmark - TSMC optimization for array operations
//
// Compares different sorting algorithms and demonstrates how TSMC
// optimizes comparison and swap operations in tight loops.

module sorting_algorithms;

// Bubble sort with instrumented operations
export fn bubble_sort(arr: *u16, size: u16) -> u16 {
    let swaps: u16 = 0;
    let i: u16 = 0;
    
    while (i < dec(size)) {
        let j: u16 = 0;
        let limit: u16 = calc_limit(size, i);
        let made_swap: bool = false;
        
        while (j < limit) {
            if (should_swap(arr, j)) {
                perform_swap(arr, j);
                swaps = inc(swaps);
                made_swap = true;
            }
            j = inc(j);
        }
        
        // Early termination if no swaps
        if (!made_swap) {
            break;
        }
        
        i = inc(i);
    }
    
    return swaps;
}

// Insertion sort - benefits from TSMC in shifting operations
export fn insertion_sort(arr: *u16, size: u16) -> u16 {
    let comparisons: u16 = 0;
    let i: u16 = 1;
    
    while (i < size) {
        let key: u16 = get_element(arr, i);
        let j: u16 = i;
        
        while (j > 0 && is_greater(get_element(arr, dec(j)), key)) {
            set_element(arr, j, get_element(arr, dec(j)));
            j = dec(j);
            comparisons = inc(comparisons);
        }
        
        set_element(arr, j, key);
        i = inc(i);
    }
    
    return comparisons;
}

// Selection sort - TSMC optimizes min finding
export fn selection_sort(arr: *u16, size: u16) -> u16 {
    let swaps: u16 = 0;
    let i: u16 = 0;
    
    while (i < dec(size)) {
        let min_idx: u16 = find_minimum(arr, i, size);
        
        if (min_idx != i) {
            swap_elements(arr, i, min_idx);
            swaps = inc(swaps);
        }
        
        i = inc(i);
    }
    
    return swaps;
}

// Find minimum element in subarray
fn find_minimum(arr: *u16, start: u16, size: u16) -> u16 {
    let min_idx: u16 = start;
    let min_val: u16 = get_element(arr, start);
    let j: u16 = inc(start);
    
    while (j < size) {
        let val: u16 = get_element(arr, j);
        if (is_less(val, min_val)) {
            min_idx = j;
            min_val = val;
        }
        j = inc(j);
    }
    
    return min_idx;
}

// Helper functions optimized by TSMC
fn calc_limit(size: u16, i: u16) -> u16 {
    return size - i - 1;
}

fn should_swap(arr: *u16, index: u16) -> bool {
    return is_greater(get_element(arr, index), get_element(arr, inc(index)));
}

fn get_element(arr: *u16, index: u16) -> u16 {
    return *(arr + index);
}

fn set_element(arr: *u16, index: u16, value: u16) -> void {
    *(arr + index) = value;
}

fn perform_swap(arr: *u16, index: u16) -> void {
    let temp: u16 = get_element(arr, index);
    set_element(arr, index, get_element(arr, inc(index)));
    set_element(arr, inc(index), temp);
}

fn swap_elements(arr: *u16, i: u16, j: u16) -> void {
    let temp: u16 = get_element(arr, i);
    set_element(arr, i, get_element(arr, j));
    set_element(arr, j, temp);
}

fn is_greater(a: u16, b: u16) -> bool {
    return a > b;
}

fn is_less(a: u16, b: u16) -> bool {
    return a < b;
}

fn inc(x: u16) -> u16 {
    return x + 1;
}

fn dec(x: u16) -> u16 {
    return x - 1;
}

// Initialize test arrays
fn init_array(arr: *u16, pattern: u16) -> void {
    // Pattern 0: Random-like
    if (pattern == 0) {
        *arr = 8; *(arr+1) = 3; *(arr+2) = 5; *(arr+3) = 1;
        *(arr+4) = 9; *(arr+5) = 2; *(arr+6) = 7; *(arr+7) = 4;
    }
    // Pattern 1: Reverse sorted
    else if (pattern == 1) {
        *arr = 8; *(arr+1) = 7; *(arr+2) = 6; *(arr+3) = 5;
        *(arr+4) = 4; *(arr+5) = 3; *(arr+6) = 2; *(arr+7) = 1;
    }
    // Pattern 2: Nearly sorted
    else {
        *arr = 1; *(arr+1) = 2; *(arr+2) = 4; *(arr+3) = 3;
        *(arr+4) = 5; *(arr+5) = 6; *(arr+6) = 8; *(arr+7) = 7;
    }
}

// Copy array for fair comparison
fn copy_array(dest: *u16, src: *u16, size: u16) -> void {
    let i: u16 = 0;
    while (i < size) {
        *(dest + i) = *(src + i);
        i = inc(i);
    }
}

// Benchmark runner
export fn run_sort_benchmark() -> u16 {
    let arr1: *u16 = 0x9000 as *u16;  // Original array
    let arr2: *u16 = 0x9100 as *u16;  // Work array
    let size: u16 = 8;
    let result: u16 = 0;
    
    // Test with random-like data
    init_array(arr1, 0);
    
    // Bubble sort
    copy_array(arr2, arr1, size);
    result = result + bubble_sort(arr2, size);
    
    // Insertion sort
    copy_array(arr2, arr1, size);
    result = result + insertion_sort(arr2, size);
    
    // Selection sort
    copy_array(arr2, arr1, size);
    result = result + selection_sort(arr2, size);
    
    // Test with reverse sorted data (worst case)
    init_array(arr1, 1);
    
    // Bubble sort on worst case
    copy_array(arr2, arr1, size);
    result = result + bubble_sort(arr2, size);
    
    return result;
}

export fn main() -> u16 {
    return run_sort_benchmark();
}