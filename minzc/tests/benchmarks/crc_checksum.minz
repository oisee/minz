// CRC Checksum Benchmark - Real-world algorithm optimization
//
// Demonstrates TSMC benefits in bit manipulation and table lookups
// commonly used in communication protocols and data integrity checks.

module crc_checksum;

// CRC-8 with polynomial 0x07 (ATM HEC)
export fn crc8_calculate(data: *u8, len: u16) -> u16 {
    let crc: u8 = 0;
    let i: u16 = 0;
    
    while (i < len) {
        crc = process_byte(crc, get_byte(data, i));
        i = advance_index(i);
    }
    
    return crc as u16;
}

// CRC-16 with polynomial 0x1021 (CCITT)
export fn crc16_calculate(data: *u8, len: u16) -> u16 {
    let crc: u16 = 0xFFFF;
    let i: u16 = 0;
    
    while (i < len) {
        crc = process_byte_16(crc, get_byte(data, i));
        i = advance_index(i);
    }
    
    return crc;
}

// Process single byte for CRC-8
fn process_byte(crc: u8, byte: u8) -> u8 {
    crc = xor_byte(crc, byte);
    let bit: u8 = 0;
    
    while (bit < 8) {
        if (has_msb_8(crc)) {
            crc = apply_polynomial_8(crc);
        } else {
            crc = shift_left_8(crc);
        }
        bit = inc_bit(bit);
    }
    
    return crc;
}

// Process single byte for CRC-16
fn process_byte_16(crc: u16, byte: u8) -> u16 {
    crc = xor_high_byte(crc, byte);
    let bit: u8 = 0;
    
    while (bit < 8) {
        if (has_msb_16(crc)) {
            crc = apply_polynomial_16(crc);
        } else {
            crc = shift_left_16(crc);
        }
        bit = inc_bit(bit);
    }
    
    return crc;
}

// Helper functions optimized by TSMC
fn get_byte(data: *u8, index: u16) -> u8 {
    return *(data + index);
}

fn advance_index(i: u16) -> u16 {
    return i + 1;
}

fn xor_byte(a: u8, b: u8) -> u8 {
    return a ^ b;
}

fn xor_high_byte(crc: u16, byte: u8) -> u16 {
    return crc ^ (byte as u16 << 8);
}

fn has_msb_8(val: u8) -> bool {
    return (val & 0x80) != 0;
}

fn has_msb_16(val: u16) -> bool {
    return (val & 0x8000) != 0;
}

fn apply_polynomial_8(val: u8) -> u8 {
    return (val << 1) ^ 0x07;
}

fn apply_polynomial_16(val: u16) -> u16 {
    return (val << 1) ^ 0x1021;
}

fn shift_left_8(val: u8) -> u8 {
    return val << 1;
}

fn shift_left_16(val: u16) -> u16 {
    return val << 1;
}

fn inc_bit(b: u8) -> u8 {
    return b + 1;
}

// Table-based CRC-8 for comparison
export fn crc8_table_based(data: *u8, len: u16) -> u16 {
    // Initialize CRC table at 0x9400
    let table: *u8 = 0x9400 as *u8;
    init_crc8_table(table);
    
    let crc: u8 = 0;
    let i: u16 = 0;
    
    while (i < len) {
        crc = table_lookup(table, xor_byte(crc, get_byte(data, i)));
        i = advance_index(i);
    }
    
    return crc as u16;
}

// Initialize CRC-8 lookup table
fn init_crc8_table(table: *u8) -> void {
    let i: u16 = 0;
    
    while (i < 256) {
        let crc: u8 = i as u8;
        let j: u8 = 0;
        
        while (j < 8) {
            if (has_msb_8(crc)) {
                crc = apply_polynomial_8(crc);
            } else {
                crc = shift_left_8(crc);
            }
            j = inc_bit(j);
        }
        
        *(table + i) = crc;
        i = advance_index(i);
    }
}

fn table_lookup(table: *u8, index: u8) -> u8 {
    return *(table + index as u16);
}

// Generate test data patterns
fn generate_test_data(data: *u8, pattern: u16, len: u16) -> void {
    let i: u16 = 0;
    
    if (pattern == 0) {
        // Incremental pattern
        while (i < len) {
            *(data + i) = i as u8;
            i = advance_index(i);
        }
    } else if (pattern == 1) {
        // Pseudo-random pattern
        while (i < len) {
            *(data + i) = ((i * 17) ^ 0x55) as u8;
            i = advance_index(i);
        }
    } else {
        // All ones (stress test)
        while (i < len) {
            *(data + i) = 0xFF;
            i = advance_index(i);
        }
    }
}

// Benchmark runner
export fn run_crc_benchmark() -> u16 {
    let data: *u8 = 0x9000 as *u8;
    let result: u16 = 0;
    
    // Test with different data patterns and sizes
    
    // Pattern 0: Incremental, 32 bytes
    generate_test_data(data, 0, 32);
    result = result + crc8_calculate(data, 32);
    result = result + crc16_calculate(data, 32);
    
    // Pattern 1: Pseudo-random, 64 bytes
    generate_test_data(data, 1, 64);
    result = result + crc8_calculate(data, 64);
    result = result + crc8_table_based(data, 64);
    
    // Pattern 2: All ones, 16 bytes
    generate_test_data(data, 2, 16);
    result = result + crc16_calculate(data, 16);
    
    return result;
}

export fn main() -> u16 {
    return run_crc_benchmark();
}