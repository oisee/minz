; MinZ generated code
; Generated: 2025-08-02 09:30:05


; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.draw
.Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.draw:
; TRUE SMC function with immediate anchors
self$immOP:
    LD A, 0        ; self anchor (will be patched)
self$imm0 EQU self$immOP+1
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.get_size
.Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.get_size:
; TRUE SMC function with immediate anchors
self$immOP:
    LD B, 0        ; self anchor (will be patched)
self$imm0 EQU self$immOP+1
    LD A, (self$imm0)    ; Reuse from anchor
    LD C, A         ; Store to physical register C
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.scale
.Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.scale:
; TRUE SMC function with immediate anchors
self$immOP:
    LD D, 0        ; self anchor (will be patched)
self$imm0 EQU self$immOP+1
factor$immOP:
    LD E, 0        ; factor anchor (will be patched)
factor$imm0 EQU factor$immOP+1
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.draw
.Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.draw:
; TRUE SMC function with immediate anchors
self$immOP:
    LD HL, 0       ; self anchor (will be patched)
self$imm0 EQU self$immOP+1
    ; Register 2 already in HL
    LD HL, (self$imm0)   ; Reuse from anchor
    LD D, H
    LD E, L
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.get_size
.Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.get_size:
; TRUE SMC function with immediate anchors
self$immOP:
    LD HL, 0       ; self anchor (will be patched)
self$imm0 EQU self$immOP+1
    LD B, H
    LD C, L
    LD HL, (self$imm0)   ; Reuse from anchor
    PUSH HL           ; Save current HL
    EXX               ; Switch to shadow registers
    POP HL            ; Load into shadow HL
    EXX               ; Switch back to main registers
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.scale
.Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.scale:
; TRUE SMC function with immediate anchors
self$immOP:
    LD HL, 0       ; self anchor (will be patched)
self$imm0 EQU self$immOP+1
    LD HL, (self$imm0)   ; Reuse from anchor
factor$immOP:
    LD A, 0        ; factor anchor (will be patched)
factor$imm0 EQU factor$immOP+1
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas$double_0
.Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas$double_0:
; TRUE SMC function with immediate anchors
x$immOP:
    LD A, 0        ; x anchor (will be patched)
x$imm0 EQU x$immOP+1
    LD L, A         ; Store to HL (low byte)
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas$add_five_1
.Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas$add_five_1:
; TRUE SMC function with immediate anchors
x$immOP:
    LD A, 0        ; x anchor (will be patched)
x$imm0 EQU x$immOP+1
    LD H, A         ; Store to physical register H
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas$multiply_2
.Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas$multiply_2:
; TRUE SMC function with immediate anchors
a$immOP:
    LD A, 0        ; a anchor (will be patched)
a$imm0 EQU a$immOP+1
    LD L, A         ; Store to physical register L
b$immOP:
    LD A, 0        ; b anchor (will be patched)
b$imm0 EQU b$immOP+1
    LD L, A         ; Store to HL (low byte)
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas
.Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    PUSH BC
    PUSH DE
    ; r3 = call double
    ; Call to double (args: 1)
    ; Stack-based parameter passing
    LD HL, ($F004)    ; Virtual register 2 from memory
    PUSH HL       ; Argument 0
    CALL double
    ; store , r3
    LD ($F002), HL
    ; r6 = call add_five
    ; Call to add_five (args: 1)
    ; Stack-based parameter passing
    LD HL, ($F00A)    ; Virtual register 5 from memory
    PUSH HL       ; Argument 0
    CALL add_five
    ; store , r6
    LD ($F008), HL
    ; r10 = call multiply
    ; Call to multiply (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F012)    ; Virtual register 9 from memory
    PUSH HL       ; Argument 1
    LD HL, ($F010)    ; Virtual register 8 from memory
    PUSH HL       ; Argument 0
    CALL multiply
    ; store , r10
    LD ($F00E), HL
    ; return
    POP DE
    POP BC
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_interfaces
.Users.alice.dev.minz-ts.examples.zero_cost_test.test_interfaces:
; IsSMCDefault=false, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    PUSH DE
    ; Allocate struct Circle
    LD HL, -1
    ADD HL, SP
    LD SP, HL
    EX DE, HL
    LD HL, SP
    ; r3 = 3
    LD A, 3
    EXX               ; Switch to shadow registers
    LD C', A         ; Store to shadow C'
    EXX               ; Switch back to main registers
    ; Store to Circle.radius
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; store , r2
    LD ($F002), HL
    ; Allocate struct Rectangle
    LD HL, -2
    ADD HL, SP
    LD SP, HL
    EX DE, HL
    LD HL, SP
    ; r6 = 4
    LD A, 4
    EXX               ; Switch to shadow registers
    LD E', A         ; Store to shadow E'
    EXX               ; Switch back to main registers
    ; Store to Rectangle.width
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r7 = 5
    LD A, 5
    LD L, A         ; Store to physical register L
    ; Store to Rectangle.height
    LD DE, 1
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; store , r5
    LD ($F008), HL
