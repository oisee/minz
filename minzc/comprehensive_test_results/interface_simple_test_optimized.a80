; MinZ generated code
; Generated: 2025-08-02 13:03:26


; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.interface_simple_test.Circle.draw
.Users.alice.dev.minz-ts.examples.interface_simple_test.Circle.draw:
; TRUE SMC function with immediate anchors
self$immOP:
    LD HL, 0       ; self anchor (will be patched)
self$imm0 EQU self$immOP+1
    ; Register 2 already in HL
    ; Load field x (offset 0)
    ; Register 2 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD HL, (self$imm0)   ; Reuse from anchor
    LD D, H
    LD E, L
    ; Load field y (offset 1)
    LD H, D
    LD L, E
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r6 = r3 + r5
    LD D, H
    LD E, L
    ADD HL, DE
    ; return r6
    POP DE
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.interface_simple_test.Circle.get_area
.Users.alice.dev.minz-ts.examples.interface_simple_test.Circle.get_area:
; TRUE SMC function with immediate anchors
self$immOP:
    LD HL, 0       ; self anchor (will be patched)
self$imm0 EQU self$immOP+1
    LD B, H
    LD C, L
    ; r5 = load r16
    LD HL, ($F004)
    ; r6 = load r16
    LD HL, ($F004)
    ; r7 = r5 * r6
    ; 16-bit multiplication
    LD (mul_src1_0), HL  ; Save multiplicand
    LD (mul_src2_0), HL  ; Save multiplier
    LD HL, 0             ; Result = 0
    LD DE, (mul_src1_0)  ; DE = multiplicand
    LD BC, (mul_src2_0)  ; BC = multiplier
    LD A, B
    OR C                 ; Check if multiplier is 0
    JR Z, .mul16_done_0
.mul16_loop_0:
    ADD HL, DE           ; Result += multiplicand
    DEC BC
    LD A, B
    OR C
    JR NZ, .mul16_loop_0
.mul16_done_0:
mul_src1_0: DW 0
mul_src2_0: DW 0
    PUSH HL           ; Save current HL
    EXX               ; Switch to shadow registers
    POP HL            ; Load into shadow HL
    EXX               ; Switch back to main registers
    ; r8 = 3
    LD A, 3
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    ; r9 = r7 * r8
    ; 16-bit multiplication
    EXX               ; Switch to shadow registers
    PUSH HL           ; Save shadow HL
    EXX               ; Switch back to main registers
    POP HL            ; Load shadow HL into main HL
    LD (mul_src1_1), HL  ; Save multiplicand
    LD (mul_src2_1), HL  ; Save multiplier
    LD HL, 0             ; Result = 0
    LD DE, (mul_src1_1)  ; DE = multiplicand
    LD BC, (mul_src2_1)  ; BC = multiplier
    LD A, B
    OR C                 ; Check if multiplier is 0
    JR Z, .mul16_done_1
.mul16_loop_1:
    ADD HL, DE           ; Result += multiplicand
    DEC BC
    LD A, B
    OR C
    JR NZ, .mul16_loop_1
.mul16_done_1:
mul_src1_1: DW 0
mul_src2_1: DW 0
    ; return r9
    POP DE
    POP BC
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.interface_simple_test.main
.Users.alice.dev.minz-ts.examples.interface_simple_test.main:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    PUSH BC
    PUSH DE
