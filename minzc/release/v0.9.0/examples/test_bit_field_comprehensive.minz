// Comprehensive test of bit struct field access
// Tests both read and write operations on bit fields

// 8-bit register flags (like Z80 F register)
type CPUFlags = bits_8 {
    carry: 1,      // C flag - bit 0
    add_sub: 1,    // N flag - bit 1  
    parity: 1,     // P/V flag - bit 2
    bit3: 1,       // Unused - bit 3
    half_carry: 1, // H flag - bit 4
    bit5: 1,       // Unused - bit 5
    zero: 1,       // Z flag - bit 6
    sign: 1        // S flag - bit 7
};

// 16-bit sprite attributes
type SpriteAttr = bits_16 {
    x_coord: 9,     // 0-511 pixels (bits 0-8)
    palette_id: 3,  // 0-7 (bits 9-11)
    priority: 2,    // 0-3 (bits 12-13)
    h_flip: 1,      // horizontal flip (bit 14)
    v_flip: 1       // vertical flip (bit 15)
};

fun test_8bit_fields() -> void {
    // Create flags with initial value
    let raw: u8 = 0b10000010; // sign=1, zero=0, carry=1
    let flags: CPUFlags = raw as CPUFlags;
    
    // Test read operations
    let c: u8 = flags.carry;        // Should be 0 (bit 0)
    let z: u8 = flags.zero;         // Should be 0 (bit 6)
    let s: u8 = flags.sign;         // Should be 1 (bit 7)
    
    // Test write operations
    flags.zero = 1;                 // Set zero flag
    flags.carry = 0;                // Clear carry flag
    flags.parity = 1;               // Set parity flag
    
    // Test mixed read/write
    let old_sign: u8 = flags.sign;
    flags.sign = 0;
    let new_sign: u8 = flags.sign;
    
    // Test compound operations
    flags.half_carry = flags.carry | flags.zero;
}

fun test_16bit_fields() -> void {
    // Create sprite attributes
    let raw: u16 = 0;
    let sprite: SpriteAttr = raw as SpriteAttr;
    
    // Set multiple fields
    sprite.x_coord = 256;     // 9-bit value
    sprite.palette_id = 3;    // 3-bit value
    sprite.priority = 2;      // 2-bit value
    
    // Read and modify
    let x: u16 = sprite.x_coord;
    sprite.x_coord = x + 1;
    
    // Test boolean-like fields
    if sprite.h_flip == 0 {
        sprite.h_flip = 1;
        sprite.v_flip = 0;
    }
}

fun test_field_expressions() -> void {
    let flags: CPUFlags = 0 as CPUFlags;
    
    // Field in expressions
    let result: u8 = flags.carry + flags.zero * 2 + flags.sign * 4;
    
    // Field as condition
    if flags.zero == 1 {
        flags.sign = 1;
    }
    
    // Multiple field updates
    flags.carry = 1;
    flags.zero = 1;
    flags.sign = 1;
    flags.parity = 0;
}

fun main() -> void {
    test_8bit_fields();
    test_16bit_fields();
    test_field_expressions();
    
    @print("Bit struct field access test completed successfully!\n");
}