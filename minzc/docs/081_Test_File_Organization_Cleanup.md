# Article 081: MinZ Test File Organization and Cleanup Strategy

**Author:** Claude Code Assistant  
**Date:** August 1, 2025  
**Version:** MinZ v0.7.0+  
**Status:** REPOSITORY CLEANUP 🧹

## Current Chaos Analysis

### Scattered Test Files Problem
Test files are currently scattered across multiple directories:

1. **Root Directory** (`/Users/alice/dev/minz-ts/`): 
   - ❌ `test_abi.a80`, `fibonacci.a80`, `simple_add.mir`
   - ❌ 50+ test files that should not be here!

2. **Examples Directory** (`examples/`):
   - ✅ Source files: `fibonacci.minz`, `test_abi.minz` 
   - ✅ Output directory: `examples/output/*.a80`, `examples/output/*.mir`

3. **MinZC Directory** (`minzc/`):
   - ❌ Mixed: some legitimate, some temporary test files

## Proper File Organization

### ✅ Correct Structure
```
minz-ts/
├── examples/                    # MinZ source examples
│   ├── fibonacci.minz          # Source files
│   ├── test_abi.minz
│   ├── simple_add.minz
│   └── output/                 # Compiler output
│       ├── fibonacci.a80       # Assembly output
│       ├── fibonacci.mir       # IR output
│       └── test_abi.a80
├── minzc/                      # Compiler directory
│   ├── tests/                  # Compiler unit tests
│   │   ├── benchmarks/         # Performance tests
│   │   └── corpus/            # Test corpus
│   ├── pkg/                    # Compiler packages
│   └── examples/              # Compiler-specific examples
└── test/                       # Tree-sitter grammar tests
    └── corpus/                 # Grammar test cases
```

### ❌ Current Wrong Structure
```
minz-ts/
├── test_abi.a80              # ❌ Should be in examples/output/
├── fibonacci.mir             # ❌ Should be in examples/output/
├── simple_add.a80            # ❌ Should be in examples/output/
├── (50+ scattered files)     # ❌ All in wrong place!
```

## Cleanup Strategy

### Phase 1: Identify File Categories
1. **MinZ Examples**: `.minz` source files → `examples/`
2. **Compiler Output**: `.a80`, `.mir` files → `examples/output/`
3. **Temporary Files**: Debug files, test artifacts → DELETE
4. **Backup Files**: Archive materials → `archive/`

### Phase 2: Safe Cleanup Process
```bash
# 1. Create proper output directory structure
mkdir -p examples/output
mkdir -p minzc/tests/integration
mkdir -p archive/temp_files

# 2. Move scattered output files to proper location
find . -maxdepth 1 -name "*.a80" -exec mv {} examples/output/ \;
find . -maxdepth 1 -name "*.mir" -exec mv {} examples/output/ \;

# 3. Move source files to examples (if not already there)
find . -maxdepth 1 -name "*.minz" -exec mv {} examples/ \;

# 4. Archive temporary/debug files
find . -maxdepth 1 -name "test_debug*.a80" -exec mv {} archive/temp_files/ \;
find . -maxdepth 1 -name "test_debug*.mir" -exec mv {} archive/temp_files/ \;
```

### Phase 3: Recompile All Examples
```bash
# Recompile all examples to ensure proper output location
cd minzc
for file in ../examples/*.minz; do
    basename=$(basename "$file" .minz)
    echo "Compiling $basename..."
    ./minzc "$file" -o "../examples/output/$basename.a80"
done
```

## Implementation Plan

### Step 1: Backup Current State
```bash
# Create safety backup
tar -czf minz_backup_$(date +%Y%m%d).tar.gz .
```

### Step 2: Clean Root Directory
Move all scattered test files to appropriate locations.

### Step 3: Establish Compilation Script
Create script to recompile all examples and place output correctly.

### Step 4: Update .gitignore
```gitignore
# Temporary files
*.tmp
test_debug*
test_final.*

# Compiler outputs (except examples/output/)
/*.a80
/*.mir
/minzc/*.a80
/minzc/*.mir

# Keep examples output
!examples/output/*.a80
!examples/output/*.mir
```

### Step 5: Documentation Update
Update README to explain proper file organization.

## Expected Benefits

### Cleaner Repository
- Clear separation of source vs output
- Easier to find relevant files
- Professional project structure

### Better Development Workflow
- Predictable file locations
- Easier CI/CD integration
- Simpler build scripts

### Maintainability
- Clear ownership of files
- Easier to clean up artifacts
- Better Git history

## File Location Rules

### Source Files (`.minz`)
- **Location**: `examples/`
- **Purpose**: Demonstrate MinZ language features
- **Naming**: Descriptive names like `fibonacci.minz`, `smc_demo.minz`

### Compiler Output (`.a80`, `.mir`)
- **Location**: `examples/output/`
- **Purpose**: Generated by compiler for testing/verification
- **Naming**: Match source file name: `fibonacci.minz` → `fibonacci.a80`

### Test Files
- **Grammar Tests**: `test/corpus/`
- **Compiler Tests**: `minzc/tests/`
- **Integration Tests**: `minzc/tests/integration/`

### Temporary Files
- **Location**: Should not be committed
- **Purpose**: Debug, development artifacts
- **Cleanup**: Automated cleanup scripts

## Implementation Commands

### Immediate Cleanup
```bash
#!/bin/bash
# cleanup_test_files.sh

echo "Starting MinZ test file cleanup..."

# Create directories
mkdir -p examples/output
mkdir -p archive/scattered_files

# Move scattered .a80 files
echo "Moving .a80 files..."
find . -maxdepth 1 -name "*.a80" -not -path "./examples/*" -exec mv {} examples/output/ \;

# Move scattered .mir files  
echo "Moving .mir files..."
find . -maxdepth 1 -name "*.mir" -not -path "./examples/*" -exec mv {} examples/output/ \;

# Archive debug files
echo "Archiving debug files..."
find . -maxdepth 1 -name "test_debug*" -exec mv {} archive/scattered_files/ \;
find . -maxdepth 1 -name "test_final*" -exec mv {} archive/scattered_files/ \;

echo "Cleanup complete!"
```

### Recompilation Script
```bash
#!/bin/bash
# recompile_examples.sh

echo "Recompiling all MinZ examples..."

cd minzc
for file in ../examples/*.minz; do
    if [ -f "$file" ]; then
        basename=$(basename "$file" .minz)
        echo "Compiling $basename..."
        ./minzc "$file" -o "../examples/output/$basename.a80"
        if [ $? -eq 0 ]; then
            echo "✅ $basename compiled successfully"
        else
            echo "❌ $basename compilation failed"
        fi
    fi
done

echo "Recompilation complete!"
```

## Conclusion

This cleanup will transform the MinZ repository from a chaotic collection of scattered files into a professionally organized codebase with clear file ownership and predictable locations.

The proper organization enables:
- **Better CI/CD**: Predictable file locations for automated testing
- **Easier Development**: Developers know exactly where to find files
- **Professional Appearance**: Clean, organized repository structure
- **Maintainability**: Clear rules for where files belong

---

*A clean repository is like a well-organized workshop - you can find what you need quickly and focus on building great things instead of searching through clutter.*