// Test cases for mutual and indirect recursion detection

// =======  DIRECT RECURSION =======
fun factorial_direct(n: u8) -> u16 {
    if n <= 1 {
        return 1;
    }
    return n * factorial_direct(n - 1);
}

// =======  MUTUAL RECURSION (A ↔ B) =======
fun is_even_mutual(n: u8) -> bool {
    if n == 0 {
        return true;
    }
    return is_odd_mutual(n - 1);
}

fun is_odd_mutual(n: u8) -> bool {
    if n == 0 {
        return false;
    }
    return is_even_mutual(n - 1);
}

// =======  INDIRECT RECURSION (A → B → C → A) =======
fun func_a(n: u8) -> u16 {
    if n == 0 {
        return 1;
    }
    return func_b(n - 1) + 1;
}

fun func_b(n: u8) -> u16 {
    if n == 0 {
        return 2;
    }
    return func_c(n - 1) + 2;
}

fun func_c(n: u8) -> u16 {
    if n == 0 {
        return 3;
    }
    return func_a(n - 1) + 3;  // Back to A - forms cycle A→B→C→A
}

// =======  DEEPER INDIRECT RECURSION (A → B → C → D → A) =======
fun deep_a(n: u8) -> u8 {
    if n == 0 {
        return 1;
    }
    return deep_b(n - 1);
}

fun deep_b(n: u8) -> u8 {
    if n == 0 {
        return 2;
    }
    return deep_c(n - 1);
}

fun deep_c(n: u8) -> u8 {
    if n == 0 {
        return 3;
    }
    return deep_d(n - 1);
}

fun deep_d(n: u8) -> u8 {
    if n == 0 {
        return 4;
    }
    return deep_a(n - 1);  // Back to A - forms cycle A→B→C→D→A
}

// =======  NON-RECURSIVE FUNCTIONS =======
fun simple_add(a: u8, b: u8) -> u8 {
    return a + b;
}

fun chain_caller(n: u8) -> u8 {
    return simple_add(n, 5);  // Calls non-recursive function
}

// =======  MIXED PATTERN =======
fun mixed_recursive(n: u8) -> u16 {
    if n <= 1 {
        return simple_add(n, 1);  // Calls non-recursive
    }
    return is_even_mutual(n) + mixed_recursive(n - 1);  // Direct + mutual recursion
}

// =======  MAIN FUNCTION =======
fun main() -> void {
    // Test all recursion patterns
    let direct = factorial_direct(5);
    let mutual1 = is_even_mutual(4);
    let mutual2 = is_odd_mutual(3);
    let indirect = func_a(3);
    let deep_indirect = deep_a(2);
    let mixed = mixed_recursive(4);
    let simple = simple_add(10, 20);
}