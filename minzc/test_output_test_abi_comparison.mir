; MinZ Intermediate Representation (MIR)
; Module: main

Function ...examples.test_abi_comparison.add_auto(a: u8, b: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r5 = r3 + r4
      3: return r5

Function ...examples.test_abi_comparison.add_register(a: u8, b: u8) -> u8
  Instructions:
      0: r3 = load a
      1: r4 = load b
      2: r5 = r3 + r4
      3: return r5

Function ...examples.test_abi_comparison.add_stack(a: u8, b: u8) -> u8
  Instructions:
      0: r3 = load a
      1: r4 = load b
      2: r5 = r3 + r4
      3: return r5

Function ...examples.test_abi_comparison.add_smc(a: u8, b: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r5 = r3 + r4
      3: return r5

Function ...examples.test_abi_comparison.add_virtual(a: u8, b: u8) -> u8
  Instructions:
      0: r3 = load a
      1: r4 = load b
      2: r5 = r3 + r4
      3: return r5

Function ...examples.test_abi_comparison.complex_calc(a: u8, b: u8, c: u16, d: u16, e: u8, f: u8) -> u16
  Locals:
    r7 = sum1: u16
    r15 = sum2: u16
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r10 = r8 + r9
      3: LOAD_PARAM
      4: r12 = r10 + r11
      5: LOAD_PARAM
      6: r14 = r12 + r13
      7: store , r14
      8: LOAD_PARAM
      9: LOAD_PARAM
     10: r18 = r16 + r17
     11: store , r18
     12: r19 = load sum1
     13: r20 = load sum2
     14: r21 = r19 + r20
     15: return r21

Function ...examples.test_abi_comparison.factorial(n: u8) -> u16
  @smc
  @recursive
  Instructions:
      0: LOAD_PARAM
      1: r3 = 1
      2: r4 = r2 <= r3
      3: jump_if_not r4, else_1
      4: r5 = 1
      5: return r5
      6: jump end_if_2
      7: else_1:
      8: end_if_2:
      9: LOAD_PARAM
     10: LOAD_PARAM
     11: r8 = 1
     12: r9 = r7 - r8
     13: r10 = call factorial
     14: r11 = r6 * r10
     15: return r11

Function ...examples.test_abi_comparison.timer_interrupt() -> void
  @smc
  Locals:
    r1 = counter: u8
  Instructions:
      0: r2 = 0
      1: store , r2
      2: r3 = load counter
      3: r4 = 1
      4: r5 = r3 + r4
      5: store counter, r5
      6: return

Function ...examples.test_abi_comparison.memcpy(dst: *u8, src: *u8, count: u16) -> void
  @smc
  Instructions:
      0: loop_3:
      1: LOAD_PARAM
      2: r5 = 0
      3: r6 = r4 > r5
      4: jump_if_not r6, end_loop_4
      5: LOAD_PARAM
      6: UNKNOWN_OP_66
      7: LOAD_PARAM
      8: UNKNOWN_OP_67 ; Store through pointer
      9: LOAD_PARAM
     10: r11 = 1
     11: r12 = r10 + r11
     12: store dst, r12
     13: LOAD_PARAM
     14: r14 = 1
     15: r15 = r13 + r14
     16: store src, r15
     17: LOAD_PARAM
     18: r17 = 1
     19: r18 = r16 - r17
     20: store count, r18
     21: jump loop_3
     22: end_loop_4:
     23: return

Function ...examples.test_abi_comparison.main() -> void
  Locals:
    r1 = r1: u16
    r5 = r2: u16
    r9 = r3: u16
    r13 = r4: u16
    r17 = r5: u16
    r21 = r6: u16
    r29 = r7: u16
    r32 = src: [10]u8
    r33 = dst: [10]u8
  Instructions:
      0: r2 = 10
      1: r3 = 20
      2: r4 = call add_auto
      3: store , r4
      4: r6 = 10
      5: r7 = 20
      6: r8 = call add_register
      7: store , r8
      8: r10 = 10
      9: r11 = 20
     10: r12 = call add_stack
     11: store , r12
     12: r14 = 10
     13: r15 = 20
     14: r16 = call add_smc
     15: store , r16
     16: r18 = 10
     17: r19 = 20
     18: r20 = call add_virtual
     19: store , r20
     20: r22 = 1
     21: r23 = 2
     22: r24 = 300
     23: r25 = 400
     24: r26 = 5
     25: r27 = 6
     26: r28 = call complex_calc
     27: store , r28
     28: r30 = 5
     29: r31 = call factorial
     30: store , r31
     31: r34 = load dst
     32: r35 = 0
     33: LOAD_INDEX ; Load array element (u8)
     34: UNKNOWN_OP_65
     35: r38 = load src
     36: r39 = 0
     37: LOAD_INDEX ; Load array element (u8)
     38: UNKNOWN_OP_65
     39: r42 = 10
     40: r43 = call memcpy
     41: return

