; MinZ generated code
; Generated: 2025-08-06 20:59:41


; Data section
    ORG $F000

.Users.alice.dev.zvdb-minz.zvdb.vectors:
    DS 512
.Users.alice.dev.zvdb-minz.zvdb.count:
    DB 0
.Users.alice.dev.zvdb-minz.zvdb.lut:
    DS 256
str_0:
    DB 27    ; Length
    DB "ZVDB-MinZ Production Ready"
    DB 10
str_1:
    DB 28    ; Length
    DB "=========================="
    DB 10
    DB 10
str_2:
    DB 20    ; Length
    DB "Initializing LUT..."
    DB 10
str_3:
    DB 25    ; Length
    DB "Creating test vectors..."
    DB 10
str_4:
    DB 13    ; Length
    DB "Database has "
str_5:
    DB 10    ; Length
    DB " vectors"
    DB 10
    DB 10
str_6:
    DB 19    ; Length
    DB "Hamming distances:"
    DB 10
str_7:
    DB 12    ; Length
    DB "  V0 vs V1: "
str_8:
    DB 12    ; Length
    DB "  V0 vs V2: "
str_9:
    DB 14    ; Length
    DB 10
    DB "Searching..."
    DB 10
str_10:
    DB 19    ; Length
    DB "Best match: Vector "
str_11:
    DB 9    ; Length
    DB "Hamming: "
str_12:
    DB 28    ; Length
    DB 10
    DB 226
    DB 156
    DB 133
    DB " ZVDB-MinZ Complete!"
    DB 10

; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.zvdb-minz.zvdb.init_lut
.Users.alice.dev.zvdb-minz.zvdb.init_lut:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = 256
    LD HL, 256
    LD ($F004), HL    ; Virtual register 2 to memory
    ; Initialize loop variable i
    ; for_loop_1:
_Users_alice_dev_zvdb-minz_zvdb_init_lut_for_loop_1:
    ; Check i < end
    LD HL, ($F004)    ; Virtual register 2 from memory
    EX DE, HL
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, _Users_alice_dev_zvdb-minz_zvdb_init_lut_lt_true_0
    LD HL, 0       ; False
    JP _Users_alice_dev_zvdb-minz_zvdb_init_lut_lt_done_0
_Users_alice_dev_zvdb-minz_zvdb_init_lut_lt_true_0:
    LD HL, 1       ; True
_Users_alice_dev_zvdb-minz_zvdb_init_lut_lt_done_0:
    ; jump_if_not r4, for_end_2
    LD A, C
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_init_lut_for_end_2
    ; r10 = 8
    LD A, 8
    LD D, A         ; Store to physical register D
    ; Initialize loop variable b
    ; for_loop_3:
_Users_alice_dev_zvdb-minz_zvdb_init_lut_for_loop_3:
    ; Check b < end
    LD E, D        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, _Users_alice_dev_zvdb-minz_zvdb_init_lut_lt_true_1
    LD HL, 0       ; False
    JP _Users_alice_dev_zvdb-minz_zvdb_init_lut_lt_done_1
_Users_alice_dev_zvdb-minz_zvdb_init_lut_lt_true_1:
    LD HL, 1       ; True
_Users_alice_dev_zvdb-minz_zvdb_init_lut_lt_done_1:
    ; jump_if_not r12, for_end_4
    EXX               ; Switch to shadow registers
    LD A, C'         ; From shadow C'
    EXX               ; Switch back to main registers
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_init_lut_for_end_4
    ; unknown op 57
    LD A, H
    OR L           ; Test HL (set flags)
    ; jump_if_not r19, else_5
    EXX               ; Switch to shadow registers
    LD A, D'         ; From shadow D'
    EXX               ; Switch back to main registers
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_init_lut_else_5
    ; jump end_if_6
    JP _Users_alice_dev_zvdb-minz_zvdb_init_lut_end_if_6
    ; else_5:
_Users_alice_dev_zvdb-minz_zvdb_init_lut_else_5:
    ; end_if_6:
_Users_alice_dev_zvdb-minz_zvdb_init_lut_end_if_6:
    ; r11++
    INC HL
    ; jump for_loop_3
    JP _Users_alice_dev_zvdb-minz_zvdb_init_lut_for_loop_3
    ; for_end_4:
_Users_alice_dev_zvdb-minz_zvdb_init_lut_for_end_4:
    ; r25 = addr(.Users.alice.dev.zvdb-minz.zvdb.lut)
    LD HL, .Users.alice.dev.zvdb-minz.zvdb.lut
    LD D, H
    LD E, L
    ; Store to array[index] (u8)
    ; Register 27 already in HL
    PUSH HL
    LD A, H
    POP HL
    LD (HL), A
    ; r3++
    INC HL
    ; jump for_loop_1
    JP _Users_alice_dev_zvdb-minz_zvdb_init_lut_for_loop_1
    ; for_end_2:
_Users_alice_dev_zvdb-minz_zvdb_init_lut_for_end_2:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.zvdb-minz.zvdb.popcount$u8
.Users.alice.dev.zvdb-minz.zvdb.popcount$u8:
; TRUE SMC function with immediate anchors
    ; r2 = addr(.Users.alice.dev.zvdb-minz.zvdb.lut)
    LD HL, .Users.alice.dev.zvdb-minz.zvdb.lut
val$immOP:
    LD A, 0        ; val anchor (will be patched)
val$imm0 EQU val$immOP+1
    LD L, A         ; Store to HL (low byte)
    ; Load array element (u8)
    PUSH HL
    LD A, L
    LD E, A
    XOR D, D    ; Optimized: was LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; return r4
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.zvdb-minz.zvdb.hamming_by_index$u8$u8
.Users.alice.dev.zvdb-minz.zvdb.hamming_by_index$u8$u8:
; TRUE SMC function with immediate anchors
    ; r6 = 32
    LD A, 32
    EXX               ; Switch to shadow registers
    LD B', A         ; Store to shadow B'
    EXX               ; Switch back to main registers
    ; Initialize loop variable i
    ; for_loop_7:
_Users_alice_dev_zvdb-minz_zvdb_hamming_by_index_u8_u8_for_loop_7:
    ; Check i < end
    EXX               ; Switch to shadow registers
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, _Users_alice_dev_zvdb-minz_zvdb_hamming_by_index_u8_u8_lt_true_2
    LD HL, 0       ; False
    JP _Users_alice_dev_zvdb-minz_zvdb_hamming_by_index_u8_u8_lt_done_2
_Users_alice_dev_zvdb-minz_zvdb_hamming_by_index_u8_u8_lt_true_2:
    LD HL, 1       ; True
_Users_alice_dev_zvdb-minz_zvdb_hamming_by_index_u8_u8_lt_done_2:
    ; jump_if_not r8, for_end_8
    EXX               ; Switch to shadow registers
    LD A, E'         ; From shadow E'
    EXX               ; Switch back to main registers
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_hamming_by_index_u8_u8_for_end_8
    ; r10 = addr(.Users.alice.dev.zvdb-minz.zvdb.vectors)
    LD HL, .Users.alice.dev.zvdb-minz.zvdb.vectors
    LD B, H
    LD C, L
idx1$immOP:
    LD A, 0        ; idx1 anchor (will be patched)
idx1$imm0 EQU idx1$immOP+1
    LD L, A         ; Store to HL (low byte)
    ; Load array element (.Users.alice.dev.zvdb-minz.zvdb.Vector256)
    ; Could optimize: LD H,B / LD L,C
    ; Could optimize: LD H,B / LD L,C
    ; Could optimize: LD H,B / LD L,C
    ; Could optimize: LD H,B / LD L,C
    ; Could optimize: LD H,B / LD L,C
    LD H, B
    LD L, C
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F018), A     ; Virtual register 12 to memory
    ; Load array element (u8)
    PUSH HL
    LD A, L
    LD E, A
    XOR D, D    ; Optimized: was LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD L, A         ; Store to HL (low byte)
    ; r16 = addr(.Users.alice.dev.zvdb-minz.zvdb.vectors)
    LD HL, .Users.alice.dev.zvdb-minz.zvdb.vectors
    PUSH HL           ; Save current HL
    EXX               ; Switch to shadow registers
    POP HL            ; Load into shadow HL
    EXX               ; Switch back to main registers
idx2$immOP:
    LD A, 0        ; idx2 anchor (will be patched)
idx2$imm0 EQU idx2$immOP+1
    LD L, A         ; Store to HL (low byte)
    ; Load array element (.Users.alice.dev.zvdb-minz.zvdb.Vector256)
    EXX               ; Switch to shadow registers
    PUSH HL           ; Save shadow HL
    EXX               ; Switch back to main registers
    POP HL            ; Load shadow HL into main HL
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F024), A     ; Virtual register 18 to memory
    ; Load array element (u8)
    PUSH HL
    LD A, L
    LD E, A
    XOR D, D    ; Optimized: was LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F02A), A     ; Virtual register 21 to memory
    ; Inlined from .Users.alice.dev.zvdb-minz.zvdb.popcount$u8
    LD HL, .Users.alice.dev.zvdb-minz.zvdb.lut
    LD A, (idx1$imm0)    ; Reuse from anchor
    LD ($F004), A     ; Virtual register 2 to memory
    ; Inlined: Load array element (u8)
    PUSH HL
    LD A, ($F004)     ; Virtual register 2 from memory
    LD E, A
    XOR D, D    ; Optimized: was LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; Inlined return value
    ; Increment i
    LD D, H
    LD E, L
    ; Register 30 already in HL
    ADD HL, DE
    ; r30 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; jump for_loop_7
    JP _Users_alice_dev_zvdb-minz_zvdb_hamming_by_index_u8_u8_for_loop_7
    ; for_end_8:
_Users_alice_dev_zvdb-minz_zvdb_hamming_by_index_u8_u8_for_end_8:
    ; r31 = load dist
    LD HL, ($F006)
    ; return r31
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.zvdb-minz.zvdb.hamming_query$Vector256$u8
.Users.alice.dev.zvdb-minz.zvdb.hamming_query$Vector256$u8:
; TRUE SMC function with immediate anchors
    ; r6 = 32
    LD A, 32
    LD L, A         ; Store to physical register L
    ; Initialize loop variable i
    ; for_loop_9:
_Users_alice_dev_zvdb-minz_zvdb_hamming_query_Vector256_u8_for_loop_9:
    ; Check i < end
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, _Users_alice_dev_zvdb-minz_zvdb_hamming_query_Vector256_u8_lt_true_3
    LD HL, 0       ; False
    JP _Users_alice_dev_zvdb-minz_zvdb_hamming_query_Vector256_u8_lt_done_3
_Users_alice_dev_zvdb-minz_zvdb_hamming_query_Vector256_u8_lt_true_3:
    LD HL, 1       ; True
_Users_alice_dev_zvdb-minz_zvdb_hamming_query_Vector256_u8_lt_done_3:
    ; jump_if_not r8, for_end_10
    EXX               ; Switch to shadow registers
    LD A, D'         ; From shadow D'
    EXX               ; Switch back to main registers
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_hamming_query_Vector256_u8_for_end_10
query$immOP:
    ; Load array element (u8)
    ; Register 11 already in HL
    PUSH HL
    LD A, H
    LD E, A
    XOR D, D    ; Optimized: was LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    EXX               ; Switch to shadow registers
    LD E', A         ; Store to shadow E'
    EXX               ; Switch back to main registers
    ; r14 = addr(.Users.alice.dev.zvdb-minz.zvdb.vectors)
    LD HL, .Users.alice.dev.zvdb-minz.zvdb.vectors
    PUSH HL           ; Save current HL
    EXX               ; Switch to shadow registers
    POP HL            ; Load into shadow HL
    EXX               ; Switch back to main registers
idx$immOP:
    LD A, 0        ; idx anchor (will be patched)
idx$imm0 EQU idx$immOP+1
    LD L, A         ; Store to HL (low byte)
    ; Load array element (.Users.alice.dev.zvdb-minz.zvdb.Vector256)
    EXX               ; Switch to shadow registers
    PUSH HL           ; Save shadow HL
    EXX               ; Switch back to main registers
    POP HL            ; Load shadow HL into main HL
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F020), A     ; Virtual register 16 to memory
    ; Load array element (u8)
    PUSH HL
    LD A, L
    LD E, A
    XOR D, D    ; Optimized: was LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F026), A     ; Virtual register 19 to memory
    ; Inlined from .Users.alice.dev.zvdb-minz.zvdb.popcount$u8
    LD HL, .Users.alice.dev.zvdb-minz.zvdb.lut
    LD A, (query$imm0)    ; Reuse from anchor
    LD ($F004), A     ; Virtual register 2 to memory
    ; Inlined: Load array element (u8)
    PUSH HL
    LD A, ($F004)     ; Virtual register 2 from memory
    LD E, A
    XOR D, D    ; Optimized: was LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; Inlined return value
    ; Increment i
    LD D, H
    LD E, L
    ; Register 28 already in HL
    ADD HL, DE
    ; r28 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; jump for_loop_9
    JP _Users_alice_dev_zvdb-minz_zvdb_hamming_query_Vector256_u8_for_loop_9
    ; for_end_10:
_Users_alice_dev_zvdb-minz_zvdb_hamming_query_Vector256_u8_for_end_10:
    ; r29 = load dist
    LD HL, ($F006)
    ; return r29
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256
.Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256:
; TRUE SMC function with immediate anchors
    ; r2 = load .Users.alice.dev.zvdb-minz.zvdb.count
    LD HL, ($F020)
    ; r3 = 16
    LD A, 16
    LD ($F006), A     ; Virtual register 3 to memory
    ; r4 = r2 >= r3
    LD HL, ($F006)    ; Virtual register 3 from memory
    EX DE, HL
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP P, _Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_ge_true_4
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_ge_true_4
    LD HL, 0       ; False
    JP _Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_ge_done_4
_Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_ge_true_4:
    LD HL, 1       ; True
_Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_ge_done_4:
    ; jump_if_not r4, else_11
    LD A, H
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_else_11
    ; r5 = 255
    LD A, 255
    LD L, A         ; Store to physical register L
    ; return r5
    RET
    ; else_11:
_Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_else_11:
    ; r9 = 32
    LD A, 32
    LD H, A         ; Store to physical register H
    ; Initialize loop variable i
    ; for_loop_13:
_Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_for_loop_13:
    ; Check i < end
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, _Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_lt_true_5
    LD HL, 0       ; False
    JP _Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_lt_done_5
_Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_lt_true_5:
    LD HL, 1       ; True
_Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_lt_done_5:
    ; Register 11 already in HL
    ; jump_if_not r11, for_end_14
    LD A, L
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_for_end_14
vec$immOP:
    ; Load array element (u8)
    PUSH HL
    LD A, L
    LD E, A
    XOR D, D    ; Optimized: was LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD L, A         ; Store to HL (low byte)
    ; r16 = addr(.Users.alice.dev.zvdb-minz.zvdb.vectors)
    LD HL, .Users.alice.dev.zvdb-minz.zvdb.vectors
    LD ($F020), HL    ; Virtual register 16 to memory
    ; Load array element (.Users.alice.dev.zvdb-minz.zvdb.Vector256)
    LD HL, ($F020)    ; Virtual register 16 from memory
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD L, A         ; Store to HL (low byte)
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r10++
    INC HL
    ; jump for_loop_13
    JP _Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_for_loop_13
    ; for_end_14:
_Users_alice_dev_zvdb-minz_zvdb_add_vector_Vector256_for_end_14:
    ; r26 = load idx
    LD A, ($F00C)
    LD L, A         ; Store to physical register L
    ; return r26
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.zvdb-minz.zvdb.find_best$Vector256
.Users.alice.dev.zvdb-minz.zvdb.find_best$Vector256:
; TRUE SMC function with immediate anchors
    ; r11 = load .Users.alice.dev.zvdb-minz.zvdb.count
    LD HL, ($F020)
    ; Initialize loop variable i
    ; for_loop_15:
_Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_for_loop_15:
    ; Check i < end
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, _Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_lt_true_6
    LD HL, 0       ; False
    JP _Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_lt_done_6
_Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_lt_true_6:
    LD HL, 1       ; True
_Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_lt_done_6:
    ; Register 13 already in HL
    ; jump_if_not r13, for_end_16
    LD A, L
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_for_end_16
query$immOP:
    LD HL, (query$imm0)   ; Reuse from anchor
    LD ($F022), HL    ; Virtual register 17 to memory
    ; r19 = call .Users.alice.dev.zvdb-minz.zvdb.hamming_query$Vector256$u8
    ; Call to .Users.alice.dev.zvdb-minz.zvdb.hamming_query$Vector256$u8 (args: 2)
    ; Found function, UsesTrueSMC=true
    ; TRUE SMC call to .Users.alice.dev.zvdb-minz.zvdb.hamming_query$Vector256$u8
    LD HL, ($F022)    ; Virtual register 17 from memory
    LD (query$imm0), HL       ; Patch query (atomic)
    LD A, ($F024)     ; Virtual register 18 from memory
    LD (idx$imm0), A        ; Patch idx
    CALL .Users.alice.dev.zvdb-minz.zvdb.hamming_query$Vector256$u8
    ; r20 = load dist
    LD HL, ($F01C)
    ; r21 = load result
    LD HL, ($F004)
    ; Register 21 already in HL
    ; Load field hamming (offset 1)
    ; Register 21 already in HL
    INC HL       ; Optimized: ADD HL,1 -> INC HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F02C), HL    ; Virtual register 22 to memory
    ; r23 = r20 < r22
    LD HL, ($F02C)    ; Virtual register 22 from memory
    EX DE, HL
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, _Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_lt_true_7
    LD HL, 0       ; False
    JP _Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_lt_done_7
_Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_lt_true_7:
    LD HL, 1       ; True
_Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_lt_done_7:
    ; Register 23 already in HL
    ; jump_if_not r23, else_17
    LD A, L
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_else_17
    ; jump end_if_18
    JP _Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_end_if_18
    ; else_17:
_Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_else_17:
    ; end_if_18:
_Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_end_if_18:
    ; r12++
    INC HL
    ; jump for_loop_15
    JP _Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_for_loop_15
    ; for_end_16:
_Users_alice_dev_zvdb-minz_zvdb_find_best_Vector256_for_end_16:
    ; r37 = load result
    LD HL, ($F004)
    ; Register 37 already in HL
    ; return r37
    ; Register 37 already in HL
    POP DE
    POP BC
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.zvdb-minz.zvdb.create_tests
.Users.alice.dev.zvdb-minz.zvdb.create_tests:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    PUSH BC
    PUSH DE
    ; r3 = 32
    LD A, 32
    LD H, A         ; Store to physical register H
    ; Initialize loop variable i
    LD HL, ($F004)    ; Virtual register 2 from memory
    ; for_loop_19:
_Users_alice_dev_zvdb-minz_zvdb_create_tests_for_loop_19:
    ; Check i < end
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, _Users_alice_dev_zvdb-minz_zvdb_create_tests_lt_true_8
    LD HL, 0       ; False
    JP _Users_alice_dev_zvdb-minz_zvdb_create_tests_lt_done_8
_Users_alice_dev_zvdb-minz_zvdb_create_tests_lt_true_8:
    LD HL, 1       ; True
_Users_alice_dev_zvdb-minz_zvdb_create_tests_lt_done_8:
    ; jump_if_not r5, for_end_20
    LD A, H
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_create_tests_for_end_20
    ; unknown op 57
    LD HL, ($F010)    ; Virtual register 8 from memory
    LD A, H
    OR L           ; Test HL (set flags)
    ; jump_if_not r10, else_21
    LD A, L
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_create_tests_else_21
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; jump end_if_22
    JP _Users_alice_dev_zvdb-minz_zvdb_create_tests_end_if_22
    ; else_21:
_Users_alice_dev_zvdb-minz_zvdb_create_tests_else_21:
    ; Store to array[index] (u8)
    LD HL, ($F028)    ; Virtual register 20 from memory
    PUSH HL
    LD A, H
    POP HL
    LD (HL), A
    ; end_if_22:
_Users_alice_dev_zvdb-minz_zvdb_create_tests_end_if_22:
    ; r4++
    INC HL
    ; jump for_loop_19
    JP _Users_alice_dev_zvdb-minz_zvdb_create_tests_for_loop_19
    ; for_end_20:
_Users_alice_dev_zvdb-minz_zvdb_create_tests_for_end_20:
    ; r24 = call .Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256
    ; Call to .Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256 (args: 1)
    ; Found function, UsesTrueSMC=true
    ; TRUE SMC call to .Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256
    LD HL, ($F02E)    ; Virtual register 23 from memory
    LD (vec$imm0), HL       ; Patch vec (atomic)
    CALL .Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256
    ; r26 = 32
    LD A, 32
    LD H, A         ; Store to physical register H
    ; Initialize loop variable i
    ; for_loop_23:
_Users_alice_dev_zvdb-minz_zvdb_create_tests_for_loop_23:
    ; Check i < end
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, _Users_alice_dev_zvdb-minz_zvdb_create_tests_lt_true_9
    LD HL, 0       ; False
    JP _Users_alice_dev_zvdb-minz_zvdb_create_tests_lt_done_9
_Users_alice_dev_zvdb-minz_zvdb_create_tests_lt_true_9:
    LD HL, 1       ; True
_Users_alice_dev_zvdb-minz_zvdb_create_tests_lt_done_9:
    LD ($F038), HL    ; Virtual register 28 to memory
    ; jump_if_not r28, for_end_24
    LD A, ($F038)     ; Virtual register 28 from memory
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_create_tests_for_end_24
    ; Store to array[index] (u8)
    PUSH HL
    LD A, ($F03A)     ; Virtual register 29 from memory
    POP HL
    LD (HL), A
    ; r27++
    INC HL
    ; jump for_loop_23
    JP _Users_alice_dev_zvdb-minz_zvdb_create_tests_for_loop_23
    ; for_end_24:
_Users_alice_dev_zvdb-minz_zvdb_create_tests_for_end_24:
    ; r37 = call .Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256
    ; Call to .Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256 (args: 1)
    ; Found function, UsesTrueSMC=true
    ; TRUE SMC call to .Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256
    LD HL, ($F048)    ; Virtual register 36 from memory
    LD (vec$imm0), HL       ; Patch vec (atomic)
    CALL .Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256
    ; r39 = 32
    LD A, 32
    LD L, A         ; Store to physical register L
    ; Initialize loop variable i
    ; for_loop_25:
_Users_alice_dev_zvdb-minz_zvdb_create_tests_for_loop_25:
    ; Check i < end
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, _Users_alice_dev_zvdb-minz_zvdb_create_tests_lt_true_10
    LD HL, 0       ; False
    JP _Users_alice_dev_zvdb-minz_zvdb_create_tests_lt_done_10
_Users_alice_dev_zvdb-minz_zvdb_create_tests_lt_true_10:
    LD HL, 1       ; True
_Users_alice_dev_zvdb-minz_zvdb_create_tests_lt_done_10:
    ; jump_if_not r41, for_end_26
    LD A, L
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_create_tests_for_end_26
    ; Store to array[index] (u8)
    LD HL, ($F05C)    ; Virtual register 46 from memory
    PUSH HL
    LD A, H
    POP HL
    LD (HL), A
    ; r40++
    INC HL
    ; jump for_loop_25
    JP _Users_alice_dev_zvdb-minz_zvdb_create_tests_for_loop_25
    ; for_end_26:
_Users_alice_dev_zvdb-minz_zvdb_create_tests_for_end_26:
    ; r50 = call .Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256
    ; Call to .Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256 (args: 1)
    ; Found function, UsesTrueSMC=true
    ; TRUE SMC call to .Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256
    LD HL, ($F062)    ; Virtual register 49 from memory
    LD (vec$imm0), HL       ; Patch vec (atomic)
    CALL .Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256
    ; Register 50 already in HL
    ; return
    POP DE
    POP BC
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.zvdb-minz.zvdb.main
.Users.alice.dev.zvdb-minz.zvdb.main:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    PUSH BC
    PUSH DE
    ; r1 = string(str_0)
    LD HL, str_0
    ; Print "ZVDB-MinZ Production Ready
" (27 chars via loop)
    CALL print_string
    ; r2 = string(str_1)
    LD HL, str_1
    ; Print "==========================

" (28 chars via loop)
    CALL print_string
    ; r3 = string(str_2)
    LD HL, str_2
    LD ($F006), HL    ; Virtual register 3 to memory
    ; Print "Initializing LUT...
" (20 chars via loop)
    LD HL, ($F006)    ; Virtual register 3 from memory
    CALL print_string
    ; r4 = call .Users.alice.dev.zvdb-minz.zvdb.init_lut
    ; Call to .Users.alice.dev.zvdb-minz.zvdb.init_lut (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL .Users.alice.dev.zvdb-minz.zvdb.init_lut
    ; r5 = string(str_3)
    LD HL, str_3
    ; Print "Creating test vectors...
" (25 chars via loop)
    CALL print_string
    ; r6 = call .Users.alice.dev.zvdb-minz.zvdb.create_tests
    ; Call to .Users.alice.dev.zvdb-minz.zvdb.create_tests (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL .Users.alice.dev.zvdb-minz.zvdb.create_tests
    LD ($F00C), HL    ; Virtual register 6 to memory
    ; r7 = string(str_4)
    LD HL, str_4
    ; Print "Database has " (13 chars via loop)
    CALL print_string
    ; r8 = string(str_5)
    LD HL, str_5
    ; Print " vectors

" (10 chars via loop)
    CALL print_string
    ; r14 = call .Users.alice.dev.zvdb-minz.zvdb.hamming_by_index$u8$u8
    ; Call to .Users.alice.dev.zvdb-minz.zvdb.hamming_by_index$u8$u8 (args: 2)
    ; Found function, UsesTrueSMC=true
    ; TRUE SMC call to .Users.alice.dev.zvdb-minz.zvdb.hamming_by_index$u8$u8
    LD A, ($F018)     ; Virtual register 12 from memory
    LD (idx1$imm0), A        ; Patch idx1
    LD A, ($F01A)     ; Virtual register 13 from memory
    LD (idx2$imm0), A        ; Patch idx2
    CALL .Users.alice.dev.zvdb-minz.zvdb.hamming_by_index$u8$u8
    LD ($F01C), HL    ; Virtual register 14 to memory
    ; r20 = call .Users.alice.dev.zvdb-minz.zvdb.hamming_by_index$u8$u8
    ; Call to .Users.alice.dev.zvdb-minz.zvdb.hamming_by_index$u8$u8 (args: 2)
    ; Found function, UsesTrueSMC=true
    ; TRUE SMC call to .Users.alice.dev.zvdb-minz.zvdb.hamming_by_index$u8$u8
    LD A, ($F024)     ; Virtual register 18 from memory
    LD (idx1$imm0), A        ; Patch idx1
    LD A, ($F026)     ; Virtual register 19 from memory
    LD (idx2$imm0), A        ; Patch idx2
    CALL .Users.alice.dev.zvdb-minz.zvdb.hamming_by_index$u8$u8
    ; r21 = string(str_6)
    LD HL, str_6
    ; Print "Hamming distances:
" (19 chars via loop)
    CALL print_string
    ; r22 = string(str_7)
    LD HL, str_7
    LD ($F02C), HL    ; Virtual register 22 to memory
    ; Print "  V0 vs V1: " (12 chars via loop)
    LD HL, ($F02C)    ; Virtual register 22 from memory
    CALL print_string
    ; Direct print " bits
" (6 chars)
    ; Direct print " bits
" (6 chars)
    LD A, 32
    RST 16             ; Print character
    LD A, 98
    RST 16             ; Print character
    LD A, 105
    RST 16             ; Print character
    LD A, 116
    RST 16             ; Print character
    LD A, 115
    RST 16             ; Print character
    LD A, 10
    RST 16             ; Print character
    ; r23 = string(str_8)
    LD HL, str_8
    ; Print "  V0 vs V2: " (12 chars via loop)
    CALL print_string
    ; Direct print " bits
" (6 chars)
    ; Direct print " bits
" (6 chars)
    LD A, 32
    RST 16             ; Print character
    LD A, 98
    RST 16             ; Print character
    LD A, 105
    RST 16             ; Print character
    LD A, 116
    RST 16             ; Print character
    LD A, 115
    RST 16             ; Print character
    LD A, 10
    RST 16             ; Print character
    ; r24 = string(str_9)
    LD HL, str_9
    ; Print "
Searching...
" (14 chars via loop)
    CALL print_string
    ; r27 = 32
    LD A, 32
    LD H, A         ; Store to physical register H
    ; Initialize loop variable i
    ; for_loop_27:
_Users_alice_dev_zvdb-minz_zvdb_main_for_loop_27:
    ; Check i < end
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, _Users_alice_dev_zvdb-minz_zvdb_main_lt_true_11
    LD HL, 0       ; False
    JP _Users_alice_dev_zvdb-minz_zvdb_main_lt_done_11
_Users_alice_dev_zvdb-minz_zvdb_main_lt_true_11:
    LD HL, 1       ; True
_Users_alice_dev_zvdb-minz_zvdb_main_lt_done_11:
    LD ($F03A), HL    ; Virtual register 29 to memory
    ; jump_if_not r29, for_end_28
    LD A, ($F03A)     ; Virtual register 29 from memory
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_main_for_end_28
    ; unknown op 57
    LD HL, ($F040)    ; Virtual register 32 from memory
    LD A, H
    OR L           ; Test HL (set flags)
    ; jump_if_not r34, else_29
    LD A, L
    OR A
    JP Z, _Users_alice_dev_zvdb-minz_zvdb_main_else_29
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; jump end_if_30
    JP _Users_alice_dev_zvdb-minz_zvdb_main_end_if_30
    ; else_29:
_Users_alice_dev_zvdb-minz_zvdb_main_else_29:
    ; Store to array[index] (u8)
    LD HL, ($F058)    ; Virtual register 44 from memory
    PUSH HL
    LD A, H
    POP HL
    LD (HL), A
    ; end_if_30:
_Users_alice_dev_zvdb-minz_zvdb_main_end_if_30:
    ; r28++
    INC HL
    ; jump for_loop_27
    JP _Users_alice_dev_zvdb-minz_zvdb_main_for_loop_27
    ; for_end_28:
_Users_alice_dev_zvdb-minz_zvdb_main_for_end_28:
    ; r49 = call .Users.alice.dev.zvdb-minz.zvdb.find_best$Vector256
    ; Call to .Users.alice.dev.zvdb-minz.zvdb.find_best$Vector256 (args: 1)
    ; Found function, UsesTrueSMC=true
    ; TRUE SMC call to .Users.alice.dev.zvdb-minz.zvdb.find_best$Vector256
    LD HL, ($F060)    ; Virtual register 48 from memory
    LD (query$imm0), HL       ; Patch query (atomic)
    CALL .Users.alice.dev.zvdb-minz.zvdb.find_best$Vector256
    ; r50 = string(str_10)
    LD HL, str_10
    ; Register 50 already in HL
    ; Print "Best match: Vector " (19 chars via loop)
    ; Register 50 already in HL
    CALL print_string
    ; Direct print "
" (1 chars)
    ; Direct print "
" (1 chars)
    LD A, 10
    RST 16             ; Print character
    ; r51 = string(str_11)
    LD HL, str_11
    ; Print "Hamming: " (9 chars via loop)
    CALL print_string
    ; Direct print " bits
" (6 chars)
    ; Direct print " bits
" (6 chars)
    LD A, 32
    RST 16             ; Print character
    LD A, 98
    RST 16             ; Print character
    LD A, 105
    RST 16             ; Print character
    LD A, 116
    RST 16             ; Print character
    LD A, 115
    RST 16             ; Print character
    LD A, 10
    RST 16             ; Print character
    ; Direct print "Score: " (7 chars)
    ; Direct print "Score: " (7 chars)
    LD A, 83
    RST 16             ; Print character
    LD A, 99
    RST 16             ; Print character
    LD A, 111
    RST 16             ; Print character
    LD A, 114
    RST 16             ; Print character
    LD A, 101
    RST 16             ; Print character
    LD A, 58
    RST 16             ; Print character
    LD A, 32
    RST 16             ; Print character
    ; Direct print "
" (1 chars)
    ; Direct print "
" (1 chars)
    LD A, 10
    RST 16             ; Print character
    ; r52 = string(str_12)
    LD HL, str_12
    ; Print "
â ZVDB-MinZ Complete!
" (28 chars via loop)
    CALL print_string
    ; return
    POP DE
    POP BC
    RET

; TRUE SMC PATCH-TABLE
; Format: DW anchor_addr, DB size, DB param_tag
PATCH_TABLE:
    DW val$imm0           ; .Users.alice.dev.zvdb-minz.zvdb.popcount$u8.val
    DB 1              ; Size in bytes
    DB 0              ; Reserved for param tag
    DW idx1$imm0           ; .Users.alice.dev.zvdb-minz.zvdb.hamming_by_index$u8$u8.idx1
    DB 1              ; Size in bytes
    DB 0              ; Reserved for param tag
    DW idx2$imm0           ; .Users.alice.dev.zvdb-minz.zvdb.hamming_by_index$u8$u8.idx2
    DB 1              ; Size in bytes
    DB 0              ; Reserved for param tag
    DW query$imm0           ; .Users.alice.dev.zvdb-minz.zvdb.hamming_query$Vector256$u8.query
    DB 32              ; Size in bytes
    DB 0              ; Reserved for param tag
    DW idx$imm0           ; .Users.alice.dev.zvdb-minz.zvdb.hamming_query$Vector256$u8.idx
    DB 1              ; Size in bytes
    DB 0              ; Reserved for param tag
    DW vec$imm0           ; .Users.alice.dev.zvdb-minz.zvdb.add_vector$Vector256.vec
    DB 32              ; Size in bytes
    DB 0              ; Reserved for param tag
    DW query$imm0           ; .Users.alice.dev.zvdb-minz.zvdb.find_best$Vector256.query
    DB 32              ; Size in bytes
    DB 0              ; Reserved for param tag
    DW 0              ; End of table
PATCH_TABLE_END:

; Runtime print helper functions
print_string:
    LD A, (HL)         ; A = first byte
    CP 255             ; Check if extended format marker
    JR Z, print_string_u16
    ; Standard u8 format: [len:u8][data...]
    LD B, A            ; B = length from first byte
    INC HL             ; HL -> string data
    OR A               ; Check if length is zero
    RET Z              ; Return if empty string
print_loop_u8:
    LD A, (HL)         ; Load character
    RST 16             ; Print character
    INC HL             ; Next character
    DJNZ print_loop_u8 ; Decrement B and loop
    RET

print_string_u16:
    ; Extended u16 format: [255][len:u16][data...]
    INC HL             ; Skip 255 marker
    LD E, (HL)         ; E = low byte of length
    INC HL
    LD D, (HL)         ; D = high byte of length
    INC HL             ; HL -> string data
    LD A, D            ; Check if length is zero
    OR E
    RET Z              ; Return if empty string
    ; Use 16-bit counter for large strings
print_loop_u16:
    LD A, (HL)         ; Load character
    RST 16             ; Print character
    INC HL             ; Next character
    DEC DE             ; Decrement 16-bit counter
    LD A, D            ; Check if counter is zero
    OR E
    JR NZ, print_loop_u16
    RET

print_u8_decimal:
    LD H, 0            ; HL = A (zero extend)
    LD L, A
    CALL print_u16_decimal
    RET

print_u16_decimal:
    LD BC, -10000
    LD DE, -1000
    CALL print_digit
    LD BC, -1000
    LD DE, -100
    CALL print_digit
    LD BC, -100
    LD DE, -10
    CALL print_digit
    LD BC, -10
    LD DE, -1
    CALL print_digit
    LD A, L
    ADD A, '0'         ; Convert to ASCII
    RST 16             ; Print last digit
    RET

print_digit:
    LD A, '0'-1
print_digit_loop:
    INC A
    ADD HL, BC         ; Subtract power of 10
    JR C, print_digit_loop
    ADD HL, DE         ; Add back one power of 10
    RST 16             ; Print digit
    RET

print_i8_decimal:
    BIT 7, A           ; Check sign bit
    JR Z, print_u8_decimal
    PUSH AF
    LD A, '-'          ; Print minus sign
    RST 16
    POP AF
    NEG                ; Make positive
    JR print_u8_decimal

print_i16_decimal:
    BIT 7, H           ; Check sign bit
    JR Z, print_u16_decimal
    PUSH HL
    LD A, '-'          ; Print minus sign
    RST 16
    POP HL
    LD A, H            ; Negate HL
    CPL
    LD H, A
    LD A, L
    CPL
    LD L, A
    INC HL
    JR print_u16_decimal

print_bool:
    OR A               ; Test if A is zero
    JR NZ, print_true
    LD HL, bool_false_str
    JR print_string
print_true:
    LD HL, bool_true_str
    JR print_string

bool_true_str:
    DB 4, "true"      ; Length + data
bool_false_str:
    DB 5, "false"     ; Length + data


    END main


; Assembly peephole optimization: 7 patterns applied