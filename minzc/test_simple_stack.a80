; MinZ generated code
; Generated: 2025-07-27 08:15:28


; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.test_simple_stack.test_stack
...examples.test_simple_stack.test_stack:
; Using stack-based locals (IX+offset)
    PUSH IX
    LD IX, SP
    LD HL, -8
    ADD HL, SP
    LD SP, HL
    ; r2 = 1
    LD A, 1
    LD ($F004), A     ; Virtual register 2 to memory
    ; store , r2
    LD HL, ($F004)    ; Virtual register 2 from memory
    LD (IX-1), L
    LD (IX+0), H
    ; r4 = 2
    LD A, 2
    LD C, A         ; Store to physical register C
    ; store , r4
    LD (IX-2), L
    LD (IX-1), H
    ; r6 = 3
    LD A, 3
    LD ($F00C), A     ; Virtual register 6 to memory
    ; store , r6
    LD HL, ($F00C)    ; Virtual register 6 from memory
    LD (IX-3), L
    LD (IX-2), H
    ; r8 = 4
    LD A, 4
    LD L, A         ; Store to physical register L
    ; store , r8
    LD (IX-4), L
    LD (IX-3), H
    ; r10 = 5
    LD A, 5
    EXX               ; Switch to shadow registers
    LD C', A         ; Store to shadow C'
    EXX               ; Switch back to main registers
    ; store , r10
    EXX               ; Switch to shadow registers
    LD (IX-5), L
    LD (IX-4), H
    ; r12 = 6
    LD A, 6
    EXX               ; Switch to shadow registers
    LD E', A         ; Store to shadow E'
    EXX               ; Switch back to main registers
    ; store , r12
    EXX               ; Switch to shadow registers
    LD (IX-6), L
    LD (IX-5), H
    ; r14 = 7
    LD A, 7
    LD ($F01C), A     ; Virtual register 14 to memory
    ; store , r14
    LD HL, ($F01C)    ; Virtual register 14 from memory
    LD (IX-7), L
    LD (IX-6), H
    ; r16 = 8
    LD A, 8
    ; Register 16 already in A
    ; store , r16
    LD (IX-8), L
    LD (IX-7), H
    ; r17 = load a
    LD L, (IX-1)
    LD H, (IX+0)
    EXX               ; Switch to shadow registers
    ; r18 = load b
    LD L, (IX-2)
    LD H, (IX-1)
    LD ($F024), HL    ; Virtual register 18 to memory
    ; r19 = r17 + r18
    EXX               ; Switch to shadow registers
    LD D, H
    LD E, L
    LD HL, ($F024)    ; Virtual register 18 from memory
    ADD HL, DE
    ; r20 = load c
    LD L, (IX-3)
    LD H, (IX-2)
    LD ($F028), HL    ; Virtual register 20 to memory
    ; r21 = r19 + r20
    LD D, H
    LD E, L
    LD HL, ($F028)    ; Virtual register 20 from memory
    ADD HL, DE
    ; r22 = load d
    LD L, (IX-4)
    LD H, (IX-3)
    ; r23 = r21 + r22
    LD D, H
    LD E, L
    ADD HL, DE
    EXX               ; Switch to shadow registers
    ; r24 = load e
    LD L, (IX-5)
    LD H, (IX-4)
    EXX               ; Switch to shadow registers
    ; r25 = r23 + r24
    EXX               ; Switch to shadow registers
    LD D, H
    LD E, L
    EXX               ; Switch to shadow registers
    ADD HL, DE
    ; r26 = load f
    LD L, (IX-6)
    LD H, (IX-5)
    LD ($F034), HL    ; Virtual register 26 to memory
    ; r27 = r25 + r26
    LD D, H
    LD E, L
    LD HL, ($F034)    ; Virtual register 26 from memory
    ADD HL, DE
    ; r28 = load g
    LD L, (IX-7)
    LD H, (IX-6)
    ; r29 = r27 + r28
    LD D, H
    LD E, L
    ADD HL, DE
    ; r30 = load h
    LD L, (IX-8)
    LD H, (IX-7)
    ; r31 = r29 + r30
    LD D, H
    LD E, L
    ADD HL, DE
    ; return r31
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.test_simple_stack.main
...examples.test_simple_stack.main:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = call test_stack
    ; Call to test_stack (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL test_stack
    ; store , r2
    LD ($F002), HL
    ; return
    RET

    END main
