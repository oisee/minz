// Code generated from grammar/MinZ.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // MinZ

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type MinZParser struct {
	*antlr.BaseParser
}

var MinZParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func minzParserInit() {
	staticData := &MinZParserStaticData
	staticData.LiteralNames = []string{
		"", "'@lua'", "'@mir'", "'@minz'", "'@if'", "'@define'", "'f8.8'", "'f.8'",
		"'f16.8'", "'f8.16'", "'Iterator'", "'@asm'", "'@target'", "'import'",
		"'as'", "'fun'", "'fn'", "'struct'", "'interface'", "'enum'", "'const'",
		"'global'", "'type'", "'let'", "'mut'", "'if'", "'else'", "'while'",
		"'for'", "'in'", "'loop'", "'match'", "'case'", "'when'", "'return'",
		"'break'", "'continue'", "'defer'", "'pub'", "'export'", "'asm'", "'mir'",
		"'self'", "'true'", "'false'", "'null'", "'impl'", "'cast'", "'sizeof'",
		"'alignof'", "'Error'", "'and'", "'or'", "'bits'", "'bits_8'", "'bits_16'",
		"'u8'", "'u16'", "'u24'", "'u32'", "'i8'", "'i16'", "'i24'", "'i32'",
		"'bool'", "'void'", "", "", "", "", "", "", "", "", "", "", "'->'",
		"'=>'", "'?'", "'??'", "'.'", "'..'", "'...'", "','", "';'", "':'",
		"'::'", "'('", "')'", "'{'", "'}'", "'['", "']'", "'<'", "'>'", "'<='",
		"'>='", "'=='", "'!='", "'='", "'+='", "'-='", "'*='", "'/='", "'%='",
		"'&='", "'|='", "'^='", "'<<='", "'>>='", "'+'", "'-'", "'*'", "'/'",
		"'%'", "'&'", "'|'", "'^'", "'!'", "'~'", "'&&'", "'||'", "'<<'", "'>>'",
		"'@'", "'_'", "'[[['", "']]]'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "IMPORT", "AS",
		"FUN", "FN", "STRUCT", "INTERFACE", "ENUM", "CONST", "GLOBAL", "TYPE",
		"LET", "MUT", "IF", "ELSE", "WHILE", "FOR", "IN", "LOOP", "MATCH", "CASE",
		"WHEN", "RETURN", "BREAK", "CONTINUE", "DEFER", "PUB", "EXPORT", "ASM",
		"MIR", "SELF", "TRUE", "FALSE", "NULL", "IMPL", "CAST", "SIZEOF", "ALIGNOF",
		"ERROR", "AND", "OR", "BITS", "BITS_8", "BITS_16", "U8", "U16", "U24",
		"U32", "I8", "I16", "I24", "I32", "BOOL", "VOID", "IDENTIFIER", "INTEGER",
		"HEX_INTEGER", "BINARY_INTEGER", "FLOAT", "STRING", "CHAR", "LINE_COMMENT",
		"BLOCK_COMMENT", "WS", "ARROW", "DOUBLE_ARROW", "QUESTION", "DOUBLE_QUESTION",
		"DOT", "RANGE", "RANGE_INCLUSIVE", "COMMA", "SEMICOLON", "COLON", "DOUBLE_COLON",
		"LPAREN", "RPAREN", "LBRACE", "RBRACE", "LBRACKET", "RBRACKET", "LT",
		"GT", "LE", "GE", "EQ", "NE", "ASSIGN", "PLUS_ASSIGN", "MINUS_ASSIGN",
		"STAR_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", "OR_ASSIGN",
		"XOR_ASSIGN", "SHL_ASSIGN", "SHR_ASSIGN", "PLUS", "MINUS", "STAR", "DIV",
		"MOD", "AMPERSAND", "PIPE", "CARET", "BANG", "TILDE", "LOGICAL_AND",
		"LOGICAL_OR", "SHL", "SHR", "AT", "UNDERSCORE", "TRIPLE_BRACKET_OPEN",
		"TRIPLE_BRACKET_CLOSE", "ASM_CODE_CONTENT", "MIR_CODE_CONTENT", "MINZ_CODE_CONTENT",
		"LUA_CODE_BLOCK", "MIR_BLOCK_CONTENT", "TEMPLATE_BODY_CONTENT", "RAW_BLOCK_CONTENT",
	}
	staticData.RuleNames = []string{
		"program", "importDecl", "importPath", "declaration", "functionDecl",
		"asmFunction", "mirFunction", "genericParams", "returnType", "errorType",
		"functionBody", "asmBody", "asmContent", "mirBody", "mirContent", "parameterList",
		"parameter", "structDecl", "structField", "interfaceDecl", "methodSignature",
		"castInterfaceBlock", "castRule", "enumDecl", "enumVariant", "bitStructDecl",
		"bitField", "constDecl", "globalDecl", "typeAlias", "implBlock", "metafunction",
		"attributedDeclaration", "attribute", "luaBlock", "luaCodeBlock", "mirBlockDeclaration",
		"mirBlockContent", "minzMetafunctionDeclaration", "compileTimeIfDeclaration",
		"defineTemplate", "templateBody", "identifierList", "metaExecutionBlock",
		"luaExecutionBlock", "minzExecutionBlock", "mirExecutionBlock", "rawBlockContent",
		"type", "primitiveType", "namedType", "arrayType", "arraySize", "pointerType",
		"functionType", "bitStructType", "errorableType", "mutableType", "iteratorType",
		"primaryType", "statement", "letStatement", "ifStatement", "whileStatement",
		"forStatement", "loopStatement", "matchStatement", "matchArm", "caseStatement",
		"caseArm", "pattern", "enumPattern", "returnStatement", "breakStatement",
		"continueStatement", "deferStatement", "assignmentStatement", "assignmentTarget",
		"assignmentOp", "expressionStatement", "block", "asmBlock", "compileTimeAsm",
		"mirBlock", "minzBlock", "minzContent", "targetBlock", "expression",
		"primaryExpression", "literal", "arrayLiteral", "arrayInitializer",
		"structLiteral", "fieldInitializer", "tupleLiteral", "inlineAssembly",
		"asmOutputList", "asmInputList", "asmClobberList", "asmOutput", "asmInput",
		"sizeofExpression", "alignofExpression", "errorLiteral", "lambdaExpression",
		"lambdaParams", "lambdaParam", "ifExpression", "ternaryExpression",
		"whenExpression", "whenArm", "metafunctionExpr", "argumentList", "expressionList",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 134, 1257, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 1, 0, 1, 0, 5, 0, 231, 8, 0, 10, 0, 12, 0, 234, 9, 0, 1, 0,
		1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 242, 8, 1, 1, 1, 1, 1, 1, 2, 1, 2,
		1, 2, 5, 2, 249, 8, 2, 10, 2, 12, 2, 252, 9, 2, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 3, 3, 273, 8, 3, 1, 4, 3, 4, 276, 8, 4, 1, 4, 3, 4, 279,
		8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 284, 8, 4, 1, 4, 1, 4, 3, 4, 288, 8, 4, 1,
		4, 1, 4, 3, 4, 292, 8, 4, 1, 4, 1, 4, 1, 5, 3, 5, 297, 8, 5, 1, 5, 3, 5,
		300, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 307, 8, 5, 1, 5, 1, 5, 3,
		5, 311, 8, 5, 1, 5, 1, 5, 1, 6, 3, 6, 316, 8, 6, 1, 6, 3, 6, 319, 8, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 326, 8, 6, 1, 6, 1, 6, 3, 6, 330, 8,
		6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 5, 7, 338, 8, 7, 10, 7, 12, 7, 341,
		9, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 3, 8, 348, 8, 8, 1, 9, 1, 9, 1, 10,
		1, 10, 3, 10, 354, 8, 10, 1, 11, 1, 11, 3, 11, 358, 8, 11, 1, 11, 1, 11,
		1, 12, 5, 12, 363, 8, 12, 10, 12, 12, 12, 366, 9, 12, 1, 13, 1, 13, 3,
		13, 370, 8, 13, 1, 13, 1, 13, 1, 14, 5, 14, 375, 8, 14, 10, 14, 12, 14,
		378, 9, 14, 1, 15, 1, 15, 1, 15, 5, 15, 383, 8, 15, 10, 15, 12, 15, 386,
		9, 15, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 392, 8, 16, 1, 17, 3, 17, 395,
		8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 5, 17, 401, 8, 17, 10, 17, 12, 17, 404,
		9, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 412, 8, 18, 1,
		19, 3, 19, 415, 8, 19, 1, 19, 1, 19, 1, 19, 3, 19, 420, 8, 19, 1, 19, 1,
		19, 1, 19, 5, 19, 425, 8, 19, 10, 19, 12, 19, 428, 9, 19, 1, 19, 1, 19,
		1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 436, 8, 20, 1, 20, 1, 20, 3, 20, 440,
		8, 20, 1, 20, 3, 20, 443, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1,
		21, 5, 21, 451, 8, 21, 10, 21, 12, 21, 454, 9, 21, 1, 21, 1, 21, 1, 22,
		1, 22, 1, 22, 1, 22, 3, 22, 462, 8, 22, 1, 22, 1, 22, 1, 23, 3, 23, 467,
		8, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 5, 23, 475, 8, 23, 10,
		23, 12, 23, 478, 9, 23, 1, 23, 3, 23, 481, 8, 23, 1, 23, 1, 23, 1, 24,
		1, 24, 1, 24, 3, 24, 488, 8, 24, 1, 25, 3, 25, 491, 8, 25, 1, 25, 1, 25,
		1, 25, 1, 25, 5, 25, 497, 8, 25, 10, 25, 12, 25, 500, 9, 25, 1, 25, 1,
		25, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 508, 8, 26, 1, 27, 3, 27, 511, 8,
		27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 28, 3, 28,
		522, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 530, 8, 28,
		1, 28, 1, 28, 1, 29, 3, 29, 535, 8, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1,
		29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 5, 30, 549, 8, 30,
		10, 30, 12, 30, 552, 9, 30, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 3,
		31, 560, 8, 31, 1, 31, 1, 31, 3, 31, 564, 8, 31, 1, 32, 1, 32, 1, 32, 1,
		33, 1, 33, 1, 33, 1, 33, 3, 33, 573, 8, 33, 1, 33, 3, 33, 576, 8, 33, 1,
		34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 35, 5, 35, 584, 8, 35, 10, 35, 12, 35,
		587, 9, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 37, 5, 37, 595, 8, 37,
		10, 37, 12, 37, 598, 9, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 5, 38, 605,
		8, 38, 10, 38, 12, 38, 608, 9, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 3, 39, 619, 8, 39, 1, 39, 1, 39, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1,
		40, 3, 40, 636, 8, 40, 1, 41, 5, 41, 639, 8, 41, 10, 41, 12, 41, 642, 9,
		41, 1, 42, 1, 42, 1, 42, 5, 42, 647, 8, 42, 10, 42, 12, 42, 650, 9, 42,
		1, 43, 1, 43, 1, 43, 3, 43, 655, 8, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1,
		44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46,
		1, 47, 5, 47, 673, 8, 47, 10, 47, 12, 47, 676, 9, 47, 1, 48, 1, 48, 1,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 687, 8, 48, 1, 49,
		1, 49, 1, 50, 1, 50, 1, 50, 5, 50, 694, 8, 50, 10, 50, 12, 50, 697, 9,
		50, 1, 51, 1, 51, 1, 51, 3, 51, 702, 8, 51, 1, 51, 1, 51, 1, 51, 1, 51,
		1, 51, 1, 51, 1, 51, 1, 51, 3, 51, 712, 8, 51, 1, 52, 1, 52, 1, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 3, 53, 721, 8, 53, 1, 54, 1, 54, 1, 54, 3, 54,
		726, 8, 54, 1, 54, 1, 54, 3, 54, 730, 8, 54, 1, 55, 1, 55, 1, 55, 5, 55,
		735, 8, 55, 10, 55, 12, 55, 738, 9, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1,
		56, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59,
		3, 59, 755, 8, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1,
		60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60,
		1, 60, 3, 60, 776, 8, 60, 1, 61, 1, 61, 3, 61, 780, 8, 61, 1, 61, 1, 61,
		1, 61, 3, 61, 785, 8, 61, 1, 61, 1, 61, 3, 61, 789, 8, 61, 1, 61, 1, 61,
		1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62, 801, 8,
		62, 10, 62, 12, 62, 804, 9, 62, 1, 62, 1, 62, 3, 62, 808, 8, 62, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 65, 1,
		65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 5, 66, 827, 8, 66, 10, 66, 12, 66,
		830, 9, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3,
		67, 840, 8, 67, 1, 67, 3, 67, 843, 8, 67, 1, 68, 1, 68, 1, 68, 1, 68, 5,
		68, 849, 8, 68, 10, 68, 12, 68, 852, 9, 68, 1, 68, 1, 68, 1, 69, 1, 69,
		1, 69, 3, 69, 859, 8, 69, 1, 69, 1, 69, 1, 69, 3, 69, 864, 8, 69, 1, 69,
		3, 69, 867, 8, 69, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 873, 8, 70, 1, 71,
		1, 71, 1, 71, 1, 71, 1, 72, 1, 72, 3, 72, 881, 8, 72, 1, 72, 1, 72, 1,
		73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		3, 75, 896, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1,
		77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 913, 8, 77,
		1, 78, 1, 78, 1, 79, 1, 79, 1, 79, 1, 80, 1, 80, 5, 80, 922, 8, 80, 10,
		80, 12, 80, 925, 9, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 3, 81, 932,
		8, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 82, 3, 82, 939, 8, 82, 1, 82, 1,
		82, 1, 83, 1, 83, 1, 83, 3, 83, 946, 8, 83, 1, 83, 1, 83, 1, 84, 1, 84,
		1, 84, 3, 84, 953, 8, 84, 1, 84, 1, 84, 1, 85, 5, 85, 958, 8, 85, 10, 85,
		12, 85, 961, 9, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 87, 1,
		87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 3, 87, 978, 8, 87,
		1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1,
		87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87,
		1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1,
		87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 3, 87, 1019, 8, 87,
		1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1,
		87, 1, 87, 1, 87, 1, 87, 5, 87, 1035, 8, 87, 10, 87, 12, 87, 1038, 9, 87,
		1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1,
		88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 3, 88, 1056, 8, 88, 1, 89, 1, 89,
		1, 90, 1, 90, 3, 90, 1062, 8, 90, 1, 90, 1, 90, 1, 91, 1, 91, 3, 91, 1068,
		8, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 5, 92, 1077, 8,
		92, 10, 92, 12, 92, 1080, 9, 92, 1, 92, 3, 92, 1083, 8, 92, 1, 92, 1, 92,
		1, 93, 1, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1,
		95, 1, 95, 1, 95, 1, 95, 1, 95, 3, 95, 1102, 8, 95, 1, 95, 1, 95, 3, 95,
		1106, 8, 95, 1, 95, 1, 95, 3, 95, 1110, 8, 95, 3, 95, 1112, 8, 95, 3, 95,
		1114, 8, 95, 3, 95, 1116, 8, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 5,
		96, 1123, 8, 96, 10, 96, 12, 96, 1126, 9, 96, 1, 97, 1, 97, 1, 97, 5, 97,
		1131, 8, 97, 10, 97, 12, 97, 1134, 9, 97, 1, 98, 1, 98, 1, 98, 5, 98, 1139,
		8, 98, 10, 98, 12, 98, 1142, 9, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101, 1, 101,
		1, 101, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103,
		1, 103, 1, 104, 1, 104, 3, 104, 1170, 8, 104, 1, 104, 1, 104, 1, 104, 3,
		104, 1175, 8, 104, 1, 104, 1, 104, 3, 104, 1179, 8, 104, 1, 105, 1, 105,
		1, 105, 5, 105, 1184, 8, 105, 10, 105, 12, 105, 1187, 9, 105, 1, 106, 1,
		106, 1, 106, 3, 106, 1192, 8, 106, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107,
		1, 107, 3, 107, 1200, 8, 107, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1,
		108, 1, 109, 1, 109, 3, 109, 1210, 8, 109, 1, 109, 1, 109, 4, 109, 1214,
		8, 109, 11, 109, 12, 109, 1215, 1, 109, 1, 109, 1, 110, 1, 110, 3, 110,
		1222, 8, 110, 1, 110, 1, 110, 3, 110, 1226, 8, 110, 1, 110, 1, 110, 1,
		110, 3, 110, 1231, 8, 110, 1, 111, 1, 111, 1, 111, 1, 111, 3, 111, 1237,
		8, 111, 1, 111, 1, 111, 1, 112, 1, 112, 1, 112, 5, 112, 1244, 8, 112, 10,
		112, 12, 112, 1247, 9, 112, 1, 113, 1, 113, 1, 113, 5, 113, 1252, 8, 113,
		10, 113, 12, 113, 1255, 9, 113, 1, 113, 0, 1, 174, 114, 0, 2, 4, 6, 8,
		10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,
		46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80,
		82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
		114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
		144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
		174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
		204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 0, 15, 1, 0,
		15, 16, 1, 0, 53, 55, 2, 0, 6, 9, 56, 65, 1, 0, 66, 67, 1, 0, 99, 109,
		3, 0, 111, 112, 115, 115, 118, 119, 1, 0, 112, 114, 1, 0, 110, 111, 1,
		0, 122, 123, 1, 0, 81, 82, 1, 0, 93, 96, 1, 0, 97, 98, 2, 0, 51, 51, 120,
		120, 2, 0, 52, 52, 121, 121, 2, 0, 43, 45, 67, 72, 1346, 0, 232, 1, 0,
		0, 0, 2, 237, 1, 0, 0, 0, 4, 245, 1, 0, 0, 0, 6, 272, 1, 0, 0, 0, 8, 275,
		1, 0, 0, 0, 10, 296, 1, 0, 0, 0, 12, 315, 1, 0, 0, 0, 14, 333, 1, 0, 0,
		0, 16, 344, 1, 0, 0, 0, 18, 349, 1, 0, 0, 0, 20, 353, 1, 0, 0, 0, 22, 355,
		1, 0, 0, 0, 24, 364, 1, 0, 0, 0, 26, 367, 1, 0, 0, 0, 28, 376, 1, 0, 0,
		0, 30, 379, 1, 0, 0, 0, 32, 391, 1, 0, 0, 0, 34, 394, 1, 0, 0, 0, 36, 407,
		1, 0, 0, 0, 38, 414, 1, 0, 0, 0, 40, 431, 1, 0, 0, 0, 42, 444, 1, 0, 0,
		0, 44, 457, 1, 0, 0, 0, 46, 466, 1, 0, 0, 0, 48, 484, 1, 0, 0, 0, 50, 490,
		1, 0, 0, 0, 52, 503, 1, 0, 0, 0, 54, 510, 1, 0, 0, 0, 56, 521, 1, 0, 0,
		0, 58, 534, 1, 0, 0, 0, 60, 542, 1, 0, 0, 0, 62, 555, 1, 0, 0, 0, 64, 565,
		1, 0, 0, 0, 66, 568, 1, 0, 0, 0, 68, 577, 1, 0, 0, 0, 70, 585, 1, 0, 0,
		0, 72, 588, 1, 0, 0, 0, 74, 596, 1, 0, 0, 0, 76, 599, 1, 0, 0, 0, 78, 611,
		1, 0, 0, 0, 80, 635, 1, 0, 0, 0, 82, 640, 1, 0, 0, 0, 84, 643, 1, 0, 0,
		0, 86, 654, 1, 0, 0, 0, 88, 656, 1, 0, 0, 0, 90, 661, 1, 0, 0, 0, 92, 666,
		1, 0, 0, 0, 94, 674, 1, 0, 0, 0, 96, 686, 1, 0, 0, 0, 98, 688, 1, 0, 0,
		0, 100, 690, 1, 0, 0, 0, 102, 711, 1, 0, 0, 0, 104, 713, 1, 0, 0, 0, 106,
		720, 1, 0, 0, 0, 108, 722, 1, 0, 0, 0, 110, 731, 1, 0, 0, 0, 112, 741,
		1, 0, 0, 0, 114, 744, 1, 0, 0, 0, 116, 747, 1, 0, 0, 0, 118, 754, 1, 0,
		0, 0, 120, 775, 1, 0, 0, 0, 122, 777, 1, 0, 0, 0, 124, 792, 1, 0, 0, 0,
		126, 809, 1, 0, 0, 0, 128, 813, 1, 0, 0, 0, 130, 819, 1, 0, 0, 0, 132,
		822, 1, 0, 0, 0, 134, 833, 1, 0, 0, 0, 136, 844, 1, 0, 0, 0, 138, 855,
		1, 0, 0, 0, 140, 872, 1, 0, 0, 0, 142, 874, 1, 0, 0, 0, 144, 878, 1, 0,
		0, 0, 146, 884, 1, 0, 0, 0, 148, 887, 1, 0, 0, 0, 150, 890, 1, 0, 0, 0,
		152, 897, 1, 0, 0, 0, 154, 912, 1, 0, 0, 0, 156, 914, 1, 0, 0, 0, 158,
		916, 1, 0, 0, 0, 160, 919, 1, 0, 0, 0, 162, 928, 1, 0, 0, 0, 164, 935,
		1, 0, 0, 0, 166, 942, 1, 0, 0, 0, 168, 949, 1, 0, 0, 0, 170, 959, 1, 0,
		0, 0, 172, 962, 1, 0, 0, 0, 174, 977, 1, 0, 0, 0, 176, 1055, 1, 0, 0, 0,
		178, 1057, 1, 0, 0, 0, 180, 1059, 1, 0, 0, 0, 182, 1065, 1, 0, 0, 0, 184,
		1071, 1, 0, 0, 0, 186, 1086, 1, 0, 0, 0, 188, 1090, 1, 0, 0, 0, 190, 1096,
		1, 0, 0, 0, 192, 1119, 1, 0, 0, 0, 194, 1127, 1, 0, 0, 0, 196, 1135, 1,
		0, 0, 0, 198, 1143, 1, 0, 0, 0, 200, 1148, 1, 0, 0, 0, 202, 1153, 1, 0,
		0, 0, 204, 1158, 1, 0, 0, 0, 206, 1163, 1, 0, 0, 0, 208, 1167, 1, 0, 0,
		0, 210, 1180, 1, 0, 0, 0, 212, 1188, 1, 0, 0, 0, 214, 1193, 1, 0, 0, 0,
		216, 1201, 1, 0, 0, 0, 218, 1207, 1, 0, 0, 0, 220, 1221, 1, 0, 0, 0, 222,
		1232, 1, 0, 0, 0, 224, 1240, 1, 0, 0, 0, 226, 1248, 1, 0, 0, 0, 228, 231,
		3, 2, 1, 0, 229, 231, 3, 6, 3, 0, 230, 228, 1, 0, 0, 0, 230, 229, 1, 0,
		0, 0, 231, 234, 1, 0, 0, 0, 232, 230, 1, 0, 0, 0, 232, 233, 1, 0, 0, 0,
		233, 235, 1, 0, 0, 0, 234, 232, 1, 0, 0, 0, 235, 236, 5, 0, 0, 1, 236,
		1, 1, 0, 0, 0, 237, 238, 5, 13, 0, 0, 238, 241, 3, 4, 2, 0, 239, 240, 5,
		14, 0, 0, 240, 242, 5, 66, 0, 0, 241, 239, 1, 0, 0, 0, 241, 242, 1, 0,
		0, 0, 242, 243, 1, 0, 0, 0, 243, 244, 5, 84, 0, 0, 244, 3, 1, 0, 0, 0,
		245, 250, 5, 66, 0, 0, 246, 247, 5, 80, 0, 0, 247, 249, 5, 66, 0, 0, 248,
		246, 1, 0, 0, 0, 249, 252, 1, 0, 0, 0, 250, 248, 1, 0, 0, 0, 250, 251,
		1, 0, 0, 0, 251, 5, 1, 0, 0, 0, 252, 250, 1, 0, 0, 0, 253, 273, 3, 8, 4,
		0, 254, 273, 3, 10, 5, 0, 255, 273, 3, 12, 6, 0, 256, 273, 3, 34, 17, 0,
		257, 273, 3, 38, 19, 0, 258, 273, 3, 46, 23, 0, 259, 273, 3, 50, 25, 0,
		260, 273, 3, 54, 27, 0, 261, 273, 3, 56, 28, 0, 262, 273, 3, 58, 29, 0,
		263, 273, 3, 60, 30, 0, 264, 273, 3, 62, 31, 0, 265, 273, 3, 64, 32, 0,
		266, 273, 3, 68, 34, 0, 267, 273, 3, 72, 36, 0, 268, 273, 3, 76, 38, 0,
		269, 273, 3, 78, 39, 0, 270, 273, 3, 80, 40, 0, 271, 273, 3, 86, 43, 0,
		272, 253, 1, 0, 0, 0, 272, 254, 1, 0, 0, 0, 272, 255, 1, 0, 0, 0, 272,
		256, 1, 0, 0, 0, 272, 257, 1, 0, 0, 0, 272, 258, 1, 0, 0, 0, 272, 259,
		1, 0, 0, 0, 272, 260, 1, 0, 0, 0, 272, 261, 1, 0, 0, 0, 272, 262, 1, 0,
		0, 0, 272, 263, 1, 0, 0, 0, 272, 264, 1, 0, 0, 0, 272, 265, 1, 0, 0, 0,
		272, 266, 1, 0, 0, 0, 272, 267, 1, 0, 0, 0, 272, 268, 1, 0, 0, 0, 272,
		269, 1, 0, 0, 0, 272, 270, 1, 0, 0, 0, 272, 271, 1, 0, 0, 0, 273, 7, 1,
		0, 0, 0, 274, 276, 5, 38, 0, 0, 275, 274, 1, 0, 0, 0, 275, 276, 1, 0, 0,
		0, 276, 278, 1, 0, 0, 0, 277, 279, 5, 39, 0, 0, 278, 277, 1, 0, 0, 0, 278,
		279, 1, 0, 0, 0, 279, 280, 1, 0, 0, 0, 280, 281, 7, 0, 0, 0, 281, 283,
		5, 66, 0, 0, 282, 284, 3, 14, 7, 0, 283, 282, 1, 0, 0, 0, 283, 284, 1,
		0, 0, 0, 284, 285, 1, 0, 0, 0, 285, 287, 5, 87, 0, 0, 286, 288, 3, 30,
		15, 0, 287, 286, 1, 0, 0, 0, 287, 288, 1, 0, 0, 0, 288, 289, 1, 0, 0, 0,
		289, 291, 5, 88, 0, 0, 290, 292, 3, 16, 8, 0, 291, 290, 1, 0, 0, 0, 291,
		292, 1, 0, 0, 0, 292, 293, 1, 0, 0, 0, 293, 294, 3, 20, 10, 0, 294, 9,
		1, 0, 0, 0, 295, 297, 5, 38, 0, 0, 296, 295, 1, 0, 0, 0, 296, 297, 1, 0,
		0, 0, 297, 299, 1, 0, 0, 0, 298, 300, 5, 39, 0, 0, 299, 298, 1, 0, 0, 0,
		299, 300, 1, 0, 0, 0, 300, 301, 1, 0, 0, 0, 301, 302, 5, 40, 0, 0, 302,
		303, 7, 0, 0, 0, 303, 304, 5, 66, 0, 0, 304, 306, 5, 87, 0, 0, 305, 307,
		3, 30, 15, 0, 306, 305, 1, 0, 0, 0, 306, 307, 1, 0, 0, 0, 307, 308, 1,
		0, 0, 0, 308, 310, 5, 88, 0, 0, 309, 311, 3, 16, 8, 0, 310, 309, 1, 0,
		0, 0, 310, 311, 1, 0, 0, 0, 311, 312, 1, 0, 0, 0, 312, 313, 3, 22, 11,
		0, 313, 11, 1, 0, 0, 0, 314, 316, 5, 38, 0, 0, 315, 314, 1, 0, 0, 0, 315,
		316, 1, 0, 0, 0, 316, 318, 1, 0, 0, 0, 317, 319, 5, 39, 0, 0, 318, 317,
		1, 0, 0, 0, 318, 319, 1, 0, 0, 0, 319, 320, 1, 0, 0, 0, 320, 321, 5, 41,
		0, 0, 321, 322, 7, 0, 0, 0, 322, 323, 5, 66, 0, 0, 323, 325, 5, 87, 0,
		0, 324, 326, 3, 30, 15, 0, 325, 324, 1, 0, 0, 0, 325, 326, 1, 0, 0, 0,
		326, 327, 1, 0, 0, 0, 327, 329, 5, 88, 0, 0, 328, 330, 3, 16, 8, 0, 329,
		328, 1, 0, 0, 0, 329, 330, 1, 0, 0, 0, 330, 331, 1, 0, 0, 0, 331, 332,
		3, 26, 13, 0, 332, 13, 1, 0, 0, 0, 333, 334, 5, 93, 0, 0, 334, 339, 5,
		66, 0, 0, 335, 336, 5, 83, 0, 0, 336, 338, 5, 66, 0, 0, 337, 335, 1, 0,
		0, 0, 338, 341, 1, 0, 0, 0, 339, 337, 1, 0, 0, 0, 339, 340, 1, 0, 0, 0,
		340, 342, 1, 0, 0, 0, 341, 339, 1, 0, 0, 0, 342, 343, 5, 94, 0, 0, 343,
		15, 1, 0, 0, 0, 344, 345, 5, 76, 0, 0, 345, 347, 3, 96, 48, 0, 346, 348,
		3, 18, 9, 0, 347, 346, 1, 0, 0, 0, 347, 348, 1, 0, 0, 0, 348, 17, 1, 0,
		0, 0, 349, 350, 5, 78, 0, 0, 350, 19, 1, 0, 0, 0, 351, 354, 3, 160, 80,
		0, 352, 354, 5, 84, 0, 0, 353, 351, 1, 0, 0, 0, 353, 352, 1, 0, 0, 0, 354,
		21, 1, 0, 0, 0, 355, 357, 5, 89, 0, 0, 356, 358, 3, 24, 12, 0, 357, 356,
		1, 0, 0, 0, 357, 358, 1, 0, 0, 0, 358, 359, 1, 0, 0, 0, 359, 360, 5, 90,
		0, 0, 360, 23, 1, 0, 0, 0, 361, 363, 5, 128, 0, 0, 362, 361, 1, 0, 0, 0,
		363, 366, 1, 0, 0, 0, 364, 362, 1, 0, 0, 0, 364, 365, 1, 0, 0, 0, 365,
		25, 1, 0, 0, 0, 366, 364, 1, 0, 0, 0, 367, 369, 5, 89, 0, 0, 368, 370,
		3, 28, 14, 0, 369, 368, 1, 0, 0, 0, 369, 370, 1, 0, 0, 0, 370, 371, 1,
		0, 0, 0, 371, 372, 5, 90, 0, 0, 372, 27, 1, 0, 0, 0, 373, 375, 5, 129,
		0, 0, 374, 373, 1, 0, 0, 0, 375, 378, 1, 0, 0, 0, 376, 374, 1, 0, 0, 0,
		376, 377, 1, 0, 0, 0, 377, 29, 1, 0, 0, 0, 378, 376, 1, 0, 0, 0, 379, 384,
		3, 32, 16, 0, 380, 381, 5, 83, 0, 0, 381, 383, 3, 32, 16, 0, 382, 380,
		1, 0, 0, 0, 383, 386, 1, 0, 0, 0, 384, 382, 1, 0, 0, 0, 384, 385, 1, 0,
		0, 0, 385, 31, 1, 0, 0, 0, 386, 384, 1, 0, 0, 0, 387, 392, 5, 42, 0, 0,
		388, 389, 5, 66, 0, 0, 389, 390, 5, 85, 0, 0, 390, 392, 3, 96, 48, 0, 391,
		387, 1, 0, 0, 0, 391, 388, 1, 0, 0, 0, 392, 33, 1, 0, 0, 0, 393, 395, 5,
		38, 0, 0, 394, 393, 1, 0, 0, 0, 394, 395, 1, 0, 0, 0, 395, 396, 1, 0, 0,
		0, 396, 397, 5, 17, 0, 0, 397, 398, 5, 66, 0, 0, 398, 402, 5, 89, 0, 0,
		399, 401, 3, 36, 18, 0, 400, 399, 1, 0, 0, 0, 401, 404, 1, 0, 0, 0, 402,
		400, 1, 0, 0, 0, 402, 403, 1, 0, 0, 0, 403, 405, 1, 0, 0, 0, 404, 402,
		1, 0, 0, 0, 405, 406, 5, 90, 0, 0, 406, 35, 1, 0, 0, 0, 407, 408, 5, 66,
		0, 0, 408, 409, 5, 85, 0, 0, 409, 411, 3, 96, 48, 0, 410, 412, 5, 83, 0,
		0, 411, 410, 1, 0, 0, 0, 411, 412, 1, 0, 0, 0, 412, 37, 1, 0, 0, 0, 413,
		415, 5, 38, 0, 0, 414, 413, 1, 0, 0, 0, 414, 415, 1, 0, 0, 0, 415, 416,
		1, 0, 0, 0, 416, 417, 5, 18, 0, 0, 417, 419, 5, 66, 0, 0, 418, 420, 3,
		14, 7, 0, 419, 418, 1, 0, 0, 0, 419, 420, 1, 0, 0, 0, 420, 421, 1, 0, 0,
		0, 421, 426, 5, 89, 0, 0, 422, 425, 3, 40, 20, 0, 423, 425, 3, 42, 21,
		0, 424, 422, 1, 0, 0, 0, 424, 423, 1, 0, 0, 0, 425, 428, 1, 0, 0, 0, 426,
		424, 1, 0, 0, 0, 426, 427, 1, 0, 0, 0, 427, 429, 1, 0, 0, 0, 428, 426,
		1, 0, 0, 0, 429, 430, 5, 90, 0, 0, 430, 39, 1, 0, 0, 0, 431, 432, 7, 0,
		0, 0, 432, 433, 5, 66, 0, 0, 433, 435, 5, 87, 0, 0, 434, 436, 3, 30, 15,
		0, 435, 434, 1, 0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 437, 1, 0, 0, 0, 437,
		439, 5, 88, 0, 0, 438, 440, 3, 16, 8, 0, 439, 438, 1, 0, 0, 0, 439, 440,
		1, 0, 0, 0, 440, 442, 1, 0, 0, 0, 441, 443, 5, 84, 0, 0, 442, 441, 1, 0,
		0, 0, 442, 443, 1, 0, 0, 0, 443, 41, 1, 0, 0, 0, 444, 445, 5, 47, 0, 0,
		445, 446, 5, 93, 0, 0, 446, 447, 5, 66, 0, 0, 447, 448, 5, 94, 0, 0, 448,
		452, 5, 89, 0, 0, 449, 451, 3, 44, 22, 0, 450, 449, 1, 0, 0, 0, 451, 454,
		1, 0, 0, 0, 452, 450, 1, 0, 0, 0, 452, 453, 1, 0, 0, 0, 453, 455, 1, 0,
		0, 0, 454, 452, 1, 0, 0, 0, 455, 456, 5, 90, 0, 0, 456, 43, 1, 0, 0, 0,
		457, 458, 5, 66, 0, 0, 458, 459, 5, 76, 0, 0, 459, 461, 5, 89, 0, 0, 460,
		462, 5, 71, 0, 0, 461, 460, 1, 0, 0, 0, 461, 462, 1, 0, 0, 0, 462, 463,
		1, 0, 0, 0, 463, 464, 5, 90, 0, 0, 464, 45, 1, 0, 0, 0, 465, 467, 5, 38,
		0, 0, 466, 465, 1, 0, 0, 0, 466, 467, 1, 0, 0, 0, 467, 468, 1, 0, 0, 0,
		468, 469, 5, 19, 0, 0, 469, 470, 5, 66, 0, 0, 470, 471, 5, 89, 0, 0, 471,
		476, 3, 48, 24, 0, 472, 473, 5, 83, 0, 0, 473, 475, 3, 48, 24, 0, 474,
		472, 1, 0, 0, 0, 475, 478, 1, 0, 0, 0, 476, 474, 1, 0, 0, 0, 476, 477,
		1, 0, 0, 0, 477, 480, 1, 0, 0, 0, 478, 476, 1, 0, 0, 0, 479, 481, 5, 83,
		0, 0, 480, 479, 1, 0, 0, 0, 480, 481, 1, 0, 0, 0, 481, 482, 1, 0, 0, 0,
		482, 483, 5, 90, 0, 0, 483, 47, 1, 0, 0, 0, 484, 487, 5, 66, 0, 0, 485,
		486, 5, 99, 0, 0, 486, 488, 5, 67, 0, 0, 487, 485, 1, 0, 0, 0, 487, 488,
		1, 0, 0, 0, 488, 49, 1, 0, 0, 0, 489, 491, 5, 38, 0, 0, 490, 489, 1, 0,
		0, 0, 490, 491, 1, 0, 0, 0, 491, 492, 1, 0, 0, 0, 492, 493, 7, 1, 0, 0,
		493, 494, 5, 66, 0, 0, 494, 498, 5, 89, 0, 0, 495, 497, 3, 52, 26, 0, 496,
		495, 1, 0, 0, 0, 497, 500, 1, 0, 0, 0, 498, 496, 1, 0, 0, 0, 498, 499,
		1, 0, 0, 0, 499, 501, 1, 0, 0, 0, 500, 498, 1, 0, 0, 0, 501, 502, 5, 90,
		0, 0, 502, 51, 1, 0, 0, 0, 503, 504, 5, 66, 0, 0, 504, 505, 5, 85, 0, 0,
		505, 507, 5, 67, 0, 0, 506, 508, 5, 83, 0, 0, 507, 506, 1, 0, 0, 0, 507,
		508, 1, 0, 0, 0, 508, 53, 1, 0, 0, 0, 509, 511, 5, 38, 0, 0, 510, 509,
		1, 0, 0, 0, 510, 511, 1, 0, 0, 0, 511, 512, 1, 0, 0, 0, 512, 513, 5, 20,
		0, 0, 513, 514, 5, 66, 0, 0, 514, 515, 5, 85, 0, 0, 515, 516, 3, 96, 48,
		0, 516, 517, 5, 99, 0, 0, 517, 518, 3, 174, 87, 0, 518, 519, 5, 84, 0,
		0, 519, 55, 1, 0, 0, 0, 520, 522, 5, 38, 0, 0, 521, 520, 1, 0, 0, 0, 521,
		522, 1, 0, 0, 0, 522, 523, 1, 0, 0, 0, 523, 524, 5, 21, 0, 0, 524, 525,
		5, 66, 0, 0, 525, 526, 5, 85, 0, 0, 526, 529, 3, 96, 48, 0, 527, 528, 5,
		99, 0, 0, 528, 530, 3, 174, 87, 0, 529, 527, 1, 0, 0, 0, 529, 530, 1, 0,
		0, 0, 530, 531, 1, 0, 0, 0, 531, 532, 5, 84, 0, 0, 532, 57, 1, 0, 0, 0,
		533, 535, 5, 38, 0, 0, 534, 533, 1, 0, 0, 0, 534, 535, 1, 0, 0, 0, 535,
		536, 1, 0, 0, 0, 536, 537, 5, 22, 0, 0, 537, 538, 5, 66, 0, 0, 538, 539,
		5, 99, 0, 0, 539, 540, 3, 96, 48, 0, 540, 541, 5, 84, 0, 0, 541, 59, 1,
		0, 0, 0, 542, 543, 5, 46, 0, 0, 543, 544, 5, 66, 0, 0, 544, 545, 5, 28,
		0, 0, 545, 546, 3, 96, 48, 0, 546, 550, 5, 89, 0, 0, 547, 549, 3, 8, 4,
		0, 548, 547, 1, 0, 0, 0, 549, 552, 1, 0, 0, 0, 550, 548, 1, 0, 0, 0, 550,
		551, 1, 0, 0, 0, 551, 553, 1, 0, 0, 0, 552, 550, 1, 0, 0, 0, 553, 554,
		5, 90, 0, 0, 554, 61, 1, 0, 0, 0, 555, 556, 5, 124, 0, 0, 556, 557, 5,
		66, 0, 0, 557, 559, 5, 87, 0, 0, 558, 560, 3, 226, 113, 0, 559, 558, 1,
		0, 0, 0, 559, 560, 1, 0, 0, 0, 560, 561, 1, 0, 0, 0, 561, 563, 5, 88, 0,
		0, 562, 564, 5, 84, 0, 0, 563, 562, 1, 0, 0, 0, 563, 564, 1, 0, 0, 0, 564,
		63, 1, 0, 0, 0, 565, 566, 3, 66, 33, 0, 566, 567, 3, 6, 3, 0, 567, 65,
		1, 0, 0, 0, 568, 569, 5, 124, 0, 0, 569, 575, 5, 66, 0, 0, 570, 572, 5,
		87, 0, 0, 571, 573, 3, 226, 113, 0, 572, 571, 1, 0, 0, 0, 572, 573, 1,
		0, 0, 0, 573, 574, 1, 0, 0, 0, 574, 576, 5, 88, 0, 0, 575, 570, 1, 0, 0,
		0, 575, 576, 1, 0, 0, 0, 576, 67, 1, 0, 0, 0, 577, 578, 5, 1, 0, 0, 578,
		579, 5, 126, 0, 0, 579, 580, 3, 70, 35, 0, 580, 581, 5, 127, 0, 0, 581,
		69, 1, 0, 0, 0, 582, 584, 5, 131, 0, 0, 583, 582, 1, 0, 0, 0, 584, 587,
		1, 0, 0, 0, 585, 583, 1, 0, 0, 0, 585, 586, 1, 0, 0, 0, 586, 71, 1, 0,
		0, 0, 587, 585, 1, 0, 0, 0, 588, 589, 5, 2, 0, 0, 589, 590, 5, 126, 0,
		0, 590, 591, 3, 74, 37, 0, 591, 592, 5, 127, 0, 0, 592, 73, 1, 0, 0, 0,
		593, 595, 5, 132, 0, 0, 594, 593, 1, 0, 0, 0, 595, 598, 1, 0, 0, 0, 596,
		594, 1, 0, 0, 0, 596, 597, 1, 0, 0, 0, 597, 75, 1, 0, 0, 0, 598, 596, 1,
		0, 0, 0, 599, 600, 5, 3, 0, 0, 600, 601, 5, 87, 0, 0, 601, 606, 5, 71,
		0, 0, 602, 603, 5, 83, 0, 0, 603, 605, 3, 174, 87, 0, 604, 602, 1, 0, 0,
		0, 605, 608, 1, 0, 0, 0, 606, 604, 1, 0, 0, 0, 606, 607, 1, 0, 0, 0, 607,
		609, 1, 0, 0, 0, 608, 606, 1, 0, 0, 0, 609, 610, 5, 88, 0, 0, 610, 77,
		1, 0, 0, 0, 611, 612, 5, 4, 0, 0, 612, 613, 5, 87, 0, 0, 613, 614, 3, 174,
		87, 0, 614, 615, 5, 83, 0, 0, 615, 618, 5, 71, 0, 0, 616, 617, 5, 83, 0,
		0, 617, 619, 5, 71, 0, 0, 618, 616, 1, 0, 0, 0, 618, 619, 1, 0, 0, 0, 619,
		620, 1, 0, 0, 0, 620, 621, 5, 88, 0, 0, 621, 79, 1, 0, 0, 0, 622, 623,
		5, 5, 0, 0, 623, 624, 5, 87, 0, 0, 624, 625, 3, 84, 42, 0, 625, 626, 5,
		88, 0, 0, 626, 627, 5, 126, 0, 0, 627, 628, 3, 82, 41, 0, 628, 629, 5,
		127, 0, 0, 629, 636, 1, 0, 0, 0, 630, 631, 5, 5, 0, 0, 631, 632, 5, 87,
		0, 0, 632, 633, 3, 226, 113, 0, 633, 634, 5, 88, 0, 0, 634, 636, 1, 0,
		0, 0, 635, 622, 1, 0, 0, 0, 635, 630, 1, 0, 0, 0, 636, 81, 1, 0, 0, 0,
		637, 639, 5, 133, 0, 0, 638, 637, 1, 0, 0, 0, 639, 642, 1, 0, 0, 0, 640,
		638, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0, 641, 83, 1, 0, 0, 0, 642, 640, 1,
		0, 0, 0, 643, 648, 5, 66, 0, 0, 644, 645, 5, 83, 0, 0, 645, 647, 5, 66,
		0, 0, 646, 644, 1, 0, 0, 0, 647, 650, 1, 0, 0, 0, 648, 646, 1, 0, 0, 0,
		648, 649, 1, 0, 0, 0, 649, 85, 1, 0, 0, 0, 650, 648, 1, 0, 0, 0, 651, 655,
		3, 88, 44, 0, 652, 655, 3, 90, 45, 0, 653, 655, 3, 92, 46, 0, 654, 651,
		1, 0, 0, 0, 654, 652, 1, 0, 0, 0, 654, 653, 1, 0, 0, 0, 655, 87, 1, 0,
		0, 0, 656, 657, 5, 1, 0, 0, 657, 658, 5, 126, 0, 0, 658, 659, 3, 94, 47,
		0, 659, 660, 5, 127, 0, 0, 660, 89, 1, 0, 0, 0, 661, 662, 5, 3, 0, 0, 662,
		663, 5, 126, 0, 0, 663, 664, 3, 94, 47, 0, 664, 665, 5, 127, 0, 0, 665,
		91, 1, 0, 0, 0, 666, 667, 5, 2, 0, 0, 667, 668, 5, 126, 0, 0, 668, 669,
		3, 94, 47, 0, 669, 670, 5, 127, 0, 0, 670, 93, 1, 0, 0, 0, 671, 673, 5,
		134, 0, 0, 672, 671, 1, 0, 0, 0, 673, 676, 1, 0, 0, 0, 674, 672, 1, 0,
		0, 0, 674, 675, 1, 0, 0, 0, 675, 95, 1, 0, 0, 0, 676, 674, 1, 0, 0, 0,
		677, 687, 3, 98, 49, 0, 678, 687, 3, 100, 50, 0, 679, 687, 3, 102, 51,
		0, 680, 687, 3, 106, 53, 0, 681, 687, 3, 108, 54, 0, 682, 687, 3, 110,
		55, 0, 683, 687, 3, 112, 56, 0, 684, 687, 3, 114, 57, 0, 685, 687, 3, 116,
		58, 0, 686, 677, 1, 0, 0, 0, 686, 678, 1, 0, 0, 0, 686, 679, 1, 0, 0, 0,
		686, 680, 1, 0, 0, 0, 686, 681, 1, 0, 0, 0, 686, 682, 1, 0, 0, 0, 686,
		683, 1, 0, 0, 0, 686, 684, 1, 0, 0, 0, 686, 685, 1, 0, 0, 0, 687, 97, 1,
		0, 0, 0, 688, 689, 7, 2, 0, 0, 689, 99, 1, 0, 0, 0, 690, 695, 5, 66, 0,
		0, 691, 692, 5, 80, 0, 0, 692, 694, 5, 66, 0, 0, 693, 691, 1, 0, 0, 0,
		694, 697, 1, 0, 0, 0, 695, 693, 1, 0, 0, 0, 695, 696, 1, 0, 0, 0, 696,
		101, 1, 0, 0, 0, 697, 695, 1, 0, 0, 0, 698, 699, 3, 118, 59, 0, 699, 701,
		5, 91, 0, 0, 700, 702, 3, 104, 52, 0, 701, 700, 1, 0, 0, 0, 701, 702, 1,
		0, 0, 0, 702, 703, 1, 0, 0, 0, 703, 704, 5, 92, 0, 0, 704, 712, 1, 0, 0,
		0, 705, 706, 5, 91, 0, 0, 706, 707, 3, 118, 59, 0, 707, 708, 5, 84, 0,
		0, 708, 709, 3, 104, 52, 0, 709, 710, 5, 92, 0, 0, 710, 712, 1, 0, 0, 0,
		711, 698, 1, 0, 0, 0, 711, 705, 1, 0, 0, 0, 712, 103, 1, 0, 0, 0, 713,
		714, 7, 3, 0, 0, 714, 105, 1, 0, 0, 0, 715, 716, 5, 112, 0, 0, 716, 721,
		3, 118, 59, 0, 717, 718, 5, 112, 0, 0, 718, 719, 5, 24, 0, 0, 719, 721,
		3, 118, 59, 0, 720, 715, 1, 0, 0, 0, 720, 717, 1, 0, 0, 0, 721, 107, 1,
		0, 0, 0, 722, 723, 7, 0, 0, 0, 723, 725, 5, 87, 0, 0, 724, 726, 3, 30,
		15, 0, 725, 724, 1, 0, 0, 0, 725, 726, 1, 0, 0, 0, 726, 727, 1, 0, 0, 0,
		727, 729, 5, 88, 0, 0, 728, 730, 3, 16, 8, 0, 729, 728, 1, 0, 0, 0, 729,
		730, 1, 0, 0, 0, 730, 109, 1, 0, 0, 0, 731, 732, 7, 1, 0, 0, 732, 736,
		5, 89, 0, 0, 733, 735, 3, 52, 26, 0, 734, 733, 1, 0, 0, 0, 735, 738, 1,
		0, 0, 0, 736, 734, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 739, 1, 0, 0,
		0, 738, 736, 1, 0, 0, 0, 739, 740, 5, 90, 0, 0, 740, 111, 1, 0, 0, 0, 741,
		742, 3, 118, 59, 0, 742, 743, 5, 78, 0, 0, 743, 113, 1, 0, 0, 0, 744, 745,
		5, 24, 0, 0, 745, 746, 3, 118, 59, 0, 746, 115, 1, 0, 0, 0, 747, 748, 5,
		10, 0, 0, 748, 749, 5, 93, 0, 0, 749, 750, 3, 118, 59, 0, 750, 751, 5,
		94, 0, 0, 751, 117, 1, 0, 0, 0, 752, 755, 3, 98, 49, 0, 753, 755, 3, 100,
		50, 0, 754, 752, 1, 0, 0, 0, 754, 753, 1, 0, 0, 0, 755, 119, 1, 0, 0, 0,
		756, 776, 3, 122, 61, 0, 757, 776, 3, 124, 62, 0, 758, 776, 3, 126, 63,
		0, 759, 776, 3, 128, 64, 0, 760, 776, 3, 130, 65, 0, 761, 776, 3, 132,
		66, 0, 762, 776, 3, 136, 68, 0, 763, 776, 3, 144, 72, 0, 764, 776, 3, 146,
		73, 0, 765, 776, 3, 148, 74, 0, 766, 776, 3, 150, 75, 0, 767, 776, 3, 160,
		80, 0, 768, 776, 3, 152, 76, 0, 769, 776, 3, 158, 79, 0, 770, 776, 3, 162,
		81, 0, 771, 776, 3, 164, 82, 0, 772, 776, 3, 166, 83, 0, 773, 776, 3, 168,
		84, 0, 774, 776, 3, 172, 86, 0, 775, 756, 1, 0, 0, 0, 775, 757, 1, 0, 0,
		0, 775, 758, 1, 0, 0, 0, 775, 759, 1, 0, 0, 0, 775, 760, 1, 0, 0, 0, 775,
		761, 1, 0, 0, 0, 775, 762, 1, 0, 0, 0, 775, 763, 1, 0, 0, 0, 775, 764,
		1, 0, 0, 0, 775, 765, 1, 0, 0, 0, 775, 766, 1, 0, 0, 0, 775, 767, 1, 0,
		0, 0, 775, 768, 1, 0, 0, 0, 775, 769, 1, 0, 0, 0, 775, 770, 1, 0, 0, 0,
		775, 771, 1, 0, 0, 0, 775, 772, 1, 0, 0, 0, 775, 773, 1, 0, 0, 0, 775,
		774, 1, 0, 0, 0, 776, 121, 1, 0, 0, 0, 777, 779, 5, 23, 0, 0, 778, 780,
		5, 24, 0, 0, 779, 778, 1, 0, 0, 0, 779, 780, 1, 0, 0, 0, 780, 781, 1, 0,
		0, 0, 781, 784, 5, 66, 0, 0, 782, 783, 5, 85, 0, 0, 783, 785, 3, 96, 48,
		0, 784, 782, 1, 0, 0, 0, 784, 785, 1, 0, 0, 0, 785, 788, 1, 0, 0, 0, 786,
		787, 5, 99, 0, 0, 787, 789, 3, 174, 87, 0, 788, 786, 1, 0, 0, 0, 788, 789,
		1, 0, 0, 0, 789, 790, 1, 0, 0, 0, 790, 791, 5, 84, 0, 0, 791, 123, 1, 0,
		0, 0, 792, 793, 5, 25, 0, 0, 793, 794, 3, 174, 87, 0, 794, 802, 3, 160,
		80, 0, 795, 796, 5, 26, 0, 0, 796, 797, 5, 25, 0, 0, 797, 798, 3, 174,
		87, 0, 798, 799, 3, 160, 80, 0, 799, 801, 1, 0, 0, 0, 800, 795, 1, 0, 0,
		0, 801, 804, 1, 0, 0, 0, 802, 800, 1, 0, 0, 0, 802, 803, 1, 0, 0, 0, 803,
		807, 1, 0, 0, 0, 804, 802, 1, 0, 0, 0, 805, 806, 5, 26, 0, 0, 806, 808,
		3, 160, 80, 0, 807, 805, 1, 0, 0, 0, 807, 808, 1, 0, 0, 0, 808, 125, 1,
		0, 0, 0, 809, 810, 5, 27, 0, 0, 810, 811, 3, 174, 87, 0, 811, 812, 3, 160,
		80, 0, 812, 127, 1, 0, 0, 0, 813, 814, 5, 28, 0, 0, 814, 815, 5, 66, 0,
		0, 815, 816, 5, 29, 0, 0, 816, 817, 3, 174, 87, 0, 817, 818, 3, 160, 80,
		0, 818, 129, 1, 0, 0, 0, 819, 820, 5, 30, 0, 0, 820, 821, 3, 160, 80, 0,
		821, 131, 1, 0, 0, 0, 822, 823, 5, 31, 0, 0, 823, 824, 3, 174, 87, 0, 824,
		828, 5, 89, 0, 0, 825, 827, 3, 134, 67, 0, 826, 825, 1, 0, 0, 0, 827, 830,
		1, 0, 0, 0, 828, 826, 1, 0, 0, 0, 828, 829, 1, 0, 0, 0, 829, 831, 1, 0,
		0, 0, 830, 828, 1, 0, 0, 0, 831, 832, 5, 90, 0, 0, 832, 133, 1, 0, 0, 0,
		833, 834, 3, 140, 70, 0, 834, 839, 5, 77, 0, 0, 835, 836, 3, 174, 87, 0,
		836, 837, 5, 84, 0, 0, 837, 840, 1, 0, 0, 0, 838, 840, 3, 160, 80, 0, 839,
		835, 1, 0, 0, 0, 839, 838, 1, 0, 0, 0, 840, 842, 1, 0, 0, 0, 841, 843,
		5, 83, 0, 0, 842, 841, 1, 0, 0, 0, 842, 843, 1, 0, 0, 0, 843, 135, 1, 0,
		0, 0, 844, 845, 5, 32, 0, 0, 845, 846, 3, 174, 87, 0, 846, 850, 5, 89,
		0, 0, 847, 849, 3, 138, 69, 0, 848, 847, 1, 0, 0, 0, 849, 852, 1, 0, 0,
		0, 850, 848, 1, 0, 0, 0, 850, 851, 1, 0, 0, 0, 851, 853, 1, 0, 0, 0, 852,
		850, 1, 0, 0, 0, 853, 854, 5, 90, 0, 0, 854, 137, 1, 0, 0, 0, 855, 858,
		3, 140, 70, 0, 856, 857, 5, 25, 0, 0, 857, 859, 3, 174, 87, 0, 858, 856,
		1, 0, 0, 0, 858, 859, 1, 0, 0, 0, 859, 860, 1, 0, 0, 0, 860, 863, 5, 77,
		0, 0, 861, 864, 3, 174, 87, 0, 862, 864, 3, 160, 80, 0, 863, 861, 1, 0,
		0, 0, 863, 862, 1, 0, 0, 0, 864, 866, 1, 0, 0, 0, 865, 867, 5, 83, 0, 0,
		866, 865, 1, 0, 0, 0, 866, 867, 1, 0, 0, 0, 867, 139, 1, 0, 0, 0, 868,
		873, 5, 125, 0, 0, 869, 873, 3, 178, 89, 0, 870, 873, 5, 66, 0, 0, 871,
		873, 3, 142, 71, 0, 872, 868, 1, 0, 0, 0, 872, 869, 1, 0, 0, 0, 872, 870,
		1, 0, 0, 0, 872, 871, 1, 0, 0, 0, 873, 141, 1, 0, 0, 0, 874, 875, 5, 66,
		0, 0, 875, 876, 5, 86, 0, 0, 876, 877, 5, 66, 0, 0, 877, 143, 1, 0, 0,
		0, 878, 880, 5, 34, 0, 0, 879, 881, 3, 174, 87, 0, 880, 879, 1, 0, 0, 0,
		880, 881, 1, 0, 0, 0, 881, 882, 1, 0, 0, 0, 882, 883, 5, 84, 0, 0, 883,
		145, 1, 0, 0, 0, 884, 885, 5, 35, 0, 0, 885, 886, 5, 84, 0, 0, 886, 147,
		1, 0, 0, 0, 887, 888, 5, 36, 0, 0, 888, 889, 5, 84, 0, 0, 889, 149, 1,
		0, 0, 0, 890, 895, 5, 37, 0, 0, 891, 892, 3, 174, 87, 0, 892, 893, 5, 84,
		0, 0, 893, 896, 1, 0, 0, 0, 894, 896, 3, 160, 80, 0, 895, 891, 1, 0, 0,
		0, 895, 894, 1, 0, 0, 0, 896, 151, 1, 0, 0, 0, 897, 898, 3, 154, 77, 0,
		898, 899, 3, 156, 78, 0, 899, 900, 3, 174, 87, 0, 900, 901, 5, 84, 0, 0,
		901, 153, 1, 0, 0, 0, 902, 913, 5, 66, 0, 0, 903, 904, 3, 174, 87, 0, 904,
		905, 5, 80, 0, 0, 905, 906, 5, 66, 0, 0, 906, 913, 1, 0, 0, 0, 907, 908,
		3, 174, 87, 0, 908, 909, 5, 91, 0, 0, 909, 910, 3, 174, 87, 0, 910, 911,
		5, 92, 0, 0, 911, 913, 1, 0, 0, 0, 912, 902, 1, 0, 0, 0, 912, 903, 1, 0,
		0, 0, 912, 907, 1, 0, 0, 0, 913, 155, 1, 0, 0, 0, 914, 915, 7, 4, 0, 0,
		915, 157, 1, 0, 0, 0, 916, 917, 3, 174, 87, 0, 917, 918, 5, 84, 0, 0, 918,
		159, 1, 0, 0, 0, 919, 923, 5, 89, 0, 0, 920, 922, 3, 120, 60, 0, 921, 920,
		1, 0, 0, 0, 922, 925, 1, 0, 0, 0, 923, 921, 1, 0, 0, 0, 923, 924, 1, 0,
		0, 0, 924, 926, 1, 0, 0, 0, 925, 923, 1, 0, 0, 0, 926, 927, 5, 90, 0, 0,
		927, 161, 1, 0, 0, 0, 928, 929, 5, 40, 0, 0, 929, 931, 5, 89, 0, 0, 930,
		932, 3, 24, 12, 0, 931, 930, 1, 0, 0, 0, 931, 932, 1, 0, 0, 0, 932, 933,
		1, 0, 0, 0, 933, 934, 5, 90, 0, 0, 934, 163, 1, 0, 0, 0, 935, 936, 5, 11,
		0, 0, 936, 938, 5, 89, 0, 0, 937, 939, 3, 24, 12, 0, 938, 937, 1, 0, 0,
		0, 938, 939, 1, 0, 0, 0, 939, 940, 1, 0, 0, 0, 940, 941, 5, 90, 0, 0, 941,
		165, 1, 0, 0, 0, 942, 943, 5, 41, 0, 0, 943, 945, 5, 89, 0, 0, 944, 946,
		3, 28, 14, 0, 945, 944, 1, 0, 0, 0, 945, 946, 1, 0, 0, 0, 946, 947, 1,
		0, 0, 0, 947, 948, 5, 90, 0, 0, 948, 167, 1, 0, 0, 0, 949, 950, 5, 3, 0,
		0, 950, 952, 5, 89, 0, 0, 951, 953, 3, 170, 85, 0, 952, 951, 1, 0, 0, 0,
		952, 953, 1, 0, 0, 0, 953, 954, 1, 0, 0, 0, 954, 955, 5, 90, 0, 0, 955,
		169, 1, 0, 0, 0, 956, 958, 5, 130, 0, 0, 957, 956, 1, 0, 0, 0, 958, 961,
		1, 0, 0, 0, 959, 957, 1, 0, 0, 0, 959, 960, 1, 0, 0, 0, 960, 171, 1, 0,
		0, 0, 961, 959, 1, 0, 0, 0, 962, 963, 5, 12, 0, 0, 963, 964, 5, 87, 0,
		0, 964, 965, 5, 71, 0, 0, 965, 966, 5, 88, 0, 0, 966, 967, 3, 160, 80,
		0, 967, 173, 1, 0, 0, 0, 968, 969, 6, 87, -1, 0, 969, 978, 3, 176, 88,
		0, 970, 971, 7, 5, 0, 0, 971, 978, 3, 174, 87, 17, 972, 978, 3, 208, 104,
		0, 973, 978, 3, 214, 107, 0, 974, 978, 3, 216, 108, 0, 975, 978, 3, 218,
		109, 0, 976, 978, 3, 222, 111, 0, 977, 968, 1, 0, 0, 0, 977, 970, 1, 0,
		0, 0, 977, 972, 1, 0, 0, 0, 977, 973, 1, 0, 0, 0, 977, 974, 1, 0, 0, 0,
		977, 975, 1, 0, 0, 0, 977, 976, 1, 0, 0, 0, 978, 1036, 1, 0, 0, 0, 979,
		980, 10, 19, 0, 0, 980, 981, 5, 79, 0, 0, 981, 1035, 3, 174, 87, 20, 982,
		983, 10, 16, 0, 0, 983, 984, 7, 6, 0, 0, 984, 1035, 3, 174, 87, 17, 985,
		986, 10, 15, 0, 0, 986, 987, 7, 7, 0, 0, 987, 1035, 3, 174, 87, 16, 988,
		989, 10, 14, 0, 0, 989, 990, 7, 8, 0, 0, 990, 1035, 3, 174, 87, 15, 991,
		992, 10, 13, 0, 0, 992, 993, 7, 9, 0, 0, 993, 1035, 3, 174, 87, 14, 994,
		995, 10, 12, 0, 0, 995, 996, 7, 10, 0, 0, 996, 1035, 3, 174, 87, 13, 997,
		998, 10, 11, 0, 0, 998, 999, 7, 11, 0, 0, 999, 1035, 3, 174, 87, 12, 1000,
		1001, 10, 10, 0, 0, 1001, 1002, 5, 115, 0, 0, 1002, 1035, 3, 174, 87, 11,
		1003, 1004, 10, 9, 0, 0, 1004, 1005, 5, 117, 0, 0, 1005, 1035, 3, 174,
		87, 10, 1006, 1007, 10, 8, 0, 0, 1007, 1008, 5, 116, 0, 0, 1008, 1035,
		3, 174, 87, 9, 1009, 1010, 10, 7, 0, 0, 1010, 1011, 7, 12, 0, 0, 1011,
		1035, 3, 174, 87, 8, 1012, 1013, 10, 6, 0, 0, 1013, 1014, 7, 13, 0, 0,
		1014, 1035, 3, 174, 87, 7, 1015, 1016, 10, 23, 0, 0, 1016, 1018, 5, 87,
		0, 0, 1017, 1019, 3, 224, 112, 0, 1018, 1017, 1, 0, 0, 0, 1018, 1019, 1,
		0, 0, 0, 1019, 1020, 1, 0, 0, 0, 1020, 1035, 5, 88, 0, 0, 1021, 1022, 10,
		22, 0, 0, 1022, 1023, 5, 80, 0, 0, 1023, 1035, 5, 66, 0, 0, 1024, 1025,
		10, 21, 0, 0, 1025, 1026, 5, 91, 0, 0, 1026, 1027, 3, 174, 87, 0, 1027,
		1028, 5, 92, 0, 0, 1028, 1035, 1, 0, 0, 0, 1029, 1030, 10, 20, 0, 0, 1030,
		1035, 5, 78, 0, 0, 1031, 1032, 10, 18, 0, 0, 1032, 1033, 5, 14, 0, 0, 1033,
		1035, 3, 96, 48, 0, 1034, 979, 1, 0, 0, 0, 1034, 982, 1, 0, 0, 0, 1034,
		985, 1, 0, 0, 0, 1034, 988, 1, 0, 0, 0, 1034, 991, 1, 0, 0, 0, 1034, 994,
		1, 0, 0, 0, 1034, 997, 1, 0, 0, 0, 1034, 1000, 1, 0, 0, 0, 1034, 1003,
		1, 0, 0, 0, 1034, 1006, 1, 0, 0, 0, 1034, 1009, 1, 0, 0, 0, 1034, 1012,
		1, 0, 0, 0, 1034, 1015, 1, 0, 0, 0, 1034, 1021, 1, 0, 0, 0, 1034, 1024,
		1, 0, 0, 0, 1034, 1029, 1, 0, 0, 0, 1034, 1031, 1, 0, 0, 0, 1035, 1038,
		1, 0, 0, 0, 1036, 1034, 1, 0, 0, 0, 1036, 1037, 1, 0, 0, 0, 1037, 175,
		1, 0, 0, 0, 1038, 1036, 1, 0, 0, 0, 1039, 1056, 3, 178, 89, 0, 1040, 1056,
		5, 66, 0, 0, 1041, 1056, 5, 42, 0, 0, 1042, 1043, 5, 87, 0, 0, 1043, 1044,
		3, 174, 87, 0, 1044, 1045, 5, 88, 0, 0, 1045, 1056, 1, 0, 0, 0, 1046, 1056,
		3, 180, 90, 0, 1047, 1056, 3, 182, 91, 0, 1048, 1056, 3, 184, 92, 0, 1049,
		1056, 3, 188, 94, 0, 1050, 1056, 3, 160, 80, 0, 1051, 1056, 3, 190, 95,
		0, 1052, 1056, 3, 202, 101, 0, 1053, 1056, 3, 204, 102, 0, 1054, 1056,
		3, 206, 103, 0, 1055, 1039, 1, 0, 0, 0, 1055, 1040, 1, 0, 0, 0, 1055, 1041,
		1, 0, 0, 0, 1055, 1042, 1, 0, 0, 0, 1055, 1046, 1, 0, 0, 0, 1055, 1047,
		1, 0, 0, 0, 1055, 1048, 1, 0, 0, 0, 1055, 1049, 1, 0, 0, 0, 1055, 1050,
		1, 0, 0, 0, 1055, 1051, 1, 0, 0, 0, 1055, 1052, 1, 0, 0, 0, 1055, 1053,
		1, 0, 0, 0, 1055, 1054, 1, 0, 0, 0, 1056, 177, 1, 0, 0, 0, 1057, 1058,
		7, 14, 0, 0, 1058, 179, 1, 0, 0, 0, 1059, 1061, 5, 91, 0, 0, 1060, 1062,
		3, 226, 113, 0, 1061, 1060, 1, 0, 0, 0, 1061, 1062, 1, 0, 0, 0, 1062, 1063,
		1, 0, 0, 0, 1063, 1064, 5, 92, 0, 0, 1064, 181, 1, 0, 0, 0, 1065, 1067,
		5, 89, 0, 0, 1066, 1068, 3, 226, 113, 0, 1067, 1066, 1, 0, 0, 0, 1067,
		1068, 1, 0, 0, 0, 1068, 1069, 1, 0, 0, 0, 1069, 1070, 5, 90, 0, 0, 1070,
		183, 1, 0, 0, 0, 1071, 1072, 5, 66, 0, 0, 1072, 1073, 5, 89, 0, 0, 1073,
		1078, 3, 186, 93, 0, 1074, 1075, 5, 83, 0, 0, 1075, 1077, 3, 186, 93, 0,
		1076, 1074, 1, 0, 0, 0, 1077, 1080, 1, 0, 0, 0, 1078, 1076, 1, 0, 0, 0,
		1078, 1079, 1, 0, 0, 0, 1079, 1082, 1, 0, 0, 0, 1080, 1078, 1, 0, 0, 0,
		1081, 1083, 5, 83, 0, 0, 1082, 1081, 1, 0, 0, 0, 1082, 1083, 1, 0, 0, 0,
		1083, 1084, 1, 0, 0, 0, 1084, 1085, 5, 90, 0, 0, 1085, 185, 1, 0, 0, 0,
		1086, 1087, 5, 66, 0, 0, 1087, 1088, 5, 85, 0, 0, 1088, 1089, 3, 174, 87,
		0, 1089, 187, 1, 0, 0, 0, 1090, 1091, 5, 87, 0, 0, 1091, 1092, 3, 174,
		87, 0, 1092, 1093, 5, 83, 0, 0, 1093, 1094, 3, 226, 113, 0, 1094, 1095,
		5, 88, 0, 0, 1095, 189, 1, 0, 0, 0, 1096, 1097, 5, 40, 0, 0, 1097, 1098,
		5, 87, 0, 0, 1098, 1115, 5, 71, 0, 0, 1099, 1101, 5, 85, 0, 0, 1100, 1102,
		3, 192, 96, 0, 1101, 1100, 1, 0, 0, 0, 1101, 1102, 1, 0, 0, 0, 1102, 1113,
		1, 0, 0, 0, 1103, 1105, 5, 85, 0, 0, 1104, 1106, 3, 194, 97, 0, 1105, 1104,
		1, 0, 0, 0, 1105, 1106, 1, 0, 0, 0, 1106, 1111, 1, 0, 0, 0, 1107, 1109,
		5, 85, 0, 0, 1108, 1110, 3, 196, 98, 0, 1109, 1108, 1, 0, 0, 0, 1109, 1110,
		1, 0, 0, 0, 1110, 1112, 1, 0, 0, 0, 1111, 1107, 1, 0, 0, 0, 1111, 1112,
		1, 0, 0, 0, 1112, 1114, 1, 0, 0, 0, 1113, 1103, 1, 0, 0, 0, 1113, 1114,
		1, 0, 0, 0, 1114, 1116, 1, 0, 0, 0, 1115, 1099, 1, 0, 0, 0, 1115, 1116,
		1, 0, 0, 0, 1116, 1117, 1, 0, 0, 0, 1117, 1118, 5, 88, 0, 0, 1118, 191,
		1, 0, 0, 0, 1119, 1124, 3, 198, 99, 0, 1120, 1121, 5, 83, 0, 0, 1121, 1123,
		3, 198, 99, 0, 1122, 1120, 1, 0, 0, 0, 1123, 1126, 1, 0, 0, 0, 1124, 1122,
		1, 0, 0, 0, 1124, 1125, 1, 0, 0, 0, 1125, 193, 1, 0, 0, 0, 1126, 1124,
		1, 0, 0, 0, 1127, 1132, 3, 200, 100, 0, 1128, 1129, 5, 83, 0, 0, 1129,
		1131, 3, 200, 100, 0, 1130, 1128, 1, 0, 0, 0, 1131, 1134, 1, 0, 0, 0, 1132,
		1130, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133, 195, 1, 0, 0, 0, 1134,
		1132, 1, 0, 0, 0, 1135, 1140, 5, 71, 0, 0, 1136, 1137, 5, 83, 0, 0, 1137,
		1139, 5, 71, 0, 0, 1138, 1136, 1, 0, 0, 0, 1139, 1142, 1, 0, 0, 0, 1140,
		1138, 1, 0, 0, 0, 1140, 1141, 1, 0, 0, 0, 1141, 197, 1, 0, 0, 0, 1142,
		1140, 1, 0, 0, 0, 1143, 1144, 5, 71, 0, 0, 1144, 1145, 5, 87, 0, 0, 1145,
		1146, 5, 66, 0, 0, 1146, 1147, 5, 88, 0, 0, 1147, 199, 1, 0, 0, 0, 1148,
		1149, 5, 71, 0, 0, 1149, 1150, 5, 87, 0, 0, 1150, 1151, 3, 174, 87, 0,
		1151, 1152, 5, 88, 0, 0, 1152, 201, 1, 0, 0, 0, 1153, 1154, 5, 48, 0, 0,
		1154, 1155, 5, 87, 0, 0, 1155, 1156, 3, 96, 48, 0, 1156, 1157, 5, 88, 0,
		0, 1157, 203, 1, 0, 0, 0, 1158, 1159, 5, 49, 0, 0, 1159, 1160, 5, 87, 0,
		0, 1160, 1161, 3, 96, 48, 0, 1161, 1162, 5, 88, 0, 0, 1162, 205, 1, 0,
		0, 0, 1163, 1164, 5, 50, 0, 0, 1164, 1165, 5, 80, 0, 0, 1165, 1166, 5,
		66, 0, 0, 1166, 207, 1, 0, 0, 0, 1167, 1169, 5, 116, 0, 0, 1168, 1170,
		3, 210, 105, 0, 1169, 1168, 1, 0, 0, 0, 1169, 1170, 1, 0, 0, 0, 1170, 1171,
		1, 0, 0, 0, 1171, 1174, 5, 116, 0, 0, 1172, 1173, 5, 77, 0, 0, 1173, 1175,
		3, 96, 48, 0, 1174, 1172, 1, 0, 0, 0, 1174, 1175, 1, 0, 0, 0, 1175, 1178,
		1, 0, 0, 0, 1176, 1179, 3, 174, 87, 0, 1177, 1179, 3, 160, 80, 0, 1178,
		1176, 1, 0, 0, 0, 1178, 1177, 1, 0, 0, 0, 1179, 209, 1, 0, 0, 0, 1180,
		1185, 3, 212, 106, 0, 1181, 1182, 5, 83, 0, 0, 1182, 1184, 3, 212, 106,
		0, 1183, 1181, 1, 0, 0, 0, 1184, 1187, 1, 0, 0, 0, 1185, 1183, 1, 0, 0,
		0, 1185, 1186, 1, 0, 0, 0, 1186, 211, 1, 0, 0, 0, 1187, 1185, 1, 0, 0,
		0, 1188, 1191, 5, 66, 0, 0, 1189, 1190, 5, 85, 0, 0, 1190, 1192, 3, 96,
		48, 0, 1191, 1189, 1, 0, 0, 0, 1191, 1192, 1, 0, 0, 0, 1192, 213, 1, 0,
		0, 0, 1193, 1194, 5, 25, 0, 0, 1194, 1195, 3, 174, 87, 0, 1195, 1196, 3,
		160, 80, 0, 1196, 1199, 5, 26, 0, 0, 1197, 1200, 3, 160, 80, 0, 1198, 1200,
		3, 214, 107, 0, 1199, 1197, 1, 0, 0, 0, 1199, 1198, 1, 0, 0, 0, 1200, 215,
		1, 0, 0, 0, 1201, 1202, 3, 176, 88, 0, 1202, 1203, 5, 25, 0, 0, 1203, 1204,
		3, 176, 88, 0, 1204, 1205, 5, 26, 0, 0, 1205, 1206, 3, 176, 88, 0, 1206,
		217, 1, 0, 0, 0, 1207, 1209, 5, 33, 0, 0, 1208, 1210, 3, 174, 87, 0, 1209,
		1208, 1, 0, 0, 0, 1209, 1210, 1, 0, 0, 0, 1210, 1211, 1, 0, 0, 0, 1211,
		1213, 5, 89, 0, 0, 1212, 1214, 3, 220, 110, 0, 1213, 1212, 1, 0, 0, 0,
		1214, 1215, 1, 0, 0, 0, 1215, 1213, 1, 0, 0, 0, 1215, 1216, 1, 0, 0, 0,
		1216, 1217, 1, 0, 0, 0, 1217, 1218, 5, 90, 0, 0, 1218, 219, 1, 0, 0, 0,
		1219, 1222, 3, 140, 70, 0, 1220, 1222, 5, 26, 0, 0, 1221, 1219, 1, 0, 0,
		0, 1221, 1220, 1, 0, 0, 0, 1222, 1225, 1, 0, 0, 0, 1223, 1224, 5, 25, 0,
		0, 1224, 1226, 3, 174, 87, 0, 1225, 1223, 1, 0, 0, 0, 1225, 1226, 1, 0,
		0, 0, 1226, 1227, 1, 0, 0, 0, 1227, 1228, 5, 77, 0, 0, 1228, 1230, 3, 174,
		87, 0, 1229, 1231, 5, 83, 0, 0, 1230, 1229, 1, 0, 0, 0, 1230, 1231, 1,
		0, 0, 0, 1231, 221, 1, 0, 0, 0, 1232, 1233, 5, 124, 0, 0, 1233, 1234, 5,
		66, 0, 0, 1234, 1236, 5, 87, 0, 0, 1235, 1237, 3, 226, 113, 0, 1236, 1235,
		1, 0, 0, 0, 1236, 1237, 1, 0, 0, 0, 1237, 1238, 1, 0, 0, 0, 1238, 1239,
		5, 88, 0, 0, 1239, 223, 1, 0, 0, 0, 1240, 1245, 3, 174, 87, 0, 1241, 1242,
		5, 83, 0, 0, 1242, 1244, 3, 174, 87, 0, 1243, 1241, 1, 0, 0, 0, 1244, 1247,
		1, 0, 0, 0, 1245, 1243, 1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246, 225,
		1, 0, 0, 0, 1247, 1245, 1, 0, 0, 0, 1248, 1253, 3, 174, 87, 0, 1249, 1250,
		5, 83, 0, 0, 1250, 1252, 3, 174, 87, 0, 1251, 1249, 1, 0, 0, 0, 1252, 1255,
		1, 0, 0, 0, 1253, 1251, 1, 0, 0, 0, 1253, 1254, 1, 0, 0, 0, 1254, 227,
		1, 0, 0, 0, 1255, 1253, 1, 0, 0, 0, 128, 230, 232, 241, 250, 272, 275,
		278, 283, 287, 291, 296, 299, 306, 310, 315, 318, 325, 329, 339, 347, 353,
		357, 364, 369, 376, 384, 391, 394, 402, 411, 414, 419, 424, 426, 435, 439,
		442, 452, 461, 466, 476, 480, 487, 490, 498, 507, 510, 521, 529, 534, 550,
		559, 563, 572, 575, 585, 596, 606, 618, 635, 640, 648, 654, 674, 686, 695,
		701, 711, 720, 725, 729, 736, 754, 775, 779, 784, 788, 802, 807, 828, 839,
		842, 850, 858, 863, 866, 872, 880, 895, 912, 923, 931, 938, 945, 952, 959,
		977, 1018, 1034, 1036, 1055, 1061, 1067, 1078, 1082, 1101, 1105, 1109,
		1111, 1113, 1115, 1124, 1132, 1140, 1169, 1174, 1178, 1185, 1191, 1199,
		1209, 1215, 1221, 1225, 1230, 1236, 1245, 1253,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// MinZParserInit initializes any static state used to implement MinZParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewMinZParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func MinZParserInit() {
	staticData := &MinZParserStaticData
	staticData.once.Do(minzParserInit)
}

// NewMinZParser produces a new parser instance for the optional input antlr.TokenStream.
func NewMinZParser(input antlr.TokenStream) *MinZParser {
	MinZParserInit()
	this := new(MinZParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &MinZParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "MinZ.g4"

	return this
}

// MinZParser tokens.
const (
	MinZParserEOF                   = antlr.TokenEOF
	MinZParserT__0                  = 1
	MinZParserT__1                  = 2
	MinZParserT__2                  = 3
	MinZParserT__3                  = 4
	MinZParserT__4                  = 5
	MinZParserT__5                  = 6
	MinZParserT__6                  = 7
	MinZParserT__7                  = 8
	MinZParserT__8                  = 9
	MinZParserT__9                  = 10
	MinZParserT__10                 = 11
	MinZParserT__11                 = 12
	MinZParserIMPORT                = 13
	MinZParserAS                    = 14
	MinZParserFUN                   = 15
	MinZParserFN                    = 16
	MinZParserSTRUCT                = 17
	MinZParserINTERFACE             = 18
	MinZParserENUM                  = 19
	MinZParserCONST                 = 20
	MinZParserGLOBAL                = 21
	MinZParserTYPE                  = 22
	MinZParserLET                   = 23
	MinZParserMUT                   = 24
	MinZParserIF                    = 25
	MinZParserELSE                  = 26
	MinZParserWHILE                 = 27
	MinZParserFOR                   = 28
	MinZParserIN                    = 29
	MinZParserLOOP                  = 30
	MinZParserMATCH                 = 31
	MinZParserCASE                  = 32
	MinZParserWHEN                  = 33
	MinZParserRETURN                = 34
	MinZParserBREAK                 = 35
	MinZParserCONTINUE              = 36
	MinZParserDEFER                 = 37
	MinZParserPUB                   = 38
	MinZParserEXPORT                = 39
	MinZParserASM                   = 40
	MinZParserMIR                   = 41
	MinZParserSELF                  = 42
	MinZParserTRUE                  = 43
	MinZParserFALSE                 = 44
	MinZParserNULL                  = 45
	MinZParserIMPL                  = 46
	MinZParserCAST                  = 47
	MinZParserSIZEOF                = 48
	MinZParserALIGNOF               = 49
	MinZParserERROR                 = 50
	MinZParserAND                   = 51
	MinZParserOR                    = 52
	MinZParserBITS                  = 53
	MinZParserBITS_8                = 54
	MinZParserBITS_16               = 55
	MinZParserU8                    = 56
	MinZParserU16                   = 57
	MinZParserU24                   = 58
	MinZParserU32                   = 59
	MinZParserI8                    = 60
	MinZParserI16                   = 61
	MinZParserI24                   = 62
	MinZParserI32                   = 63
	MinZParserBOOL                  = 64
	MinZParserVOID                  = 65
	MinZParserIDENTIFIER            = 66
	MinZParserINTEGER               = 67
	MinZParserHEX_INTEGER           = 68
	MinZParserBINARY_INTEGER        = 69
	MinZParserFLOAT                 = 70
	MinZParserSTRING                = 71
	MinZParserCHAR                  = 72
	MinZParserLINE_COMMENT          = 73
	MinZParserBLOCK_COMMENT         = 74
	MinZParserWS                    = 75
	MinZParserARROW                 = 76
	MinZParserDOUBLE_ARROW          = 77
	MinZParserQUESTION              = 78
	MinZParserDOUBLE_QUESTION       = 79
	MinZParserDOT                   = 80
	MinZParserRANGE                 = 81
	MinZParserRANGE_INCLUSIVE       = 82
	MinZParserCOMMA                 = 83
	MinZParserSEMICOLON             = 84
	MinZParserCOLON                 = 85
	MinZParserDOUBLE_COLON          = 86
	MinZParserLPAREN                = 87
	MinZParserRPAREN                = 88
	MinZParserLBRACE                = 89
	MinZParserRBRACE                = 90
	MinZParserLBRACKET              = 91
	MinZParserRBRACKET              = 92
	MinZParserLT                    = 93
	MinZParserGT                    = 94
	MinZParserLE                    = 95
	MinZParserGE                    = 96
	MinZParserEQ                    = 97
	MinZParserNE                    = 98
	MinZParserASSIGN                = 99
	MinZParserPLUS_ASSIGN           = 100
	MinZParserMINUS_ASSIGN          = 101
	MinZParserSTAR_ASSIGN           = 102
	MinZParserDIV_ASSIGN            = 103
	MinZParserMOD_ASSIGN            = 104
	MinZParserAND_ASSIGN            = 105
	MinZParserOR_ASSIGN             = 106
	MinZParserXOR_ASSIGN            = 107
	MinZParserSHL_ASSIGN            = 108
	MinZParserSHR_ASSIGN            = 109
	MinZParserPLUS                  = 110
	MinZParserMINUS                 = 111
	MinZParserSTAR                  = 112
	MinZParserDIV                   = 113
	MinZParserMOD                   = 114
	MinZParserAMPERSAND             = 115
	MinZParserPIPE                  = 116
	MinZParserCARET                 = 117
	MinZParserBANG                  = 118
	MinZParserTILDE                 = 119
	MinZParserLOGICAL_AND           = 120
	MinZParserLOGICAL_OR            = 121
	MinZParserSHL                   = 122
	MinZParserSHR                   = 123
	MinZParserAT                    = 124
	MinZParserUNDERSCORE            = 125
	MinZParserTRIPLE_BRACKET_OPEN   = 126
	MinZParserTRIPLE_BRACKET_CLOSE  = 127
	MinZParserASM_CODE_CONTENT      = 128
	MinZParserMIR_CODE_CONTENT      = 129
	MinZParserMINZ_CODE_CONTENT     = 130
	MinZParserLUA_CODE_BLOCK        = 131
	MinZParserMIR_BLOCK_CONTENT     = 132
	MinZParserTEMPLATE_BODY_CONTENT = 133
	MinZParserRAW_BLOCK_CONTENT     = 134
)

// MinZParser rules.
const (
	MinZParserRULE_program                     = 0
	MinZParserRULE_importDecl                  = 1
	MinZParserRULE_importPath                  = 2
	MinZParserRULE_declaration                 = 3
	MinZParserRULE_functionDecl                = 4
	MinZParserRULE_asmFunction                 = 5
	MinZParserRULE_mirFunction                 = 6
	MinZParserRULE_genericParams               = 7
	MinZParserRULE_returnType                  = 8
	MinZParserRULE_errorType                   = 9
	MinZParserRULE_functionBody                = 10
	MinZParserRULE_asmBody                     = 11
	MinZParserRULE_asmContent                  = 12
	MinZParserRULE_mirBody                     = 13
	MinZParserRULE_mirContent                  = 14
	MinZParserRULE_parameterList               = 15
	MinZParserRULE_parameter                   = 16
	MinZParserRULE_structDecl                  = 17
	MinZParserRULE_structField                 = 18
	MinZParserRULE_interfaceDecl               = 19
	MinZParserRULE_methodSignature             = 20
	MinZParserRULE_castInterfaceBlock          = 21
	MinZParserRULE_castRule                    = 22
	MinZParserRULE_enumDecl                    = 23
	MinZParserRULE_enumVariant                 = 24
	MinZParserRULE_bitStructDecl               = 25
	MinZParserRULE_bitField                    = 26
	MinZParserRULE_constDecl                   = 27
	MinZParserRULE_globalDecl                  = 28
	MinZParserRULE_typeAlias                   = 29
	MinZParserRULE_implBlock                   = 30
	MinZParserRULE_metafunction                = 31
	MinZParserRULE_attributedDeclaration       = 32
	MinZParserRULE_attribute                   = 33
	MinZParserRULE_luaBlock                    = 34
	MinZParserRULE_luaCodeBlock                = 35
	MinZParserRULE_mirBlockDeclaration         = 36
	MinZParserRULE_mirBlockContent             = 37
	MinZParserRULE_minzMetafunctionDeclaration = 38
	MinZParserRULE_compileTimeIfDeclaration    = 39
	MinZParserRULE_defineTemplate              = 40
	MinZParserRULE_templateBody                = 41
	MinZParserRULE_identifierList              = 42
	MinZParserRULE_metaExecutionBlock          = 43
	MinZParserRULE_luaExecutionBlock           = 44
	MinZParserRULE_minzExecutionBlock          = 45
	MinZParserRULE_mirExecutionBlock           = 46
	MinZParserRULE_rawBlockContent             = 47
	MinZParserRULE_type                        = 48
	MinZParserRULE_primitiveType               = 49
	MinZParserRULE_namedType                   = 50
	MinZParserRULE_arrayType                   = 51
	MinZParserRULE_arraySize                   = 52
	MinZParserRULE_pointerType                 = 53
	MinZParserRULE_functionType                = 54
	MinZParserRULE_bitStructType               = 55
	MinZParserRULE_errorableType               = 56
	MinZParserRULE_mutableType                 = 57
	MinZParserRULE_iteratorType                = 58
	MinZParserRULE_primaryType                 = 59
	MinZParserRULE_statement                   = 60
	MinZParserRULE_letStatement                = 61
	MinZParserRULE_ifStatement                 = 62
	MinZParserRULE_whileStatement              = 63
	MinZParserRULE_forStatement                = 64
	MinZParserRULE_loopStatement               = 65
	MinZParserRULE_matchStatement              = 66
	MinZParserRULE_matchArm                    = 67
	MinZParserRULE_caseStatement               = 68
	MinZParserRULE_caseArm                     = 69
	MinZParserRULE_pattern                     = 70
	MinZParserRULE_enumPattern                 = 71
	MinZParserRULE_returnStatement             = 72
	MinZParserRULE_breakStatement              = 73
	MinZParserRULE_continueStatement           = 74
	MinZParserRULE_deferStatement              = 75
	MinZParserRULE_assignmentStatement         = 76
	MinZParserRULE_assignmentTarget            = 77
	MinZParserRULE_assignmentOp                = 78
	MinZParserRULE_expressionStatement         = 79
	MinZParserRULE_block                       = 80
	MinZParserRULE_asmBlock                    = 81
	MinZParserRULE_compileTimeAsm              = 82
	MinZParserRULE_mirBlock                    = 83
	MinZParserRULE_minzBlock                   = 84
	MinZParserRULE_minzContent                 = 85
	MinZParserRULE_targetBlock                 = 86
	MinZParserRULE_expression                  = 87
	MinZParserRULE_primaryExpression           = 88
	MinZParserRULE_literal                     = 89
	MinZParserRULE_arrayLiteral                = 90
	MinZParserRULE_arrayInitializer            = 91
	MinZParserRULE_structLiteral               = 92
	MinZParserRULE_fieldInitializer            = 93
	MinZParserRULE_tupleLiteral                = 94
	MinZParserRULE_inlineAssembly              = 95
	MinZParserRULE_asmOutputList               = 96
	MinZParserRULE_asmInputList                = 97
	MinZParserRULE_asmClobberList              = 98
	MinZParserRULE_asmOutput                   = 99
	MinZParserRULE_asmInput                    = 100
	MinZParserRULE_sizeofExpression            = 101
	MinZParserRULE_alignofExpression           = 102
	MinZParserRULE_errorLiteral                = 103
	MinZParserRULE_lambdaExpression            = 104
	MinZParserRULE_lambdaParams                = 105
	MinZParserRULE_lambdaParam                 = 106
	MinZParserRULE_ifExpression                = 107
	MinZParserRULE_ternaryExpression           = 108
	MinZParserRULE_whenExpression              = 109
	MinZParserRULE_whenArm                     = 110
	MinZParserRULE_metafunctionExpr            = 111
	MinZParserRULE_argumentList                = 112
	MinZParserRULE_expressionList              = 113
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllImportDecl() []IImportDeclContext
	ImportDecl(i int) IImportDeclContext
	AllDeclaration() []IDeclarationContext
	Declaration(i int) IDeclarationContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(MinZParserEOF, 0)
}

func (s *ProgramContext) AllImportDecl() []IImportDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportDeclContext); ok {
			len++
		}
	}

	tst := make([]IImportDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportDeclContext); ok {
			tst[i] = t.(IImportDeclContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) ImportDecl(i int) IImportDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclContext)
}

func (s *ProgramContext) AllDeclaration() []IDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationContext); ok {
			tst[i] = t.(IDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) Declaration(i int) IDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, MinZParserRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(232)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&63124886704332862) != 0) || _la == MinZParserAT {
		p.SetState(230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MinZParserIMPORT:
			{
				p.SetState(228)
				p.ImportDecl()
			}

		case MinZParserT__0, MinZParserT__1, MinZParserT__2, MinZParserT__3, MinZParserT__4, MinZParserFUN, MinZParserFN, MinZParserSTRUCT, MinZParserINTERFACE, MinZParserENUM, MinZParserCONST, MinZParserGLOBAL, MinZParserTYPE, MinZParserPUB, MinZParserEXPORT, MinZParserASM, MinZParserMIR, MinZParserIMPL, MinZParserBITS, MinZParserBITS_8, MinZParserBITS_16, MinZParserAT:
			{
				p.SetState(229)
				p.Declaration()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(234)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(235)
		p.Match(MinZParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeclContext is an interface to support dynamic dispatch.
type IImportDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlias returns the alias token.
	GetAlias() antlr.Token

	// SetAlias sets the alias token.
	SetAlias(antlr.Token)

	// Getter signatures
	IMPORT() antlr.TerminalNode
	ImportPath() IImportPathContext
	SEMICOLON() antlr.TerminalNode
	AS() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsImportDeclContext differentiates from other interfaces.
	IsImportDeclContext()
}

type ImportDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	alias  antlr.Token
}

func NewEmptyImportDeclContext() *ImportDeclContext {
	var p = new(ImportDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_importDecl
	return p
}

func InitEmptyImportDeclContext(p *ImportDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_importDecl
}

func (*ImportDeclContext) IsImportDeclContext() {}

func NewImportDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclContext {
	var p = new(ImportDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_importDecl

	return p
}

func (s *ImportDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclContext) GetAlias() antlr.Token { return s.alias }

func (s *ImportDeclContext) SetAlias(v antlr.Token) { s.alias = v }

func (s *ImportDeclContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(MinZParserIMPORT, 0)
}

func (s *ImportDeclContext) ImportPath() IImportPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportPathContext)
}

func (s *ImportDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *ImportDeclContext) AS() antlr.TerminalNode {
	return s.GetToken(MinZParserAS, 0)
}

func (s *ImportDeclContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *ImportDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterImportDecl(s)
	}
}

func (s *ImportDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitImportDecl(s)
	}
}

func (s *ImportDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitImportDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ImportDecl() (localctx IImportDeclContext) {
	localctx = NewImportDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, MinZParserRULE_importDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(237)
		p.Match(MinZParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(238)
		p.ImportPath()
	}
	p.SetState(241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserAS {
		{
			p.SetState(239)
			p.Match(MinZParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(240)

			var _m = p.Match(MinZParserIDENTIFIER)

			localctx.(*ImportDeclContext).alias = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(243)
		p.Match(MinZParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportPathContext is an interface to support dynamic dispatch.
type IImportPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsImportPathContext differentiates from other interfaces.
	IsImportPathContext()
}

type ImportPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportPathContext() *ImportPathContext {
	var p = new(ImportPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_importPath
	return p
}

func InitEmptyImportPathContext(p *ImportPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_importPath
}

func (*ImportPathContext) IsImportPathContext() {}

func NewImportPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportPathContext {
	var p = new(ImportPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_importPath

	return p
}

func (s *ImportPathContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportPathContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(MinZParserIDENTIFIER)
}

func (s *ImportPathContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, i)
}

func (s *ImportPathContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(MinZParserDOT)
}

func (s *ImportPathContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserDOT, i)
}

func (s *ImportPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterImportPath(s)
	}
}

func (s *ImportPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitImportPath(s)
	}
}

func (s *ImportPathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitImportPath(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ImportPath() (localctx IImportPathContext) {
	localctx = NewImportPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, MinZParserRULE_importPath)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(245)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(250)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserDOT {
		{
			p.SetState(246)
			p.Match(MinZParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(247)
			p.Match(MinZParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(252)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionDecl() IFunctionDeclContext
	AsmFunction() IAsmFunctionContext
	MirFunction() IMirFunctionContext
	StructDecl() IStructDeclContext
	InterfaceDecl() IInterfaceDeclContext
	EnumDecl() IEnumDeclContext
	BitStructDecl() IBitStructDeclContext
	ConstDecl() IConstDeclContext
	GlobalDecl() IGlobalDeclContext
	TypeAlias() ITypeAliasContext
	ImplBlock() IImplBlockContext
	Metafunction() IMetafunctionContext
	AttributedDeclaration() IAttributedDeclarationContext
	LuaBlock() ILuaBlockContext
	MirBlockDeclaration() IMirBlockDeclarationContext
	MinzMetafunctionDeclaration() IMinzMetafunctionDeclarationContext
	CompileTimeIfDeclaration() ICompileTimeIfDeclarationContext
	DefineTemplate() IDefineTemplateContext
	MetaExecutionBlock() IMetaExecutionBlockContext

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_declaration
	return p
}

func InitEmptyDeclarationContext(p *DeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_declaration
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) FunctionDecl() IFunctionDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclContext)
}

func (s *DeclarationContext) AsmFunction() IAsmFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmFunctionContext)
}

func (s *DeclarationContext) MirFunction() IMirFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirFunctionContext)
}

func (s *DeclarationContext) StructDecl() IStructDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDeclContext)
}

func (s *DeclarationContext) InterfaceDecl() IInterfaceDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclContext)
}

func (s *DeclarationContext) EnumDecl() IEnumDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclContext)
}

func (s *DeclarationContext) BitStructDecl() IBitStructDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitStructDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitStructDeclContext)
}

func (s *DeclarationContext) ConstDecl() IConstDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstDeclContext)
}

func (s *DeclarationContext) GlobalDecl() IGlobalDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalDeclContext)
}

func (s *DeclarationContext) TypeAlias() ITypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasContext)
}

func (s *DeclarationContext) ImplBlock() IImplBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplBlockContext)
}

func (s *DeclarationContext) Metafunction() IMetafunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMetafunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMetafunctionContext)
}

func (s *DeclarationContext) AttributedDeclaration() IAttributedDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributedDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributedDeclarationContext)
}

func (s *DeclarationContext) LuaBlock() ILuaBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILuaBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILuaBlockContext)
}

func (s *DeclarationContext) MirBlockDeclaration() IMirBlockDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirBlockDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirBlockDeclarationContext)
}

func (s *DeclarationContext) MinzMetafunctionDeclaration() IMinzMetafunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMinzMetafunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMinzMetafunctionDeclarationContext)
}

func (s *DeclarationContext) CompileTimeIfDeclaration() ICompileTimeIfDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompileTimeIfDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompileTimeIfDeclarationContext)
}

func (s *DeclarationContext) DefineTemplate() IDefineTemplateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefineTemplateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefineTemplateContext)
}

func (s *DeclarationContext) MetaExecutionBlock() IMetaExecutionBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMetaExecutionBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMetaExecutionBlockContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, MinZParserRULE_declaration)
	p.SetState(272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(253)
			p.FunctionDecl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(254)
			p.AsmFunction()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(255)
			p.MirFunction()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(256)
			p.StructDecl()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(257)
			p.InterfaceDecl()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(258)
			p.EnumDecl()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(259)
			p.BitStructDecl()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(260)
			p.ConstDecl()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(261)
			p.GlobalDecl()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(262)
			p.TypeAlias()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(263)
			p.ImplBlock()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(264)
			p.Metafunction()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(265)
			p.AttributedDeclaration()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(266)
			p.LuaBlock()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(267)
			p.MirBlockDeclaration()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(268)
			p.MinzMetafunctionDeclaration()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(269)
			p.CompileTimeIfDeclaration()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(270)
			p.DefineTemplate()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(271)
			p.MetaExecutionBlock()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclContext is an interface to support dynamic dispatch.
type IFunctionDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	FunctionBody() IFunctionBodyContext
	FUN() antlr.TerminalNode
	FN() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	PUB() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	GenericParams() IGenericParamsContext
	ParameterList() IParameterListContext
	ReturnType() IReturnTypeContext

	// IsFunctionDeclContext differentiates from other interfaces.
	IsFunctionDeclContext()
}

type FunctionDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyFunctionDeclContext() *FunctionDeclContext {
	var p = new(FunctionDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_functionDecl
	return p
}

func InitEmptyFunctionDeclContext(p *FunctionDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_functionDecl
}

func (*FunctionDeclContext) IsFunctionDeclContext() {}

func NewFunctionDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclContext {
	var p = new(FunctionDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_functionDecl

	return p
}

func (s *FunctionDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclContext) GetName() antlr.Token { return s.name }

func (s *FunctionDeclContext) SetName(v antlr.Token) { s.name = v }

func (s *FunctionDeclContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *FunctionDeclContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *FunctionDeclContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDeclContext) FUN() antlr.TerminalNode {
	return s.GetToken(MinZParserFUN, 0)
}

func (s *FunctionDeclContext) FN() antlr.TerminalNode {
	return s.GetToken(MinZParserFN, 0)
}

func (s *FunctionDeclContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *FunctionDeclContext) PUB() antlr.TerminalNode {
	return s.GetToken(MinZParserPUB, 0)
}

func (s *FunctionDeclContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(MinZParserEXPORT, 0)
}

func (s *FunctionDeclContext) GenericParams() IGenericParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParamsContext)
}

func (s *FunctionDeclContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionDeclContext) ReturnType() IReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *FunctionDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterFunctionDecl(s)
	}
}

func (s *FunctionDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitFunctionDecl(s)
	}
}

func (s *FunctionDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitFunctionDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) FunctionDecl() (localctx IFunctionDeclContext) {
	localctx = NewFunctionDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, MinZParserRULE_functionDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserPUB {
		{
			p.SetState(274)
			p.Match(MinZParserPUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserEXPORT {
		{
			p.SetState(277)
			p.Match(MinZParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(280)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MinZParserFUN || _la == MinZParserFN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(281)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*FunctionDeclContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserLT {
		{
			p.SetState(282)
			p.GenericParams()
		}

	}
	{
		p.SetState(285)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserSELF || _la == MinZParserIDENTIFIER {
		{
			p.SetState(286)
			p.ParameterList()
		}

	}
	{
		p.SetState(289)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserARROW {
		{
			p.SetState(290)
			p.ReturnType()
		}

	}
	{
		p.SetState(293)
		p.FunctionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsmFunctionContext is an interface to support dynamic dispatch.
type IAsmFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	ASM() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AsmBody() IAsmBodyContext
	FUN() antlr.TerminalNode
	FN() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	PUB() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	ParameterList() IParameterListContext
	ReturnType() IReturnTypeContext

	// IsAsmFunctionContext differentiates from other interfaces.
	IsAsmFunctionContext()
}

type AsmFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyAsmFunctionContext() *AsmFunctionContext {
	var p = new(AsmFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmFunction
	return p
}

func InitEmptyAsmFunctionContext(p *AsmFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmFunction
}

func (*AsmFunctionContext) IsAsmFunctionContext() {}

func NewAsmFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmFunctionContext {
	var p = new(AsmFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_asmFunction

	return p
}

func (s *AsmFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmFunctionContext) GetName() antlr.Token { return s.name }

func (s *AsmFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *AsmFunctionContext) ASM() antlr.TerminalNode {
	return s.GetToken(MinZParserASM, 0)
}

func (s *AsmFunctionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *AsmFunctionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *AsmFunctionContext) AsmBody() IAsmBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmBodyContext)
}

func (s *AsmFunctionContext) FUN() antlr.TerminalNode {
	return s.GetToken(MinZParserFUN, 0)
}

func (s *AsmFunctionContext) FN() antlr.TerminalNode {
	return s.GetToken(MinZParserFN, 0)
}

func (s *AsmFunctionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *AsmFunctionContext) PUB() antlr.TerminalNode {
	return s.GetToken(MinZParserPUB, 0)
}

func (s *AsmFunctionContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(MinZParserEXPORT, 0)
}

func (s *AsmFunctionContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *AsmFunctionContext) ReturnType() IReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *AsmFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAsmFunction(s)
	}
}

func (s *AsmFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAsmFunction(s)
	}
}

func (s *AsmFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAsmFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) AsmFunction() (localctx IAsmFunctionContext) {
	localctx = NewAsmFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, MinZParserRULE_asmFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(296)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserPUB {
		{
			p.SetState(295)
			p.Match(MinZParserPUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserEXPORT {
		{
			p.SetState(298)
			p.Match(MinZParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(301)
		p.Match(MinZParserASM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(302)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MinZParserFUN || _la == MinZParserFN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(303)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*AsmFunctionContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(304)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(306)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserSELF || _la == MinZParserIDENTIFIER {
		{
			p.SetState(305)
			p.ParameterList()
		}

	}
	{
		p.SetState(308)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserARROW {
		{
			p.SetState(309)
			p.ReturnType()
		}

	}
	{
		p.SetState(312)
		p.AsmBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirFunctionContext is an interface to support dynamic dispatch.
type IMirFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	MIR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	MirBody() IMirBodyContext
	FUN() antlr.TerminalNode
	FN() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	PUB() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	ParameterList() IParameterListContext
	ReturnType() IReturnTypeContext

	// IsMirFunctionContext differentiates from other interfaces.
	IsMirFunctionContext()
}

type MirFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyMirFunctionContext() *MirFunctionContext {
	var p = new(MirFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirFunction
	return p
}

func InitEmptyMirFunctionContext(p *MirFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirFunction
}

func (*MirFunctionContext) IsMirFunctionContext() {}

func NewMirFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirFunctionContext {
	var p = new(MirFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirFunction

	return p
}

func (s *MirFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *MirFunctionContext) GetName() antlr.Token { return s.name }

func (s *MirFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *MirFunctionContext) MIR() antlr.TerminalNode {
	return s.GetToken(MinZParserMIR, 0)
}

func (s *MirFunctionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *MirFunctionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *MirFunctionContext) MirBody() IMirBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirBodyContext)
}

func (s *MirFunctionContext) FUN() antlr.TerminalNode {
	return s.GetToken(MinZParserFUN, 0)
}

func (s *MirFunctionContext) FN() antlr.TerminalNode {
	return s.GetToken(MinZParserFN, 0)
}

func (s *MirFunctionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *MirFunctionContext) PUB() antlr.TerminalNode {
	return s.GetToken(MinZParserPUB, 0)
}

func (s *MirFunctionContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(MinZParserEXPORT, 0)
}

func (s *MirFunctionContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *MirFunctionContext) ReturnType() IReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *MirFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirFunction(s)
	}
}

func (s *MirFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirFunction(s)
	}
}

func (s *MirFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMirFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MirFunction() (localctx IMirFunctionContext) {
	localctx = NewMirFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, MinZParserRULE_mirFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(315)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserPUB {
		{
			p.SetState(314)
			p.Match(MinZParserPUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserEXPORT {
		{
			p.SetState(317)
			p.Match(MinZParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(320)
		p.Match(MinZParserMIR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(321)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MinZParserFUN || _la == MinZParserFN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(322)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*MirFunctionContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(323)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserSELF || _la == MinZParserIDENTIFIER {
		{
			p.SetState(324)
			p.ParameterList()
		}

	}
	{
		p.SetState(327)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserARROW {
		{
			p.SetState(328)
			p.ReturnType()
		}

	}
	{
		p.SetState(331)
		p.MirBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericParamsContext is an interface to support dynamic dispatch.
type IGenericParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	GT() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGenericParamsContext differentiates from other interfaces.
	IsGenericParamsContext()
}

type GenericParamsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericParamsContext() *GenericParamsContext {
	var p = new(GenericParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_genericParams
	return p
}

func InitEmptyGenericParamsContext(p *GenericParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_genericParams
}

func (*GenericParamsContext) IsGenericParamsContext() {}

func NewGenericParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericParamsContext {
	var p = new(GenericParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_genericParams

	return p
}

func (s *GenericParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericParamsContext) LT() antlr.TerminalNode {
	return s.GetToken(MinZParserLT, 0)
}

func (s *GenericParamsContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(MinZParserIDENTIFIER)
}

func (s *GenericParamsContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, i)
}

func (s *GenericParamsContext) GT() antlr.TerminalNode {
	return s.GetToken(MinZParserGT, 0)
}

func (s *GenericParamsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MinZParserCOMMA)
}

func (s *GenericParamsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, i)
}

func (s *GenericParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterGenericParams(s)
	}
}

func (s *GenericParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitGenericParams(s)
	}
}

func (s *GenericParamsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitGenericParams(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) GenericParams() (localctx IGenericParamsContext) {
	localctx = NewGenericParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, MinZParserRULE_genericParams)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(333)
		p.Match(MinZParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(334)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserCOMMA {
		{
			p.SetState(335)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(336)
			p.Match(MinZParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(342)
		p.Match(MinZParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnTypeContext is an interface to support dynamic dispatch.
type IReturnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARROW() antlr.TerminalNode
	Type_() ITypeContext
	ErrorType() IErrorTypeContext

	// IsReturnTypeContext differentiates from other interfaces.
	IsReturnTypeContext()
}

type ReturnTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnTypeContext() *ReturnTypeContext {
	var p = new(ReturnTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_returnType
	return p
}

func InitEmptyReturnTypeContext(p *ReturnTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_returnType
}

func (*ReturnTypeContext) IsReturnTypeContext() {}

func NewReturnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnTypeContext {
	var p = new(ReturnTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_returnType

	return p
}

func (s *ReturnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnTypeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(MinZParserARROW, 0)
}

func (s *ReturnTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ReturnTypeContext) ErrorType() IErrorTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorTypeContext)
}

func (s *ReturnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterReturnType(s)
	}
}

func (s *ReturnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitReturnType(s)
	}
}

func (s *ReturnTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitReturnType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ReturnType() (localctx IReturnTypeContext) {
	localctx = NewReturnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, MinZParserRULE_returnType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(344)
		p.Match(MinZParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(345)
		p.Type_()
	}
	p.SetState(347)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(346)
			p.ErrorType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorTypeContext is an interface to support dynamic dispatch.
type IErrorTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUESTION() antlr.TerminalNode

	// IsErrorTypeContext differentiates from other interfaces.
	IsErrorTypeContext()
}

type ErrorTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorTypeContext() *ErrorTypeContext {
	var p = new(ErrorTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_errorType
	return p
}

func InitEmptyErrorTypeContext(p *ErrorTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_errorType
}

func (*ErrorTypeContext) IsErrorTypeContext() {}

func NewErrorTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorTypeContext {
	var p = new(ErrorTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_errorType

	return p
}

func (s *ErrorTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorTypeContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(MinZParserQUESTION, 0)
}

func (s *ErrorTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterErrorType(s)
	}
}

func (s *ErrorTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitErrorType(s)
	}
}

func (s *ErrorTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitErrorType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ErrorType() (localctx IErrorTypeContext) {
	localctx = NewErrorTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, MinZParserRULE_errorType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(349)
		p.Match(MinZParserQUESTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	SEMICOLON() antlr.TerminalNode

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_functionBody
	return p
}

func InitEmptyFunctionBodyContext(p *FunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_functionBody
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionBodyContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (s *FunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, MinZParserRULE_functionBody)
	p.SetState(353)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(351)
			p.Block()
		}

	case MinZParserSEMICOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(352)
			p.Match(MinZParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsmBodyContext is an interface to support dynamic dispatch.
type IAsmBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AsmContent() IAsmContentContext

	// IsAsmBodyContext differentiates from other interfaces.
	IsAsmBodyContext()
}

type AsmBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmBodyContext() *AsmBodyContext {
	var p = new(AsmBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmBody
	return p
}

func InitEmptyAsmBodyContext(p *AsmBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmBody
}

func (*AsmBodyContext) IsAsmBodyContext() {}

func NewAsmBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmBodyContext {
	var p = new(AsmBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_asmBody

	return p
}

func (s *AsmBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *AsmBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *AsmBodyContext) AsmContent() IAsmContentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmContentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmContentContext)
}

func (s *AsmBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAsmBody(s)
	}
}

func (s *AsmBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAsmBody(s)
	}
}

func (s *AsmBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAsmBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) AsmBody() (localctx IAsmBodyContext) {
	localctx = NewAsmBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, MinZParserRULE_asmBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(355)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(357)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(356)
			p.AsmContent()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(359)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsmContentContext is an interface to support dynamic dispatch.
type IAsmContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllASM_CODE_CONTENT() []antlr.TerminalNode
	ASM_CODE_CONTENT(i int) antlr.TerminalNode

	// IsAsmContentContext differentiates from other interfaces.
	IsAsmContentContext()
}

type AsmContentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmContentContext() *AsmContentContext {
	var p = new(AsmContentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmContent
	return p
}

func InitEmptyAsmContentContext(p *AsmContentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmContent
}

func (*AsmContentContext) IsAsmContentContext() {}

func NewAsmContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmContentContext {
	var p = new(AsmContentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_asmContent

	return p
}

func (s *AsmContentContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmContentContext) AllASM_CODE_CONTENT() []antlr.TerminalNode {
	return s.GetTokens(MinZParserASM_CODE_CONTENT)
}

func (s *AsmContentContext) ASM_CODE_CONTENT(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserASM_CODE_CONTENT, i)
}

func (s *AsmContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAsmContent(s)
	}
}

func (s *AsmContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAsmContent(s)
	}
}

func (s *AsmContentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAsmContent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) AsmContent() (localctx IAsmContentContext) {
	localctx = NewAsmContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, MinZParserRULE_asmContent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserASM_CODE_CONTENT {
		{
			p.SetState(361)
			p.Match(MinZParserASM_CODE_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirBodyContext is an interface to support dynamic dispatch.
type IMirBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	MirContent() IMirContentContext

	// IsMirBodyContext differentiates from other interfaces.
	IsMirBodyContext()
}

type MirBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMirBodyContext() *MirBodyContext {
	var p = new(MirBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirBody
	return p
}

func InitEmptyMirBodyContext(p *MirBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirBody
}

func (*MirBodyContext) IsMirBodyContext() {}

func NewMirBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirBodyContext {
	var p = new(MirBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirBody

	return p
}

func (s *MirBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MirBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *MirBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *MirBodyContext) MirContent() IMirContentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirContentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirContentContext)
}

func (s *MirBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirBody(s)
	}
}

func (s *MirBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirBody(s)
	}
}

func (s *MirBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMirBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MirBody() (localctx IMirBodyContext) {
	localctx = NewMirBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, MinZParserRULE_mirBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(367)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(369)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(368)
			p.MirContent()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(371)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirContentContext is an interface to support dynamic dispatch.
type IMirContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMIR_CODE_CONTENT() []antlr.TerminalNode
	MIR_CODE_CONTENT(i int) antlr.TerminalNode

	// IsMirContentContext differentiates from other interfaces.
	IsMirContentContext()
}

type MirContentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMirContentContext() *MirContentContext {
	var p = new(MirContentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirContent
	return p
}

func InitEmptyMirContentContext(p *MirContentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirContent
}

func (*MirContentContext) IsMirContentContext() {}

func NewMirContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirContentContext {
	var p = new(MirContentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirContent

	return p
}

func (s *MirContentContext) GetParser() antlr.Parser { return s.parser }

func (s *MirContentContext) AllMIR_CODE_CONTENT() []antlr.TerminalNode {
	return s.GetTokens(MinZParserMIR_CODE_CONTENT)
}

func (s *MirContentContext) MIR_CODE_CONTENT(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserMIR_CODE_CONTENT, i)
}

func (s *MirContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirContent(s)
	}
}

func (s *MirContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirContent(s)
	}
}

func (s *MirContentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMirContent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MirContent() (localctx IMirContentContext) {
	localctx = NewMirContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, MinZParserRULE_mirContent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserMIR_CODE_CONTENT {
		{
			p.SetState(373)
			p.Match(MinZParserMIR_CODE_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(378)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParameter() []IParameterContext
	Parameter(i int) IParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_parameterList
	return p
}

func InitEmptyParameterListContext(p *ParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_parameterList
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) AllParameter() []IParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterContext); ok {
			len++
		}
	}

	tst := make([]IParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterContext); ok {
			tst[i] = t.(IParameterContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) Parameter(i int) IParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *ParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MinZParserCOMMA)
}

func (s *ParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, i)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (s *ParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ParameterList() (localctx IParameterListContext) {
	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, MinZParserRULE_parameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.Parameter()
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserCOMMA {
		{
			p.SetState(380)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(381)
			p.Parameter()
		}

		p.SetState(386)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	SELF() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	IDENTIFIER() antlr.TerminalNode

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_parameter
	return p
}

func InitEmptyParameterContext(p *ParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_parameter
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) GetName() antlr.Token { return s.name }

func (s *ParameterContext) SetName(v antlr.Token) { s.name = v }

func (s *ParameterContext) SELF() antlr.TerminalNode {
	return s.GetToken(MinZParserSELF, 0)
}

func (s *ParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(MinZParserCOLON, 0)
}

func (s *ParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ParameterContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, MinZParserRULE_parameter)
	p.SetState(391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserSELF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(387)
			p.Match(MinZParserSELF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(388)

			var _m = p.Match(MinZParserIDENTIFIER)

			localctx.(*ParameterContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(389)
			p.Match(MinZParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(390)
			p.Type_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructDeclContext is an interface to support dynamic dispatch.
type IStructDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	STRUCT() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	PUB() antlr.TerminalNode
	AllStructField() []IStructFieldContext
	StructField(i int) IStructFieldContext

	// IsStructDeclContext differentiates from other interfaces.
	IsStructDeclContext()
}

type StructDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyStructDeclContext() *StructDeclContext {
	var p = new(StructDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_structDecl
	return p
}

func InitEmptyStructDeclContext(p *StructDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_structDecl
}

func (*StructDeclContext) IsStructDeclContext() {}

func NewStructDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDeclContext {
	var p = new(StructDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_structDecl

	return p
}

func (s *StructDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDeclContext) GetName() antlr.Token { return s.name }

func (s *StructDeclContext) SetName(v antlr.Token) { s.name = v }

func (s *StructDeclContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(MinZParserSTRUCT, 0)
}

func (s *StructDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *StructDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *StructDeclContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *StructDeclContext) PUB() antlr.TerminalNode {
	return s.GetToken(MinZParserPUB, 0)
}

func (s *StructDeclContext) AllStructField() []IStructFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructFieldContext); ok {
			len++
		}
	}

	tst := make([]IStructFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructFieldContext); ok {
			tst[i] = t.(IStructFieldContext)
			i++
		}
	}

	return tst
}

func (s *StructDeclContext) StructField(i int) IStructFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructFieldContext)
}

func (s *StructDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterStructDecl(s)
	}
}

func (s *StructDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitStructDecl(s)
	}
}

func (s *StructDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitStructDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) StructDecl() (localctx IStructDeclContext) {
	localctx = NewStructDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, MinZParserRULE_structDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserPUB {
		{
			p.SetState(393)
			p.Match(MinZParserPUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(396)
		p.Match(MinZParserSTRUCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(397)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*StructDeclContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(398)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserIDENTIFIER {
		{
			p.SetState(399)
			p.StructField()
		}

		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(405)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructFieldContext is an interface to support dynamic dispatch.
type IStructFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	IDENTIFIER() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsStructFieldContext differentiates from other interfaces.
	IsStructFieldContext()
}

type StructFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyStructFieldContext() *StructFieldContext {
	var p = new(StructFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_structField
	return p
}

func InitEmptyStructFieldContext(p *StructFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_structField
}

func (*StructFieldContext) IsStructFieldContext() {}

func NewStructFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructFieldContext {
	var p = new(StructFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_structField

	return p
}

func (s *StructFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *StructFieldContext) GetName() antlr.Token { return s.name }

func (s *StructFieldContext) SetName(v antlr.Token) { s.name = v }

func (s *StructFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(MinZParserCOLON, 0)
}

func (s *StructFieldContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *StructFieldContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *StructFieldContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, 0)
}

func (s *StructFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterStructField(s)
	}
}

func (s *StructFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitStructField(s)
	}
}

func (s *StructFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitStructField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) StructField() (localctx IStructFieldContext) {
	localctx = NewStructFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, MinZParserRULE_structField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(407)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*StructFieldContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(408)
		p.Match(MinZParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(409)
		p.Type_()
	}
	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserCOMMA {
		{
			p.SetState(410)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclContext is an interface to support dynamic dispatch.
type IInterfaceDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	PUB() antlr.TerminalNode
	GenericParams() IGenericParamsContext
	AllMethodSignature() []IMethodSignatureContext
	MethodSignature(i int) IMethodSignatureContext
	AllCastInterfaceBlock() []ICastInterfaceBlockContext
	CastInterfaceBlock(i int) ICastInterfaceBlockContext

	// IsInterfaceDeclContext differentiates from other interfaces.
	IsInterfaceDeclContext()
}

type InterfaceDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyInterfaceDeclContext() *InterfaceDeclContext {
	var p = new(InterfaceDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_interfaceDecl
	return p
}

func InitEmptyInterfaceDeclContext(p *InterfaceDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_interfaceDecl
}

func (*InterfaceDeclContext) IsInterfaceDeclContext() {}

func NewInterfaceDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclContext {
	var p = new(InterfaceDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_interfaceDecl

	return p
}

func (s *InterfaceDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclContext) GetName() antlr.Token { return s.name }

func (s *InterfaceDeclContext) SetName(v antlr.Token) { s.name = v }

func (s *InterfaceDeclContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(MinZParserINTERFACE, 0)
}

func (s *InterfaceDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *InterfaceDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *InterfaceDeclContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *InterfaceDeclContext) PUB() antlr.TerminalNode {
	return s.GetToken(MinZParserPUB, 0)
}

func (s *InterfaceDeclContext) GenericParams() IGenericParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParamsContext)
}

func (s *InterfaceDeclContext) AllMethodSignature() []IMethodSignatureContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodSignatureContext); ok {
			len++
		}
	}

	tst := make([]IMethodSignatureContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodSignatureContext); ok {
			tst[i] = t.(IMethodSignatureContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclContext) MethodSignature(i int) IMethodSignatureContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodSignatureContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodSignatureContext)
}

func (s *InterfaceDeclContext) AllCastInterfaceBlock() []ICastInterfaceBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICastInterfaceBlockContext); ok {
			len++
		}
	}

	tst := make([]ICastInterfaceBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICastInterfaceBlockContext); ok {
			tst[i] = t.(ICastInterfaceBlockContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclContext) CastInterfaceBlock(i int) ICastInterfaceBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastInterfaceBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastInterfaceBlockContext)
}

func (s *InterfaceDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterInterfaceDecl(s)
	}
}

func (s *InterfaceDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitInterfaceDecl(s)
	}
}

func (s *InterfaceDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitInterfaceDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) InterfaceDecl() (localctx IInterfaceDeclContext) {
	localctx = NewInterfaceDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, MinZParserRULE_interfaceDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserPUB {
		{
			p.SetState(413)
			p.Match(MinZParserPUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(416)
		p.Match(MinZParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(417)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*InterfaceDeclContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserLT {
		{
			p.SetState(418)
			p.GenericParams()
		}

	}
	{
		p.SetState(421)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&140737488453632) != 0 {
		p.SetState(424)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MinZParserFUN, MinZParserFN:
			{
				p.SetState(422)
				p.MethodSignature()
			}

		case MinZParserCAST:
			{
				p.SetState(423)
				p.CastInterfaceBlock()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(428)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(429)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodSignatureContext is an interface to support dynamic dispatch.
type IMethodSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	FUN() antlr.TerminalNode
	FN() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	ParameterList() IParameterListContext
	ReturnType() IReturnTypeContext
	SEMICOLON() antlr.TerminalNode

	// IsMethodSignatureContext differentiates from other interfaces.
	IsMethodSignatureContext()
}

type MethodSignatureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyMethodSignatureContext() *MethodSignatureContext {
	var p = new(MethodSignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_methodSignature
	return p
}

func InitEmptyMethodSignatureContext(p *MethodSignatureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_methodSignature
}

func (*MethodSignatureContext) IsMethodSignatureContext() {}

func NewMethodSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodSignatureContext {
	var p = new(MethodSignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_methodSignature

	return p
}

func (s *MethodSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodSignatureContext) GetName() antlr.Token { return s.name }

func (s *MethodSignatureContext) SetName(v antlr.Token) { s.name = v }

func (s *MethodSignatureContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *MethodSignatureContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *MethodSignatureContext) FUN() antlr.TerminalNode {
	return s.GetToken(MinZParserFUN, 0)
}

func (s *MethodSignatureContext) FN() antlr.TerminalNode {
	return s.GetToken(MinZParserFN, 0)
}

func (s *MethodSignatureContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *MethodSignatureContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *MethodSignatureContext) ReturnType() IReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *MethodSignatureContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *MethodSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMethodSignature(s)
	}
}

func (s *MethodSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMethodSignature(s)
	}
}

func (s *MethodSignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMethodSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MethodSignature() (localctx IMethodSignatureContext) {
	localctx = NewMethodSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, MinZParserRULE_methodSignature)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(431)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MinZParserFUN || _la == MinZParserFN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(432)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*MethodSignatureContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(433)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserSELF || _la == MinZParserIDENTIFIER {
		{
			p.SetState(434)
			p.ParameterList()
		}

	}
	{
		p.SetState(437)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserARROW {
		{
			p.SetState(438)
			p.ReturnType()
		}

	}
	p.SetState(442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserSEMICOLON {
		{
			p.SetState(441)
			p.Match(MinZParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastInterfaceBlockContext is an interface to support dynamic dispatch.
type ICastInterfaceBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTargetType returns the targetType token.
	GetTargetType() antlr.Token

	// SetTargetType sets the targetType token.
	SetTargetType(antlr.Token)

	// Getter signatures
	CAST() antlr.TerminalNode
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	AllCastRule() []ICastRuleContext
	CastRule(i int) ICastRuleContext

	// IsCastInterfaceBlockContext differentiates from other interfaces.
	IsCastInterfaceBlockContext()
}

type CastInterfaceBlockContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	targetType antlr.Token
}

func NewEmptyCastInterfaceBlockContext() *CastInterfaceBlockContext {
	var p = new(CastInterfaceBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_castInterfaceBlock
	return p
}

func InitEmptyCastInterfaceBlockContext(p *CastInterfaceBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_castInterfaceBlock
}

func (*CastInterfaceBlockContext) IsCastInterfaceBlockContext() {}

func NewCastInterfaceBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastInterfaceBlockContext {
	var p = new(CastInterfaceBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_castInterfaceBlock

	return p
}

func (s *CastInterfaceBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CastInterfaceBlockContext) GetTargetType() antlr.Token { return s.targetType }

func (s *CastInterfaceBlockContext) SetTargetType(v antlr.Token) { s.targetType = v }

func (s *CastInterfaceBlockContext) CAST() antlr.TerminalNode {
	return s.GetToken(MinZParserCAST, 0)
}

func (s *CastInterfaceBlockContext) LT() antlr.TerminalNode {
	return s.GetToken(MinZParserLT, 0)
}

func (s *CastInterfaceBlockContext) GT() antlr.TerminalNode {
	return s.GetToken(MinZParserGT, 0)
}

func (s *CastInterfaceBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *CastInterfaceBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *CastInterfaceBlockContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *CastInterfaceBlockContext) AllCastRule() []ICastRuleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICastRuleContext); ok {
			len++
		}
	}

	tst := make([]ICastRuleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICastRuleContext); ok {
			tst[i] = t.(ICastRuleContext)
			i++
		}
	}

	return tst
}

func (s *CastInterfaceBlockContext) CastRule(i int) ICastRuleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastRuleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastRuleContext)
}

func (s *CastInterfaceBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastInterfaceBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastInterfaceBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCastInterfaceBlock(s)
	}
}

func (s *CastInterfaceBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCastInterfaceBlock(s)
	}
}

func (s *CastInterfaceBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitCastInterfaceBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) CastInterfaceBlock() (localctx ICastInterfaceBlockContext) {
	localctx = NewCastInterfaceBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, MinZParserRULE_castInterfaceBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(444)
		p.Match(MinZParserCAST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(445)
		p.Match(MinZParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(446)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*CastInterfaceBlockContext).targetType = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(447)
		p.Match(MinZParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(448)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserIDENTIFIER {
		{
			p.SetState(449)
			p.CastRule()
		}

		p.SetState(454)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(455)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastRuleContext is an interface to support dynamic dispatch.
type ICastRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFromType returns the fromType token.
	GetFromType() antlr.Token

	// GetTransformCode returns the transformCode token.
	GetTransformCode() antlr.Token

	// SetFromType sets the fromType token.
	SetFromType(antlr.Token)

	// SetTransformCode sets the transformCode token.
	SetTransformCode(antlr.Token)

	// Getter signatures
	ARROW() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsCastRuleContext differentiates from other interfaces.
	IsCastRuleContext()
}

type CastRuleContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	fromType      antlr.Token
	transformCode antlr.Token
}

func NewEmptyCastRuleContext() *CastRuleContext {
	var p = new(CastRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_castRule
	return p
}

func InitEmptyCastRuleContext(p *CastRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_castRule
}

func (*CastRuleContext) IsCastRuleContext() {}

func NewCastRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastRuleContext {
	var p = new(CastRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_castRule

	return p
}

func (s *CastRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *CastRuleContext) GetFromType() antlr.Token { return s.fromType }

func (s *CastRuleContext) GetTransformCode() antlr.Token { return s.transformCode }

func (s *CastRuleContext) SetFromType(v antlr.Token) { s.fromType = v }

func (s *CastRuleContext) SetTransformCode(v antlr.Token) { s.transformCode = v }

func (s *CastRuleContext) ARROW() antlr.TerminalNode {
	return s.GetToken(MinZParserARROW, 0)
}

func (s *CastRuleContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *CastRuleContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *CastRuleContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *CastRuleContext) STRING() antlr.TerminalNode {
	return s.GetToken(MinZParserSTRING, 0)
}

func (s *CastRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCastRule(s)
	}
}

func (s *CastRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCastRule(s)
	}
}

func (s *CastRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitCastRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) CastRule() (localctx ICastRuleContext) {
	localctx = NewCastRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, MinZParserRULE_castRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*CastRuleContext).fromType = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(458)
		p.Match(MinZParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(459)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserSTRING {
		{
			p.SetState(460)

			var _m = p.Match(MinZParserSTRING)

			localctx.(*CastRuleContext).transformCode = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(463)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumDeclContext is an interface to support dynamic dispatch.
type IEnumDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	ENUM() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	AllEnumVariant() []IEnumVariantContext
	EnumVariant(i int) IEnumVariantContext
	RBRACE() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	PUB() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsEnumDeclContext differentiates from other interfaces.
	IsEnumDeclContext()
}

type EnumDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyEnumDeclContext() *EnumDeclContext {
	var p = new(EnumDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_enumDecl
	return p
}

func InitEmptyEnumDeclContext(p *EnumDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_enumDecl
}

func (*EnumDeclContext) IsEnumDeclContext() {}

func NewEnumDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclContext {
	var p = new(EnumDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_enumDecl

	return p
}

func (s *EnumDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclContext) GetName() antlr.Token { return s.name }

func (s *EnumDeclContext) SetName(v antlr.Token) { s.name = v }

func (s *EnumDeclContext) ENUM() antlr.TerminalNode {
	return s.GetToken(MinZParserENUM, 0)
}

func (s *EnumDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *EnumDeclContext) AllEnumVariant() []IEnumVariantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumVariantContext); ok {
			len++
		}
	}

	tst := make([]IEnumVariantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumVariantContext); ok {
			tst[i] = t.(IEnumVariantContext)
			i++
		}
	}

	return tst
}

func (s *EnumDeclContext) EnumVariant(i int) IEnumVariantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumVariantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumVariantContext)
}

func (s *EnumDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *EnumDeclContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *EnumDeclContext) PUB() antlr.TerminalNode {
	return s.GetToken(MinZParserPUB, 0)
}

func (s *EnumDeclContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MinZParserCOMMA)
}

func (s *EnumDeclContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, i)
}

func (s *EnumDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterEnumDecl(s)
	}
}

func (s *EnumDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitEnumDecl(s)
	}
}

func (s *EnumDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitEnumDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) EnumDecl() (localctx IEnumDeclContext) {
	localctx = NewEnumDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, MinZParserRULE_enumDecl)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserPUB {
		{
			p.SetState(465)
			p.Match(MinZParserPUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(468)
		p.Match(MinZParserENUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(469)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*EnumDeclContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(470)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(471)
		p.EnumVariant()
	}
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(472)
				p.Match(MinZParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(473)
				p.EnumVariant()
			}

		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(480)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserCOMMA {
		{
			p.SetState(479)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(482)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumVariantContext is an interface to support dynamic dispatch.
type IEnumVariantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	INTEGER() antlr.TerminalNode

	// IsEnumVariantContext differentiates from other interfaces.
	IsEnumVariantContext()
}

type EnumVariantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumVariantContext() *EnumVariantContext {
	var p = new(EnumVariantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_enumVariant
	return p
}

func InitEmptyEnumVariantContext(p *EnumVariantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_enumVariant
}

func (*EnumVariantContext) IsEnumVariantContext() {}

func NewEnumVariantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumVariantContext {
	var p = new(EnumVariantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_enumVariant

	return p
}

func (s *EnumVariantContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumVariantContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *EnumVariantContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserASSIGN, 0)
}

func (s *EnumVariantContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MinZParserINTEGER, 0)
}

func (s *EnumVariantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumVariantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumVariantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterEnumVariant(s)
	}
}

func (s *EnumVariantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitEnumVariant(s)
	}
}

func (s *EnumVariantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitEnumVariant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) EnumVariant() (localctx IEnumVariantContext) {
	localctx = NewEnumVariantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, MinZParserRULE_enumVariant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(484)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserASSIGN {
		{
			p.SetState(485)
			p.Match(MinZParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(486)
			p.Match(MinZParserINTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitStructDeclContext is an interface to support dynamic dispatch.
type IBitStructDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	BITS() antlr.TerminalNode
	BITS_8() antlr.TerminalNode
	BITS_16() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	PUB() antlr.TerminalNode
	AllBitField() []IBitFieldContext
	BitField(i int) IBitFieldContext

	// IsBitStructDeclContext differentiates from other interfaces.
	IsBitStructDeclContext()
}

type BitStructDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyBitStructDeclContext() *BitStructDeclContext {
	var p = new(BitStructDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_bitStructDecl
	return p
}

func InitEmptyBitStructDeclContext(p *BitStructDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_bitStructDecl
}

func (*BitStructDeclContext) IsBitStructDeclContext() {}

func NewBitStructDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitStructDeclContext {
	var p = new(BitStructDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_bitStructDecl

	return p
}

func (s *BitStructDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *BitStructDeclContext) GetName() antlr.Token { return s.name }

func (s *BitStructDeclContext) SetName(v antlr.Token) { s.name = v }

func (s *BitStructDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *BitStructDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *BitStructDeclContext) BITS() antlr.TerminalNode {
	return s.GetToken(MinZParserBITS, 0)
}

func (s *BitStructDeclContext) BITS_8() antlr.TerminalNode {
	return s.GetToken(MinZParserBITS_8, 0)
}

func (s *BitStructDeclContext) BITS_16() antlr.TerminalNode {
	return s.GetToken(MinZParserBITS_16, 0)
}

func (s *BitStructDeclContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *BitStructDeclContext) PUB() antlr.TerminalNode {
	return s.GetToken(MinZParserPUB, 0)
}

func (s *BitStructDeclContext) AllBitField() []IBitFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBitFieldContext); ok {
			len++
		}
	}

	tst := make([]IBitFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBitFieldContext); ok {
			tst[i] = t.(IBitFieldContext)
			i++
		}
	}

	return tst
}

func (s *BitStructDeclContext) BitField(i int) IBitFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitFieldContext)
}

func (s *BitStructDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitStructDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitStructDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBitStructDecl(s)
	}
}

func (s *BitStructDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBitStructDecl(s)
	}
}

func (s *BitStructDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitBitStructDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) BitStructDecl() (localctx IBitStructDeclContext) {
	localctx = NewBitStructDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, MinZParserRULE_bitStructDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserPUB {
		{
			p.SetState(489)
			p.Match(MinZParserPUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(492)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&63050394783186944) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(493)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*BitStructDeclContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(494)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserIDENTIFIER {
		{
			p.SetState(495)
			p.BitField()
		}

		p.SetState(500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(501)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitFieldContext is an interface to support dynamic dispatch.
type IBitFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// GetBitWidth returns the bitWidth token.
	GetBitWidth() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// SetBitWidth sets the bitWidth token.
	SetBitWidth(antlr.Token)

	// Getter signatures
	COLON() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsBitFieldContext differentiates from other interfaces.
	IsBitFieldContext()
}

type BitFieldContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	name     antlr.Token
	bitWidth antlr.Token
}

func NewEmptyBitFieldContext() *BitFieldContext {
	var p = new(BitFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_bitField
	return p
}

func InitEmptyBitFieldContext(p *BitFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_bitField
}

func (*BitFieldContext) IsBitFieldContext() {}

func NewBitFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitFieldContext {
	var p = new(BitFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_bitField

	return p
}

func (s *BitFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *BitFieldContext) GetName() antlr.Token { return s.name }

func (s *BitFieldContext) GetBitWidth() antlr.Token { return s.bitWidth }

func (s *BitFieldContext) SetName(v antlr.Token) { s.name = v }

func (s *BitFieldContext) SetBitWidth(v antlr.Token) { s.bitWidth = v }

func (s *BitFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(MinZParserCOLON, 0)
}

func (s *BitFieldContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *BitFieldContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MinZParserINTEGER, 0)
}

func (s *BitFieldContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, 0)
}

func (s *BitFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBitField(s)
	}
}

func (s *BitFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBitField(s)
	}
}

func (s *BitFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitBitField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) BitField() (localctx IBitFieldContext) {
	localctx = NewBitFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, MinZParserRULE_bitField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(503)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*BitFieldContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(504)
		p.Match(MinZParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(505)

		var _m = p.Match(MinZParserINTEGER)

		localctx.(*BitFieldContext).bitWidth = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserCOMMA {
		{
			p.SetState(506)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstDeclContext is an interface to support dynamic dispatch.
type IConstDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	CONST() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	SEMICOLON() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	PUB() antlr.TerminalNode

	// IsConstDeclContext differentiates from other interfaces.
	IsConstDeclContext()
}

type ConstDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyConstDeclContext() *ConstDeclContext {
	var p = new(ConstDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_constDecl
	return p
}

func InitEmptyConstDeclContext(p *ConstDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_constDecl
}

func (*ConstDeclContext) IsConstDeclContext() {}

func NewConstDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstDeclContext {
	var p = new(ConstDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_constDecl

	return p
}

func (s *ConstDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstDeclContext) GetName() antlr.Token { return s.name }

func (s *ConstDeclContext) SetName(v antlr.Token) { s.name = v }

func (s *ConstDeclContext) CONST() antlr.TerminalNode {
	return s.GetToken(MinZParserCONST, 0)
}

func (s *ConstDeclContext) COLON() antlr.TerminalNode {
	return s.GetToken(MinZParserCOLON, 0)
}

func (s *ConstDeclContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ConstDeclContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserASSIGN, 0)
}

func (s *ConstDeclContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConstDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *ConstDeclContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *ConstDeclContext) PUB() antlr.TerminalNode {
	return s.GetToken(MinZParserPUB, 0)
}

func (s *ConstDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterConstDecl(s)
	}
}

func (s *ConstDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitConstDecl(s)
	}
}

func (s *ConstDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitConstDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ConstDecl() (localctx IConstDeclContext) {
	localctx = NewConstDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, MinZParserRULE_constDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserPUB {
		{
			p.SetState(509)
			p.Match(MinZParserPUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(512)
		p.Match(MinZParserCONST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(513)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*ConstDeclContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(514)
		p.Match(MinZParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(515)
		p.Type_()
	}
	{
		p.SetState(516)
		p.Match(MinZParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(517)
		p.expression(0)
	}
	{
		p.SetState(518)
		p.Match(MinZParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGlobalDeclContext is an interface to support dynamic dispatch.
type IGlobalDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	GLOBAL() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	SEMICOLON() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	PUB() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsGlobalDeclContext differentiates from other interfaces.
	IsGlobalDeclContext()
}

type GlobalDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyGlobalDeclContext() *GlobalDeclContext {
	var p = new(GlobalDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_globalDecl
	return p
}

func InitEmptyGlobalDeclContext(p *GlobalDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_globalDecl
}

func (*GlobalDeclContext) IsGlobalDeclContext() {}

func NewGlobalDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalDeclContext {
	var p = new(GlobalDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_globalDecl

	return p
}

func (s *GlobalDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalDeclContext) GetName() antlr.Token { return s.name }

func (s *GlobalDeclContext) SetName(v antlr.Token) { s.name = v }

func (s *GlobalDeclContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MinZParserGLOBAL, 0)
}

func (s *GlobalDeclContext) COLON() antlr.TerminalNode {
	return s.GetToken(MinZParserCOLON, 0)
}

func (s *GlobalDeclContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *GlobalDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *GlobalDeclContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *GlobalDeclContext) PUB() antlr.TerminalNode {
	return s.GetToken(MinZParserPUB, 0)
}

func (s *GlobalDeclContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserASSIGN, 0)
}

func (s *GlobalDeclContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GlobalDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterGlobalDecl(s)
	}
}

func (s *GlobalDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitGlobalDecl(s)
	}
}

func (s *GlobalDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitGlobalDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) GlobalDecl() (localctx IGlobalDeclContext) {
	localctx = NewGlobalDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, MinZParserRULE_globalDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserPUB {
		{
			p.SetState(520)
			p.Match(MinZParserPUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(523)
		p.Match(MinZParserGLOBAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(524)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*GlobalDeclContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(525)
		p.Match(MinZParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(526)
		p.Type_()
	}
	p.SetState(529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserASSIGN {
		{
			p.SetState(527)
			p.Match(MinZParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(528)
			p.expression(0)
		}

	}
	{
		p.SetState(531)
		p.Match(MinZParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAliasContext is an interface to support dynamic dispatch.
type ITypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	TYPE() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Type_() ITypeContext
	SEMICOLON() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	PUB() antlr.TerminalNode

	// IsTypeAliasContext differentiates from other interfaces.
	IsTypeAliasContext()
}

type TypeAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyTypeAliasContext() *TypeAliasContext {
	var p = new(TypeAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_typeAlias
	return p
}

func InitEmptyTypeAliasContext(p *TypeAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_typeAlias
}

func (*TypeAliasContext) IsTypeAliasContext() {}

func NewTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasContext {
	var p = new(TypeAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_typeAlias

	return p
}

func (s *TypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasContext) GetName() antlr.Token { return s.name }

func (s *TypeAliasContext) SetName(v antlr.Token) { s.name = v }

func (s *TypeAliasContext) TYPE() antlr.TerminalNode {
	return s.GetToken(MinZParserTYPE, 0)
}

func (s *TypeAliasContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserASSIGN, 0)
}

func (s *TypeAliasContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeAliasContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *TypeAliasContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *TypeAliasContext) PUB() antlr.TerminalNode {
	return s.GetToken(MinZParserPUB, 0)
}

func (s *TypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterTypeAlias(s)
	}
}

func (s *TypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitTypeAlias(s)
	}
}

func (s *TypeAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitTypeAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) TypeAlias() (localctx ITypeAliasContext) {
	localctx = NewTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, MinZParserRULE_typeAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserPUB {
		{
			p.SetState(533)
			p.Match(MinZParserPUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(536)
		p.Match(MinZParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(537)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*TypeAliasContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(538)
		p.Match(MinZParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(539)
		p.Type_()
	}
	{
		p.SetState(540)
		p.Match(MinZParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplBlockContext is an interface to support dynamic dispatch.
type IImplBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInterfaceName returns the interfaceName token.
	GetInterfaceName() antlr.Token

	// SetInterfaceName sets the interfaceName token.
	SetInterfaceName(antlr.Token)

	// GetForType returns the forType rule contexts.
	GetForType() ITypeContext

	// SetForType sets the forType rule contexts.
	SetForType(ITypeContext)

	// Getter signatures
	IMPL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	Type_() ITypeContext
	AllFunctionDecl() []IFunctionDeclContext
	FunctionDecl(i int) IFunctionDeclContext

	// IsImplBlockContext differentiates from other interfaces.
	IsImplBlockContext()
}

type ImplBlockContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	interfaceName antlr.Token
	forType       ITypeContext
}

func NewEmptyImplBlockContext() *ImplBlockContext {
	var p = new(ImplBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_implBlock
	return p
}

func InitEmptyImplBlockContext(p *ImplBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_implBlock
}

func (*ImplBlockContext) IsImplBlockContext() {}

func NewImplBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplBlockContext {
	var p = new(ImplBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_implBlock

	return p
}

func (s *ImplBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplBlockContext) GetInterfaceName() antlr.Token { return s.interfaceName }

func (s *ImplBlockContext) SetInterfaceName(v antlr.Token) { s.interfaceName = v }

func (s *ImplBlockContext) GetForType() ITypeContext { return s.forType }

func (s *ImplBlockContext) SetForType(v ITypeContext) { s.forType = v }

func (s *ImplBlockContext) IMPL() antlr.TerminalNode {
	return s.GetToken(MinZParserIMPL, 0)
}

func (s *ImplBlockContext) FOR() antlr.TerminalNode {
	return s.GetToken(MinZParserFOR, 0)
}

func (s *ImplBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *ImplBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *ImplBlockContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *ImplBlockContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ImplBlockContext) AllFunctionDecl() []IFunctionDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDeclContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDeclContext); ok {
			tst[i] = t.(IFunctionDeclContext)
			i++
		}
	}

	return tst
}

func (s *ImplBlockContext) FunctionDecl(i int) IFunctionDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclContext)
}

func (s *ImplBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterImplBlock(s)
	}
}

func (s *ImplBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitImplBlock(s)
	}
}

func (s *ImplBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitImplBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ImplBlock() (localctx IImplBlockContext) {
	localctx = NewImplBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, MinZParserRULE_implBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)
		p.Match(MinZParserIMPL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(543)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*ImplBlockContext).interfaceName = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(544)
		p.Match(MinZParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(545)

		var _x = p.Type_()

		localctx.(*ImplBlockContext).forType = _x
	}
	{
		p.SetState(546)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&824633819136) != 0 {
		{
			p.SetState(547)
			p.FunctionDecl()
		}

		p.SetState(552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(553)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMetafunctionContext is an interface to support dynamic dispatch.
type IMetafunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	AT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	SEMICOLON() antlr.TerminalNode

	// IsMetafunctionContext differentiates from other interfaces.
	IsMetafunctionContext()
}

type MetafunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyMetafunctionContext() *MetafunctionContext {
	var p = new(MetafunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_metafunction
	return p
}

func InitEmptyMetafunctionContext(p *MetafunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_metafunction
}

func (*MetafunctionContext) IsMetafunctionContext() {}

func NewMetafunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetafunctionContext {
	var p = new(MetafunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_metafunction

	return p
}

func (s *MetafunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *MetafunctionContext) GetName() antlr.Token { return s.name }

func (s *MetafunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *MetafunctionContext) AT() antlr.TerminalNode {
	return s.GetToken(MinZParserAT, 0)
}

func (s *MetafunctionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *MetafunctionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *MetafunctionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *MetafunctionContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *MetafunctionContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *MetafunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetafunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetafunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMetafunction(s)
	}
}

func (s *MetafunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMetafunction(s)
	}
}

func (s *MetafunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMetafunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) Metafunction() (localctx IMetafunctionContext) {
	localctx = NewMetafunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, MinZParserRULE_metafunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(555)
		p.Match(MinZParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(556)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*MetafunctionContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(557)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2037403669757952) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&303535578054393983) != 0) {
		{
			p.SetState(558)
			p.ExpressionList()
		}

	}
	{
		p.SetState(561)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserSEMICOLON {
		{
			p.SetState(562)
			p.Match(MinZParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributedDeclarationContext is an interface to support dynamic dispatch.
type IAttributedDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Attribute() IAttributeContext
	Declaration() IDeclarationContext

	// IsAttributedDeclarationContext differentiates from other interfaces.
	IsAttributedDeclarationContext()
}

type AttributedDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributedDeclarationContext() *AttributedDeclarationContext {
	var p = new(AttributedDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_attributedDeclaration
	return p
}

func InitEmptyAttributedDeclarationContext(p *AttributedDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_attributedDeclaration
}

func (*AttributedDeclarationContext) IsAttributedDeclarationContext() {}

func NewAttributedDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributedDeclarationContext {
	var p = new(AttributedDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_attributedDeclaration

	return p
}

func (s *AttributedDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributedDeclarationContext) Attribute() IAttributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *AttributedDeclarationContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *AttributedDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributedDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributedDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAttributedDeclaration(s)
	}
}

func (s *AttributedDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAttributedDeclaration(s)
	}
}

func (s *AttributedDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAttributedDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) AttributedDeclaration() (localctx IAttributedDeclarationContext) {
	localctx = NewAttributedDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, MinZParserRULE_attributedDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(565)
		p.Attribute()
	}
	{
		p.SetState(566)
		p.Declaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeContext is an interface to support dynamic dispatch.
type IAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	AT() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsAttributeContext differentiates from other interfaces.
	IsAttributeContext()
}

type AttributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyAttributeContext() *AttributeContext {
	var p = new(AttributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_attribute
	return p
}

func InitEmptyAttributeContext(p *AttributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_attribute
}

func (*AttributeContext) IsAttributeContext() {}

func NewAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeContext {
	var p = new(AttributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_attribute

	return p
}

func (s *AttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeContext) GetName() antlr.Token { return s.name }

func (s *AttributeContext) SetName(v antlr.Token) { s.name = v }

func (s *AttributeContext) AT() antlr.TerminalNode {
	return s.GetToken(MinZParserAT, 0)
}

func (s *AttributeContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *AttributeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *AttributeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *AttributeContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *AttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAttribute(s)
	}
}

func (s *AttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAttribute(s)
	}
}

func (s *AttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) Attribute() (localctx IAttributeContext) {
	localctx = NewAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, MinZParserRULE_attribute)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(568)
		p.Match(MinZParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(569)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*AttributeContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserLPAREN {
		{
			p.SetState(570)
			p.Match(MinZParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(572)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2037403669757952) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&303535578054393983) != 0) {
			{
				p.SetState(571)
				p.ExpressionList()
			}

		}
		{
			p.SetState(574)
			p.Match(MinZParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILuaBlockContext is an interface to support dynamic dispatch.
type ILuaBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIPLE_BRACKET_OPEN() antlr.TerminalNode
	LuaCodeBlock() ILuaCodeBlockContext
	TRIPLE_BRACKET_CLOSE() antlr.TerminalNode

	// IsLuaBlockContext differentiates from other interfaces.
	IsLuaBlockContext()
}

type LuaBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLuaBlockContext() *LuaBlockContext {
	var p = new(LuaBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_luaBlock
	return p
}

func InitEmptyLuaBlockContext(p *LuaBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_luaBlock
}

func (*LuaBlockContext) IsLuaBlockContext() {}

func NewLuaBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LuaBlockContext {
	var p = new(LuaBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_luaBlock

	return p
}

func (s *LuaBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *LuaBlockContext) TRIPLE_BRACKET_OPEN() antlr.TerminalNode {
	return s.GetToken(MinZParserTRIPLE_BRACKET_OPEN, 0)
}

func (s *LuaBlockContext) LuaCodeBlock() ILuaCodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILuaCodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILuaCodeBlockContext)
}

func (s *LuaBlockContext) TRIPLE_BRACKET_CLOSE() antlr.TerminalNode {
	return s.GetToken(MinZParserTRIPLE_BRACKET_CLOSE, 0)
}

func (s *LuaBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LuaBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LuaBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLuaBlock(s)
	}
}

func (s *LuaBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLuaBlock(s)
	}
}

func (s *LuaBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitLuaBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) LuaBlock() (localctx ILuaBlockContext) {
	localctx = NewLuaBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, MinZParserRULE_luaBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(577)
		p.Match(MinZParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(578)
		p.Match(MinZParserTRIPLE_BRACKET_OPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(579)
		p.LuaCodeBlock()
	}
	{
		p.SetState(580)
		p.Match(MinZParserTRIPLE_BRACKET_CLOSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILuaCodeBlockContext is an interface to support dynamic dispatch.
type ILuaCodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLUA_CODE_BLOCK() []antlr.TerminalNode
	LUA_CODE_BLOCK(i int) antlr.TerminalNode

	// IsLuaCodeBlockContext differentiates from other interfaces.
	IsLuaCodeBlockContext()
}

type LuaCodeBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLuaCodeBlockContext() *LuaCodeBlockContext {
	var p = new(LuaCodeBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_luaCodeBlock
	return p
}

func InitEmptyLuaCodeBlockContext(p *LuaCodeBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_luaCodeBlock
}

func (*LuaCodeBlockContext) IsLuaCodeBlockContext() {}

func NewLuaCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LuaCodeBlockContext {
	var p = new(LuaCodeBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_luaCodeBlock

	return p
}

func (s *LuaCodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *LuaCodeBlockContext) AllLUA_CODE_BLOCK() []antlr.TerminalNode {
	return s.GetTokens(MinZParserLUA_CODE_BLOCK)
}

func (s *LuaCodeBlockContext) LUA_CODE_BLOCK(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserLUA_CODE_BLOCK, i)
}

func (s *LuaCodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LuaCodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LuaCodeBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLuaCodeBlock(s)
	}
}

func (s *LuaCodeBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLuaCodeBlock(s)
	}
}

func (s *LuaCodeBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitLuaCodeBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) LuaCodeBlock() (localctx ILuaCodeBlockContext) {
	localctx = NewLuaCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, MinZParserRULE_luaCodeBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserLUA_CODE_BLOCK {
		{
			p.SetState(582)
			p.Match(MinZParserLUA_CODE_BLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(587)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirBlockDeclarationContext is an interface to support dynamic dispatch.
type IMirBlockDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIPLE_BRACKET_OPEN() antlr.TerminalNode
	MirBlockContent() IMirBlockContentContext
	TRIPLE_BRACKET_CLOSE() antlr.TerminalNode

	// IsMirBlockDeclarationContext differentiates from other interfaces.
	IsMirBlockDeclarationContext()
}

type MirBlockDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMirBlockDeclarationContext() *MirBlockDeclarationContext {
	var p = new(MirBlockDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirBlockDeclaration
	return p
}

func InitEmptyMirBlockDeclarationContext(p *MirBlockDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirBlockDeclaration
}

func (*MirBlockDeclarationContext) IsMirBlockDeclarationContext() {}

func NewMirBlockDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirBlockDeclarationContext {
	var p = new(MirBlockDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirBlockDeclaration

	return p
}

func (s *MirBlockDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MirBlockDeclarationContext) TRIPLE_BRACKET_OPEN() antlr.TerminalNode {
	return s.GetToken(MinZParserTRIPLE_BRACKET_OPEN, 0)
}

func (s *MirBlockDeclarationContext) MirBlockContent() IMirBlockContentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirBlockContentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirBlockContentContext)
}

func (s *MirBlockDeclarationContext) TRIPLE_BRACKET_CLOSE() antlr.TerminalNode {
	return s.GetToken(MinZParserTRIPLE_BRACKET_CLOSE, 0)
}

func (s *MirBlockDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirBlockDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirBlockDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirBlockDeclaration(s)
	}
}

func (s *MirBlockDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirBlockDeclaration(s)
	}
}

func (s *MirBlockDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMirBlockDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MirBlockDeclaration() (localctx IMirBlockDeclarationContext) {
	localctx = NewMirBlockDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, MinZParserRULE_mirBlockDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(588)
		p.Match(MinZParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(589)
		p.Match(MinZParserTRIPLE_BRACKET_OPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(590)
		p.MirBlockContent()
	}
	{
		p.SetState(591)
		p.Match(MinZParserTRIPLE_BRACKET_CLOSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirBlockContentContext is an interface to support dynamic dispatch.
type IMirBlockContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMIR_BLOCK_CONTENT() []antlr.TerminalNode
	MIR_BLOCK_CONTENT(i int) antlr.TerminalNode

	// IsMirBlockContentContext differentiates from other interfaces.
	IsMirBlockContentContext()
}

type MirBlockContentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMirBlockContentContext() *MirBlockContentContext {
	var p = new(MirBlockContentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirBlockContent
	return p
}

func InitEmptyMirBlockContentContext(p *MirBlockContentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirBlockContent
}

func (*MirBlockContentContext) IsMirBlockContentContext() {}

func NewMirBlockContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirBlockContentContext {
	var p = new(MirBlockContentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirBlockContent

	return p
}

func (s *MirBlockContentContext) GetParser() antlr.Parser { return s.parser }

func (s *MirBlockContentContext) AllMIR_BLOCK_CONTENT() []antlr.TerminalNode {
	return s.GetTokens(MinZParserMIR_BLOCK_CONTENT)
}

func (s *MirBlockContentContext) MIR_BLOCK_CONTENT(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserMIR_BLOCK_CONTENT, i)
}

func (s *MirBlockContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirBlockContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirBlockContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirBlockContent(s)
	}
}

func (s *MirBlockContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirBlockContent(s)
	}
}

func (s *MirBlockContentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMirBlockContent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MirBlockContent() (localctx IMirBlockContentContext) {
	localctx = NewMirBlockContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, MinZParserRULE_mirBlockContent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserMIR_BLOCK_CONTENT {
		{
			p.SetState(593)
			p.Match(MinZParserMIR_BLOCK_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(598)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMinzMetafunctionDeclarationContext is an interface to support dynamic dispatch.
type IMinzMetafunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTemplateString returns the templateString token.
	GetTemplateString() antlr.Token

	// SetTemplateString sets the templateString token.
	SetTemplateString(antlr.Token)

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	STRING() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsMinzMetafunctionDeclarationContext differentiates from other interfaces.
	IsMinzMetafunctionDeclarationContext()
}

type MinzMetafunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	templateString antlr.Token
}

func NewEmptyMinzMetafunctionDeclarationContext() *MinzMetafunctionDeclarationContext {
	var p = new(MinzMetafunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_minzMetafunctionDeclaration
	return p
}

func InitEmptyMinzMetafunctionDeclarationContext(p *MinzMetafunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_minzMetafunctionDeclaration
}

func (*MinzMetafunctionDeclarationContext) IsMinzMetafunctionDeclarationContext() {}

func NewMinzMetafunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinzMetafunctionDeclarationContext {
	var p = new(MinzMetafunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_minzMetafunctionDeclaration

	return p
}

func (s *MinzMetafunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MinzMetafunctionDeclarationContext) GetTemplateString() antlr.Token { return s.templateString }

func (s *MinzMetafunctionDeclarationContext) SetTemplateString(v antlr.Token) { s.templateString = v }

func (s *MinzMetafunctionDeclarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *MinzMetafunctionDeclarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *MinzMetafunctionDeclarationContext) STRING() antlr.TerminalNode {
	return s.GetToken(MinZParserSTRING, 0)
}

func (s *MinzMetafunctionDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MinZParserCOMMA)
}

func (s *MinzMetafunctionDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, i)
}

func (s *MinzMetafunctionDeclarationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MinzMetafunctionDeclarationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MinzMetafunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinzMetafunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinzMetafunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMinzMetafunctionDeclaration(s)
	}
}

func (s *MinzMetafunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMinzMetafunctionDeclaration(s)
	}
}

func (s *MinzMetafunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMinzMetafunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MinzMetafunctionDeclaration() (localctx IMinzMetafunctionDeclarationContext) {
	localctx = NewMinzMetafunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, MinZParserRULE_minzMetafunctionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(599)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(600)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(601)

		var _m = p.Match(MinZParserSTRING)

		localctx.(*MinzMetafunctionDeclarationContext).templateString = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserCOMMA {
		{
			p.SetState(602)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(603)
			p.expression(0)
		}

		p.SetState(608)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(609)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompileTimeIfDeclarationContext is an interface to support dynamic dispatch.
type ICompileTimeIfDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetThenCode returns the thenCode token.
	GetThenCode() antlr.Token

	// GetElseCode returns the elseCode token.
	GetElseCode() antlr.Token

	// SetThenCode sets the thenCode token.
	SetThenCode(antlr.Token)

	// SetElseCode sets the elseCode token.
	SetElseCode(antlr.Token)

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode

	// IsCompileTimeIfDeclarationContext differentiates from other interfaces.
	IsCompileTimeIfDeclarationContext()
}

type CompileTimeIfDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	thenCode  antlr.Token
	elseCode  antlr.Token
}

func NewEmptyCompileTimeIfDeclarationContext() *CompileTimeIfDeclarationContext {
	var p = new(CompileTimeIfDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_compileTimeIfDeclaration
	return p
}

func InitEmptyCompileTimeIfDeclarationContext(p *CompileTimeIfDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_compileTimeIfDeclaration
}

func (*CompileTimeIfDeclarationContext) IsCompileTimeIfDeclarationContext() {}

func NewCompileTimeIfDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompileTimeIfDeclarationContext {
	var p = new(CompileTimeIfDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_compileTimeIfDeclaration

	return p
}

func (s *CompileTimeIfDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *CompileTimeIfDeclarationContext) GetThenCode() antlr.Token { return s.thenCode }

func (s *CompileTimeIfDeclarationContext) GetElseCode() antlr.Token { return s.elseCode }

func (s *CompileTimeIfDeclarationContext) SetThenCode(v antlr.Token) { s.thenCode = v }

func (s *CompileTimeIfDeclarationContext) SetElseCode(v antlr.Token) { s.elseCode = v }

func (s *CompileTimeIfDeclarationContext) GetCondition() IExpressionContext { return s.condition }

func (s *CompileTimeIfDeclarationContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *CompileTimeIfDeclarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *CompileTimeIfDeclarationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MinZParserCOMMA)
}

func (s *CompileTimeIfDeclarationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, i)
}

func (s *CompileTimeIfDeclarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *CompileTimeIfDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CompileTimeIfDeclarationContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(MinZParserSTRING)
}

func (s *CompileTimeIfDeclarationContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserSTRING, i)
}

func (s *CompileTimeIfDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompileTimeIfDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompileTimeIfDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCompileTimeIfDeclaration(s)
	}
}

func (s *CompileTimeIfDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCompileTimeIfDeclaration(s)
	}
}

func (s *CompileTimeIfDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitCompileTimeIfDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) CompileTimeIfDeclaration() (localctx ICompileTimeIfDeclarationContext) {
	localctx = NewCompileTimeIfDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, MinZParserRULE_compileTimeIfDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(611)
		p.Match(MinZParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(612)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(613)

		var _x = p.expression(0)

		localctx.(*CompileTimeIfDeclarationContext).condition = _x
	}
	{
		p.SetState(614)
		p.Match(MinZParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(615)

		var _m = p.Match(MinZParserSTRING)

		localctx.(*CompileTimeIfDeclarationContext).thenCode = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserCOMMA {
		{
			p.SetState(616)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(617)

			var _m = p.Match(MinZParserSTRING)

			localctx.(*CompileTimeIfDeclarationContext).elseCode = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(620)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefineTemplateContext is an interface to support dynamic dispatch.
type IDefineTemplateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	RPAREN() antlr.TerminalNode
	TRIPLE_BRACKET_OPEN() antlr.TerminalNode
	TemplateBody() ITemplateBodyContext
	TRIPLE_BRACKET_CLOSE() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsDefineTemplateContext differentiates from other interfaces.
	IsDefineTemplateContext()
}

type DefineTemplateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefineTemplateContext() *DefineTemplateContext {
	var p = new(DefineTemplateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_defineTemplate
	return p
}

func InitEmptyDefineTemplateContext(p *DefineTemplateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_defineTemplate
}

func (*DefineTemplateContext) IsDefineTemplateContext() {}

func NewDefineTemplateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefineTemplateContext {
	var p = new(DefineTemplateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_defineTemplate

	return p
}

func (s *DefineTemplateContext) GetParser() antlr.Parser { return s.parser }

func (s *DefineTemplateContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *DefineTemplateContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DefineTemplateContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *DefineTemplateContext) TRIPLE_BRACKET_OPEN() antlr.TerminalNode {
	return s.GetToken(MinZParserTRIPLE_BRACKET_OPEN, 0)
}

func (s *DefineTemplateContext) TemplateBody() ITemplateBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateBodyContext)
}

func (s *DefineTemplateContext) TRIPLE_BRACKET_CLOSE() antlr.TerminalNode {
	return s.GetToken(MinZParserTRIPLE_BRACKET_CLOSE, 0)
}

func (s *DefineTemplateContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *DefineTemplateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefineTemplateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefineTemplateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterDefineTemplate(s)
	}
}

func (s *DefineTemplateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitDefineTemplate(s)
	}
}

func (s *DefineTemplateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitDefineTemplate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) DefineTemplate() (localctx IDefineTemplateContext) {
	localctx = NewDefineTemplateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, MinZParserRULE_defineTemplate)
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(622)
			p.Match(MinZParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(623)
			p.Match(MinZParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(624)
			p.IdentifierList()
		}
		{
			p.SetState(625)
			p.Match(MinZParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(626)
			p.Match(MinZParserTRIPLE_BRACKET_OPEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(627)
			p.TemplateBody()
		}
		{
			p.SetState(628)
			p.Match(MinZParserTRIPLE_BRACKET_CLOSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(630)
			p.Match(MinZParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(631)
			p.Match(MinZParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(632)
			p.ExpressionList()
		}
		{
			p.SetState(633)
			p.Match(MinZParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemplateBodyContext is an interface to support dynamic dispatch.
type ITemplateBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTEMPLATE_BODY_CONTENT() []antlr.TerminalNode
	TEMPLATE_BODY_CONTENT(i int) antlr.TerminalNode

	// IsTemplateBodyContext differentiates from other interfaces.
	IsTemplateBodyContext()
}

type TemplateBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateBodyContext() *TemplateBodyContext {
	var p = new(TemplateBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_templateBody
	return p
}

func InitEmptyTemplateBodyContext(p *TemplateBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_templateBody
}

func (*TemplateBodyContext) IsTemplateBodyContext() {}

func NewTemplateBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateBodyContext {
	var p = new(TemplateBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_templateBody

	return p
}

func (s *TemplateBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateBodyContext) AllTEMPLATE_BODY_CONTENT() []antlr.TerminalNode {
	return s.GetTokens(MinZParserTEMPLATE_BODY_CONTENT)
}

func (s *TemplateBodyContext) TEMPLATE_BODY_CONTENT(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserTEMPLATE_BODY_CONTENT, i)
}

func (s *TemplateBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterTemplateBody(s)
	}
}

func (s *TemplateBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitTemplateBody(s)
	}
}

func (s *TemplateBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitTemplateBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) TemplateBody() (localctx ITemplateBodyContext) {
	localctx = NewTemplateBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, MinZParserRULE_templateBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserTEMPLATE_BODY_CONTENT {
		{
			p.SetState(637)
			p.Match(MinZParserTEMPLATE_BODY_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(MinZParserIDENTIFIER)
}

func (s *IdentifierListContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, i)
}

func (s *IdentifierListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MinZParserCOMMA)
}

func (s *IdentifierListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, i)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, MinZParserRULE_identifierList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(643)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserCOMMA {
		{
			p.SetState(644)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(645)
			p.Match(MinZParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMetaExecutionBlockContext is an interface to support dynamic dispatch.
type IMetaExecutionBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LuaExecutionBlock() ILuaExecutionBlockContext
	MinzExecutionBlock() IMinzExecutionBlockContext
	MirExecutionBlock() IMirExecutionBlockContext

	// IsMetaExecutionBlockContext differentiates from other interfaces.
	IsMetaExecutionBlockContext()
}

type MetaExecutionBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMetaExecutionBlockContext() *MetaExecutionBlockContext {
	var p = new(MetaExecutionBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_metaExecutionBlock
	return p
}

func InitEmptyMetaExecutionBlockContext(p *MetaExecutionBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_metaExecutionBlock
}

func (*MetaExecutionBlockContext) IsMetaExecutionBlockContext() {}

func NewMetaExecutionBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetaExecutionBlockContext {
	var p = new(MetaExecutionBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_metaExecutionBlock

	return p
}

func (s *MetaExecutionBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *MetaExecutionBlockContext) LuaExecutionBlock() ILuaExecutionBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILuaExecutionBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILuaExecutionBlockContext)
}

func (s *MetaExecutionBlockContext) MinzExecutionBlock() IMinzExecutionBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMinzExecutionBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMinzExecutionBlockContext)
}

func (s *MetaExecutionBlockContext) MirExecutionBlock() IMirExecutionBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirExecutionBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirExecutionBlockContext)
}

func (s *MetaExecutionBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetaExecutionBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetaExecutionBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMetaExecutionBlock(s)
	}
}

func (s *MetaExecutionBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMetaExecutionBlock(s)
	}
}

func (s *MetaExecutionBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMetaExecutionBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MetaExecutionBlock() (localctx IMetaExecutionBlockContext) {
	localctx = NewMetaExecutionBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, MinZParserRULE_metaExecutionBlock)
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserT__0:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(651)
			p.LuaExecutionBlock()
		}

	case MinZParserT__2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(652)
			p.MinzExecutionBlock()
		}

	case MinZParserT__1:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(653)
			p.MirExecutionBlock()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILuaExecutionBlockContext is an interface to support dynamic dispatch.
type ILuaExecutionBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIPLE_BRACKET_OPEN() antlr.TerminalNode
	RawBlockContent() IRawBlockContentContext
	TRIPLE_BRACKET_CLOSE() antlr.TerminalNode

	// IsLuaExecutionBlockContext differentiates from other interfaces.
	IsLuaExecutionBlockContext()
}

type LuaExecutionBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLuaExecutionBlockContext() *LuaExecutionBlockContext {
	var p = new(LuaExecutionBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_luaExecutionBlock
	return p
}

func InitEmptyLuaExecutionBlockContext(p *LuaExecutionBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_luaExecutionBlock
}

func (*LuaExecutionBlockContext) IsLuaExecutionBlockContext() {}

func NewLuaExecutionBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LuaExecutionBlockContext {
	var p = new(LuaExecutionBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_luaExecutionBlock

	return p
}

func (s *LuaExecutionBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *LuaExecutionBlockContext) TRIPLE_BRACKET_OPEN() antlr.TerminalNode {
	return s.GetToken(MinZParserTRIPLE_BRACKET_OPEN, 0)
}

func (s *LuaExecutionBlockContext) RawBlockContent() IRawBlockContentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRawBlockContentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRawBlockContentContext)
}

func (s *LuaExecutionBlockContext) TRIPLE_BRACKET_CLOSE() antlr.TerminalNode {
	return s.GetToken(MinZParserTRIPLE_BRACKET_CLOSE, 0)
}

func (s *LuaExecutionBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LuaExecutionBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LuaExecutionBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLuaExecutionBlock(s)
	}
}

func (s *LuaExecutionBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLuaExecutionBlock(s)
	}
}

func (s *LuaExecutionBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitLuaExecutionBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) LuaExecutionBlock() (localctx ILuaExecutionBlockContext) {
	localctx = NewLuaExecutionBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, MinZParserRULE_luaExecutionBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(MinZParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(657)
		p.Match(MinZParserTRIPLE_BRACKET_OPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(658)
		p.RawBlockContent()
	}
	{
		p.SetState(659)
		p.Match(MinZParserTRIPLE_BRACKET_CLOSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMinzExecutionBlockContext is an interface to support dynamic dispatch.
type IMinzExecutionBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIPLE_BRACKET_OPEN() antlr.TerminalNode
	RawBlockContent() IRawBlockContentContext
	TRIPLE_BRACKET_CLOSE() antlr.TerminalNode

	// IsMinzExecutionBlockContext differentiates from other interfaces.
	IsMinzExecutionBlockContext()
}

type MinzExecutionBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMinzExecutionBlockContext() *MinzExecutionBlockContext {
	var p = new(MinzExecutionBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_minzExecutionBlock
	return p
}

func InitEmptyMinzExecutionBlockContext(p *MinzExecutionBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_minzExecutionBlock
}

func (*MinzExecutionBlockContext) IsMinzExecutionBlockContext() {}

func NewMinzExecutionBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinzExecutionBlockContext {
	var p = new(MinzExecutionBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_minzExecutionBlock

	return p
}

func (s *MinzExecutionBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *MinzExecutionBlockContext) TRIPLE_BRACKET_OPEN() antlr.TerminalNode {
	return s.GetToken(MinZParserTRIPLE_BRACKET_OPEN, 0)
}

func (s *MinzExecutionBlockContext) RawBlockContent() IRawBlockContentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRawBlockContentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRawBlockContentContext)
}

func (s *MinzExecutionBlockContext) TRIPLE_BRACKET_CLOSE() antlr.TerminalNode {
	return s.GetToken(MinZParserTRIPLE_BRACKET_CLOSE, 0)
}

func (s *MinzExecutionBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinzExecutionBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinzExecutionBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMinzExecutionBlock(s)
	}
}

func (s *MinzExecutionBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMinzExecutionBlock(s)
	}
}

func (s *MinzExecutionBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMinzExecutionBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MinzExecutionBlock() (localctx IMinzExecutionBlockContext) {
	localctx = NewMinzExecutionBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, MinZParserRULE_minzExecutionBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(661)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(662)
		p.Match(MinZParserTRIPLE_BRACKET_OPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(663)
		p.RawBlockContent()
	}
	{
		p.SetState(664)
		p.Match(MinZParserTRIPLE_BRACKET_CLOSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirExecutionBlockContext is an interface to support dynamic dispatch.
type IMirExecutionBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIPLE_BRACKET_OPEN() antlr.TerminalNode
	RawBlockContent() IRawBlockContentContext
	TRIPLE_BRACKET_CLOSE() antlr.TerminalNode

	// IsMirExecutionBlockContext differentiates from other interfaces.
	IsMirExecutionBlockContext()
}

type MirExecutionBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMirExecutionBlockContext() *MirExecutionBlockContext {
	var p = new(MirExecutionBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirExecutionBlock
	return p
}

func InitEmptyMirExecutionBlockContext(p *MirExecutionBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirExecutionBlock
}

func (*MirExecutionBlockContext) IsMirExecutionBlockContext() {}

func NewMirExecutionBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirExecutionBlockContext {
	var p = new(MirExecutionBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirExecutionBlock

	return p
}

func (s *MirExecutionBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *MirExecutionBlockContext) TRIPLE_BRACKET_OPEN() antlr.TerminalNode {
	return s.GetToken(MinZParserTRIPLE_BRACKET_OPEN, 0)
}

func (s *MirExecutionBlockContext) RawBlockContent() IRawBlockContentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRawBlockContentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRawBlockContentContext)
}

func (s *MirExecutionBlockContext) TRIPLE_BRACKET_CLOSE() antlr.TerminalNode {
	return s.GetToken(MinZParserTRIPLE_BRACKET_CLOSE, 0)
}

func (s *MirExecutionBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirExecutionBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirExecutionBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirExecutionBlock(s)
	}
}

func (s *MirExecutionBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirExecutionBlock(s)
	}
}

func (s *MirExecutionBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMirExecutionBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MirExecutionBlock() (localctx IMirExecutionBlockContext) {
	localctx = NewMirExecutionBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, MinZParserRULE_mirExecutionBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.Match(MinZParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(667)
		p.Match(MinZParserTRIPLE_BRACKET_OPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(668)
		p.RawBlockContent()
	}
	{
		p.SetState(669)
		p.Match(MinZParserTRIPLE_BRACKET_CLOSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRawBlockContentContext is an interface to support dynamic dispatch.
type IRawBlockContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRAW_BLOCK_CONTENT() []antlr.TerminalNode
	RAW_BLOCK_CONTENT(i int) antlr.TerminalNode

	// IsRawBlockContentContext differentiates from other interfaces.
	IsRawBlockContentContext()
}

type RawBlockContentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRawBlockContentContext() *RawBlockContentContext {
	var p = new(RawBlockContentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_rawBlockContent
	return p
}

func InitEmptyRawBlockContentContext(p *RawBlockContentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_rawBlockContent
}

func (*RawBlockContentContext) IsRawBlockContentContext() {}

func NewRawBlockContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RawBlockContentContext {
	var p = new(RawBlockContentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_rawBlockContent

	return p
}

func (s *RawBlockContentContext) GetParser() antlr.Parser { return s.parser }

func (s *RawBlockContentContext) AllRAW_BLOCK_CONTENT() []antlr.TerminalNode {
	return s.GetTokens(MinZParserRAW_BLOCK_CONTENT)
}

func (s *RawBlockContentContext) RAW_BLOCK_CONTENT(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserRAW_BLOCK_CONTENT, i)
}

func (s *RawBlockContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RawBlockContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RawBlockContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterRawBlockContent(s)
	}
}

func (s *RawBlockContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitRawBlockContent(s)
	}
}

func (s *RawBlockContentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitRawBlockContent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) RawBlockContent() (localctx IRawBlockContentContext) {
	localctx = NewRawBlockContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, MinZParserRULE_rawBlockContent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserRAW_BLOCK_CONTENT {
		{
			p.SetState(671)
			p.Match(MinZParserRAW_BLOCK_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(676)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimitiveType() IPrimitiveTypeContext
	NamedType() INamedTypeContext
	ArrayType() IArrayTypeContext
	PointerType() IPointerTypeContext
	FunctionType() IFunctionTypeContext
	BitStructType() IBitStructTypeContext
	ErrorableType() IErrorableTypeContext
	MutableType() IMutableTypeContext
	IteratorType() IIteratorTypeContext

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeContext) NamedType() INamedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *TypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeContext) PointerType() IPointerTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerTypeContext)
}

func (s *TypeContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *TypeContext) BitStructType() IBitStructTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitStructTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitStructTypeContext)
}

func (s *TypeContext) ErrorableType() IErrorableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorableTypeContext)
}

func (s *TypeContext) MutableType() IMutableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMutableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMutableTypeContext)
}

func (s *TypeContext) IteratorType() IIteratorTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIteratorTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIteratorTypeContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitType(s)
	}
}

func (s *TypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, MinZParserRULE_type)
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(677)
			p.PrimitiveType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(678)
			p.NamedType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(679)
			p.ArrayType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(680)
			p.PointerType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(681)
			p.FunctionType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(682)
			p.BitStructType()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(683)
			p.ErrorableType()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(684)
			p.MutableType()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(685)
			p.IteratorType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	U8() antlr.TerminalNode
	U16() antlr.TerminalNode
	U24() antlr.TerminalNode
	U32() antlr.TerminalNode
	I8() antlr.TerminalNode
	I16() antlr.TerminalNode
	I24() antlr.TerminalNode
	I32() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	VOID() antlr.TerminalNode

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_primitiveType
	return p
}

func InitEmptyPrimitiveTypeContext(p *PrimitiveTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_primitiveType
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) U8() antlr.TerminalNode {
	return s.GetToken(MinZParserU8, 0)
}

func (s *PrimitiveTypeContext) U16() antlr.TerminalNode {
	return s.GetToken(MinZParserU16, 0)
}

func (s *PrimitiveTypeContext) U24() antlr.TerminalNode {
	return s.GetToken(MinZParserU24, 0)
}

func (s *PrimitiveTypeContext) U32() antlr.TerminalNode {
	return s.GetToken(MinZParserU32, 0)
}

func (s *PrimitiveTypeContext) I8() antlr.TerminalNode {
	return s.GetToken(MinZParserI8, 0)
}

func (s *PrimitiveTypeContext) I16() antlr.TerminalNode {
	return s.GetToken(MinZParserI16, 0)
}

func (s *PrimitiveTypeContext) I24() antlr.TerminalNode {
	return s.GetToken(MinZParserI24, 0)
}

func (s *PrimitiveTypeContext) I32() antlr.TerminalNode {
	return s.GetToken(MinZParserI32, 0)
}

func (s *PrimitiveTypeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(MinZParserBOOL, 0)
}

func (s *PrimitiveTypeContext) VOID() antlr.TerminalNode {
	return s.GetToken(MinZParserVOID, 0)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitPrimitiveType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, MinZParserRULE_primitiveType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(688)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-6)) & ^0x3f) == 0 && ((int64(1)<<(_la-6))&1151795604700004367) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedTypeContext is an interface to support dynamic dispatch.
type INamedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsNamedTypeContext differentiates from other interfaces.
	IsNamedTypeContext()
}

type NamedTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedTypeContext() *NamedTypeContext {
	var p = new(NamedTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_namedType
	return p
}

func InitEmptyNamedTypeContext(p *NamedTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_namedType
}

func (*NamedTypeContext) IsNamedTypeContext() {}

func NewNamedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedTypeContext {
	var p = new(NamedTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_namedType

	return p
}

func (s *NamedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedTypeContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(MinZParserIDENTIFIER)
}

func (s *NamedTypeContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, i)
}

func (s *NamedTypeContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(MinZParserDOT)
}

func (s *NamedTypeContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserDOT, i)
}

func (s *NamedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterNamedType(s)
	}
}

func (s *NamedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitNamedType(s)
	}
}

func (s *NamedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitNamedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) NamedType() (localctx INamedTypeContext) {
	localctx = NewNamedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, MinZParserRULE_namedType)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(690)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(691)
				p.Match(MinZParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(692)
				p.Match(MinZParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBaseType returns the baseType rule contexts.
	GetBaseType() IPrimaryTypeContext

	// GetElementType returns the elementType rule contexts.
	GetElementType() IPrimaryTypeContext

	// SetBaseType sets the baseType rule contexts.
	SetBaseType(IPrimaryTypeContext)

	// SetElementType sets the elementType rule contexts.
	SetElementType(IPrimaryTypeContext)

	// Getter signatures
	LBRACKET() antlr.TerminalNode
	RBRACKET() antlr.TerminalNode
	PrimaryType() IPrimaryTypeContext
	ArraySize() IArraySizeContext
	SEMICOLON() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	baseType    IPrimaryTypeContext
	elementType IPrimaryTypeContext
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) GetBaseType() IPrimaryTypeContext { return s.baseType }

func (s *ArrayTypeContext) GetElementType() IPrimaryTypeContext { return s.elementType }

func (s *ArrayTypeContext) SetBaseType(v IPrimaryTypeContext) { s.baseType = v }

func (s *ArrayTypeContext) SetElementType(v IPrimaryTypeContext) { s.elementType = v }

func (s *ArrayTypeContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACKET, 0)
}

func (s *ArrayTypeContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACKET, 0)
}

func (s *ArrayTypeContext) PrimaryType() IPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryTypeContext)
}

func (s *ArrayTypeContext) ArraySize() IArraySizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArraySizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArraySizeContext)
}

func (s *ArrayTypeContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, MinZParserRULE_arrayType)
	var _la int

	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserT__5, MinZParserT__6, MinZParserT__7, MinZParserT__8, MinZParserU8, MinZParserU16, MinZParserU24, MinZParserU32, MinZParserI8, MinZParserI16, MinZParserI24, MinZParserI32, MinZParserBOOL, MinZParserVOID, MinZParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(698)

			var _x = p.PrimaryType()

			localctx.(*ArrayTypeContext).baseType = _x
		}
		{
			p.SetState(699)
			p.Match(MinZParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(701)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MinZParserIDENTIFIER || _la == MinZParserINTEGER {
			{
				p.SetState(700)
				p.ArraySize()
			}

		}
		{
			p.SetState(703)
			p.Match(MinZParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserLBRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(705)
			p.Match(MinZParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(706)

			var _x = p.PrimaryType()

			localctx.(*ArrayTypeContext).elementType = _x
		}
		{
			p.SetState(707)
			p.Match(MinZParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(708)
			p.ArraySize()
		}
		{
			p.SetState(709)
			p.Match(MinZParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArraySizeContext is an interface to support dynamic dispatch.
type IArraySizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsArraySizeContext differentiates from other interfaces.
	IsArraySizeContext()
}

type ArraySizeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArraySizeContext() *ArraySizeContext {
	var p = new(ArraySizeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_arraySize
	return p
}

func InitEmptyArraySizeContext(p *ArraySizeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_arraySize
}

func (*ArraySizeContext) IsArraySizeContext() {}

func NewArraySizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArraySizeContext {
	var p = new(ArraySizeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_arraySize

	return p
}

func (s *ArraySizeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArraySizeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MinZParserINTEGER, 0)
}

func (s *ArraySizeContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *ArraySizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraySizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArraySizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterArraySize(s)
	}
}

func (s *ArraySizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitArraySize(s)
	}
}

func (s *ArraySizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitArraySize(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ArraySize() (localctx IArraySizeContext) {
	localctx = NewArraySizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, MinZParserRULE_arraySize)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(713)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MinZParserIDENTIFIER || _la == MinZParserINTEGER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPointerTypeContext is an interface to support dynamic dispatch.
type IPointerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBaseType returns the baseType rule contexts.
	GetBaseType() IPrimaryTypeContext

	// SetBaseType sets the baseType rule contexts.
	SetBaseType(IPrimaryTypeContext)

	// Getter signatures
	STAR() antlr.TerminalNode
	PrimaryType() IPrimaryTypeContext
	MUT() antlr.TerminalNode

	// IsPointerTypeContext differentiates from other interfaces.
	IsPointerTypeContext()
}

type PointerTypeContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	baseType IPrimaryTypeContext
}

func NewEmptyPointerTypeContext() *PointerTypeContext {
	var p = new(PointerTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_pointerType
	return p
}

func InitEmptyPointerTypeContext(p *PointerTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_pointerType
}

func (*PointerTypeContext) IsPointerTypeContext() {}

func NewPointerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerTypeContext {
	var p = new(PointerTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_pointerType

	return p
}

func (s *PointerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerTypeContext) GetBaseType() IPrimaryTypeContext { return s.baseType }

func (s *PointerTypeContext) SetBaseType(v IPrimaryTypeContext) { s.baseType = v }

func (s *PointerTypeContext) STAR() antlr.TerminalNode {
	return s.GetToken(MinZParserSTAR, 0)
}

func (s *PointerTypeContext) PrimaryType() IPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryTypeContext)
}

func (s *PointerTypeContext) MUT() antlr.TerminalNode {
	return s.GetToken(MinZParserMUT, 0)
}

func (s *PointerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterPointerType(s)
	}
}

func (s *PointerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitPointerType(s)
	}
}

func (s *PointerTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitPointerType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) PointerType() (localctx IPointerTypeContext) {
	localctx = NewPointerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, MinZParserRULE_pointerType)
	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(715)
			p.Match(MinZParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(716)

			var _x = p.PrimaryType()

			localctx.(*PointerTypeContext).baseType = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(717)
			p.Match(MinZParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(718)
			p.Match(MinZParserMUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(719)

			var _x = p.PrimaryType()

			localctx.(*PointerTypeContext).baseType = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	FUN() antlr.TerminalNode
	FN() antlr.TerminalNode
	ParameterList() IParameterListContext
	ReturnType() IReturnTypeContext

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_functionType
	return p
}

func InitEmptyFunctionTypeContext(p *FunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_functionType
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *FunctionTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *FunctionTypeContext) FUN() antlr.TerminalNode {
	return s.GetToken(MinZParserFUN, 0)
}

func (s *FunctionTypeContext) FN() antlr.TerminalNode {
	return s.GetToken(MinZParserFN, 0)
}

func (s *FunctionTypeContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionTypeContext) ReturnType() IReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (s *FunctionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitFunctionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, MinZParserRULE_functionType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(722)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MinZParserFUN || _la == MinZParserFN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(723)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserSELF || _la == MinZParserIDENTIFIER {
		{
			p.SetState(724)
			p.ParameterList()
		}

	}
	{
		p.SetState(727)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(729)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(728)
			p.ReturnType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitStructTypeContext is an interface to support dynamic dispatch.
type IBitStructTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	BITS() antlr.TerminalNode
	BITS_8() antlr.TerminalNode
	BITS_16() antlr.TerminalNode
	AllBitField() []IBitFieldContext
	BitField(i int) IBitFieldContext

	// IsBitStructTypeContext differentiates from other interfaces.
	IsBitStructTypeContext()
}

type BitStructTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitStructTypeContext() *BitStructTypeContext {
	var p = new(BitStructTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_bitStructType
	return p
}

func InitEmptyBitStructTypeContext(p *BitStructTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_bitStructType
}

func (*BitStructTypeContext) IsBitStructTypeContext() {}

func NewBitStructTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitStructTypeContext {
	var p = new(BitStructTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_bitStructType

	return p
}

func (s *BitStructTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BitStructTypeContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *BitStructTypeContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *BitStructTypeContext) BITS() antlr.TerminalNode {
	return s.GetToken(MinZParserBITS, 0)
}

func (s *BitStructTypeContext) BITS_8() antlr.TerminalNode {
	return s.GetToken(MinZParserBITS_8, 0)
}

func (s *BitStructTypeContext) BITS_16() antlr.TerminalNode {
	return s.GetToken(MinZParserBITS_16, 0)
}

func (s *BitStructTypeContext) AllBitField() []IBitFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBitFieldContext); ok {
			len++
		}
	}

	tst := make([]IBitFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBitFieldContext); ok {
			tst[i] = t.(IBitFieldContext)
			i++
		}
	}

	return tst
}

func (s *BitStructTypeContext) BitField(i int) IBitFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitFieldContext)
}

func (s *BitStructTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitStructTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitStructTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBitStructType(s)
	}
}

func (s *BitStructTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBitStructType(s)
	}
}

func (s *BitStructTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitBitStructType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) BitStructType() (localctx IBitStructTypeContext) {
	localctx = NewBitStructTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, MinZParserRULE_bitStructType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(731)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&63050394783186944) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(732)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserIDENTIFIER {
		{
			p.SetState(733)
			p.BitField()
		}

		p.SetState(738)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(739)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorableTypeContext is an interface to support dynamic dispatch.
type IErrorableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBaseType returns the baseType rule contexts.
	GetBaseType() IPrimaryTypeContext

	// SetBaseType sets the baseType rule contexts.
	SetBaseType(IPrimaryTypeContext)

	// Getter signatures
	QUESTION() antlr.TerminalNode
	PrimaryType() IPrimaryTypeContext

	// IsErrorableTypeContext differentiates from other interfaces.
	IsErrorableTypeContext()
}

type ErrorableTypeContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	baseType IPrimaryTypeContext
}

func NewEmptyErrorableTypeContext() *ErrorableTypeContext {
	var p = new(ErrorableTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_errorableType
	return p
}

func InitEmptyErrorableTypeContext(p *ErrorableTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_errorableType
}

func (*ErrorableTypeContext) IsErrorableTypeContext() {}

func NewErrorableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorableTypeContext {
	var p = new(ErrorableTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_errorableType

	return p
}

func (s *ErrorableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorableTypeContext) GetBaseType() IPrimaryTypeContext { return s.baseType }

func (s *ErrorableTypeContext) SetBaseType(v IPrimaryTypeContext) { s.baseType = v }

func (s *ErrorableTypeContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(MinZParserQUESTION, 0)
}

func (s *ErrorableTypeContext) PrimaryType() IPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryTypeContext)
}

func (s *ErrorableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterErrorableType(s)
	}
}

func (s *ErrorableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitErrorableType(s)
	}
}

func (s *ErrorableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitErrorableType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ErrorableType() (localctx IErrorableTypeContext) {
	localctx = NewErrorableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, MinZParserRULE_errorableType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)

		var _x = p.PrimaryType()

		localctx.(*ErrorableTypeContext).baseType = _x
	}
	{
		p.SetState(742)
		p.Match(MinZParserQUESTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMutableTypeContext is an interface to support dynamic dispatch.
type IMutableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBaseType returns the baseType rule contexts.
	GetBaseType() IPrimaryTypeContext

	// SetBaseType sets the baseType rule contexts.
	SetBaseType(IPrimaryTypeContext)

	// Getter signatures
	MUT() antlr.TerminalNode
	PrimaryType() IPrimaryTypeContext

	// IsMutableTypeContext differentiates from other interfaces.
	IsMutableTypeContext()
}

type MutableTypeContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	baseType IPrimaryTypeContext
}

func NewEmptyMutableTypeContext() *MutableTypeContext {
	var p = new(MutableTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mutableType
	return p
}

func InitEmptyMutableTypeContext(p *MutableTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mutableType
}

func (*MutableTypeContext) IsMutableTypeContext() {}

func NewMutableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MutableTypeContext {
	var p = new(MutableTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mutableType

	return p
}

func (s *MutableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MutableTypeContext) GetBaseType() IPrimaryTypeContext { return s.baseType }

func (s *MutableTypeContext) SetBaseType(v IPrimaryTypeContext) { s.baseType = v }

func (s *MutableTypeContext) MUT() antlr.TerminalNode {
	return s.GetToken(MinZParserMUT, 0)
}

func (s *MutableTypeContext) PrimaryType() IPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryTypeContext)
}

func (s *MutableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MutableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MutableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMutableType(s)
	}
}

func (s *MutableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMutableType(s)
	}
}

func (s *MutableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMutableType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MutableType() (localctx IMutableTypeContext) {
	localctx = NewMutableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, MinZParserRULE_mutableType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(744)
		p.Match(MinZParserMUT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(745)

		var _x = p.PrimaryType()

		localctx.(*MutableTypeContext).baseType = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIteratorTypeContext is an interface to support dynamic dispatch.
type IIteratorTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetElementType returns the elementType rule contexts.
	GetElementType() IPrimaryTypeContext

	// SetElementType sets the elementType rule contexts.
	SetElementType(IPrimaryTypeContext)

	// Getter signatures
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	PrimaryType() IPrimaryTypeContext

	// IsIteratorTypeContext differentiates from other interfaces.
	IsIteratorTypeContext()
}

type IteratorTypeContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	elementType IPrimaryTypeContext
}

func NewEmptyIteratorTypeContext() *IteratorTypeContext {
	var p = new(IteratorTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_iteratorType
	return p
}

func InitEmptyIteratorTypeContext(p *IteratorTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_iteratorType
}

func (*IteratorTypeContext) IsIteratorTypeContext() {}

func NewIteratorTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IteratorTypeContext {
	var p = new(IteratorTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_iteratorType

	return p
}

func (s *IteratorTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IteratorTypeContext) GetElementType() IPrimaryTypeContext { return s.elementType }

func (s *IteratorTypeContext) SetElementType(v IPrimaryTypeContext) { s.elementType = v }

func (s *IteratorTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(MinZParserLT, 0)
}

func (s *IteratorTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(MinZParserGT, 0)
}

func (s *IteratorTypeContext) PrimaryType() IPrimaryTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryTypeContext)
}

func (s *IteratorTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IteratorTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IteratorTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterIteratorType(s)
	}
}

func (s *IteratorTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitIteratorType(s)
	}
}

func (s *IteratorTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitIteratorType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) IteratorType() (localctx IIteratorTypeContext) {
	localctx = NewIteratorTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, MinZParserRULE_iteratorType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(MinZParserT__9)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(748)
		p.Match(MinZParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(749)

		var _x = p.PrimaryType()

		localctx.(*IteratorTypeContext).elementType = _x
	}
	{
		p.SetState(750)
		p.Match(MinZParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryTypeContext is an interface to support dynamic dispatch.
type IPrimaryTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimitiveType() IPrimitiveTypeContext
	NamedType() INamedTypeContext

	// IsPrimaryTypeContext differentiates from other interfaces.
	IsPrimaryTypeContext()
}

type PrimaryTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryTypeContext() *PrimaryTypeContext {
	var p = new(PrimaryTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_primaryType
	return p
}

func InitEmptyPrimaryTypeContext(p *PrimaryTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_primaryType
}

func (*PrimaryTypeContext) IsPrimaryTypeContext() {}

func NewPrimaryTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryTypeContext {
	var p = new(PrimaryTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_primaryType

	return p
}

func (s *PrimaryTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *PrimaryTypeContext) NamedType() INamedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedTypeContext)
}

func (s *PrimaryTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterPrimaryType(s)
	}
}

func (s *PrimaryTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitPrimaryType(s)
	}
}

func (s *PrimaryTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitPrimaryType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) PrimaryType() (localctx IPrimaryTypeContext) {
	localctx = NewPrimaryTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, MinZParserRULE_primaryType)
	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserT__5, MinZParserT__6, MinZParserT__7, MinZParserT__8, MinZParserU8, MinZParserU16, MinZParserU24, MinZParserU32, MinZParserI8, MinZParserI16, MinZParserI24, MinZParserI32, MinZParserBOOL, MinZParserVOID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(752)
			p.PrimitiveType()
		}

	case MinZParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(753)
			p.NamedType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LetStatement() ILetStatementContext
	IfStatement() IIfStatementContext
	WhileStatement() IWhileStatementContext
	ForStatement() IForStatementContext
	LoopStatement() ILoopStatementContext
	MatchStatement() IMatchStatementContext
	CaseStatement() ICaseStatementContext
	ReturnStatement() IReturnStatementContext
	BreakStatement() IBreakStatementContext
	ContinueStatement() IContinueStatementContext
	DeferStatement() IDeferStatementContext
	Block() IBlockContext
	AssignmentStatement() IAssignmentStatementContext
	ExpressionStatement() IExpressionStatementContext
	AsmBlock() IAsmBlockContext
	CompileTimeAsm() ICompileTimeAsmContext
	MirBlock() IMirBlockContext
	MinzBlock() IMinzBlockContext
	TargetBlock() ITargetBlockContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) LetStatement() ILetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) LoopStatement() ILoopStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *StatementContext) MatchStatement() IMatchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchStatementContext)
}

func (s *StatementContext) CaseStatement() ICaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) DeferStatement() IDeferStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeferStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeferStatementContext)
}

func (s *StatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) AssignmentStatement() IAssignmentStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentStatementContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) AsmBlock() IAsmBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmBlockContext)
}

func (s *StatementContext) CompileTimeAsm() ICompileTimeAsmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompileTimeAsmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompileTimeAsmContext)
}

func (s *StatementContext) MirBlock() IMirBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirBlockContext)
}

func (s *StatementContext) MinzBlock() IMinzBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMinzBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMinzBlockContext)
}

func (s *StatementContext) TargetBlock() ITargetBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetBlockContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, MinZParserRULE_statement)
	p.SetState(775)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(756)
			p.LetStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(757)
			p.IfStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(758)
			p.WhileStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(759)
			p.ForStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(760)
			p.LoopStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(761)
			p.MatchStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(762)
			p.CaseStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(763)
			p.ReturnStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(764)
			p.BreakStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(765)
			p.ContinueStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(766)
			p.DeferStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(767)
			p.Block()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(768)
			p.AssignmentStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(769)
			p.ExpressionStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(770)
			p.AsmBlock()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(771)
			p.CompileTimeAsm()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(772)
			p.MirBlock()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(773)
			p.MinzBlock()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(774)
			p.TargetBlock()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetStatementContext is an interface to support dynamic dispatch.
type ILetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// GetInitializer returns the initializer rule contexts.
	GetInitializer() IExpressionContext

	// SetInitializer sets the initializer rule contexts.
	SetInitializer(IExpressionContext)

	// Getter signatures
	LET() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	MUT() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsLetStatementContext differentiates from other interfaces.
	IsLetStatementContext()
}

type LetStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	name        antlr.Token
	initializer IExpressionContext
}

func NewEmptyLetStatementContext() *LetStatementContext {
	var p = new(LetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_letStatement
	return p
}

func InitEmptyLetStatementContext(p *LetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_letStatement
}

func (*LetStatementContext) IsLetStatementContext() {}

func NewLetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetStatementContext {
	var p = new(LetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_letStatement

	return p
}

func (s *LetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LetStatementContext) GetName() antlr.Token { return s.name }

func (s *LetStatementContext) SetName(v antlr.Token) { s.name = v }

func (s *LetStatementContext) GetInitializer() IExpressionContext { return s.initializer }

func (s *LetStatementContext) SetInitializer(v IExpressionContext) { s.initializer = v }

func (s *LetStatementContext) LET() antlr.TerminalNode {
	return s.GetToken(MinZParserLET, 0)
}

func (s *LetStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *LetStatementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *LetStatementContext) MUT() antlr.TerminalNode {
	return s.GetToken(MinZParserMUT, 0)
}

func (s *LetStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(MinZParserCOLON, 0)
}

func (s *LetStatementContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *LetStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserASSIGN, 0)
}

func (s *LetStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLetStatement(s)
	}
}

func (s *LetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLetStatement(s)
	}
}

func (s *LetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitLetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) LetStatement() (localctx ILetStatementContext) {
	localctx = NewLetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, MinZParserRULE_letStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(777)
		p.Match(MinZParserLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(779)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserMUT {
		{
			p.SetState(778)
			p.Match(MinZParserMUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(781)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*LetStatementContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserCOLON {
		{
			p.SetState(782)
			p.Match(MinZParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(783)
			p.Type_()
		}

	}
	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserASSIGN {
		{
			p.SetState(786)
			p.Match(MinZParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(787)

			var _x = p.expression(0)

			localctx.(*LetStatementContext).initializer = _x
		}

	}
	{
		p.SetState(790)
		p.Match(MinZParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetThenBlock returns the thenBlock rule contexts.
	GetThenBlock() IBlockContext

	// GetElseIfCondition returns the elseIfCondition rule contexts.
	GetElseIfCondition() IExpressionContext

	// GetElseIfBlock returns the elseIfBlock rule contexts.
	GetElseIfBlock() IBlockContext

	// GetElseBlock returns the elseBlock rule contexts.
	GetElseBlock() IBlockContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetThenBlock sets the thenBlock rule contexts.
	SetThenBlock(IBlockContext)

	// SetElseIfCondition sets the elseIfCondition rule contexts.
	SetElseIfCondition(IExpressionContext)

	// SetElseIfBlock sets the elseIfBlock rule contexts.
	SetElseIfBlock(IBlockContext)

	// SetElseBlock sets the elseBlock rule contexts.
	SetElseBlock(IBlockContext)

	// Getter signatures
	AllIF() []antlr.TerminalNode
	IF(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllBlock() []IBlockContext
	Block(i int) IBlockContext
	AllELSE() []antlr.TerminalNode
	ELSE(i int) antlr.TerminalNode

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	condition       IExpressionContext
	thenBlock       IBlockContext
	elseIfCondition IExpressionContext
	elseIfBlock     IBlockContext
	elseBlock       IBlockContext
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) GetCondition() IExpressionContext { return s.condition }

func (s *IfStatementContext) GetThenBlock() IBlockContext { return s.thenBlock }

func (s *IfStatementContext) GetElseIfCondition() IExpressionContext { return s.elseIfCondition }

func (s *IfStatementContext) GetElseIfBlock() IBlockContext { return s.elseIfBlock }

func (s *IfStatementContext) GetElseBlock() IBlockContext { return s.elseBlock }

func (s *IfStatementContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *IfStatementContext) SetThenBlock(v IBlockContext) { s.thenBlock = v }

func (s *IfStatementContext) SetElseIfCondition(v IExpressionContext) { s.elseIfCondition = v }

func (s *IfStatementContext) SetElseIfBlock(v IBlockContext) { s.elseIfBlock = v }

func (s *IfStatementContext) SetElseBlock(v IBlockContext) { s.elseBlock = v }

func (s *IfStatementContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(MinZParserIF)
}

func (s *IfStatementContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserIF, i)
}

func (s *IfStatementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) AllBlock() []IBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockContext); ok {
			len++
		}
	}

	tst := make([]IBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockContext); ok {
			tst[i] = t.(IBlockContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Block(i int) IBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *IfStatementContext) AllELSE() []antlr.TerminalNode {
	return s.GetTokens(MinZParserELSE)
}

func (s *IfStatementContext) ELSE(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserELSE, i)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, MinZParserRULE_ifStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Match(MinZParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(793)

		var _x = p.expression(0)

		localctx.(*IfStatementContext).condition = _x
	}
	{
		p.SetState(794)

		var _x = p.Block()

		localctx.(*IfStatementContext).thenBlock = _x
	}
	p.SetState(802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(795)
				p.Match(MinZParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(796)
				p.Match(MinZParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(797)

				var _x = p.expression(0)

				localctx.(*IfStatementContext).elseIfCondition = _x
			}
			{
				p.SetState(798)

				var _x = p.Block()

				localctx.(*IfStatementContext).elseIfBlock = _x
			}

		}
		p.SetState(804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserELSE {
		{
			p.SetState(805)
			p.Match(MinZParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(806)

			var _x = p.Block()

			localctx.(*IfStatementContext).elseBlock = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetBody returns the body rule contexts.
	GetBody() IBlockContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetBody sets the body rule contexts.
	SetBody(IBlockContext)

	// Getter signatures
	WHILE() antlr.TerminalNode
	Expression() IExpressionContext
	Block() IBlockContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	body      IBlockContext
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhileStatementContext) GetBody() IBlockContext { return s.body }

func (s *WhileStatementContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhileStatementContext) SetBody(v IBlockContext) { s.body = v }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(MinZParserWHILE, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, MinZParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(809)
		p.Match(MinZParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(810)

		var _x = p.expression(0)

		localctx.(*WhileStatementContext).condition = _x
	}
	{
		p.SetState(811)

		var _x = p.Block()

		localctx.(*WhileStatementContext).body = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIterator returns the iterator token.
	GetIterator() antlr.Token

	// SetIterator sets the iterator token.
	SetIterator(antlr.Token)

	// GetIterable returns the iterable rule contexts.
	GetIterable() IExpressionContext

	// GetBody returns the body rule contexts.
	GetBody() IBlockContext

	// SetIterable sets the iterable rule contexts.
	SetIterable(IExpressionContext)

	// SetBody sets the body rule contexts.
	SetBody(IBlockContext)

	// Getter signatures
	FOR() antlr.TerminalNode
	IN() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	Expression() IExpressionContext
	Block() IBlockContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	iterator antlr.Token
	iterable IExpressionContext
	body     IBlockContext
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) GetIterator() antlr.Token { return s.iterator }

func (s *ForStatementContext) SetIterator(v antlr.Token) { s.iterator = v }

func (s *ForStatementContext) GetIterable() IExpressionContext { return s.iterable }

func (s *ForStatementContext) GetBody() IBlockContext { return s.body }

func (s *ForStatementContext) SetIterable(v IExpressionContext) { s.iterable = v }

func (s *ForStatementContext) SetBody(v IBlockContext) { s.body = v }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(MinZParserFOR, 0)
}

func (s *ForStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(MinZParserIN, 0)
}

func (s *ForStatementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *ForStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, MinZParserRULE_forStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(813)
		p.Match(MinZParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(814)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*ForStatementContext).iterator = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(815)
		p.Match(MinZParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(816)

		var _x = p.expression(0)

		localctx.(*ForStatementContext).iterable = _x
	}
	{
		p.SetState(817)

		var _x = p.Block()

		localctx.(*ForStatementContext).body = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOOP() antlr.TerminalNode
	Block() IBlockContext

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_loopStatement
	return p
}

func InitEmptyLoopStatementContext(p *LoopStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_loopStatement
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) LOOP() antlr.TerminalNode {
	return s.GetToken(MinZParserLOOP, 0)
}

func (s *LoopStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLoopStatement(s)
	}
}

func (s *LoopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLoopStatement(s)
	}
}

func (s *LoopStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitLoopStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) LoopStatement() (localctx ILoopStatementContext) {
	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, MinZParserRULE_loopStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(819)
		p.Match(MinZParserLOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(820)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchStatementContext is an interface to support dynamic dispatch.
type IMatchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MATCH() antlr.TerminalNode
	Expression() IExpressionContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllMatchArm() []IMatchArmContext
	MatchArm(i int) IMatchArmContext

	// IsMatchStatementContext differentiates from other interfaces.
	IsMatchStatementContext()
}

type MatchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchStatementContext() *MatchStatementContext {
	var p = new(MatchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_matchStatement
	return p
}

func InitEmptyMatchStatementContext(p *MatchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_matchStatement
}

func (*MatchStatementContext) IsMatchStatementContext() {}

func NewMatchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchStatementContext {
	var p = new(MatchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_matchStatement

	return p
}

func (s *MatchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchStatementContext) MATCH() antlr.TerminalNode {
	return s.GetToken(MinZParserMATCH, 0)
}

func (s *MatchStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MatchStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *MatchStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *MatchStatementContext) AllMatchArm() []IMatchArmContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatchArmContext); ok {
			len++
		}
	}

	tst := make([]IMatchArmContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatchArmContext); ok {
			tst[i] = t.(IMatchArmContext)
			i++
		}
	}

	return tst
}

func (s *MatchStatementContext) MatchArm(i int) IMatchArmContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchArmContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchArmContext)
}

func (s *MatchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMatchStatement(s)
	}
}

func (s *MatchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMatchStatement(s)
	}
}

func (s *MatchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMatchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MatchStatement() (localctx IMatchStatementContext) {
	localctx = NewMatchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, MinZParserRULE_matchStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(822)
		p.Match(MinZParserMATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(823)
		p.expression(0)
	}
	{
		p.SetState(824)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&61572651155456) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&576460752303423615) != 0) {
		{
			p.SetState(825)
			p.MatchArm()
		}

		p.SetState(830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(831)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchArmContext is an interface to support dynamic dispatch.
type IMatchArmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pattern() IPatternContext
	DOUBLE_ARROW() antlr.TerminalNode
	Expression() IExpressionContext
	SEMICOLON() antlr.TerminalNode
	Block() IBlockContext
	COMMA() antlr.TerminalNode

	// IsMatchArmContext differentiates from other interfaces.
	IsMatchArmContext()
}

type MatchArmContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchArmContext() *MatchArmContext {
	var p = new(MatchArmContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_matchArm
	return p
}

func InitEmptyMatchArmContext(p *MatchArmContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_matchArm
}

func (*MatchArmContext) IsMatchArmContext() {}

func NewMatchArmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchArmContext {
	var p = new(MatchArmContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_matchArm

	return p
}

func (s *MatchArmContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchArmContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *MatchArmContext) DOUBLE_ARROW() antlr.TerminalNode {
	return s.GetToken(MinZParserDOUBLE_ARROW, 0)
}

func (s *MatchArmContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MatchArmContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *MatchArmContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MatchArmContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, 0)
}

func (s *MatchArmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchArmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchArmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMatchArm(s)
	}
}

func (s *MatchArmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMatchArm(s)
	}
}

func (s *MatchArmContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMatchArm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MatchArm() (localctx IMatchArmContext) {
	localctx = NewMatchArmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, MinZParserRULE_matchArm)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(833)
		p.Pattern()
	}
	{
		p.SetState(834)
		p.Match(MinZParserDOUBLE_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(835)
			p.expression(0)
		}
		{
			p.SetState(836)
			p.Match(MinZParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(838)
			p.Block()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserCOMMA {
		{
			p.SetState(841)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Expression() IExpressionContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllCaseArm() []ICaseArmContext
	CaseArm(i int) ICaseArmContext

	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_caseStatement
	return p
}

func InitEmptyCaseStatementContext(p *CaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_caseStatement
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) CASE() antlr.TerminalNode {
	return s.GetToken(MinZParserCASE, 0)
}

func (s *CaseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *CaseStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *CaseStatementContext) AllCaseArm() []ICaseArmContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseArmContext); ok {
			len++
		}
	}

	tst := make([]ICaseArmContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseArmContext); ok {
			tst[i] = t.(ICaseArmContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) CaseArm(i int) ICaseArmContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseArmContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseArmContext)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCaseStatement(s)
	}
}

func (s *CaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCaseStatement(s)
	}
}

func (s *CaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) CaseStatement() (localctx ICaseStatementContext) {
	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, MinZParserRULE_caseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(844)
		p.Match(MinZParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(845)
		p.expression(0)
	}
	{
		p.SetState(846)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&61572651155456) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&576460752303423615) != 0) {
		{
			p.SetState(847)
			p.CaseArm()
		}

		p.SetState(852)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(853)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseArmContext is an interface to support dynamic dispatch.
type ICaseArmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pattern() IPatternContext
	DOUBLE_ARROW() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	Block() IBlockContext
	IF() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsCaseArmContext differentiates from other interfaces.
	IsCaseArmContext()
}

type CaseArmContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseArmContext() *CaseArmContext {
	var p = new(CaseArmContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_caseArm
	return p
}

func InitEmptyCaseArmContext(p *CaseArmContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_caseArm
}

func (*CaseArmContext) IsCaseArmContext() {}

func NewCaseArmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseArmContext {
	var p = new(CaseArmContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_caseArm

	return p
}

func (s *CaseArmContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseArmContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *CaseArmContext) DOUBLE_ARROW() antlr.TerminalNode {
	return s.GetToken(MinZParserDOUBLE_ARROW, 0)
}

func (s *CaseArmContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CaseArmContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseArmContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CaseArmContext) IF() antlr.TerminalNode {
	return s.GetToken(MinZParserIF, 0)
}

func (s *CaseArmContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, 0)
}

func (s *CaseArmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseArmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseArmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCaseArm(s)
	}
}

func (s *CaseArmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCaseArm(s)
	}
}

func (s *CaseArmContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitCaseArm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) CaseArm() (localctx ICaseArmContext) {
	localctx = NewCaseArmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, MinZParserRULE_caseArm)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(855)
		p.Pattern()
	}
	p.SetState(858)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserIF {
		{
			p.SetState(856)
			p.Match(MinZParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(857)
			p.expression(0)
		}

	}
	{
		p.SetState(860)
		p.Match(MinZParserDOUBLE_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(863)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(861)
			p.expression(0)
		}

	case 2:
		{
			p.SetState(862)
			p.Block()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserCOMMA {
		{
			p.SetState(865)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNDERSCORE() antlr.TerminalNode
	Literal() ILiteralContext
	IDENTIFIER() antlr.TerminalNode
	EnumPattern() IEnumPatternContext

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_pattern
	return p
}

func InitEmptyPatternContext(p *PatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_pattern
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(MinZParserUNDERSCORE, 0)
}

func (s *PatternContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PatternContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *PatternContext) EnumPattern() IEnumPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumPatternContext)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterPattern(s)
	}
}

func (s *PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitPattern(s)
	}
}

func (s *PatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) Pattern() (localctx IPatternContext) {
	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, MinZParserRULE_pattern)
	p.SetState(872)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(868)
			p.Match(MinZParserUNDERSCORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(869)
			p.Literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(870)
			p.Match(MinZParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(871)
			p.EnumPattern()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumPatternContext is an interface to support dynamic dispatch.
type IEnumPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	DOUBLE_COLON() antlr.TerminalNode

	// IsEnumPatternContext differentiates from other interfaces.
	IsEnumPatternContext()
}

type EnumPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumPatternContext() *EnumPatternContext {
	var p = new(EnumPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_enumPattern
	return p
}

func InitEmptyEnumPatternContext(p *EnumPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_enumPattern
}

func (*EnumPatternContext) IsEnumPatternContext() {}

func NewEnumPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumPatternContext {
	var p = new(EnumPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_enumPattern

	return p
}

func (s *EnumPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumPatternContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(MinZParserIDENTIFIER)
}

func (s *EnumPatternContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, i)
}

func (s *EnumPatternContext) DOUBLE_COLON() antlr.TerminalNode {
	return s.GetToken(MinZParserDOUBLE_COLON, 0)
}

func (s *EnumPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterEnumPattern(s)
	}
}

func (s *EnumPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitEnumPattern(s)
	}
}

func (s *EnumPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitEnumPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) EnumPattern() (localctx IEnumPatternContext) {
	localctx = NewEnumPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, MinZParserRULE_enumPattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(874)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(875)
		p.Match(MinZParserDOUBLE_COLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(876)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(MinZParserRETURN, 0)
}

func (s *ReturnStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, MinZParserRULE_returnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(878)
		p.Match(MinZParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(880)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2037403669757952) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&303535578054393983) != 0) {
		{
			p.SetState(879)
			p.expression(0)
		}

	}
	{
		p.SetState(882)
		p.Match(MinZParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_breakStatement
	return p
}

func InitEmptyBreakStatementContext(p *BreakStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_breakStatement
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(MinZParserBREAK, 0)
}

func (s *BreakStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (s *BreakStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitBreakStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, MinZParserRULE_breakStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(884)
		p.Match(MinZParserBREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(885)
		p.Match(MinZParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_continueStatement
	return p
}

func InitEmptyContinueStatementContext(p *ContinueStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_continueStatement
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(MinZParserCONTINUE, 0)
}

func (s *ContinueStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, MinZParserRULE_continueStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(887)
		p.Match(MinZParserCONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(888)
		p.Match(MinZParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeferStatementContext is an interface to support dynamic dispatch.
type IDeferStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFER() antlr.TerminalNode
	Expression() IExpressionContext
	SEMICOLON() antlr.TerminalNode
	Block() IBlockContext

	// IsDeferStatementContext differentiates from other interfaces.
	IsDeferStatementContext()
}

type DeferStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferStatementContext() *DeferStatementContext {
	var p = new(DeferStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_deferStatement
	return p
}

func InitEmptyDeferStatementContext(p *DeferStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_deferStatement
}

func (*DeferStatementContext) IsDeferStatementContext() {}

func NewDeferStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeferStatementContext {
	var p = new(DeferStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_deferStatement

	return p
}

func (s *DeferStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeferStatementContext) DEFER() antlr.TerminalNode {
	return s.GetToken(MinZParserDEFER, 0)
}

func (s *DeferStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeferStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *DeferStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *DeferStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeferStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeferStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterDeferStatement(s)
	}
}

func (s *DeferStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitDeferStatement(s)
	}
}

func (s *DeferStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitDeferStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) DeferStatement() (localctx IDeferStatementContext) {
	localctx = NewDeferStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, MinZParserRULE_deferStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(890)
		p.Match(MinZParserDEFER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(895)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(891)
			p.expression(0)
		}
		{
			p.SetState(892)
			p.Match(MinZParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(894)
			p.Block()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentStatementContext is an interface to support dynamic dispatch.
type IAssignmentStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentTarget() IAssignmentTargetContext
	AssignmentOp() IAssignmentOpContext
	Expression() IExpressionContext
	SEMICOLON() antlr.TerminalNode

	// IsAssignmentStatementContext differentiates from other interfaces.
	IsAssignmentStatementContext()
}

type AssignmentStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentStatementContext() *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_assignmentStatement
	return p
}

func InitEmptyAssignmentStatementContext(p *AssignmentStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_assignmentStatement
}

func (*AssignmentStatementContext) IsAssignmentStatementContext() {}

func NewAssignmentStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_assignmentStatement

	return p
}

func (s *AssignmentStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentStatementContext) AssignmentTarget() IAssignmentTargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentTargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentTargetContext)
}

func (s *AssignmentStatementContext) AssignmentOp() IAssignmentOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOpContext)
}

func (s *AssignmentStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *AssignmentStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAssignmentStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) AssignmentStatement() (localctx IAssignmentStatementContext) {
	localctx = NewAssignmentStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, MinZParserRULE_assignmentStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(897)
		p.AssignmentTarget()
	}
	{
		p.SetState(898)
		p.AssignmentOp()
	}
	{
		p.SetState(899)
		p.expression(0)
	}
	{
		p.SetState(900)
		p.Match(MinZParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentTargetContext is an interface to support dynamic dispatch.
type IAssignmentTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	DOT() antlr.TerminalNode
	LBRACKET() antlr.TerminalNode
	RBRACKET() antlr.TerminalNode

	// IsAssignmentTargetContext differentiates from other interfaces.
	IsAssignmentTargetContext()
}

type AssignmentTargetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentTargetContext() *AssignmentTargetContext {
	var p = new(AssignmentTargetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_assignmentTarget
	return p
}

func InitEmptyAssignmentTargetContext(p *AssignmentTargetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_assignmentTarget
}

func (*AssignmentTargetContext) IsAssignmentTargetContext() {}

func NewAssignmentTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentTargetContext {
	var p = new(AssignmentTargetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_assignmentTarget

	return p
}

func (s *AssignmentTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentTargetContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *AssignmentTargetContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentTargetContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentTargetContext) DOT() antlr.TerminalNode {
	return s.GetToken(MinZParserDOT, 0)
}

func (s *AssignmentTargetContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACKET, 0)
}

func (s *AssignmentTargetContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACKET, 0)
}

func (s *AssignmentTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAssignmentTarget(s)
	}
}

func (s *AssignmentTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAssignmentTarget(s)
	}
}

func (s *AssignmentTargetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAssignmentTarget(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) AssignmentTarget() (localctx IAssignmentTargetContext) {
	localctx = NewAssignmentTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, MinZParserRULE_assignmentTarget)
	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(902)
			p.Match(MinZParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(903)
			p.expression(0)
		}
		{
			p.SetState(904)
			p.Match(MinZParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(905)
			p.Match(MinZParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(907)
			p.expression(0)
		}
		{
			p.SetState(908)
			p.Match(MinZParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(909)
			p.expression(0)
		}
		{
			p.SetState(910)
			p.Match(MinZParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentOpContext is an interface to support dynamic dispatch.
type IAssignmentOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	PLUS_ASSIGN() antlr.TerminalNode
	MINUS_ASSIGN() antlr.TerminalNode
	STAR_ASSIGN() antlr.TerminalNode
	DIV_ASSIGN() antlr.TerminalNode
	MOD_ASSIGN() antlr.TerminalNode
	AND_ASSIGN() antlr.TerminalNode
	OR_ASSIGN() antlr.TerminalNode
	XOR_ASSIGN() antlr.TerminalNode
	SHL_ASSIGN() antlr.TerminalNode
	SHR_ASSIGN() antlr.TerminalNode

	// IsAssignmentOpContext differentiates from other interfaces.
	IsAssignmentOpContext()
}

type AssignmentOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOpContext() *AssignmentOpContext {
	var p = new(AssignmentOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_assignmentOp
	return p
}

func InitEmptyAssignmentOpContext(p *AssignmentOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_assignmentOp
}

func (*AssignmentOpContext) IsAssignmentOpContext() {}

func NewAssignmentOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOpContext {
	var p = new(AssignmentOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_assignmentOp

	return p
}

func (s *AssignmentOpContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOpContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserASSIGN, 0)
}

func (s *AssignmentOpContext) PLUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserPLUS_ASSIGN, 0)
}

func (s *AssignmentOpContext) MINUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserMINUS_ASSIGN, 0)
}

func (s *AssignmentOpContext) STAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserSTAR_ASSIGN, 0)
}

func (s *AssignmentOpContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserDIV_ASSIGN, 0)
}

func (s *AssignmentOpContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserMOD_ASSIGN, 0)
}

func (s *AssignmentOpContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserAND_ASSIGN, 0)
}

func (s *AssignmentOpContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserOR_ASSIGN, 0)
}

func (s *AssignmentOpContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserXOR_ASSIGN, 0)
}

func (s *AssignmentOpContext) SHL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserSHL_ASSIGN, 0)
}

func (s *AssignmentOpContext) SHR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MinZParserSHR_ASSIGN, 0)
}

func (s *AssignmentOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAssignmentOp(s)
	}
}

func (s *AssignmentOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAssignmentOp(s)
	}
}

func (s *AssignmentOpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAssignmentOp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) AssignmentOp() (localctx IAssignmentOpContext) {
	localctx = NewAssignmentOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, MinZParserRULE_assignmentOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(914)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-99)) & ^0x3f) == 0 && ((int64(1)<<(_la-99))&2047) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	SEMICOLON() antlr.TerminalNode

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_expressionStatement
	return p
}

func InitEmptyExpressionStatementContext(p *ExpressionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_expressionStatement
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(MinZParserSEMICOLON, 0)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, MinZParserRULE_expressionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(916)
		p.expression(0)
	}
	{
		p.SetState(917)
		p.Match(MinZParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *BlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *BlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, MinZParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(919)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2039868318291976) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&303535578054393983) != 0) {
		{
			p.SetState(920)
			p.Statement()
		}

		p.SetState(925)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(926)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsmBlockContext is an interface to support dynamic dispatch.
type IAsmBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASM() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AsmContent() IAsmContentContext

	// IsAsmBlockContext differentiates from other interfaces.
	IsAsmBlockContext()
}

type AsmBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmBlockContext() *AsmBlockContext {
	var p = new(AsmBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmBlock
	return p
}

func InitEmptyAsmBlockContext(p *AsmBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmBlock
}

func (*AsmBlockContext) IsAsmBlockContext() {}

func NewAsmBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmBlockContext {
	var p = new(AsmBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_asmBlock

	return p
}

func (s *AsmBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmBlockContext) ASM() antlr.TerminalNode {
	return s.GetToken(MinZParserASM, 0)
}

func (s *AsmBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *AsmBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *AsmBlockContext) AsmContent() IAsmContentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmContentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmContentContext)
}

func (s *AsmBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAsmBlock(s)
	}
}

func (s *AsmBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAsmBlock(s)
	}
}

func (s *AsmBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAsmBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) AsmBlock() (localctx IAsmBlockContext) {
	localctx = NewAsmBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, MinZParserRULE_asmBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(928)
		p.Match(MinZParserASM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(929)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(931)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(930)
			p.AsmContent()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(933)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompileTimeAsmContext is an interface to support dynamic dispatch.
type ICompileTimeAsmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AsmContent() IAsmContentContext

	// IsCompileTimeAsmContext differentiates from other interfaces.
	IsCompileTimeAsmContext()
}

type CompileTimeAsmContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompileTimeAsmContext() *CompileTimeAsmContext {
	var p = new(CompileTimeAsmContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_compileTimeAsm
	return p
}

func InitEmptyCompileTimeAsmContext(p *CompileTimeAsmContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_compileTimeAsm
}

func (*CompileTimeAsmContext) IsCompileTimeAsmContext() {}

func NewCompileTimeAsmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompileTimeAsmContext {
	var p = new(CompileTimeAsmContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_compileTimeAsm

	return p
}

func (s *CompileTimeAsmContext) GetParser() antlr.Parser { return s.parser }

func (s *CompileTimeAsmContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *CompileTimeAsmContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *CompileTimeAsmContext) AsmContent() IAsmContentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmContentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmContentContext)
}

func (s *CompileTimeAsmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompileTimeAsmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompileTimeAsmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCompileTimeAsm(s)
	}
}

func (s *CompileTimeAsmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCompileTimeAsm(s)
	}
}

func (s *CompileTimeAsmContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitCompileTimeAsm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) CompileTimeAsm() (localctx ICompileTimeAsmContext) {
	localctx = NewCompileTimeAsmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, MinZParserRULE_compileTimeAsm)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(935)
		p.Match(MinZParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(936)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(938)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(937)
			p.AsmContent()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(940)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirBlockContext is an interface to support dynamic dispatch.
type IMirBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MIR() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	MirContent() IMirContentContext

	// IsMirBlockContext differentiates from other interfaces.
	IsMirBlockContext()
}

type MirBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMirBlockContext() *MirBlockContext {
	var p = new(MirBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirBlock
	return p
}

func InitEmptyMirBlockContext(p *MirBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirBlock
}

func (*MirBlockContext) IsMirBlockContext() {}

func NewMirBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirBlockContext {
	var p = new(MirBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirBlock

	return p
}

func (s *MirBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *MirBlockContext) MIR() antlr.TerminalNode {
	return s.GetToken(MinZParserMIR, 0)
}

func (s *MirBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *MirBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *MirBlockContext) MirContent() IMirContentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirContentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirContentContext)
}

func (s *MirBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirBlock(s)
	}
}

func (s *MirBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirBlock(s)
	}
}

func (s *MirBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMirBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MirBlock() (localctx IMirBlockContext) {
	localctx = NewMirBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, MinZParserRULE_mirBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(942)
		p.Match(MinZParserMIR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(943)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(945)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(944)
			p.MirContent()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(947)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMinzBlockContext is an interface to support dynamic dispatch.
type IMinzBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	MinzContent() IMinzContentContext

	// IsMinzBlockContext differentiates from other interfaces.
	IsMinzBlockContext()
}

type MinzBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMinzBlockContext() *MinzBlockContext {
	var p = new(MinzBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_minzBlock
	return p
}

func InitEmptyMinzBlockContext(p *MinzBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_minzBlock
}

func (*MinzBlockContext) IsMinzBlockContext() {}

func NewMinzBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinzBlockContext {
	var p = new(MinzBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_minzBlock

	return p
}

func (s *MinzBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *MinzBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *MinzBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *MinzBlockContext) MinzContent() IMinzContentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMinzContentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMinzContentContext)
}

func (s *MinzBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinzBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinzBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMinzBlock(s)
	}
}

func (s *MinzBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMinzBlock(s)
	}
}

func (s *MinzBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMinzBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MinzBlock() (localctx IMinzBlockContext) {
	localctx = NewMinzBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, MinZParserRULE_minzBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(949)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(950)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(952)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(951)
			p.MinzContent()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(954)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMinzContentContext is an interface to support dynamic dispatch.
type IMinzContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMINZ_CODE_CONTENT() []antlr.TerminalNode
	MINZ_CODE_CONTENT(i int) antlr.TerminalNode

	// IsMinzContentContext differentiates from other interfaces.
	IsMinzContentContext()
}

type MinzContentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMinzContentContext() *MinzContentContext {
	var p = new(MinzContentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_minzContent
	return p
}

func InitEmptyMinzContentContext(p *MinzContentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_minzContent
}

func (*MinzContentContext) IsMinzContentContext() {}

func NewMinzContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinzContentContext {
	var p = new(MinzContentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_minzContent

	return p
}

func (s *MinzContentContext) GetParser() antlr.Parser { return s.parser }

func (s *MinzContentContext) AllMINZ_CODE_CONTENT() []antlr.TerminalNode {
	return s.GetTokens(MinZParserMINZ_CODE_CONTENT)
}

func (s *MinzContentContext) MINZ_CODE_CONTENT(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserMINZ_CODE_CONTENT, i)
}

func (s *MinzContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinzContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinzContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMinzContent(s)
	}
}

func (s *MinzContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMinzContent(s)
	}
}

func (s *MinzContentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMinzContent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MinzContent() (localctx IMinzContentContext) {
	localctx = NewMinzContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, MinZParserRULE_minzContent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserMINZ_CODE_CONTENT {
		{
			p.SetState(956)
			p.Match(MinZParserMINZ_CODE_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(961)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetBlockContext is an interface to support dynamic dispatch.
type ITargetBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTargetName returns the targetName token.
	GetTargetName() antlr.Token

	// SetTargetName sets the targetName token.
	SetTargetName(antlr.Token)

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Block() IBlockContext
	STRING() antlr.TerminalNode

	// IsTargetBlockContext differentiates from other interfaces.
	IsTargetBlockContext()
}

type TargetBlockContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	targetName antlr.Token
}

func NewEmptyTargetBlockContext() *TargetBlockContext {
	var p = new(TargetBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_targetBlock
	return p
}

func InitEmptyTargetBlockContext(p *TargetBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_targetBlock
}

func (*TargetBlockContext) IsTargetBlockContext() {}

func NewTargetBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetBlockContext {
	var p = new(TargetBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_targetBlock

	return p
}

func (s *TargetBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetBlockContext) GetTargetName() antlr.Token { return s.targetName }

func (s *TargetBlockContext) SetTargetName(v antlr.Token) { s.targetName = v }

func (s *TargetBlockContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *TargetBlockContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *TargetBlockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TargetBlockContext) STRING() antlr.TerminalNode {
	return s.GetToken(MinZParserSTRING, 0)
}

func (s *TargetBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterTargetBlock(s)
	}
}

func (s *TargetBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitTargetBlock(s)
	}
}

func (s *TargetBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitTargetBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) TargetBlock() (localctx ITargetBlockContext) {
	localctx = NewTargetBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, MinZParserRULE_targetBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(962)
		p.Match(MinZParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(963)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(964)

		var _m = p.Match(MinZParserSTRING)

		localctx.(*TargetBlockContext).targetName = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(965)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(966)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShiftContext struct {
	ExpressionContext
	op antlr.Token
}

func NewShiftContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShiftContext {
	var p = new(ShiftContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ShiftContext) GetOp() antlr.Token { return s.op }

func (s *ShiftContext) SetOp(v antlr.Token) { s.op = v }

func (s *ShiftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ShiftContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShiftContext) SHL() antlr.TerminalNode {
	return s.GetToken(MinZParserSHL, 0)
}

func (s *ShiftContext) SHR() antlr.TerminalNode {
	return s.GetToken(MinZParserSHR, 0)
}

func (s *ShiftContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterShift(s)
	}
}

func (s *ShiftContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitShift(s)
	}
}

func (s *ShiftContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitShift(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastContext struct {
	ExpressionContext
	targetType ITypeContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CastContext) GetTargetType() ITypeContext { return s.targetType }

func (s *CastContext) SetTargetType(v ITypeContext) { s.targetType = v }

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(MinZParserAS, 0)
}

func (s *CastContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCast(s)
	}
}

func (s *CastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitCast(s)

	default:
		return t.VisitChildren(s)
	}
}

type CallContext struct {
	ExpressionContext
}

func NewCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CallContext {
	var p = new(CallContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *CallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *CallContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *CallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCall(s)
	}
}

func (s *CallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCall(s)
	}
}

func (s *CallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type IfExprContext struct {
	ExpressionContext
}

func NewIfExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IfExprContext {
	var p = new(IfExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *IfExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExprContext) IfExpression() IIfExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExpressionContext)
}

func (s *IfExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterIfExpr(s)
	}
}

func (s *IfExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitIfExpr(s)
	}
}

func (s *IfExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitIfExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type IndexAccessContext struct {
	ExpressionContext
	index IExpressionContext
}

func NewIndexAccessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexAccessContext {
	var p = new(IndexAccessContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *IndexAccessContext) GetIndex() IExpressionContext { return s.index }

func (s *IndexAccessContext) SetIndex(v IExpressionContext) { s.index = v }

func (s *IndexAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexAccessContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IndexAccessContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexAccessContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACKET, 0)
}

func (s *IndexAccessContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACKET, 0)
}

func (s *IndexAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterIndexAccess(s)
	}
}

func (s *IndexAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitIndexAccess(s)
	}
}

func (s *IndexAccessContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitIndexAccess(s)

	default:
		return t.VisitChildren(s)
	}
}

type RelationalContext struct {
	ExpressionContext
	op antlr.Token
}

func NewRelationalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationalContext {
	var p = new(RelationalContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *RelationalContext) GetOp() antlr.Token { return s.op }

func (s *RelationalContext) SetOp(v antlr.Token) { s.op = v }

func (s *RelationalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RelationalContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RelationalContext) LT() antlr.TerminalNode {
	return s.GetToken(MinZParserLT, 0)
}

func (s *RelationalContext) LE() antlr.TerminalNode {
	return s.GetToken(MinZParserLE, 0)
}

func (s *RelationalContext) GT() antlr.TerminalNode {
	return s.GetToken(MinZParserGT, 0)
}

func (s *RelationalContext) GE() antlr.TerminalNode {
	return s.GetToken(MinZParserGE, 0)
}

func (s *RelationalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterRelational(s)
	}
}

func (s *RelationalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitRelational(s)
	}
}

func (s *RelationalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitRelational(s)

	default:
		return t.VisitChildren(s)
	}
}

type ErrorCheckContext struct {
	ExpressionContext
}

func NewErrorCheckContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ErrorCheckContext {
	var p = new(ErrorCheckContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ErrorCheckContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCheckContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ErrorCheckContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(MinZParserQUESTION, 0)
}

func (s *ErrorCheckContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterErrorCheck(s)
	}
}

func (s *ErrorCheckContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitErrorCheck(s)
	}
}

func (s *ErrorCheckContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitErrorCheck(s)

	default:
		return t.VisitChildren(s)
	}
}

type MetafunctionCallContext struct {
	ExpressionContext
}

func NewMetafunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MetafunctionCallContext {
	var p = new(MetafunctionCallContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MetafunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetafunctionCallContext) MetafunctionExpr() IMetafunctionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMetafunctionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMetafunctionExprContext)
}

func (s *MetafunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMetafunctionCall(s)
	}
}

func (s *MetafunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMetafunctionCall(s)
	}
}

func (s *MetafunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMetafunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type RangeContext struct {
	ExpressionContext
	op antlr.Token
}

func NewRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RangeContext {
	var p = new(RangeContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *RangeContext) GetOp() antlr.Token { return s.op }

func (s *RangeContext) SetOp(v antlr.Token) { s.op = v }

func (s *RangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RangeContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RangeContext) RANGE() antlr.TerminalNode {
	return s.GetToken(MinZParserRANGE, 0)
}

func (s *RangeContext) RANGE_INCLUSIVE() antlr.TerminalNode {
	return s.GetToken(MinZParserRANGE_INCLUSIVE, 0)
}

func (s *RangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterRange(s)
	}
}

func (s *RangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitRange(s)
	}
}

func (s *RangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitRange(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryContext struct {
	ExpressionContext
	op antlr.Token
}

func NewUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryContext {
	var p = new(UnaryContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryContext) GetOp() antlr.Token { return s.op }

func (s *UnaryContext) SetOp(v antlr.Token) { s.op = v }

func (s *UnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryContext) BANG() antlr.TerminalNode {
	return s.GetToken(MinZParserBANG, 0)
}

func (s *UnaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MinZParserMINUS, 0)
}

func (s *UnaryContext) TILDE() antlr.TerminalNode {
	return s.GetToken(MinZParserTILDE, 0)
}

func (s *UnaryContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(MinZParserAMPERSAND, 0)
}

func (s *UnaryContext) STAR() antlr.TerminalNode {
	return s.GetToken(MinZParserSTAR, 0)
}

func (s *UnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterUnary(s)
	}
}

func (s *UnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitUnary(s)
	}
}

func (s *UnaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitUnary(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalOrContext struct {
	ExpressionContext
	op antlr.Token
}

func NewLogicalOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalOrContext {
	var p = new(LogicalOrContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalOrContext) GetOp() antlr.Token { return s.op }

func (s *LogicalOrContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalOrContext) LOGICAL_OR() antlr.TerminalNode {
	return s.GetToken(MinZParserLOGICAL_OR, 0)
}

func (s *LogicalOrContext) OR() antlr.TerminalNode {
	return s.GetToken(MinZParserOR, 0)
}

func (s *LogicalOrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLogicalOr(s)
	}
}

func (s *LogicalOrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLogicalOr(s)
	}
}

func (s *LogicalOrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitLogicalOr(s)

	default:
		return t.VisitChildren(s)
	}
}

type MultiplicativeContext struct {
	ExpressionContext
	op antlr.Token
}

func NewMultiplicativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicativeContext {
	var p = new(MultiplicativeContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MultiplicativeContext) GetOp() antlr.Token { return s.op }

func (s *MultiplicativeContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultiplicativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultiplicativeContext) STAR() antlr.TerminalNode {
	return s.GetToken(MinZParserSTAR, 0)
}

func (s *MultiplicativeContext) DIV() antlr.TerminalNode {
	return s.GetToken(MinZParserDIV, 0)
}

func (s *MultiplicativeContext) MOD() antlr.TerminalNode {
	return s.GetToken(MinZParserMOD, 0)
}

func (s *MultiplicativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMultiplicative(s)
	}
}

func (s *MultiplicativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMultiplicative(s)
	}
}

func (s *MultiplicativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMultiplicative(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdditiveContext struct {
	ExpressionContext
	op antlr.Token
}

func NewAdditiveContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditiveContext {
	var p = new(AdditiveContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *AdditiveContext) GetOp() antlr.Token { return s.op }

func (s *AdditiveContext) SetOp(v antlr.Token) { s.op = v }

func (s *AdditiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AdditiveContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MinZParserPLUS, 0)
}

func (s *AdditiveContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MinZParserMINUS, 0)
}

func (s *AdditiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAdditive(s)
	}
}

func (s *AdditiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAdditive(s)
	}
}

func (s *AdditiveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAdditive(s)

	default:
		return t.VisitChildren(s)
	}
}

type MemberAccessContext struct {
	ExpressionContext
	member antlr.Token
}

func NewMemberAccessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberAccessContext {
	var p = new(MemberAccessContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MemberAccessContext) GetMember() antlr.Token { return s.member }

func (s *MemberAccessContext) SetMember(v antlr.Token) { s.member = v }

func (s *MemberAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberAccessContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MemberAccessContext) DOT() antlr.TerminalNode {
	return s.GetToken(MinZParserDOT, 0)
}

func (s *MemberAccessContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *MemberAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMemberAccess(s)
	}
}

func (s *MemberAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMemberAccess(s)
	}
}

func (s *MemberAccessContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMemberAccess(s)

	default:
		return t.VisitChildren(s)
	}
}

type ErrorDefaultContext struct {
	ExpressionContext
	defaultValue IExpressionContext
}

func NewErrorDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ErrorDefaultContext {
	var p = new(ErrorDefaultContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ErrorDefaultContext) GetDefaultValue() IExpressionContext { return s.defaultValue }

func (s *ErrorDefaultContext) SetDefaultValue(v IExpressionContext) { s.defaultValue = v }

func (s *ErrorDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorDefaultContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ErrorDefaultContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ErrorDefaultContext) DOUBLE_QUESTION() antlr.TerminalNode {
	return s.GetToken(MinZParserDOUBLE_QUESTION, 0)
}

func (s *ErrorDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterErrorDefault(s)
	}
}

func (s *ErrorDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitErrorDefault(s)
	}
}

func (s *ErrorDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitErrorDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitwiseXorContext struct {
	ExpressionContext
	op antlr.Token
}

func NewBitwiseXorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitwiseXorContext {
	var p = new(BitwiseXorContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitwiseXorContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseXorContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseXorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseXorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseXorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseXorContext) CARET() antlr.TerminalNode {
	return s.GetToken(MinZParserCARET, 0)
}

func (s *BitwiseXorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBitwiseXor(s)
	}
}

func (s *BitwiseXorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBitwiseXor(s)
	}
}

func (s *BitwiseXorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitBitwiseXor(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitwiseOrContext struct {
	ExpressionContext
	op antlr.Token
}

func NewBitwiseOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitwiseOrContext {
	var p = new(BitwiseOrContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitwiseOrContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseOrContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseOrContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseOrContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseOrContext) PIPE() antlr.TerminalNode {
	return s.GetToken(MinZParserPIPE, 0)
}

func (s *BitwiseOrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBitwiseOr(s)
	}
}

func (s *BitwiseOrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBitwiseOr(s)
	}
}

func (s *BitwiseOrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitBitwiseOr(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryContext struct {
	ExpressionContext
}

func NewPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryContext {
	var p = new(PrimaryContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (s *PrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalAndContext struct {
	ExpressionContext
	op antlr.Token
}

func NewLogicalAndContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalAndContext {
	var p = new(LogicalAndContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalAndContext) GetOp() antlr.Token { return s.op }

func (s *LogicalAndContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalAndContext) LOGICAL_AND() antlr.TerminalNode {
	return s.GetToken(MinZParserLOGICAL_AND, 0)
}

func (s *LogicalAndContext) AND() antlr.TerminalNode {
	return s.GetToken(MinZParserAND, 0)
}

func (s *LogicalAndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLogicalAnd(s)
	}
}

func (s *LogicalAndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLogicalAnd(s)
	}
}

func (s *LogicalAndContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitLogicalAnd(s)

	default:
		return t.VisitChildren(s)
	}
}

type WhenExprContext struct {
	ExpressionContext
}

func NewWhenExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhenExprContext {
	var p = new(WhenExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *WhenExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenExprContext) WhenExpression() IWhenExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenExpressionContext)
}

func (s *WhenExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterWhenExpr(s)
	}
}

func (s *WhenExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitWhenExpr(s)
	}
}

func (s *WhenExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitWhenExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitwiseAndContext struct {
	ExpressionContext
	op antlr.Token
}

func NewBitwiseAndContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitwiseAndContext {
	var p = new(BitwiseAndContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitwiseAndContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseAndContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseAndContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseAndContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseAndContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(MinZParserAMPERSAND, 0)
}

func (s *BitwiseAndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBitwiseAnd(s)
	}
}

func (s *BitwiseAndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBitwiseAnd(s)
	}
}

func (s *BitwiseAndContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitBitwiseAnd(s)

	default:
		return t.VisitChildren(s)
	}
}

type EqualityContext struct {
	ExpressionContext
	op antlr.Token
}

func NewEqualityContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityContext {
	var p = new(EqualityContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *EqualityContext) GetOp() antlr.Token { return s.op }

func (s *EqualityContext) SetOp(v antlr.Token) { s.op = v }

func (s *EqualityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EqualityContext) EQ() antlr.TerminalNode {
	return s.GetToken(MinZParserEQ, 0)
}

func (s *EqualityContext) NE() antlr.TerminalNode {
	return s.GetToken(MinZParserNE, 0)
}

func (s *EqualityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterEquality(s)
	}
}

func (s *EqualityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitEquality(s)
	}
}

func (s *EqualityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitEquality(s)

	default:
		return t.VisitChildren(s)
	}
}

type LambdaContext struct {
	ExpressionContext
}

func NewLambdaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaContext {
	var p = new(LambdaContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLambda(s)
	}
}

func (s *LambdaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitLambda(s)

	default:
		return t.VisitChildren(s)
	}
}

type TernaryExprContext struct {
	ExpressionContext
}

func NewTernaryExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TernaryExprContext {
	var p = new(TernaryExprContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *TernaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryExprContext) TernaryExpression() ITernaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITernaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITernaryExpressionContext)
}

func (s *TernaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterTernaryExpr(s)
	}
}

func (s *TernaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitTernaryExpr(s)
	}
}

func (s *TernaryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitTernaryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *MinZParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 174
	p.EnterRecursionRule(localctx, 174, MinZParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(977)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPrimaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(969)
			p.PrimaryExpression()
		}

	case 2:
		localctx = NewUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(970)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnaryContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-111)) & ^0x3f) == 0 && ((int64(1)<<(_la-111))&403) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnaryContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(971)
			p.expression(17)
		}

	case 3:
		localctx = NewLambdaContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(972)
			p.LambdaExpression()
		}

	case 4:
		localctx = NewIfExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(973)
			p.IfExpression()
		}

	case 5:
		localctx = NewTernaryExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(974)
			p.TernaryExpression()
		}

	case 6:
		localctx = NewWhenExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(975)
			p.WhenExpression()
		}

	case 7:
		localctx = NewMetafunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(976)
			p.MetafunctionExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1036)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1034)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) {
			case 1:
				localctx = NewErrorDefaultContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(979)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(980)
					p.Match(MinZParserDOUBLE_QUESTION)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(981)

					var _x = p.expression(20)

					localctx.(*ErrorDefaultContext).defaultValue = _x
				}

			case 2:
				localctx = NewMultiplicativeContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(982)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(983)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*MultiplicativeContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&7) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*MultiplicativeContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(984)
					p.expression(17)
				}

			case 3:
				localctx = NewAdditiveContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(985)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(986)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*AdditiveContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MinZParserPLUS || _la == MinZParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*AdditiveContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(987)
					p.expression(16)
				}

			case 4:
				localctx = NewShiftContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(988)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(989)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ShiftContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MinZParserSHL || _la == MinZParserSHR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ShiftContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(990)
					p.expression(15)
				}

			case 5:
				localctx = NewRangeContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(991)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(992)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RangeContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MinZParserRANGE || _la == MinZParserRANGE_INCLUSIVE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RangeContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(993)
					p.expression(14)
				}

			case 6:
				localctx = NewRelationalContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(994)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(995)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RelationalContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-93)) & ^0x3f) == 0 && ((int64(1)<<(_la-93))&15) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RelationalContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(996)
					p.expression(13)
				}

			case 7:
				localctx = NewEqualityContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(997)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(998)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*EqualityContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MinZParserEQ || _la == MinZParserNE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*EqualityContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(999)
					p.expression(12)
				}

			case 8:
				localctx = NewBitwiseAndContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(1000)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(1001)

					var _m = p.Match(MinZParserAMPERSAND)

					localctx.(*BitwiseAndContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1002)
					p.expression(11)
				}

			case 9:
				localctx = NewBitwiseXorContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(1003)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(1004)

					var _m = p.Match(MinZParserCARET)

					localctx.(*BitwiseXorContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1005)
					p.expression(10)
				}

			case 10:
				localctx = NewBitwiseOrContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(1006)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(1007)

					var _m = p.Match(MinZParserPIPE)

					localctx.(*BitwiseOrContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1008)
					p.expression(9)
				}

			case 11:
				localctx = NewLogicalAndContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(1009)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(1010)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalAndContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MinZParserAND || _la == MinZParserLOGICAL_AND) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalAndContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1011)
					p.expression(8)
				}

			case 12:
				localctx = NewLogicalOrContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(1012)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(1013)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalOrContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MinZParserOR || _la == MinZParserLOGICAL_OR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalOrContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1014)
					p.expression(7)
				}

			case 13:
				localctx = NewCallContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(1015)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(1016)
					p.Match(MinZParserLPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1018)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2037403669757952) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&303535578054393983) != 0) {
					{
						p.SetState(1017)
						p.ArgumentList()
					}

				}
				{
					p.SetState(1020)
					p.Match(MinZParserRPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 14:
				localctx = NewMemberAccessContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(1021)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
					goto errorExit
				}
				{
					p.SetState(1022)
					p.Match(MinZParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1023)

					var _m = p.Match(MinZParserIDENTIFIER)

					localctx.(*MemberAccessContext).member = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 15:
				localctx = NewIndexAccessContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(1024)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
					goto errorExit
				}
				{
					p.SetState(1025)
					p.Match(MinZParserLBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1026)

					var _x = p.expression(0)

					localctx.(*IndexAccessContext).index = _x
				}
				{
					p.SetState(1027)
					p.Match(MinZParserRBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 16:
				localctx = NewErrorCheckContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(1029)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
					goto errorExit
				}
				{
					p.SetState(1030)
					p.Match(MinZParserQUESTION)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 17:
				localctx = NewCastContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MinZParserRULE_expression)
				p.SetState(1031)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(1032)
					p.Match(MinZParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1033)

					var _x = p.Type_()

					localctx.(*CastContext).targetType = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	IDENTIFIER() antlr.TerminalNode
	SELF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	ArrayLiteral() IArrayLiteralContext
	ArrayInitializer() IArrayInitializerContext
	StructLiteral() IStructLiteralContext
	TupleLiteral() ITupleLiteralContext
	Block() IBlockContext
	InlineAssembly() IInlineAssemblyContext
	SizeofExpression() ISizeofExpressionContext
	AlignofExpression() IAlignofExpressionContext
	ErrorLiteral() IErrorLiteralContext

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryExpressionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *PrimaryExpressionContext) SELF() antlr.TerminalNode {
	return s.GetToken(MinZParserSELF, 0)
}

func (s *PrimaryExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *PrimaryExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *PrimaryExpressionContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *PrimaryExpressionContext) ArrayInitializer() IArrayInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *PrimaryExpressionContext) StructLiteral() IStructLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructLiteralContext)
}

func (s *PrimaryExpressionContext) TupleLiteral() ITupleLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleLiteralContext)
}

func (s *PrimaryExpressionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *PrimaryExpressionContext) InlineAssembly() IInlineAssemblyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineAssemblyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineAssemblyContext)
}

func (s *PrimaryExpressionContext) SizeofExpression() ISizeofExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISizeofExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISizeofExpressionContext)
}

func (s *PrimaryExpressionContext) AlignofExpression() IAlignofExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlignofExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlignofExpressionContext)
}

func (s *PrimaryExpressionContext) ErrorLiteral() IErrorLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorLiteralContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitPrimaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, MinZParserRULE_primaryExpression)
	p.SetState(1055)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1039)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1040)
			p.Match(MinZParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1041)
			p.Match(MinZParserSELF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1042)
			p.Match(MinZParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1043)
			p.expression(0)
		}
		{
			p.SetState(1044)
			p.Match(MinZParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1046)
			p.ArrayLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1047)
			p.ArrayInitializer()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1048)
			p.StructLiteral()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1049)
			p.TupleLiteral()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1050)
			p.Block()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1051)
			p.InlineAssembly()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1052)
			p.SizeofExpression()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1053)
			p.AlignofExpression()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1054)
			p.ErrorLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER() antlr.TerminalNode
	HEX_INTEGER() antlr.TerminalNode
	BINARY_INTEGER() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	STRING() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	NULL() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MinZParserINTEGER, 0)
}

func (s *LiteralContext) HEX_INTEGER() antlr.TerminalNode {
	return s.GetToken(MinZParserHEX_INTEGER, 0)
}

func (s *LiteralContext) BINARY_INTEGER() antlr.TerminalNode {
	return s.GetToken(MinZParserBINARY_INTEGER, 0)
}

func (s *LiteralContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(MinZParserFLOAT, 0)
}

func (s *LiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(MinZParserSTRING, 0)
}

func (s *LiteralContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MinZParserCHAR, 0)
}

func (s *LiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MinZParserTRUE, 0)
}

func (s *LiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MinZParserFALSE, 0)
}

func (s *LiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(MinZParserNULL, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, MinZParserRULE_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1057)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-43)) & ^0x3f) == 0 && ((int64(1)<<(_la-43))&1056964615) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACKET() antlr.TerminalNode
	RBRACKET() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_arrayLiteral
	return p
}

func InitEmptyArrayLiteralContext(p *ArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_arrayLiteral
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACKET, 0)
}

func (s *ArrayLiteralContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACKET, 0)
}

func (s *ArrayLiteralContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, MinZParserRULE_arrayLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1059)
		p.Match(MinZParserLBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2037403669757952) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&303535578054393983) != 0) {
		{
			p.SetState(1060)
			p.ExpressionList()
		}

	}
	{
		p.SetState(1063)
		p.Match(MinZParserRBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayInitializerContext is an interface to support dynamic dispatch.
type IArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsArrayInitializerContext differentiates from other interfaces.
	IsArrayInitializerContext()
}

type ArrayInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayInitializerContext() *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_arrayInitializer
	return p
}

func InitEmptyArrayInitializerContext(p *ArrayInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_arrayInitializer
}

func (*ArrayInitializerContext) IsArrayInitializerContext() {}

func NewArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_arrayInitializer

	return p
}

func (s *ArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *ArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *ArrayInitializerContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterArrayInitializer(s)
	}
}

func (s *ArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitArrayInitializer(s)
	}
}

func (s *ArrayInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitArrayInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ArrayInitializer() (localctx IArrayInitializerContext) {
	localctx = NewArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, MinZParserRULE_arrayInitializer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1065)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1067)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2037403669757952) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&303535578054393983) != 0) {
		{
			p.SetState(1066)
			p.ExpressionList()
		}

	}
	{
		p.SetState(1069)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructLiteralContext is an interface to support dynamic dispatch.
type IStructLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	AllFieldInitializer() []IFieldInitializerContext
	FieldInitializer(i int) IFieldInitializerContext
	RBRACE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStructLiteralContext differentiates from other interfaces.
	IsStructLiteralContext()
}

type StructLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructLiteralContext() *StructLiteralContext {
	var p = new(StructLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_structLiteral
	return p
}

func InitEmptyStructLiteralContext(p *StructLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_structLiteral
}

func (*StructLiteralContext) IsStructLiteralContext() {}

func NewStructLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructLiteralContext {
	var p = new(StructLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_structLiteral

	return p
}

func (s *StructLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StructLiteralContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *StructLiteralContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *StructLiteralContext) AllFieldInitializer() []IFieldInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldInitializerContext); ok {
			len++
		}
	}

	tst := make([]IFieldInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldInitializerContext); ok {
			tst[i] = t.(IFieldInitializerContext)
			i++
		}
	}

	return tst
}

func (s *StructLiteralContext) FieldInitializer(i int) IFieldInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldInitializerContext)
}

func (s *StructLiteralContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *StructLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MinZParserCOMMA)
}

func (s *StructLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, i)
}

func (s *StructLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterStructLiteral(s)
	}
}

func (s *StructLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitStructLiteral(s)
	}
}

func (s *StructLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitStructLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) StructLiteral() (localctx IStructLiteralContext) {
	localctx = NewStructLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, MinZParserRULE_structLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1071)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1072)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1073)
		p.FieldInitializer()
	}
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1074)
				p.Match(MinZParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1075)
				p.FieldInitializer()
			}

		}
		p.SetState(1080)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1082)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserCOMMA {
		{
			p.SetState(1081)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1084)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldInitializerContext is an interface to support dynamic dispatch.
type IFieldInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFieldInitializerContext differentiates from other interfaces.
	IsFieldInitializerContext()
}

type FieldInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldInitializerContext() *FieldInitializerContext {
	var p = new(FieldInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_fieldInitializer
	return p
}

func InitEmptyFieldInitializerContext(p *FieldInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_fieldInitializer
}

func (*FieldInitializerContext) IsFieldInitializerContext() {}

func NewFieldInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldInitializerContext {
	var p = new(FieldInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_fieldInitializer

	return p
}

func (s *FieldInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldInitializerContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *FieldInitializerContext) COLON() antlr.TerminalNode {
	return s.GetToken(MinZParserCOLON, 0)
}

func (s *FieldInitializerContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FieldInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterFieldInitializer(s)
	}
}

func (s *FieldInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitFieldInitializer(s)
	}
}

func (s *FieldInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitFieldInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) FieldInitializer() (localctx IFieldInitializerContext) {
	localctx = NewFieldInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, MinZParserRULE_fieldInitializer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1086)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1087)
		p.Match(MinZParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1088)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleLiteralContext is an interface to support dynamic dispatch.
type ITupleLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	COMMA() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	RPAREN() antlr.TerminalNode

	// IsTupleLiteralContext differentiates from other interfaces.
	IsTupleLiteralContext()
}

type TupleLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleLiteralContext() *TupleLiteralContext {
	var p = new(TupleLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_tupleLiteral
	return p
}

func InitEmptyTupleLiteralContext(p *TupleLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_tupleLiteral
}

func (*TupleLiteralContext) IsTupleLiteralContext() {}

func NewTupleLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleLiteralContext {
	var p = new(TupleLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_tupleLiteral

	return p
}

func (s *TupleLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleLiteralContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *TupleLiteralContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TupleLiteralContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, 0)
}

func (s *TupleLiteralContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *TupleLiteralContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *TupleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterTupleLiteral(s)
	}
}

func (s *TupleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitTupleLiteral(s)
	}
}

func (s *TupleLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitTupleLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) TupleLiteral() (localctx ITupleLiteralContext) {
	localctx = NewTupleLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, MinZParserRULE_tupleLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1090)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1091)
		p.expression(0)
	}
	{
		p.SetState(1092)
		p.Match(MinZParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1093)
		p.ExpressionList()
	}
	{
		p.SetState(1094)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineAssemblyContext is an interface to support dynamic dispatch.
type IInlineAssemblyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASM() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	STRING() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AsmOutputList() IAsmOutputListContext
	AsmInputList() IAsmInputListContext
	AsmClobberList() IAsmClobberListContext

	// IsInlineAssemblyContext differentiates from other interfaces.
	IsInlineAssemblyContext()
}

type InlineAssemblyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineAssemblyContext() *InlineAssemblyContext {
	var p = new(InlineAssemblyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_inlineAssembly
	return p
}

func InitEmptyInlineAssemblyContext(p *InlineAssemblyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_inlineAssembly
}

func (*InlineAssemblyContext) IsInlineAssemblyContext() {}

func NewInlineAssemblyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineAssemblyContext {
	var p = new(InlineAssemblyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_inlineAssembly

	return p
}

func (s *InlineAssemblyContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineAssemblyContext) ASM() antlr.TerminalNode {
	return s.GetToken(MinZParserASM, 0)
}

func (s *InlineAssemblyContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *InlineAssemblyContext) STRING() antlr.TerminalNode {
	return s.GetToken(MinZParserSTRING, 0)
}

func (s *InlineAssemblyContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *InlineAssemblyContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(MinZParserCOLON)
}

func (s *InlineAssemblyContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserCOLON, i)
}

func (s *InlineAssemblyContext) AsmOutputList() IAsmOutputListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmOutputListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmOutputListContext)
}

func (s *InlineAssemblyContext) AsmInputList() IAsmInputListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmInputListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmInputListContext)
}

func (s *InlineAssemblyContext) AsmClobberList() IAsmClobberListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmClobberListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmClobberListContext)
}

func (s *InlineAssemblyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineAssemblyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineAssemblyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterInlineAssembly(s)
	}
}

func (s *InlineAssemblyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitInlineAssembly(s)
	}
}

func (s *InlineAssemblyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitInlineAssembly(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) InlineAssembly() (localctx IInlineAssemblyContext) {
	localctx = NewInlineAssemblyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, MinZParserRULE_inlineAssembly)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1096)
		p.Match(MinZParserASM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1097)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1098)
		p.Match(MinZParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1115)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserCOLON {
		{
			p.SetState(1099)
			p.Match(MinZParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1101)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MinZParserSTRING {
			{
				p.SetState(1100)
				p.AsmOutputList()
			}

		}
		p.SetState(1113)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MinZParserCOLON {
			{
				p.SetState(1103)
				p.Match(MinZParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1105)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MinZParserSTRING {
				{
					p.SetState(1104)
					p.AsmInputList()
				}

			}
			p.SetState(1111)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MinZParserCOLON {
				{
					p.SetState(1107)
					p.Match(MinZParserCOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1109)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MinZParserSTRING {
					{
						p.SetState(1108)
						p.AsmClobberList()
					}

				}

			}

		}

	}
	{
		p.SetState(1117)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsmOutputListContext is an interface to support dynamic dispatch.
type IAsmOutputListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAsmOutput() []IAsmOutputContext
	AsmOutput(i int) IAsmOutputContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAsmOutputListContext differentiates from other interfaces.
	IsAsmOutputListContext()
}

type AsmOutputListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmOutputListContext() *AsmOutputListContext {
	var p = new(AsmOutputListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmOutputList
	return p
}

func InitEmptyAsmOutputListContext(p *AsmOutputListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmOutputList
}

func (*AsmOutputListContext) IsAsmOutputListContext() {}

func NewAsmOutputListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmOutputListContext {
	var p = new(AsmOutputListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_asmOutputList

	return p
}

func (s *AsmOutputListContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmOutputListContext) AllAsmOutput() []IAsmOutputContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAsmOutputContext); ok {
			len++
		}
	}

	tst := make([]IAsmOutputContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAsmOutputContext); ok {
			tst[i] = t.(IAsmOutputContext)
			i++
		}
	}

	return tst
}

func (s *AsmOutputListContext) AsmOutput(i int) IAsmOutputContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmOutputContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmOutputContext)
}

func (s *AsmOutputListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MinZParserCOMMA)
}

func (s *AsmOutputListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, i)
}

func (s *AsmOutputListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmOutputListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmOutputListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAsmOutputList(s)
	}
}

func (s *AsmOutputListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAsmOutputList(s)
	}
}

func (s *AsmOutputListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAsmOutputList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) AsmOutputList() (localctx IAsmOutputListContext) {
	localctx = NewAsmOutputListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, MinZParserRULE_asmOutputList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1119)
		p.AsmOutput()
	}
	p.SetState(1124)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserCOMMA {
		{
			p.SetState(1120)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1121)
			p.AsmOutput()
		}

		p.SetState(1126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsmInputListContext is an interface to support dynamic dispatch.
type IAsmInputListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAsmInput() []IAsmInputContext
	AsmInput(i int) IAsmInputContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAsmInputListContext differentiates from other interfaces.
	IsAsmInputListContext()
}

type AsmInputListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmInputListContext() *AsmInputListContext {
	var p = new(AsmInputListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmInputList
	return p
}

func InitEmptyAsmInputListContext(p *AsmInputListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmInputList
}

func (*AsmInputListContext) IsAsmInputListContext() {}

func NewAsmInputListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmInputListContext {
	var p = new(AsmInputListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_asmInputList

	return p
}

func (s *AsmInputListContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmInputListContext) AllAsmInput() []IAsmInputContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAsmInputContext); ok {
			len++
		}
	}

	tst := make([]IAsmInputContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAsmInputContext); ok {
			tst[i] = t.(IAsmInputContext)
			i++
		}
	}

	return tst
}

func (s *AsmInputListContext) AsmInput(i int) IAsmInputContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmInputContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmInputContext)
}

func (s *AsmInputListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MinZParserCOMMA)
}

func (s *AsmInputListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, i)
}

func (s *AsmInputListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmInputListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmInputListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAsmInputList(s)
	}
}

func (s *AsmInputListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAsmInputList(s)
	}
}

func (s *AsmInputListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAsmInputList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) AsmInputList() (localctx IAsmInputListContext) {
	localctx = NewAsmInputListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, MinZParserRULE_asmInputList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1127)
		p.AsmInput()
	}
	p.SetState(1132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserCOMMA {
		{
			p.SetState(1128)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1129)
			p.AsmInput()
		}

		p.SetState(1134)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsmClobberListContext is an interface to support dynamic dispatch.
type IAsmClobberListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAsmClobberListContext differentiates from other interfaces.
	IsAsmClobberListContext()
}

type AsmClobberListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmClobberListContext() *AsmClobberListContext {
	var p = new(AsmClobberListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmClobberList
	return p
}

func InitEmptyAsmClobberListContext(p *AsmClobberListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmClobberList
}

func (*AsmClobberListContext) IsAsmClobberListContext() {}

func NewAsmClobberListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmClobberListContext {
	var p = new(AsmClobberListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_asmClobberList

	return p
}

func (s *AsmClobberListContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmClobberListContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(MinZParserSTRING)
}

func (s *AsmClobberListContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserSTRING, i)
}

func (s *AsmClobberListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MinZParserCOMMA)
}

func (s *AsmClobberListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, i)
}

func (s *AsmClobberListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmClobberListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmClobberListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAsmClobberList(s)
	}
}

func (s *AsmClobberListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAsmClobberList(s)
	}
}

func (s *AsmClobberListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAsmClobberList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) AsmClobberList() (localctx IAsmClobberListContext) {
	localctx = NewAsmClobberListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, MinZParserRULE_asmClobberList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1135)
		p.Match(MinZParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1140)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserCOMMA {
		{
			p.SetState(1136)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1137)
			p.Match(MinZParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1142)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsmOutputContext is an interface to support dynamic dispatch.
type IAsmOutputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsAsmOutputContext differentiates from other interfaces.
	IsAsmOutputContext()
}

type AsmOutputContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmOutputContext() *AsmOutputContext {
	var p = new(AsmOutputContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmOutput
	return p
}

func InitEmptyAsmOutputContext(p *AsmOutputContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmOutput
}

func (*AsmOutputContext) IsAsmOutputContext() {}

func NewAsmOutputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmOutputContext {
	var p = new(AsmOutputContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_asmOutput

	return p
}

func (s *AsmOutputContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmOutputContext) STRING() antlr.TerminalNode {
	return s.GetToken(MinZParserSTRING, 0)
}

func (s *AsmOutputContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *AsmOutputContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *AsmOutputContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *AsmOutputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmOutputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmOutputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAsmOutput(s)
	}
}

func (s *AsmOutputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAsmOutput(s)
	}
}

func (s *AsmOutputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAsmOutput(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) AsmOutput() (localctx IAsmOutputContext) {
	localctx = NewAsmOutputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, MinZParserRULE_asmOutput)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1143)
		p.Match(MinZParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1144)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1145)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1146)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsmInputContext is an interface to support dynamic dispatch.
type IAsmInputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsAsmInputContext differentiates from other interfaces.
	IsAsmInputContext()
}

type AsmInputContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmInputContext() *AsmInputContext {
	var p = new(AsmInputContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmInput
	return p
}

func InitEmptyAsmInputContext(p *AsmInputContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmInput
}

func (*AsmInputContext) IsAsmInputContext() {}

func NewAsmInputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmInputContext {
	var p = new(AsmInputContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_asmInput

	return p
}

func (s *AsmInputContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmInputContext) STRING() antlr.TerminalNode {
	return s.GetToken(MinZParserSTRING, 0)
}

func (s *AsmInputContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *AsmInputContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AsmInputContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *AsmInputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmInputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmInputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAsmInput(s)
	}
}

func (s *AsmInputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAsmInput(s)
	}
}

func (s *AsmInputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAsmInput(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) AsmInput() (localctx IAsmInputContext) {
	localctx = NewAsmInputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, MinZParserRULE_asmInput)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1148)
		p.Match(MinZParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1149)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1150)
		p.expression(0)
	}
	{
		p.SetState(1151)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISizeofExpressionContext is an interface to support dynamic dispatch.
type ISizeofExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SIZEOF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Type_() ITypeContext
	RPAREN() antlr.TerminalNode

	// IsSizeofExpressionContext differentiates from other interfaces.
	IsSizeofExpressionContext()
}

type SizeofExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySizeofExpressionContext() *SizeofExpressionContext {
	var p = new(SizeofExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_sizeofExpression
	return p
}

func InitEmptySizeofExpressionContext(p *SizeofExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_sizeofExpression
}

func (*SizeofExpressionContext) IsSizeofExpressionContext() {}

func NewSizeofExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SizeofExpressionContext {
	var p = new(SizeofExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_sizeofExpression

	return p
}

func (s *SizeofExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SizeofExpressionContext) SIZEOF() antlr.TerminalNode {
	return s.GetToken(MinZParserSIZEOF, 0)
}

func (s *SizeofExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *SizeofExpressionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *SizeofExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *SizeofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SizeofExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SizeofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterSizeofExpression(s)
	}
}

func (s *SizeofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitSizeofExpression(s)
	}
}

func (s *SizeofExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitSizeofExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) SizeofExpression() (localctx ISizeofExpressionContext) {
	localctx = NewSizeofExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, MinZParserRULE_sizeofExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1153)
		p.Match(MinZParserSIZEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1154)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1155)
		p.Type_()
	}
	{
		p.SetState(1156)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlignofExpressionContext is an interface to support dynamic dispatch.
type IAlignofExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALIGNOF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Type_() ITypeContext
	RPAREN() antlr.TerminalNode

	// IsAlignofExpressionContext differentiates from other interfaces.
	IsAlignofExpressionContext()
}

type AlignofExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlignofExpressionContext() *AlignofExpressionContext {
	var p = new(AlignofExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_alignofExpression
	return p
}

func InitEmptyAlignofExpressionContext(p *AlignofExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_alignofExpression
}

func (*AlignofExpressionContext) IsAlignofExpressionContext() {}

func NewAlignofExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlignofExpressionContext {
	var p = new(AlignofExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_alignofExpression

	return p
}

func (s *AlignofExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlignofExpressionContext) ALIGNOF() antlr.TerminalNode {
	return s.GetToken(MinZParserALIGNOF, 0)
}

func (s *AlignofExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *AlignofExpressionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *AlignofExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *AlignofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlignofExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlignofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAlignofExpression(s)
	}
}

func (s *AlignofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAlignofExpression(s)
	}
}

func (s *AlignofExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitAlignofExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) AlignofExpression() (localctx IAlignofExpressionContext) {
	localctx = NewAlignofExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, MinZParserRULE_alignofExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1158)
		p.Match(MinZParserALIGNOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1159)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1160)
		p.Type_()
	}
	{
		p.SetState(1161)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorLiteralContext is an interface to support dynamic dispatch.
type IErrorLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ERROR() antlr.TerminalNode
	DOT() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode

	// IsErrorLiteralContext differentiates from other interfaces.
	IsErrorLiteralContext()
}

type ErrorLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorLiteralContext() *ErrorLiteralContext {
	var p = new(ErrorLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_errorLiteral
	return p
}

func InitEmptyErrorLiteralContext(p *ErrorLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_errorLiteral
}

func (*ErrorLiteralContext) IsErrorLiteralContext() {}

func NewErrorLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorLiteralContext {
	var p = new(ErrorLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_errorLiteral

	return p
}

func (s *ErrorLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorLiteralContext) ERROR() antlr.TerminalNode {
	return s.GetToken(MinZParserERROR, 0)
}

func (s *ErrorLiteralContext) DOT() antlr.TerminalNode {
	return s.GetToken(MinZParserDOT, 0)
}

func (s *ErrorLiteralContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *ErrorLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterErrorLiteral(s)
	}
}

func (s *ErrorLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitErrorLiteral(s)
	}
}

func (s *ErrorLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitErrorLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ErrorLiteral() (localctx IErrorLiteralContext) {
	localctx = NewErrorLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, MinZParserRULE_errorLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1163)
		p.Match(MinZParserERROR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1164)
		p.Match(MinZParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1165)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPIPE() []antlr.TerminalNode
	PIPE(i int) antlr.TerminalNode
	Expression() IExpressionContext
	Block() IBlockContext
	LambdaParams() ILambdaParamsContext
	DOUBLE_ARROW() antlr.TerminalNode
	Type_() ITypeContext

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_lambdaExpression
	return p
}

func InitEmptyLambdaExpressionContext(p *LambdaExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_lambdaExpression
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(MinZParserPIPE)
}

func (s *LambdaExpressionContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserPIPE, i)
}

func (s *LambdaExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaExpressionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *LambdaExpressionContext) LambdaParams() ILambdaParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParamsContext)
}

func (s *LambdaExpressionContext) DOUBLE_ARROW() antlr.TerminalNode {
	return s.GetToken(MinZParserDOUBLE_ARROW, 0)
}

func (s *LambdaExpressionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitLambdaExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) LambdaExpression() (localctx ILambdaExpressionContext) {
	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, MinZParserRULE_lambdaExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1167)
		p.Match(MinZParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1169)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserIDENTIFIER {
		{
			p.SetState(1168)
			p.LambdaParams()
		}

	}
	{
		p.SetState(1171)
		p.Match(MinZParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserDOUBLE_ARROW {
		{
			p.SetState(1172)
			p.Match(MinZParserDOUBLE_ARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1173)
			p.Type_()
		}

	}
	p.SetState(1178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1176)
			p.expression(0)
		}

	case 2:
		{
			p.SetState(1177)
			p.Block()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaParamsContext is an interface to support dynamic dispatch.
type ILambdaParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLambdaParam() []ILambdaParamContext
	LambdaParam(i int) ILambdaParamContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLambdaParamsContext differentiates from other interfaces.
	IsLambdaParamsContext()
}

type LambdaParamsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParamsContext() *LambdaParamsContext {
	var p = new(LambdaParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_lambdaParams
	return p
}

func InitEmptyLambdaParamsContext(p *LambdaParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_lambdaParams
}

func (*LambdaParamsContext) IsLambdaParamsContext() {}

func NewLambdaParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParamsContext {
	var p = new(LambdaParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_lambdaParams

	return p
}

func (s *LambdaParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParamsContext) AllLambdaParam() []ILambdaParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILambdaParamContext); ok {
			len++
		}
	}

	tst := make([]ILambdaParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILambdaParamContext); ok {
			tst[i] = t.(ILambdaParamContext)
			i++
		}
	}

	return tst
}

func (s *LambdaParamsContext) LambdaParam(i int) ILambdaParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParamContext)
}

func (s *LambdaParamsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MinZParserCOMMA)
}

func (s *LambdaParamsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, i)
}

func (s *LambdaParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLambdaParams(s)
	}
}

func (s *LambdaParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLambdaParams(s)
	}
}

func (s *LambdaParamsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitLambdaParams(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) LambdaParams() (localctx ILambdaParamsContext) {
	localctx = NewLambdaParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, MinZParserRULE_lambdaParams)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1180)
		p.LambdaParam()
	}
	p.SetState(1185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserCOMMA {
		{
			p.SetState(1181)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1182)
			p.LambdaParam()
		}

		p.SetState(1187)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaParamContext is an interface to support dynamic dispatch.
type ILambdaParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsLambdaParamContext differentiates from other interfaces.
	IsLambdaParamContext()
}

type LambdaParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParamContext() *LambdaParamContext {
	var p = new(LambdaParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_lambdaParam
	return p
}

func InitEmptyLambdaParamContext(p *LambdaParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_lambdaParam
}

func (*LambdaParamContext) IsLambdaParamContext() {}

func NewLambdaParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParamContext {
	var p = new(LambdaParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_lambdaParam

	return p
}

func (s *LambdaParamContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParamContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *LambdaParamContext) COLON() antlr.TerminalNode {
	return s.GetToken(MinZParserCOLON, 0)
}

func (s *LambdaParamContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *LambdaParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLambdaParam(s)
	}
}

func (s *LambdaParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLambdaParam(s)
	}
}

func (s *LambdaParamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitLambdaParam(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) LambdaParam() (localctx ILambdaParamContext) {
	localctx = NewLambdaParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, MinZParserRULE_lambdaParam)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1188)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserCOLON {
		{
			p.SetState(1189)
			p.Match(MinZParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1190)
			p.Type_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfExpressionContext is an interface to support dynamic dispatch.
type IIfExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetThenBranch returns the thenBranch rule contexts.
	GetThenBranch() IBlockContext

	// GetElseBranch returns the elseBranch rule contexts.
	GetElseBranch() IBlockContext

	// GetElseIfExpr returns the elseIfExpr rule contexts.
	GetElseIfExpr() IIfExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetThenBranch sets the thenBranch rule contexts.
	SetThenBranch(IBlockContext)

	// SetElseBranch sets the elseBranch rule contexts.
	SetElseBranch(IBlockContext)

	// SetElseIfExpr sets the elseIfExpr rule contexts.
	SetElseIfExpr(IIfExpressionContext)

	// Getter signatures
	IF() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	Expression() IExpressionContext
	AllBlock() []IBlockContext
	Block(i int) IBlockContext
	IfExpression() IIfExpressionContext

	// IsIfExpressionContext differentiates from other interfaces.
	IsIfExpressionContext()
}

type IfExpressionContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	condition  IExpressionContext
	thenBranch IBlockContext
	elseBranch IBlockContext
	elseIfExpr IIfExpressionContext
}

func NewEmptyIfExpressionContext() *IfExpressionContext {
	var p = new(IfExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_ifExpression
	return p
}

func InitEmptyIfExpressionContext(p *IfExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_ifExpression
}

func (*IfExpressionContext) IsIfExpressionContext() {}

func NewIfExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExpressionContext {
	var p = new(IfExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_ifExpression

	return p
}

func (s *IfExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExpressionContext) GetCondition() IExpressionContext { return s.condition }

func (s *IfExpressionContext) GetThenBranch() IBlockContext { return s.thenBranch }

func (s *IfExpressionContext) GetElseBranch() IBlockContext { return s.elseBranch }

func (s *IfExpressionContext) GetElseIfExpr() IIfExpressionContext { return s.elseIfExpr }

func (s *IfExpressionContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *IfExpressionContext) SetThenBranch(v IBlockContext) { s.thenBranch = v }

func (s *IfExpressionContext) SetElseBranch(v IBlockContext) { s.elseBranch = v }

func (s *IfExpressionContext) SetElseIfExpr(v IIfExpressionContext) { s.elseIfExpr = v }

func (s *IfExpressionContext) IF() antlr.TerminalNode {
	return s.GetToken(MinZParserIF, 0)
}

func (s *IfExpressionContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MinZParserELSE, 0)
}

func (s *IfExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfExpressionContext) AllBlock() []IBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockContext); ok {
			len++
		}
	}

	tst := make([]IBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockContext); ok {
			tst[i] = t.(IBlockContext)
			i++
		}
	}

	return tst
}

func (s *IfExpressionContext) Block(i int) IBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *IfExpressionContext) IfExpression() IIfExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExpressionContext)
}

func (s *IfExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterIfExpression(s)
	}
}

func (s *IfExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitIfExpression(s)
	}
}

func (s *IfExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitIfExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) IfExpression() (localctx IIfExpressionContext) {
	localctx = NewIfExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, MinZParserRULE_ifExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1193)
		p.Match(MinZParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1194)

		var _x = p.expression(0)

		localctx.(*IfExpressionContext).condition = _x
	}
	{
		p.SetState(1195)

		var _x = p.Block()

		localctx.(*IfExpressionContext).thenBranch = _x
	}
	{
		p.SetState(1196)
		p.Match(MinZParserELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1199)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserLBRACE:
		{
			p.SetState(1197)

			var _x = p.Block()

			localctx.(*IfExpressionContext).elseBranch = _x
		}

	case MinZParserIF:
		{
			p.SetState(1198)

			var _x = p.IfExpression()

			localctx.(*IfExpressionContext).elseIfExpr = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITernaryExpressionContext is an interface to support dynamic dispatch.
type ITernaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTrueExpr returns the trueExpr rule contexts.
	GetTrueExpr() IPrimaryExpressionContext

	// GetCondition returns the condition rule contexts.
	GetCondition() IPrimaryExpressionContext

	// GetFalseExpr returns the falseExpr rule contexts.
	GetFalseExpr() IPrimaryExpressionContext

	// SetTrueExpr sets the trueExpr rule contexts.
	SetTrueExpr(IPrimaryExpressionContext)

	// SetCondition sets the condition rule contexts.
	SetCondition(IPrimaryExpressionContext)

	// SetFalseExpr sets the falseExpr rule contexts.
	SetFalseExpr(IPrimaryExpressionContext)

	// Getter signatures
	IF() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	AllPrimaryExpression() []IPrimaryExpressionContext
	PrimaryExpression(i int) IPrimaryExpressionContext

	// IsTernaryExpressionContext differentiates from other interfaces.
	IsTernaryExpressionContext()
}

type TernaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	trueExpr  IPrimaryExpressionContext
	condition IPrimaryExpressionContext
	falseExpr IPrimaryExpressionContext
}

func NewEmptyTernaryExpressionContext() *TernaryExpressionContext {
	var p = new(TernaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_ternaryExpression
	return p
}

func InitEmptyTernaryExpressionContext(p *TernaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_ternaryExpression
}

func (*TernaryExpressionContext) IsTernaryExpressionContext() {}

func NewTernaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TernaryExpressionContext {
	var p = new(TernaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_ternaryExpression

	return p
}

func (s *TernaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TernaryExpressionContext) GetTrueExpr() IPrimaryExpressionContext { return s.trueExpr }

func (s *TernaryExpressionContext) GetCondition() IPrimaryExpressionContext { return s.condition }

func (s *TernaryExpressionContext) GetFalseExpr() IPrimaryExpressionContext { return s.falseExpr }

func (s *TernaryExpressionContext) SetTrueExpr(v IPrimaryExpressionContext) { s.trueExpr = v }

func (s *TernaryExpressionContext) SetCondition(v IPrimaryExpressionContext) { s.condition = v }

func (s *TernaryExpressionContext) SetFalseExpr(v IPrimaryExpressionContext) { s.falseExpr = v }

func (s *TernaryExpressionContext) IF() antlr.TerminalNode {
	return s.GetToken(MinZParserIF, 0)
}

func (s *TernaryExpressionContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MinZParserELSE, 0)
}

func (s *TernaryExpressionContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TernaryExpressionContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *TernaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TernaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterTernaryExpression(s)
	}
}

func (s *TernaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitTernaryExpression(s)
	}
}

func (s *TernaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitTernaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) TernaryExpression() (localctx ITernaryExpressionContext) {
	localctx = NewTernaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, MinZParserRULE_ternaryExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1201)

		var _x = p.PrimaryExpression()

		localctx.(*TernaryExpressionContext).trueExpr = _x
	}
	{
		p.SetState(1202)
		p.Match(MinZParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1203)

		var _x = p.PrimaryExpression()

		localctx.(*TernaryExpressionContext).condition = _x
	}
	{
		p.SetState(1204)
		p.Match(MinZParserELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1205)

		var _x = p.PrimaryExpression()

		localctx.(*TernaryExpressionContext).falseExpr = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenExpressionContext is an interface to support dynamic dispatch.
type IWhenExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllWhenArm() []IWhenArmContext
	WhenArm(i int) IWhenArmContext
	Expression() IExpressionContext

	// IsWhenExpressionContext differentiates from other interfaces.
	IsWhenExpressionContext()
}

type WhenExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
}

func NewEmptyWhenExpressionContext() *WhenExpressionContext {
	var p = new(WhenExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_whenExpression
	return p
}

func InitEmptyWhenExpressionContext(p *WhenExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_whenExpression
}

func (*WhenExpressionContext) IsWhenExpressionContext() {}

func NewWhenExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenExpressionContext {
	var p = new(WhenExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_whenExpression

	return p
}

func (s *WhenExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenExpressionContext) GetValue() IExpressionContext { return s.value }

func (s *WhenExpressionContext) SetValue(v IExpressionContext) { s.value = v }

func (s *WhenExpressionContext) WHEN() antlr.TerminalNode {
	return s.GetToken(MinZParserWHEN, 0)
}

func (s *WhenExpressionContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserLBRACE, 0)
}

func (s *WhenExpressionContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(MinZParserRBRACE, 0)
}

func (s *WhenExpressionContext) AllWhenArm() []IWhenArmContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenArmContext); ok {
			len++
		}
	}

	tst := make([]IWhenArmContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenArmContext); ok {
			tst[i] = t.(IWhenArmContext)
			i++
		}
	}

	return tst
}

func (s *WhenExpressionContext) WhenArm(i int) IWhenArmContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenArmContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenArmContext)
}

func (s *WhenExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterWhenExpression(s)
	}
}

func (s *WhenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitWhenExpression(s)
	}
}

func (s *WhenExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitWhenExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) WhenExpression() (localctx IWhenExpressionContext) {
	localctx = NewWhenExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, MinZParserRULE_whenExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1207)
		p.Match(MinZParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1209)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1208)

			var _x = p.expression(0)

			localctx.(*WhenExpressionContext).value = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1211)
		p.Match(MinZParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&61572718264320) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&576460752303423615) != 0) {
		{
			p.SetState(1212)
			p.WhenArm()
		}

		p.SetState(1215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1217)
		p.Match(MinZParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenArmContext is an interface to support dynamic dispatch.
type IWhenArmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetGuard returns the guard rule contexts.
	GetGuard() IExpressionContext

	// GetBody returns the body rule contexts.
	GetBody() IExpressionContext

	// SetGuard sets the guard rule contexts.
	SetGuard(IExpressionContext)

	// SetBody sets the body rule contexts.
	SetBody(IExpressionContext)

	// Getter signatures
	DOUBLE_ARROW() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	Pattern() IPatternContext
	ELSE() antlr.TerminalNode
	IF() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsWhenArmContext differentiates from other interfaces.
	IsWhenArmContext()
}

type WhenArmContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	guard  IExpressionContext
	body   IExpressionContext
}

func NewEmptyWhenArmContext() *WhenArmContext {
	var p = new(WhenArmContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_whenArm
	return p
}

func InitEmptyWhenArmContext(p *WhenArmContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_whenArm
}

func (*WhenArmContext) IsWhenArmContext() {}

func NewWhenArmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenArmContext {
	var p = new(WhenArmContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_whenArm

	return p
}

func (s *WhenArmContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenArmContext) GetGuard() IExpressionContext { return s.guard }

func (s *WhenArmContext) GetBody() IExpressionContext { return s.body }

func (s *WhenArmContext) SetGuard(v IExpressionContext) { s.guard = v }

func (s *WhenArmContext) SetBody(v IExpressionContext) { s.body = v }

func (s *WhenArmContext) DOUBLE_ARROW() antlr.TerminalNode {
	return s.GetToken(MinZParserDOUBLE_ARROW, 0)
}

func (s *WhenArmContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenArmContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenArmContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *WhenArmContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MinZParserELSE, 0)
}

func (s *WhenArmContext) IF() antlr.TerminalNode {
	return s.GetToken(MinZParserIF, 0)
}

func (s *WhenArmContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, 0)
}

func (s *WhenArmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenArmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenArmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterWhenArm(s)
	}
}

func (s *WhenArmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitWhenArm(s)
	}
}

func (s *WhenArmContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitWhenArm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) WhenArm() (localctx IWhenArmContext) {
	localctx = NewWhenArmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, MinZParserRULE_whenArm)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1221)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserTRUE, MinZParserFALSE, MinZParserNULL, MinZParserIDENTIFIER, MinZParserINTEGER, MinZParserHEX_INTEGER, MinZParserBINARY_INTEGER, MinZParserFLOAT, MinZParserSTRING, MinZParserCHAR, MinZParserUNDERSCORE:
		{
			p.SetState(1219)
			p.Pattern()
		}

	case MinZParserELSE:
		{
			p.SetState(1220)
			p.Match(MinZParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserIF {
		{
			p.SetState(1223)
			p.Match(MinZParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1224)

			var _x = p.expression(0)

			localctx.(*WhenArmContext).guard = _x
		}

	}
	{
		p.SetState(1227)
		p.Match(MinZParserDOUBLE_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1228)

		var _x = p.expression(0)

		localctx.(*WhenArmContext).body = _x
	}
	p.SetState(1230)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserCOMMA {
		{
			p.SetState(1229)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMetafunctionExprContext is an interface to support dynamic dispatch.
type IMetafunctionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	AT() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsMetafunctionExprContext differentiates from other interfaces.
	IsMetafunctionExprContext()
}

type MetafunctionExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyMetafunctionExprContext() *MetafunctionExprContext {
	var p = new(MetafunctionExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_metafunctionExpr
	return p
}

func InitEmptyMetafunctionExprContext(p *MetafunctionExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_metafunctionExpr
}

func (*MetafunctionExprContext) IsMetafunctionExprContext() {}

func NewMetafunctionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetafunctionExprContext {
	var p = new(MetafunctionExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_metafunctionExpr

	return p
}

func (s *MetafunctionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MetafunctionExprContext) GetName() antlr.Token { return s.name }

func (s *MetafunctionExprContext) SetName(v antlr.Token) { s.name = v }

func (s *MetafunctionExprContext) AT() antlr.TerminalNode {
	return s.GetToken(MinZParserAT, 0)
}

func (s *MetafunctionExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserLPAREN, 0)
}

func (s *MetafunctionExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(MinZParserRPAREN, 0)
}

func (s *MetafunctionExprContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *MetafunctionExprContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *MetafunctionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetafunctionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetafunctionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMetafunctionExpr(s)
	}
}

func (s *MetafunctionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMetafunctionExpr(s)
	}
}

func (s *MetafunctionExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitMetafunctionExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) MetafunctionExpr() (localctx IMetafunctionExprContext) {
	localctx = NewMetafunctionExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, MinZParserRULE_metafunctionExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1232)
		p.Match(MinZParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1233)

		var _m = p.Match(MinZParserIDENTIFIER)

		localctx.(*MetafunctionExprContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1234)
		p.Match(MinZParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2037403669757952) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&303535578054393983) != 0) {
		{
			p.SetState(1235)
			p.ExpressionList()
		}

	}
	{
		p.SetState(1238)
		p.Match(MinZParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MinZParserCOMMA)
}

func (s *ArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, i)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (s *ArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, MinZParserRULE_argumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1240)
		p.expression(0)
	}
	p.SetState(1245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserCOMMA {
		{
			p.SetState(1241)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1242)
			p.expression(0)
		}

		p.SetState(1247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MinZParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MinZVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MinZParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, MinZParserRULE_expressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1248)
		p.expression(0)
	}
	p.SetState(1253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserCOMMA {
		{
			p.SetState(1249)
			p.Match(MinZParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1250)
			p.expression(0)
		}

		p.SetState(1255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *MinZParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 87:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *MinZParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 18)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
