// Code generated from grammar/MinZ.g4 by ANTLR 4.13.2. DO NOT EDIT.

package minzparser // MinZ
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type MinZParser struct {
	*antlr.BaseParser
}

var MinZParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func minzParserInit() {
	staticData := &MinZParserStaticData
	staticData.LiteralNames = []string{
		"", "'import'", "'as'", "';'", "'.'", "'('", "')'", "'fun'", "'fn'",
		"'asm'", "'mir'", "'pub'", "'<'", "','", "'>'", "':'", "'->'", "'?'",
		"'struct'", "'{'", "'}'", "'enum'", "'='", "'type'", "'interface'",
		"'impl'", "'for'", "'const'", "'global'", "'@if'", "'else'", "'@minz'",
		"'@mir'", "'r'", "'#'", "'['", "']'", "'@target'", "'let'", "'mut'",
		"'var'", "'return'", "'if'", "'while'", "'in'", "'loop'", "'case'",
		"'=>'", "'break'", "'continue'", "'defer'", "'_'", "'|'", "'then'",
		"'when'", "'||'", "'or'", "'&&'", "'and'", "'=='", "'!='", "'<='", "'>='",
		"'+'", "'-'", "'*'", "'/'", "'%'", "'!'", "'~'", "'&'", "'??'", "'.iter()'",
		"'.map'", "'.filter'", "'.forEach'", "'true'", "'false'", "'@print'",
		"'@assert'", "'@error'", "'@abi'", "'@lua'", "'@lua_eval'", "'@define'",
		"'@include'", "'\"'", "'u8'", "'u16'", "'u24'", "'i8'", "'i16'", "'i24'",
		"'bool'", "'void'", "'f8.8'", "'f.8'", "'f.16'", "'f16.8'", "'f8.16'",
		"'bitstruct'", "'::'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"IDENTIFIER", "NUMBER", "HEX_NUMBER", "BINARY_NUMBER", "STRING", "LSTRING",
		"CHAR", "LUA_BLOCK", "LINE_COMMENT", "BLOCK_COMMENT", "WS",
	}
	staticData.RuleNames = []string{
		"sourceFile", "importStatement", "importPath", "declaration", "functionDeclaration",
		"functionPrefix", "visibility", "genericParams", "parameterList", "parameter",
		"returnType", "errorReturnType", "structDeclaration", "fieldList", "field",
		"enumDeclaration", "enumMemberList", "enumMember", "typeAliasDeclaration",
		"interfaceDeclaration", "interfaceMethodList", "interfaceMethod", "implBlock",
		"constDeclaration", "globalVarDeclaration", "compileTimeDeclaration",
		"compileTimeIf", "compileTimeMinz", "compileTimeMir", "mirBlock", "mirStatement",
		"mirInstruction", "mirOperand", "mirRegister", "mirImmediate", "mirMemory",
		"mirLabel", "targetBlock", "statement", "letStatement", "varStatement",
		"assignmentStatement", "expressionStatement", "returnStatement", "ifStatement",
		"whileStatement", "forStatement", "loopStatement", "caseStatement",
		"caseArm", "blockStatement", "block", "breakStatement", "continueStatement",
		"deferStatement", "asmStatement", "asmBlock", "pattern", "literalPattern",
		"identifierPattern", "wildcardPattern", "tuplePattern", "structPattern",
		"fieldPattern", "expression", "lambdaExpression", "lambdaParams", "lambdaParam",
		"conditionalExpression", "whenExpression", "whenArm", "logicalOrExpression",
		"logicalAndExpression", "equalityExpression", "relationalExpression",
		"additiveExpression", "multiplicativeExpression", "castExpression",
		"unaryExpression", "postfixExpression", "postfixOperator", "argumentList",
		"primaryExpression", "literal", "numberLiteral", "stringLiteral", "charLiteral",
		"booleanLiteral", "arrayLiteral", "structLiteral", "fieldInit", "metafunction",
		"luaBlock", "inlineAssembly", "asmOperand", "asmConstraint", "type",
		"primitiveType", "arrayType", "pointerType", "functionType", "typeList",
		"structType", "enumType", "bitStructType", "bitFieldList", "bitField",
		"typeIdentifier", "errorType",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 112, 1131, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 1, 0, 1, 0, 1, 0, 5, 0, 222, 8, 0, 10, 0, 12, 0, 225, 9, 0, 1, 0,
		1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 233, 8, 1, 1, 1, 1, 1, 1, 2, 1, 2,
		1, 2, 1, 2, 5, 2, 241, 8, 2, 10, 2, 12, 2, 244, 9, 2, 3, 2, 246, 8, 2,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 257, 8, 3,
		1, 4, 3, 4, 260, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 265, 8, 4, 1, 4, 1, 4, 3,
		4, 269, 8, 4, 1, 4, 1, 4, 3, 4, 273, 8, 4, 1, 4, 3, 4, 276, 8, 4, 1, 4,
		1, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 286, 8, 5, 1, 6, 1, 6,
		1, 7, 1, 7, 1, 7, 1, 7, 5, 7, 294, 8, 7, 10, 7, 12, 7, 297, 9, 7, 1, 7,
		1, 7, 1, 8, 1, 8, 1, 8, 5, 8, 304, 8, 8, 10, 8, 12, 8, 307, 9, 8, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 3, 11, 318, 8, 11,
		1, 12, 3, 12, 321, 8, 12, 1, 12, 1, 12, 1, 12, 3, 12, 326, 8, 12, 1, 12,
		1, 12, 3, 12, 330, 8, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 5, 13, 337,
		8, 13, 10, 13, 12, 13, 340, 9, 13, 1, 13, 3, 13, 343, 8, 13, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 15, 3, 15, 350, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15,
		355, 8, 15, 1, 15, 1, 15, 3, 15, 359, 8, 15, 1, 15, 1, 15, 1, 16, 1, 16,
		1, 16, 5, 16, 366, 8, 16, 10, 16, 12, 16, 369, 9, 16, 1, 16, 3, 16, 372,
		8, 16, 1, 17, 1, 17, 1, 17, 3, 17, 377, 8, 17, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 19, 3, 19, 386, 8, 19, 1, 19, 1, 19, 1, 19, 3, 19,
		391, 8, 19, 1, 19, 1, 19, 3, 19, 395, 8, 19, 1, 19, 1, 19, 1, 20, 5, 20,
		400, 8, 20, 10, 20, 12, 20, 403, 9, 20, 1, 21, 1, 21, 1, 21, 3, 21, 408,
		8, 21, 1, 21, 1, 21, 3, 21, 412, 8, 21, 1, 21, 3, 21, 415, 8, 21, 1, 21,
		1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 425, 8, 22, 10,
		22, 12, 22, 428, 9, 22, 1, 22, 1, 22, 1, 23, 3, 23, 433, 8, 23, 1, 23,
		1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 24, 3, 24, 444, 8,
		24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 452, 8, 24, 1, 24,
		1, 24, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 460, 8, 25, 1, 26, 1, 26, 1,
		26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 469, 8, 26, 1, 27, 1, 27, 1, 27,
		1, 27, 1, 27, 5, 27, 476, 8, 27, 10, 27, 12, 27, 479, 9, 27, 1, 27, 1,
		27, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 5, 29, 488, 8, 29, 10, 29, 12, 29,
		491, 9, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 31, 1, 31, 5, 31, 500,
		8, 31, 10, 31, 12, 31, 503, 9, 31, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 509,
		8, 32, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 38,
		1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1,
		38, 1, 38, 1, 38, 1, 38, 3, 38, 545, 8, 38, 1, 39, 1, 39, 3, 39, 549, 8,
		39, 1, 39, 1, 39, 1, 39, 3, 39, 554, 8, 39, 1, 39, 1, 39, 1, 39, 1, 39,
		1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 564, 8, 40, 1, 40, 1, 40, 1, 40, 1,
		40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43,
		3, 43, 580, 8, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1,
		44, 3, 44, 590, 8, 44, 3, 44, 592, 8, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 48, 1, 48,
		1, 48, 1, 48, 5, 48, 611, 8, 48, 10, 48, 12, 48, 614, 9, 48, 1, 48, 1,
		48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 623, 8, 49, 3, 49, 625, 8,
		49, 1, 50, 1, 50, 1, 51, 1, 51, 5, 51, 631, 8, 51, 10, 51, 12, 51, 634,
		9, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 54, 1,
		54, 1, 54, 1, 54, 1, 54, 3, 54, 649, 8, 54, 1, 55, 1, 55, 1, 55, 1, 56,
		1, 56, 5, 56, 656, 8, 56, 10, 56, 12, 56, 659, 9, 56, 1, 56, 1, 56, 1,
		57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 668, 8, 57, 1, 58, 1, 58, 1, 59,
		1, 59, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 5, 61, 680, 8, 61, 10,
		61, 12, 61, 683, 9, 61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62,
		5, 62, 692, 8, 62, 10, 62, 12, 62, 695, 9, 62, 1, 62, 1, 62, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 64, 1, 64, 3, 64, 705, 8, 64, 1, 65, 1, 65, 3, 65,
		709, 8, 65, 1, 65, 1, 65, 1, 65, 3, 65, 714, 8, 65, 1, 65, 1, 65, 3, 65,
		718, 8, 65, 1, 66, 1, 66, 1, 66, 5, 66, 723, 8, 66, 10, 66, 12, 66, 726,
		9, 66, 1, 67, 1, 67, 1, 67, 3, 67, 731, 8, 67, 1, 68, 1, 68, 1, 68, 1,
		68, 1, 68, 1, 68, 1, 68, 3, 68, 740, 8, 68, 1, 68, 1, 68, 1, 68, 1, 68,
		1, 68, 1, 68, 1, 68, 3, 68, 749, 8, 68, 1, 69, 1, 69, 1, 69, 1, 69, 5,
		69, 755, 8, 69, 10, 69, 12, 69, 758, 9, 69, 1, 69, 1, 69, 1, 70, 1, 70,
		1, 70, 3, 70, 765, 8, 70, 1, 70, 1, 70, 1, 70, 3, 70, 770, 8, 70, 1, 71,
		1, 71, 1, 71, 5, 71, 775, 8, 71, 10, 71, 12, 71, 778, 9, 71, 1, 72, 1,
		72, 1, 72, 5, 72, 783, 8, 72, 10, 72, 12, 72, 786, 9, 72, 1, 73, 1, 73,
		1, 73, 5, 73, 791, 8, 73, 10, 73, 12, 73, 794, 9, 73, 1, 74, 1, 74, 1,
		74, 5, 74, 799, 8, 74, 10, 74, 12, 74, 802, 9, 74, 1, 75, 1, 75, 1, 75,
		5, 75, 807, 8, 75, 10, 75, 12, 75, 810, 9, 75, 1, 76, 1, 76, 1, 76, 5,
		76, 815, 8, 76, 10, 76, 12, 76, 818, 9, 76, 1, 77, 1, 77, 1, 77, 3, 77,
		823, 8, 77, 1, 78, 1, 78, 1, 78, 3, 78, 828, 8, 78, 1, 79, 1, 79, 5, 79,
		832, 8, 79, 10, 79, 12, 79, 835, 9, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1,
		80, 1, 80, 1, 80, 1, 80, 3, 80, 845, 8, 80, 1, 80, 1, 80, 1, 80, 1, 80,
		1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1,
		80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 866, 8, 80, 1, 81, 1, 81, 1, 81,
		5, 81, 871, 8, 81, 10, 81, 12, 81, 874, 9, 81, 1, 82, 1, 82, 1, 82, 1,
		82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 886, 8, 82, 1, 83,
		1, 83, 1, 83, 1, 83, 3, 83, 892, 8, 83, 1, 84, 1, 84, 1, 85, 1, 85, 1,
		86, 1, 86, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 5, 88, 906, 8, 88,
		10, 88, 12, 88, 909, 9, 88, 3, 88, 911, 8, 88, 1, 88, 1, 88, 1, 89, 1,
		89, 1, 89, 1, 89, 1, 89, 5, 89, 920, 8, 89, 10, 89, 12, 89, 923, 9, 89,
		3, 89, 925, 8, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91, 1,
		91, 1, 91, 1, 91, 1, 91, 5, 91, 938, 8, 91, 10, 91, 12, 91, 941, 9, 91,
		1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 3, 91, 950, 8, 91, 1,
		91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91,
		1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1,
		91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 3, 91,
		983, 8, 91, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 5, 93, 992,
		8, 93, 10, 93, 12, 93, 995, 9, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1,
		94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96,
		1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 3, 96, 1018, 8, 96, 1, 97, 1, 97, 1,
		98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 3, 98,
		1032, 8, 98, 1, 99, 1, 99, 3, 99, 1036, 8, 99, 1, 99, 1, 99, 1, 99, 1,
		99, 3, 99, 1042, 8, 99, 1, 100, 1, 100, 1, 100, 3, 100, 1047, 8, 100, 1,
		100, 1, 100, 3, 100, 1051, 8, 100, 1, 101, 1, 101, 1, 101, 5, 101, 1056,
		8, 101, 10, 101, 12, 101, 1059, 9, 101, 1, 102, 1, 102, 1, 102, 3, 102,
		1064, 8, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 3, 103, 1071, 8,
		103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 3, 104, 1078, 8, 104, 1, 104,
		1, 104, 1, 105, 1, 105, 1, 105, 5, 105, 1085, 8, 105, 10, 105, 12, 105,
		1088, 9, 105, 1, 105, 3, 105, 1091, 8, 105, 1, 106, 1, 106, 1, 106, 1,
		106, 1, 107, 1, 107, 1, 107, 5, 107, 1100, 8, 107, 10, 107, 12, 107, 1103,
		9, 107, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108,
		1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108,
		1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 1129, 8,
		108, 1, 108, 0, 0, 109, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
		26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60,
		62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96,
		98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126,
		128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156,
		158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186,
		188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216,
		0, 12, 1, 0, 20, 20, 1, 0, 55, 56, 1, 0, 57, 58, 1, 0, 59, 60, 3, 0, 12,
		12, 14, 14, 61, 62, 1, 0, 63, 64, 1, 0, 65, 67, 2, 0, 64, 65, 68, 70, 1,
		0, 103, 105, 1, 0, 106, 107, 1, 0, 76, 77, 1, 0, 87, 99, 1191, 0, 223,
		1, 0, 0, 0, 2, 228, 1, 0, 0, 0, 4, 245, 1, 0, 0, 0, 6, 256, 1, 0, 0, 0,
		8, 259, 1, 0, 0, 0, 10, 285, 1, 0, 0, 0, 12, 287, 1, 0, 0, 0, 14, 289,
		1, 0, 0, 0, 16, 300, 1, 0, 0, 0, 18, 308, 1, 0, 0, 0, 20, 312, 1, 0, 0,
		0, 22, 315, 1, 0, 0, 0, 24, 320, 1, 0, 0, 0, 26, 333, 1, 0, 0, 0, 28, 344,
		1, 0, 0, 0, 30, 349, 1, 0, 0, 0, 32, 362, 1, 0, 0, 0, 34, 373, 1, 0, 0,
		0, 36, 378, 1, 0, 0, 0, 38, 385, 1, 0, 0, 0, 40, 401, 1, 0, 0, 0, 42, 404,
		1, 0, 0, 0, 44, 418, 1, 0, 0, 0, 46, 432, 1, 0, 0, 0, 48, 443, 1, 0, 0,
		0, 50, 459, 1, 0, 0, 0, 52, 461, 1, 0, 0, 0, 54, 470, 1, 0, 0, 0, 56, 482,
		1, 0, 0, 0, 58, 485, 1, 0, 0, 0, 60, 494, 1, 0, 0, 0, 62, 497, 1, 0, 0,
		0, 64, 508, 1, 0, 0, 0, 66, 510, 1, 0, 0, 0, 68, 513, 1, 0, 0, 0, 70, 516,
		1, 0, 0, 0, 72, 520, 1, 0, 0, 0, 74, 523, 1, 0, 0, 0, 76, 544, 1, 0, 0,
		0, 78, 546, 1, 0, 0, 0, 80, 559, 1, 0, 0, 0, 82, 569, 1, 0, 0, 0, 84, 574,
		1, 0, 0, 0, 86, 577, 1, 0, 0, 0, 88, 583, 1, 0, 0, 0, 90, 593, 1, 0, 0,
		0, 92, 597, 1, 0, 0, 0, 94, 603, 1, 0, 0, 0, 96, 606, 1, 0, 0, 0, 98, 617,
		1, 0, 0, 0, 100, 626, 1, 0, 0, 0, 102, 628, 1, 0, 0, 0, 104, 637, 1, 0,
		0, 0, 106, 640, 1, 0, 0, 0, 108, 643, 1, 0, 0, 0, 110, 650, 1, 0, 0, 0,
		112, 653, 1, 0, 0, 0, 114, 667, 1, 0, 0, 0, 116, 669, 1, 0, 0, 0, 118,
		671, 1, 0, 0, 0, 120, 673, 1, 0, 0, 0, 122, 675, 1, 0, 0, 0, 124, 686,
		1, 0, 0, 0, 126, 698, 1, 0, 0, 0, 128, 704, 1, 0, 0, 0, 130, 717, 1, 0,
		0, 0, 132, 719, 1, 0, 0, 0, 134, 727, 1, 0, 0, 0, 136, 748, 1, 0, 0, 0,
		138, 750, 1, 0, 0, 0, 140, 761, 1, 0, 0, 0, 142, 771, 1, 0, 0, 0, 144,
		779, 1, 0, 0, 0, 146, 787, 1, 0, 0, 0, 148, 795, 1, 0, 0, 0, 150, 803,
		1, 0, 0, 0, 152, 811, 1, 0, 0, 0, 154, 819, 1, 0, 0, 0, 156, 827, 1, 0,
		0, 0, 158, 829, 1, 0, 0, 0, 160, 865, 1, 0, 0, 0, 162, 867, 1, 0, 0, 0,
		164, 885, 1, 0, 0, 0, 166, 891, 1, 0, 0, 0, 168, 893, 1, 0, 0, 0, 170,
		895, 1, 0, 0, 0, 172, 897, 1, 0, 0, 0, 174, 899, 1, 0, 0, 0, 176, 901,
		1, 0, 0, 0, 178, 914, 1, 0, 0, 0, 180, 928, 1, 0, 0, 0, 182, 982, 1, 0,
		0, 0, 184, 984, 1, 0, 0, 0, 186, 986, 1, 0, 0, 0, 188, 998, 1, 0, 0, 0,
		190, 1006, 1, 0, 0, 0, 192, 1017, 1, 0, 0, 0, 194, 1019, 1, 0, 0, 0, 196,
		1031, 1, 0, 0, 0, 198, 1041, 1, 0, 0, 0, 200, 1043, 1, 0, 0, 0, 202, 1052,
		1, 0, 0, 0, 204, 1060, 1, 0, 0, 0, 206, 1067, 1, 0, 0, 0, 208, 1074, 1,
		0, 0, 0, 210, 1081, 1, 0, 0, 0, 212, 1092, 1, 0, 0, 0, 214, 1096, 1, 0,
		0, 0, 216, 1128, 1, 0, 0, 0, 218, 222, 3, 2, 1, 0, 219, 222, 3, 6, 3, 0,
		220, 222, 3, 76, 38, 0, 221, 218, 1, 0, 0, 0, 221, 219, 1, 0, 0, 0, 221,
		220, 1, 0, 0, 0, 222, 225, 1, 0, 0, 0, 223, 221, 1, 0, 0, 0, 223, 224,
		1, 0, 0, 0, 224, 226, 1, 0, 0, 0, 225, 223, 1, 0, 0, 0, 226, 227, 5, 0,
		0, 1, 227, 1, 1, 0, 0, 0, 228, 229, 5, 1, 0, 0, 229, 232, 3, 4, 2, 0, 230,
		231, 5, 2, 0, 0, 231, 233, 5, 102, 0, 0, 232, 230, 1, 0, 0, 0, 232, 233,
		1, 0, 0, 0, 233, 234, 1, 0, 0, 0, 234, 235, 5, 3, 0, 0, 235, 3, 1, 0, 0,
		0, 236, 246, 3, 170, 85, 0, 237, 242, 5, 102, 0, 0, 238, 239, 5, 4, 0,
		0, 239, 241, 5, 102, 0, 0, 240, 238, 1, 0, 0, 0, 241, 244, 1, 0, 0, 0,
		242, 240, 1, 0, 0, 0, 242, 243, 1, 0, 0, 0, 243, 246, 1, 0, 0, 0, 244,
		242, 1, 0, 0, 0, 245, 236, 1, 0, 0, 0, 245, 237, 1, 0, 0, 0, 246, 5, 1,
		0, 0, 0, 247, 257, 3, 8, 4, 0, 248, 257, 3, 24, 12, 0, 249, 257, 3, 30,
		15, 0, 250, 257, 3, 36, 18, 0, 251, 257, 3, 38, 19, 0, 252, 257, 3, 44,
		22, 0, 253, 257, 3, 46, 23, 0, 254, 257, 3, 48, 24, 0, 255, 257, 3, 50,
		25, 0, 256, 247, 1, 0, 0, 0, 256, 248, 1, 0, 0, 0, 256, 249, 1, 0, 0, 0,
		256, 250, 1, 0, 0, 0, 256, 251, 1, 0, 0, 0, 256, 252, 1, 0, 0, 0, 256,
		253, 1, 0, 0, 0, 256, 254, 1, 0, 0, 0, 256, 255, 1, 0, 0, 0, 257, 7, 1,
		0, 0, 0, 258, 260, 3, 12, 6, 0, 259, 258, 1, 0, 0, 0, 259, 260, 1, 0, 0,
		0, 260, 261, 1, 0, 0, 0, 261, 262, 3, 10, 5, 0, 262, 264, 5, 102, 0, 0,
		263, 265, 3, 14, 7, 0, 264, 263, 1, 0, 0, 0, 264, 265, 1, 0, 0, 0, 265,
		266, 1, 0, 0, 0, 266, 268, 5, 5, 0, 0, 267, 269, 3, 16, 8, 0, 268, 267,
		1, 0, 0, 0, 268, 269, 1, 0, 0, 0, 269, 270, 1, 0, 0, 0, 270, 272, 5, 6,
		0, 0, 271, 273, 3, 20, 10, 0, 272, 271, 1, 0, 0, 0, 272, 273, 1, 0, 0,
		0, 273, 275, 1, 0, 0, 0, 274, 276, 3, 22, 11, 0, 275, 274, 1, 0, 0, 0,
		275, 276, 1, 0, 0, 0, 276, 277, 1, 0, 0, 0, 277, 278, 3, 102, 51, 0, 278,
		9, 1, 0, 0, 0, 279, 286, 5, 7, 0, 0, 280, 286, 5, 8, 0, 0, 281, 282, 5,
		9, 0, 0, 282, 286, 5, 7, 0, 0, 283, 284, 5, 10, 0, 0, 284, 286, 5, 7, 0,
		0, 285, 279, 1, 0, 0, 0, 285, 280, 1, 0, 0, 0, 285, 281, 1, 0, 0, 0, 285,
		283, 1, 0, 0, 0, 286, 11, 1, 0, 0, 0, 287, 288, 5, 11, 0, 0, 288, 13, 1,
		0, 0, 0, 289, 290, 5, 12, 0, 0, 290, 295, 5, 102, 0, 0, 291, 292, 5, 13,
		0, 0, 292, 294, 5, 102, 0, 0, 293, 291, 1, 0, 0, 0, 294, 297, 1, 0, 0,
		0, 295, 293, 1, 0, 0, 0, 295, 296, 1, 0, 0, 0, 296, 298, 1, 0, 0, 0, 297,
		295, 1, 0, 0, 0, 298, 299, 5, 14, 0, 0, 299, 15, 1, 0, 0, 0, 300, 305,
		3, 18, 9, 0, 301, 302, 5, 13, 0, 0, 302, 304, 3, 18, 9, 0, 303, 301, 1,
		0, 0, 0, 304, 307, 1, 0, 0, 0, 305, 303, 1, 0, 0, 0, 305, 306, 1, 0, 0,
		0, 306, 17, 1, 0, 0, 0, 307, 305, 1, 0, 0, 0, 308, 309, 5, 102, 0, 0, 309,
		310, 5, 15, 0, 0, 310, 311, 3, 192, 96, 0, 311, 19, 1, 0, 0, 0, 312, 313,
		5, 16, 0, 0, 313, 314, 3, 192, 96, 0, 314, 21, 1, 0, 0, 0, 315, 317, 5,
		17, 0, 0, 316, 318, 3, 192, 96, 0, 317, 316, 1, 0, 0, 0, 317, 318, 1, 0,
		0, 0, 318, 23, 1, 0, 0, 0, 319, 321, 3, 12, 6, 0, 320, 319, 1, 0, 0, 0,
		320, 321, 1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322, 323, 5, 18, 0, 0, 323,
		325, 5, 102, 0, 0, 324, 326, 3, 14, 7, 0, 325, 324, 1, 0, 0, 0, 325, 326,
		1, 0, 0, 0, 326, 327, 1, 0, 0, 0, 327, 329, 5, 19, 0, 0, 328, 330, 3, 26,
		13, 0, 329, 328, 1, 0, 0, 0, 329, 330, 1, 0, 0, 0, 330, 331, 1, 0, 0, 0,
		331, 332, 5, 20, 0, 0, 332, 25, 1, 0, 0, 0, 333, 338, 3, 28, 14, 0, 334,
		335, 5, 13, 0, 0, 335, 337, 3, 28, 14, 0, 336, 334, 1, 0, 0, 0, 337, 340,
		1, 0, 0, 0, 338, 336, 1, 0, 0, 0, 338, 339, 1, 0, 0, 0, 339, 342, 1, 0,
		0, 0, 340, 338, 1, 0, 0, 0, 341, 343, 5, 13, 0, 0, 342, 341, 1, 0, 0, 0,
		342, 343, 1, 0, 0, 0, 343, 27, 1, 0, 0, 0, 344, 345, 5, 102, 0, 0, 345,
		346, 5, 15, 0, 0, 346, 347, 3, 192, 96, 0, 347, 29, 1, 0, 0, 0, 348, 350,
		3, 12, 6, 0, 349, 348, 1, 0, 0, 0, 349, 350, 1, 0, 0, 0, 350, 351, 1, 0,
		0, 0, 351, 352, 5, 21, 0, 0, 352, 354, 5, 102, 0, 0, 353, 355, 3, 14, 7,
		0, 354, 353, 1, 0, 0, 0, 354, 355, 1, 0, 0, 0, 355, 356, 1, 0, 0, 0, 356,
		358, 5, 19, 0, 0, 357, 359, 3, 32, 16, 0, 358, 357, 1, 0, 0, 0, 358, 359,
		1, 0, 0, 0, 359, 360, 1, 0, 0, 0, 360, 361, 5, 20, 0, 0, 361, 31, 1, 0,
		0, 0, 362, 367, 3, 34, 17, 0, 363, 364, 5, 13, 0, 0, 364, 366, 3, 34, 17,
		0, 365, 363, 1, 0, 0, 0, 366, 369, 1, 0, 0, 0, 367, 365, 1, 0, 0, 0, 367,
		368, 1, 0, 0, 0, 368, 371, 1, 0, 0, 0, 369, 367, 1, 0, 0, 0, 370, 372,
		5, 13, 0, 0, 371, 370, 1, 0, 0, 0, 371, 372, 1, 0, 0, 0, 372, 33, 1, 0,
		0, 0, 373, 376, 5, 102, 0, 0, 374, 375, 5, 22, 0, 0, 375, 377, 3, 128,
		64, 0, 376, 374, 1, 0, 0, 0, 376, 377, 1, 0, 0, 0, 377, 35, 1, 0, 0, 0,
		378, 379, 5, 23, 0, 0, 379, 380, 5, 102, 0, 0, 380, 381, 5, 22, 0, 0, 381,
		382, 3, 192, 96, 0, 382, 383, 5, 3, 0, 0, 383, 37, 1, 0, 0, 0, 384, 386,
		3, 12, 6, 0, 385, 384, 1, 0, 0, 0, 385, 386, 1, 0, 0, 0, 386, 387, 1, 0,
		0, 0, 387, 388, 5, 24, 0, 0, 388, 390, 5, 102, 0, 0, 389, 391, 3, 14, 7,
		0, 390, 389, 1, 0, 0, 0, 390, 391, 1, 0, 0, 0, 391, 392, 1, 0, 0, 0, 392,
		394, 5, 19, 0, 0, 393, 395, 3, 40, 20, 0, 394, 393, 1, 0, 0, 0, 394, 395,
		1, 0, 0, 0, 395, 396, 1, 0, 0, 0, 396, 397, 5, 20, 0, 0, 397, 39, 1, 0,
		0, 0, 398, 400, 3, 42, 21, 0, 399, 398, 1, 0, 0, 0, 400, 403, 1, 0, 0,
		0, 401, 399, 1, 0, 0, 0, 401, 402, 1, 0, 0, 0, 402, 41, 1, 0, 0, 0, 403,
		401, 1, 0, 0, 0, 404, 405, 5, 102, 0, 0, 405, 407, 5, 5, 0, 0, 406, 408,
		3, 16, 8, 0, 407, 406, 1, 0, 0, 0, 407, 408, 1, 0, 0, 0, 408, 409, 1, 0,
		0, 0, 409, 411, 5, 6, 0, 0, 410, 412, 3, 20, 10, 0, 411, 410, 1, 0, 0,
		0, 411, 412, 1, 0, 0, 0, 412, 414, 1, 0, 0, 0, 413, 415, 3, 22, 11, 0,
		414, 413, 1, 0, 0, 0, 414, 415, 1, 0, 0, 0, 415, 416, 1, 0, 0, 0, 416,
		417, 5, 3, 0, 0, 417, 43, 1, 0, 0, 0, 418, 419, 5, 25, 0, 0, 419, 420,
		3, 192, 96, 0, 420, 421, 5, 26, 0, 0, 421, 422, 3, 192, 96, 0, 422, 426,
		5, 19, 0, 0, 423, 425, 3, 8, 4, 0, 424, 423, 1, 0, 0, 0, 425, 428, 1, 0,
		0, 0, 426, 424, 1, 0, 0, 0, 426, 427, 1, 0, 0, 0, 427, 429, 1, 0, 0, 0,
		428, 426, 1, 0, 0, 0, 429, 430, 5, 20, 0, 0, 430, 45, 1, 0, 0, 0, 431,
		433, 3, 12, 6, 0, 432, 431, 1, 0, 0, 0, 432, 433, 1, 0, 0, 0, 433, 434,
		1, 0, 0, 0, 434, 435, 5, 27, 0, 0, 435, 436, 5, 102, 0, 0, 436, 437, 5,
		15, 0, 0, 437, 438, 3, 192, 96, 0, 438, 439, 5, 22, 0, 0, 439, 440, 3,
		128, 64, 0, 440, 441, 5, 3, 0, 0, 441, 47, 1, 0, 0, 0, 442, 444, 3, 12,
		6, 0, 443, 442, 1, 0, 0, 0, 443, 444, 1, 0, 0, 0, 444, 445, 1, 0, 0, 0,
		445, 446, 5, 28, 0, 0, 446, 447, 5, 102, 0, 0, 447, 448, 5, 15, 0, 0, 448,
		451, 3, 192, 96, 0, 449, 450, 5, 22, 0, 0, 450, 452, 3, 128, 64, 0, 451,
		449, 1, 0, 0, 0, 451, 452, 1, 0, 0, 0, 452, 453, 1, 0, 0, 0, 453, 454,
		5, 3, 0, 0, 454, 49, 1, 0, 0, 0, 455, 460, 3, 52, 26, 0, 456, 460, 3, 54,
		27, 0, 457, 460, 3, 56, 28, 0, 458, 460, 3, 74, 37, 0, 459, 455, 1, 0,
		0, 0, 459, 456, 1, 0, 0, 0, 459, 457, 1, 0, 0, 0, 459, 458, 1, 0, 0, 0,
		460, 51, 1, 0, 0, 0, 461, 462, 5, 29, 0, 0, 462, 463, 5, 5, 0, 0, 463,
		464, 3, 128, 64, 0, 464, 465, 5, 6, 0, 0, 465, 468, 3, 102, 51, 0, 466,
		467, 5, 30, 0, 0, 467, 469, 3, 102, 51, 0, 468, 466, 1, 0, 0, 0, 468, 469,
		1, 0, 0, 0, 469, 53, 1, 0, 0, 0, 470, 471, 5, 31, 0, 0, 471, 472, 5, 5,
		0, 0, 472, 477, 3, 170, 85, 0, 473, 474, 5, 13, 0, 0, 474, 476, 3, 128,
		64, 0, 475, 473, 1, 0, 0, 0, 476, 479, 1, 0, 0, 0, 477, 475, 1, 0, 0, 0,
		477, 478, 1, 0, 0, 0, 478, 480, 1, 0, 0, 0, 479, 477, 1, 0, 0, 0, 480,
		481, 5, 6, 0, 0, 481, 55, 1, 0, 0, 0, 482, 483, 5, 32, 0, 0, 483, 484,
		3, 58, 29, 0, 484, 57, 1, 0, 0, 0, 485, 489, 5, 19, 0, 0, 486, 488, 3,
		60, 30, 0, 487, 486, 1, 0, 0, 0, 488, 491, 1, 0, 0, 0, 489, 487, 1, 0,
		0, 0, 489, 490, 1, 0, 0, 0, 490, 492, 1, 0, 0, 0, 491, 489, 1, 0, 0, 0,
		492, 493, 5, 20, 0, 0, 493, 59, 1, 0, 0, 0, 494, 495, 3, 62, 31, 0, 495,
		496, 5, 3, 0, 0, 496, 61, 1, 0, 0, 0, 497, 501, 5, 102, 0, 0, 498, 500,
		3, 64, 32, 0, 499, 498, 1, 0, 0, 0, 500, 503, 1, 0, 0, 0, 501, 499, 1,
		0, 0, 0, 501, 502, 1, 0, 0, 0, 502, 63, 1, 0, 0, 0, 503, 501, 1, 0, 0,
		0, 504, 509, 3, 66, 33, 0, 505, 509, 3, 68, 34, 0, 506, 509, 3, 70, 35,
		0, 507, 509, 3, 72, 36, 0, 508, 504, 1, 0, 0, 0, 508, 505, 1, 0, 0, 0,
		508, 506, 1, 0, 0, 0, 508, 507, 1, 0, 0, 0, 509, 65, 1, 0, 0, 0, 510, 511,
		5, 33, 0, 0, 511, 512, 5, 103, 0, 0, 512, 67, 1, 0, 0, 0, 513, 514, 5,
		34, 0, 0, 514, 515, 5, 103, 0, 0, 515, 69, 1, 0, 0, 0, 516, 517, 5, 35,
		0, 0, 517, 518, 3, 128, 64, 0, 518, 519, 5, 36, 0, 0, 519, 71, 1, 0, 0,
		0, 520, 521, 5, 102, 0, 0, 521, 522, 5, 15, 0, 0, 522, 73, 1, 0, 0, 0,
		523, 524, 5, 37, 0, 0, 524, 525, 5, 5, 0, 0, 525, 526, 3, 170, 85, 0, 526,
		527, 5, 6, 0, 0, 527, 528, 3, 102, 51, 0, 528, 75, 1, 0, 0, 0, 529, 545,
		3, 78, 39, 0, 530, 545, 3, 80, 40, 0, 531, 545, 3, 82, 41, 0, 532, 545,
		3, 84, 42, 0, 533, 545, 3, 86, 43, 0, 534, 545, 3, 88, 44, 0, 535, 545,
		3, 90, 45, 0, 536, 545, 3, 92, 46, 0, 537, 545, 3, 94, 47, 0, 538, 545,
		3, 96, 48, 0, 539, 545, 3, 100, 50, 0, 540, 545, 3, 104, 52, 0, 541, 545,
		3, 106, 53, 0, 542, 545, 3, 108, 54, 0, 543, 545, 3, 110, 55, 0, 544, 529,
		1, 0, 0, 0, 544, 530, 1, 0, 0, 0, 544, 531, 1, 0, 0, 0, 544, 532, 1, 0,
		0, 0, 544, 533, 1, 0, 0, 0, 544, 534, 1, 0, 0, 0, 544, 535, 1, 0, 0, 0,
		544, 536, 1, 0, 0, 0, 544, 537, 1, 0, 0, 0, 544, 538, 1, 0, 0, 0, 544,
		539, 1, 0, 0, 0, 544, 540, 1, 0, 0, 0, 544, 541, 1, 0, 0, 0, 544, 542,
		1, 0, 0, 0, 544, 543, 1, 0, 0, 0, 545, 77, 1, 0, 0, 0, 546, 548, 5, 38,
		0, 0, 547, 549, 5, 39, 0, 0, 548, 547, 1, 0, 0, 0, 548, 549, 1, 0, 0, 0,
		549, 550, 1, 0, 0, 0, 550, 553, 5, 102, 0, 0, 551, 552, 5, 15, 0, 0, 552,
		554, 3, 192, 96, 0, 553, 551, 1, 0, 0, 0, 553, 554, 1, 0, 0, 0, 554, 555,
		1, 0, 0, 0, 555, 556, 5, 22, 0, 0, 556, 557, 3, 128, 64, 0, 557, 558, 5,
		3, 0, 0, 558, 79, 1, 0, 0, 0, 559, 560, 5, 40, 0, 0, 560, 563, 5, 102,
		0, 0, 561, 562, 5, 15, 0, 0, 562, 564, 3, 192, 96, 0, 563, 561, 1, 0, 0,
		0, 563, 564, 1, 0, 0, 0, 564, 565, 1, 0, 0, 0, 565, 566, 5, 22, 0, 0, 566,
		567, 3, 128, 64, 0, 567, 568, 5, 3, 0, 0, 568, 81, 1, 0, 0, 0, 569, 570,
		3, 128, 64, 0, 570, 571, 5, 22, 0, 0, 571, 572, 3, 128, 64, 0, 572, 573,
		5, 3, 0, 0, 573, 83, 1, 0, 0, 0, 574, 575, 3, 128, 64, 0, 575, 576, 5,
		3, 0, 0, 576, 85, 1, 0, 0, 0, 577, 579, 5, 41, 0, 0, 578, 580, 3, 128,
		64, 0, 579, 578, 1, 0, 0, 0, 579, 580, 1, 0, 0, 0, 580, 581, 1, 0, 0, 0,
		581, 582, 5, 3, 0, 0, 582, 87, 1, 0, 0, 0, 583, 584, 5, 42, 0, 0, 584,
		585, 3, 128, 64, 0, 585, 591, 3, 102, 51, 0, 586, 589, 5, 30, 0, 0, 587,
		590, 3, 88, 44, 0, 588, 590, 3, 102, 51, 0, 589, 587, 1, 0, 0, 0, 589,
		588, 1, 0, 0, 0, 590, 592, 1, 0, 0, 0, 591, 586, 1, 0, 0, 0, 591, 592,
		1, 0, 0, 0, 592, 89, 1, 0, 0, 0, 593, 594, 5, 43, 0, 0, 594, 595, 3, 128,
		64, 0, 595, 596, 3, 102, 51, 0, 596, 91, 1, 0, 0, 0, 597, 598, 5, 26, 0,
		0, 598, 599, 5, 102, 0, 0, 599, 600, 5, 44, 0, 0, 600, 601, 3, 128, 64,
		0, 601, 602, 3, 102, 51, 0, 602, 93, 1, 0, 0, 0, 603, 604, 5, 45, 0, 0,
		604, 605, 3, 102, 51, 0, 605, 95, 1, 0, 0, 0, 606, 607, 5, 46, 0, 0, 607,
		608, 3, 128, 64, 0, 608, 612, 5, 19, 0, 0, 609, 611, 3, 98, 49, 0, 610,
		609, 1, 0, 0, 0, 611, 614, 1, 0, 0, 0, 612, 610, 1, 0, 0, 0, 612, 613,
		1, 0, 0, 0, 613, 615, 1, 0, 0, 0, 614, 612, 1, 0, 0, 0, 615, 616, 5, 20,
		0, 0, 616, 97, 1, 0, 0, 0, 617, 618, 3, 114, 57, 0, 618, 624, 5, 47, 0,
		0, 619, 625, 3, 102, 51, 0, 620, 622, 3, 128, 64, 0, 621, 623, 5, 13, 0,
		0, 622, 621, 1, 0, 0, 0, 622, 623, 1, 0, 0, 0, 623, 625, 1, 0, 0, 0, 624,
		619, 1, 0, 0, 0, 624, 620, 1, 0, 0, 0, 625, 99, 1, 0, 0, 0, 626, 627, 3,
		102, 51, 0, 627, 101, 1, 0, 0, 0, 628, 632, 5, 19, 0, 0, 629, 631, 3, 76,
		38, 0, 630, 629, 1, 0, 0, 0, 631, 634, 1, 0, 0, 0, 632, 630, 1, 0, 0, 0,
		632, 633, 1, 0, 0, 0, 633, 635, 1, 0, 0, 0, 634, 632, 1, 0, 0, 0, 635,
		636, 5, 20, 0, 0, 636, 103, 1, 0, 0, 0, 637, 638, 5, 48, 0, 0, 638, 639,
		5, 3, 0, 0, 639, 105, 1, 0, 0, 0, 640, 641, 5, 49, 0, 0, 641, 642, 5, 3,
		0, 0, 642, 107, 1, 0, 0, 0, 643, 648, 5, 50, 0, 0, 644, 649, 3, 102, 51,
		0, 645, 646, 3, 128, 64, 0, 646, 647, 5, 3, 0, 0, 647, 649, 1, 0, 0, 0,
		648, 644, 1, 0, 0, 0, 648, 645, 1, 0, 0, 0, 649, 109, 1, 0, 0, 0, 650,
		651, 5, 9, 0, 0, 651, 652, 3, 112, 56, 0, 652, 111, 1, 0, 0, 0, 653, 657,
		5, 19, 0, 0, 654, 656, 8, 0, 0, 0, 655, 654, 1, 0, 0, 0, 656, 659, 1, 0,
		0, 0, 657, 655, 1, 0, 0, 0, 657, 658, 1, 0, 0, 0, 658, 660, 1, 0, 0, 0,
		659, 657, 1, 0, 0, 0, 660, 661, 5, 20, 0, 0, 661, 113, 1, 0, 0, 0, 662,
		668, 3, 116, 58, 0, 663, 668, 3, 118, 59, 0, 664, 668, 3, 120, 60, 0, 665,
		668, 3, 122, 61, 0, 666, 668, 3, 124, 62, 0, 667, 662, 1, 0, 0, 0, 667,
		663, 1, 0, 0, 0, 667, 664, 1, 0, 0, 0, 667, 665, 1, 0, 0, 0, 667, 666,
		1, 0, 0, 0, 668, 115, 1, 0, 0, 0, 669, 670, 3, 166, 83, 0, 670, 117, 1,
		0, 0, 0, 671, 672, 5, 102, 0, 0, 672, 119, 1, 0, 0, 0, 673, 674, 5, 51,
		0, 0, 674, 121, 1, 0, 0, 0, 675, 676, 5, 5, 0, 0, 676, 681, 3, 114, 57,
		0, 677, 678, 5, 13, 0, 0, 678, 680, 3, 114, 57, 0, 679, 677, 1, 0, 0, 0,
		680, 683, 1, 0, 0, 0, 681, 679, 1, 0, 0, 0, 681, 682, 1, 0, 0, 0, 682,
		684, 1, 0, 0, 0, 683, 681, 1, 0, 0, 0, 684, 685, 5, 6, 0, 0, 685, 123,
		1, 0, 0, 0, 686, 687, 5, 102, 0, 0, 687, 688, 5, 19, 0, 0, 688, 693, 3,
		126, 63, 0, 689, 690, 5, 13, 0, 0, 690, 692, 3, 126, 63, 0, 691, 689, 1,
		0, 0, 0, 692, 695, 1, 0, 0, 0, 693, 691, 1, 0, 0, 0, 693, 694, 1, 0, 0,
		0, 694, 696, 1, 0, 0, 0, 695, 693, 1, 0, 0, 0, 696, 697, 5, 20, 0, 0, 697,
		125, 1, 0, 0, 0, 698, 699, 5, 102, 0, 0, 699, 700, 5, 15, 0, 0, 700, 701,
		3, 114, 57, 0, 701, 127, 1, 0, 0, 0, 702, 705, 3, 130, 65, 0, 703, 705,
		3, 136, 68, 0, 704, 702, 1, 0, 0, 0, 704, 703, 1, 0, 0, 0, 705, 129, 1,
		0, 0, 0, 706, 708, 5, 52, 0, 0, 707, 709, 3, 132, 66, 0, 708, 707, 1, 0,
		0, 0, 708, 709, 1, 0, 0, 0, 709, 710, 1, 0, 0, 0, 710, 713, 5, 52, 0, 0,
		711, 712, 5, 47, 0, 0, 712, 714, 3, 192, 96, 0, 713, 711, 1, 0, 0, 0, 713,
		714, 1, 0, 0, 0, 714, 715, 1, 0, 0, 0, 715, 718, 3, 102, 51, 0, 716, 718,
		3, 136, 68, 0, 717, 706, 1, 0, 0, 0, 717, 716, 1, 0, 0, 0, 718, 131, 1,
		0, 0, 0, 719, 724, 3, 134, 67, 0, 720, 721, 5, 13, 0, 0, 721, 723, 3, 134,
		67, 0, 722, 720, 1, 0, 0, 0, 723, 726, 1, 0, 0, 0, 724, 722, 1, 0, 0, 0,
		724, 725, 1, 0, 0, 0, 725, 133, 1, 0, 0, 0, 726, 724, 1, 0, 0, 0, 727,
		730, 5, 102, 0, 0, 728, 729, 5, 15, 0, 0, 729, 731, 3, 192, 96, 0, 730,
		728, 1, 0, 0, 0, 730, 731, 1, 0, 0, 0, 731, 135, 1, 0, 0, 0, 732, 749,
		3, 138, 69, 0, 733, 739, 3, 142, 71, 0, 734, 735, 5, 17, 0, 0, 735, 736,
		3, 128, 64, 0, 736, 737, 5, 15, 0, 0, 737, 738, 3, 128, 64, 0, 738, 740,
		1, 0, 0, 0, 739, 734, 1, 0, 0, 0, 739, 740, 1, 0, 0, 0, 740, 749, 1, 0,
		0, 0, 741, 742, 5, 42, 0, 0, 742, 743, 3, 142, 71, 0, 743, 744, 5, 53,
		0, 0, 744, 745, 3, 128, 64, 0, 745, 746, 5, 30, 0, 0, 746, 747, 3, 128,
		64, 0, 747, 749, 1, 0, 0, 0, 748, 732, 1, 0, 0, 0, 748, 733, 1, 0, 0, 0,
		748, 741, 1, 0, 0, 0, 749, 137, 1, 0, 0, 0, 750, 751, 5, 54, 0, 0, 751,
		752, 3, 128, 64, 0, 752, 756, 5, 19, 0, 0, 753, 755, 3, 140, 70, 0, 754,
		753, 1, 0, 0, 0, 755, 758, 1, 0, 0, 0, 756, 754, 1, 0, 0, 0, 756, 757,
		1, 0, 0, 0, 757, 759, 1, 0, 0, 0, 758, 756, 1, 0, 0, 0, 759, 760, 5, 20,
		0, 0, 760, 139, 1, 0, 0, 0, 761, 764, 3, 114, 57, 0, 762, 763, 5, 42, 0,
		0, 763, 765, 3, 128, 64, 0, 764, 762, 1, 0, 0, 0, 764, 765, 1, 0, 0, 0,
		765, 766, 1, 0, 0, 0, 766, 767, 5, 47, 0, 0, 767, 769, 3, 128, 64, 0, 768,
		770, 5, 13, 0, 0, 769, 768, 1, 0, 0, 0, 769, 770, 1, 0, 0, 0, 770, 141,
		1, 0, 0, 0, 771, 776, 3, 144, 72, 0, 772, 773, 7, 1, 0, 0, 773, 775, 3,
		144, 72, 0, 774, 772, 1, 0, 0, 0, 775, 778, 1, 0, 0, 0, 776, 774, 1, 0,
		0, 0, 776, 777, 1, 0, 0, 0, 777, 143, 1, 0, 0, 0, 778, 776, 1, 0, 0, 0,
		779, 784, 3, 146, 73, 0, 780, 781, 7, 2, 0, 0, 781, 783, 3, 146, 73, 0,
		782, 780, 1, 0, 0, 0, 783, 786, 1, 0, 0, 0, 784, 782, 1, 0, 0, 0, 784,
		785, 1, 0, 0, 0, 785, 145, 1, 0, 0, 0, 786, 784, 1, 0, 0, 0, 787, 792,
		3, 148, 74, 0, 788, 789, 7, 3, 0, 0, 789, 791, 3, 148, 74, 0, 790, 788,
		1, 0, 0, 0, 791, 794, 1, 0, 0, 0, 792, 790, 1, 0, 0, 0, 792, 793, 1, 0,
		0, 0, 793, 147, 1, 0, 0, 0, 794, 792, 1, 0, 0, 0, 795, 800, 3, 150, 75,
		0, 796, 797, 7, 4, 0, 0, 797, 799, 3, 150, 75, 0, 798, 796, 1, 0, 0, 0,
		799, 802, 1, 0, 0, 0, 800, 798, 1, 0, 0, 0, 800, 801, 1, 0, 0, 0, 801,
		149, 1, 0, 0, 0, 802, 800, 1, 0, 0, 0, 803, 808, 3, 152, 76, 0, 804, 805,
		7, 5, 0, 0, 805, 807, 3, 152, 76, 0, 806, 804, 1, 0, 0, 0, 807, 810, 1,
		0, 0, 0, 808, 806, 1, 0, 0, 0, 808, 809, 1, 0, 0, 0, 809, 151, 1, 0, 0,
		0, 810, 808, 1, 0, 0, 0, 811, 816, 3, 154, 77, 0, 812, 813, 7, 6, 0, 0,
		813, 815, 3, 154, 77, 0, 814, 812, 1, 0, 0, 0, 815, 818, 1, 0, 0, 0, 816,
		814, 1, 0, 0, 0, 816, 817, 1, 0, 0, 0, 817, 153, 1, 0, 0, 0, 818, 816,
		1, 0, 0, 0, 819, 822, 3, 156, 78, 0, 820, 821, 5, 2, 0, 0, 821, 823, 3,
		192, 96, 0, 822, 820, 1, 0, 0, 0, 822, 823, 1, 0, 0, 0, 823, 155, 1, 0,
		0, 0, 824, 825, 7, 7, 0, 0, 825, 828, 3, 156, 78, 0, 826, 828, 3, 158,
		79, 0, 827, 824, 1, 0, 0, 0, 827, 826, 1, 0, 0, 0, 828, 157, 1, 0, 0, 0,
		829, 833, 3, 164, 82, 0, 830, 832, 3, 160, 80, 0, 831, 830, 1, 0, 0, 0,
		832, 835, 1, 0, 0, 0, 833, 831, 1, 0, 0, 0, 833, 834, 1, 0, 0, 0, 834,
		159, 1, 0, 0, 0, 835, 833, 1, 0, 0, 0, 836, 837, 5, 35, 0, 0, 837, 838,
		3, 128, 64, 0, 838, 839, 5, 36, 0, 0, 839, 866, 1, 0, 0, 0, 840, 841, 5,
		4, 0, 0, 841, 866, 5, 102, 0, 0, 842, 844, 5, 5, 0, 0, 843, 845, 3, 162,
		81, 0, 844, 843, 1, 0, 0, 0, 844, 845, 1, 0, 0, 0, 845, 846, 1, 0, 0, 0,
		846, 866, 5, 6, 0, 0, 847, 866, 5, 17, 0, 0, 848, 866, 5, 71, 0, 0, 849,
		866, 5, 72, 0, 0, 850, 851, 5, 73, 0, 0, 851, 852, 5, 5, 0, 0, 852, 853,
		3, 130, 65, 0, 853, 854, 5, 6, 0, 0, 854, 866, 1, 0, 0, 0, 855, 856, 5,
		74, 0, 0, 856, 857, 5, 5, 0, 0, 857, 858, 3, 130, 65, 0, 858, 859, 5, 6,
		0, 0, 859, 866, 1, 0, 0, 0, 860, 861, 5, 75, 0, 0, 861, 862, 5, 5, 0, 0,
		862, 863, 3, 130, 65, 0, 863, 864, 5, 6, 0, 0, 864, 866, 1, 0, 0, 0, 865,
		836, 1, 0, 0, 0, 865, 840, 1, 0, 0, 0, 865, 842, 1, 0, 0, 0, 865, 847,
		1, 0, 0, 0, 865, 848, 1, 0, 0, 0, 865, 849, 1, 0, 0, 0, 865, 850, 1, 0,
		0, 0, 865, 855, 1, 0, 0, 0, 865, 860, 1, 0, 0, 0, 866, 161, 1, 0, 0, 0,
		867, 872, 3, 128, 64, 0, 868, 869, 5, 13, 0, 0, 869, 871, 3, 128, 64, 0,
		870, 868, 1, 0, 0, 0, 871, 874, 1, 0, 0, 0, 872, 870, 1, 0, 0, 0, 872,
		873, 1, 0, 0, 0, 873, 163, 1, 0, 0, 0, 874, 872, 1, 0, 0, 0, 875, 886,
		3, 166, 83, 0, 876, 886, 5, 102, 0, 0, 877, 878, 5, 5, 0, 0, 878, 879,
		3, 128, 64, 0, 879, 880, 5, 6, 0, 0, 880, 886, 1, 0, 0, 0, 881, 886, 3,
		176, 88, 0, 882, 886, 3, 178, 89, 0, 883, 886, 3, 182, 91, 0, 884, 886,
		3, 186, 93, 0, 885, 875, 1, 0, 0, 0, 885, 876, 1, 0, 0, 0, 885, 877, 1,
		0, 0, 0, 885, 881, 1, 0, 0, 0, 885, 882, 1, 0, 0, 0, 885, 883, 1, 0, 0,
		0, 885, 884, 1, 0, 0, 0, 886, 165, 1, 0, 0, 0, 887, 892, 3, 168, 84, 0,
		888, 892, 3, 170, 85, 0, 889, 892, 3, 172, 86, 0, 890, 892, 3, 174, 87,
		0, 891, 887, 1, 0, 0, 0, 891, 888, 1, 0, 0, 0, 891, 889, 1, 0, 0, 0, 891,
		890, 1, 0, 0, 0, 892, 167, 1, 0, 0, 0, 893, 894, 7, 8, 0, 0, 894, 169,
		1, 0, 0, 0, 895, 896, 7, 9, 0, 0, 896, 171, 1, 0, 0, 0, 897, 898, 5, 108,
		0, 0, 898, 173, 1, 0, 0, 0, 899, 900, 7, 10, 0, 0, 900, 175, 1, 0, 0, 0,
		901, 910, 5, 35, 0, 0, 902, 907, 3, 128, 64, 0, 903, 904, 5, 13, 0, 0,
		904, 906, 3, 128, 64, 0, 905, 903, 1, 0, 0, 0, 906, 909, 1, 0, 0, 0, 907,
		905, 1, 0, 0, 0, 907, 908, 1, 0, 0, 0, 908, 911, 1, 0, 0, 0, 909, 907,
		1, 0, 0, 0, 910, 902, 1, 0, 0, 0, 910, 911, 1, 0, 0, 0, 911, 912, 1, 0,
		0, 0, 912, 913, 5, 36, 0, 0, 913, 177, 1, 0, 0, 0, 914, 915, 5, 102, 0,
		0, 915, 924, 5, 19, 0, 0, 916, 921, 3, 180, 90, 0, 917, 918, 5, 13, 0,
		0, 918, 920, 3, 180, 90, 0, 919, 917, 1, 0, 0, 0, 920, 923, 1, 0, 0, 0,
		921, 919, 1, 0, 0, 0, 921, 922, 1, 0, 0, 0, 922, 925, 1, 0, 0, 0, 923,
		921, 1, 0, 0, 0, 924, 916, 1, 0, 0, 0, 924, 925, 1, 0, 0, 0, 925, 926,
		1, 0, 0, 0, 926, 927, 5, 20, 0, 0, 927, 179, 1, 0, 0, 0, 928, 929, 5, 102,
		0, 0, 929, 930, 5, 15, 0, 0, 930, 931, 3, 128, 64, 0, 931, 181, 1, 0, 0,
		0, 932, 933, 5, 78, 0, 0, 933, 934, 5, 5, 0, 0, 934, 939, 3, 128, 64, 0,
		935, 936, 5, 13, 0, 0, 936, 938, 3, 128, 64, 0, 937, 935, 1, 0, 0, 0, 938,
		941, 1, 0, 0, 0, 939, 937, 1, 0, 0, 0, 939, 940, 1, 0, 0, 0, 940, 942,
		1, 0, 0, 0, 941, 939, 1, 0, 0, 0, 942, 943, 5, 6, 0, 0, 943, 983, 1, 0,
		0, 0, 944, 945, 5, 79, 0, 0, 945, 946, 5, 5, 0, 0, 946, 949, 3, 128, 64,
		0, 947, 948, 5, 13, 0, 0, 948, 950, 3, 128, 64, 0, 949, 947, 1, 0, 0, 0,
		949, 950, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 952, 5, 6, 0, 0, 952,
		983, 1, 0, 0, 0, 953, 954, 5, 80, 0, 0, 954, 955, 5, 5, 0, 0, 955, 956,
		3, 170, 85, 0, 956, 957, 5, 6, 0, 0, 957, 983, 1, 0, 0, 0, 958, 959, 5,
		81, 0, 0, 959, 960, 5, 5, 0, 0, 960, 961, 3, 170, 85, 0, 961, 962, 5, 6,
		0, 0, 962, 983, 1, 0, 0, 0, 963, 964, 5, 82, 0, 0, 964, 983, 3, 184, 92,
		0, 965, 966, 5, 83, 0, 0, 966, 967, 5, 5, 0, 0, 967, 968, 3, 128, 64, 0,
		968, 969, 5, 6, 0, 0, 969, 983, 1, 0, 0, 0, 970, 971, 5, 84, 0, 0, 971,
		972, 5, 5, 0, 0, 972, 973, 5, 102, 0, 0, 973, 974, 5, 13, 0, 0, 974, 975,
		3, 128, 64, 0, 975, 976, 5, 6, 0, 0, 976, 983, 1, 0, 0, 0, 977, 978, 5,
		85, 0, 0, 978, 979, 5, 5, 0, 0, 979, 980, 3, 170, 85, 0, 980, 981, 5, 6,
		0, 0, 981, 983, 1, 0, 0, 0, 982, 932, 1, 0, 0, 0, 982, 944, 1, 0, 0, 0,
		982, 953, 1, 0, 0, 0, 982, 958, 1, 0, 0, 0, 982, 963, 1, 0, 0, 0, 982,
		965, 1, 0, 0, 0, 982, 970, 1, 0, 0, 0, 982, 977, 1, 0, 0, 0, 983, 183,
		1, 0, 0, 0, 984, 985, 5, 109, 0, 0, 985, 185, 1, 0, 0, 0, 986, 987, 5,
		9, 0, 0, 987, 988, 5, 5, 0, 0, 988, 993, 3, 170, 85, 0, 989, 990, 5, 13,
		0, 0, 990, 992, 3, 188, 94, 0, 991, 989, 1, 0, 0, 0, 992, 995, 1, 0, 0,
		0, 993, 991, 1, 0, 0, 0, 993, 994, 1, 0, 0, 0, 994, 996, 1, 0, 0, 0, 995,
		993, 1, 0, 0, 0, 996, 997, 5, 6, 0, 0, 997, 187, 1, 0, 0, 0, 998, 999,
		5, 15, 0, 0, 999, 1000, 5, 86, 0, 0, 1000, 1001, 3, 190, 95, 0, 1001, 1002,
		5, 86, 0, 0, 1002, 1003, 5, 5, 0, 0, 1003, 1004, 3, 128, 64, 0, 1004, 1005,
		5, 6, 0, 0, 1005, 189, 1, 0, 0, 0, 1006, 1007, 5, 102, 0, 0, 1007, 191,
		1, 0, 0, 0, 1008, 1018, 3, 194, 97, 0, 1009, 1018, 3, 196, 98, 0, 1010,
		1018, 3, 198, 99, 0, 1011, 1018, 3, 200, 100, 0, 1012, 1018, 3, 204, 102,
		0, 1013, 1018, 3, 206, 103, 0, 1014, 1018, 3, 208, 104, 0, 1015, 1018,
		3, 214, 107, 0, 1016, 1018, 3, 216, 108, 0, 1017, 1008, 1, 0, 0, 0, 1017,
		1009, 1, 0, 0, 0, 1017, 1010, 1, 0, 0, 0, 1017, 1011, 1, 0, 0, 0, 1017,
		1012, 1, 0, 0, 0, 1017, 1013, 1, 0, 0, 0, 1017, 1014, 1, 0, 0, 0, 1017,
		1015, 1, 0, 0, 0, 1017, 1016, 1, 0, 0, 0, 1018, 193, 1, 0, 0, 0, 1019,
		1020, 7, 11, 0, 0, 1020, 195, 1, 0, 0, 0, 1021, 1022, 5, 35, 0, 0, 1022,
		1023, 3, 192, 96, 0, 1023, 1024, 5, 3, 0, 0, 1024, 1025, 3, 128, 64, 0,
		1025, 1026, 5, 36, 0, 0, 1026, 1032, 1, 0, 0, 0, 1027, 1028, 5, 35, 0,
		0, 1028, 1029, 3, 192, 96, 0, 1029, 1030, 5, 36, 0, 0, 1030, 1032, 1, 0,
		0, 0, 1031, 1021, 1, 0, 0, 0, 1031, 1027, 1, 0, 0, 0, 1032, 197, 1, 0,
		0, 0, 1033, 1035, 5, 65, 0, 0, 1034, 1036, 5, 27, 0, 0, 1035, 1034, 1,
		0, 0, 0, 1035, 1036, 1, 0, 0, 0, 1036, 1037, 1, 0, 0, 0, 1037, 1042, 3,
		192, 96, 0, 1038, 1039, 5, 65, 0, 0, 1039, 1040, 5, 39, 0, 0, 1040, 1042,
		3, 192, 96, 0, 1041, 1033, 1, 0, 0, 0, 1041, 1038, 1, 0, 0, 0, 1042, 199,
		1, 0, 0, 0, 1043, 1044, 5, 8, 0, 0, 1044, 1046, 5, 5, 0, 0, 1045, 1047,
		3, 202, 101, 0, 1046, 1045, 1, 0, 0, 0, 1046, 1047, 1, 0, 0, 0, 1047, 1048,
		1, 0, 0, 0, 1048, 1050, 5, 6, 0, 0, 1049, 1051, 3, 20, 10, 0, 1050, 1049,
		1, 0, 0, 0, 1050, 1051, 1, 0, 0, 0, 1051, 201, 1, 0, 0, 0, 1052, 1057,
		3, 192, 96, 0, 1053, 1054, 5, 13, 0, 0, 1054, 1056, 3, 192, 96, 0, 1055,
		1053, 1, 0, 0, 0, 1056, 1059, 1, 0, 0, 0, 1057, 1055, 1, 0, 0, 0, 1057,
		1058, 1, 0, 0, 0, 1058, 203, 1, 0, 0, 0, 1059, 1057, 1, 0, 0, 0, 1060,
		1061, 5, 18, 0, 0, 1061, 1063, 5, 19, 0, 0, 1062, 1064, 3, 26, 13, 0, 1063,
		1062, 1, 0, 0, 0, 1063, 1064, 1, 0, 0, 0, 1064, 1065, 1, 0, 0, 0, 1065,
		1066, 5, 20, 0, 0, 1066, 205, 1, 0, 0, 0, 1067, 1068, 5, 21, 0, 0, 1068,
		1070, 5, 19, 0, 0, 1069, 1071, 3, 32, 16, 0, 1070, 1069, 1, 0, 0, 0, 1070,
		1071, 1, 0, 0, 0, 1071, 1072, 1, 0, 0, 0, 1072, 1073, 5, 20, 0, 0, 1073,
		207, 1, 0, 0, 0, 1074, 1075, 5, 100, 0, 0, 1075, 1077, 5, 19, 0, 0, 1076,
		1078, 3, 210, 105, 0, 1077, 1076, 1, 0, 0, 0, 1077, 1078, 1, 0, 0, 0, 1078,
		1079, 1, 0, 0, 0, 1079, 1080, 5, 20, 0, 0, 1080, 209, 1, 0, 0, 0, 1081,
		1086, 3, 212, 106, 0, 1082, 1083, 5, 13, 0, 0, 1083, 1085, 3, 212, 106,
		0, 1084, 1082, 1, 0, 0, 0, 1085, 1088, 1, 0, 0, 0, 1086, 1084, 1, 0, 0,
		0, 1086, 1087, 1, 0, 0, 0, 1087, 1090, 1, 0, 0, 0, 1088, 1086, 1, 0, 0,
		0, 1089, 1091, 5, 13, 0, 0, 1090, 1089, 1, 0, 0, 0, 1090, 1091, 1, 0, 0,
		0, 1091, 211, 1, 0, 0, 0, 1092, 1093, 5, 102, 0, 0, 1093, 1094, 5, 15,
		0, 0, 1094, 1095, 5, 103, 0, 0, 1095, 213, 1, 0, 0, 0, 1096, 1101, 5, 102,
		0, 0, 1097, 1098, 5, 101, 0, 0, 1098, 1100, 5, 102, 0, 0, 1099, 1097, 1,
		0, 0, 0, 1100, 1103, 1, 0, 0, 0, 1101, 1099, 1, 0, 0, 0, 1101, 1102, 1,
		0, 0, 0, 1102, 215, 1, 0, 0, 0, 1103, 1101, 1, 0, 0, 0, 1104, 1105, 3,
		194, 97, 0, 1105, 1106, 5, 17, 0, 0, 1106, 1129, 1, 0, 0, 0, 1107, 1108,
		3, 196, 98, 0, 1108, 1109, 5, 17, 0, 0, 1109, 1129, 1, 0, 0, 0, 1110, 1111,
		3, 198, 99, 0, 1111, 1112, 5, 17, 0, 0, 1112, 1129, 1, 0, 0, 0, 1113, 1114,
		3, 200, 100, 0, 1114, 1115, 5, 17, 0, 0, 1115, 1129, 1, 0, 0, 0, 1116,
		1117, 3, 204, 102, 0, 1117, 1118, 5, 17, 0, 0, 1118, 1129, 1, 0, 0, 0,
		1119, 1120, 3, 206, 103, 0, 1120, 1121, 5, 17, 0, 0, 1121, 1129, 1, 0,
		0, 0, 1122, 1123, 3, 208, 104, 0, 1123, 1124, 5, 17, 0, 0, 1124, 1129,
		1, 0, 0, 0, 1125, 1126, 3, 214, 107, 0, 1126, 1127, 5, 17, 0, 0, 1127,
		1129, 1, 0, 0, 0, 1128, 1104, 1, 0, 0, 0, 1128, 1107, 1, 0, 0, 0, 1128,
		1110, 1, 0, 0, 0, 1128, 1113, 1, 0, 0, 0, 1128, 1116, 1, 0, 0, 0, 1128,
		1119, 1, 0, 0, 0, 1128, 1122, 1, 0, 0, 0, 1128, 1125, 1, 0, 0, 0, 1129,
		217, 1, 0, 0, 0, 106, 221, 223, 232, 242, 245, 256, 259, 264, 268, 272,
		275, 285, 295, 305, 317, 320, 325, 329, 338, 342, 349, 354, 358, 367, 371,
		376, 385, 390, 394, 401, 407, 411, 414, 426, 432, 443, 451, 459, 468, 477,
		489, 501, 508, 544, 548, 553, 563, 579, 589, 591, 612, 622, 624, 632, 648,
		657, 667, 681, 693, 704, 708, 713, 717, 724, 730, 739, 748, 756, 764, 769,
		776, 784, 792, 800, 808, 816, 822, 827, 833, 844, 865, 872, 885, 891, 907,
		910, 921, 924, 939, 949, 982, 993, 1017, 1031, 1035, 1041, 1046, 1050,
		1057, 1063, 1070, 1077, 1086, 1090, 1101, 1128,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// MinZParserInit initializes any static state used to implement MinZParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewMinZParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func MinZParserInit() {
	staticData := &MinZParserStaticData
	staticData.once.Do(minzParserInit)
}

// NewMinZParser produces a new parser instance for the optional input antlr.TokenStream.
func NewMinZParser(input antlr.TokenStream) *MinZParser {
	MinZParserInit()
	this := new(MinZParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &MinZParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "MinZ.g4"

	return this
}

// MinZParser tokens.
const (
	MinZParserEOF           = antlr.TokenEOF
	MinZParserT__0          = 1
	MinZParserT__1          = 2
	MinZParserT__2          = 3
	MinZParserT__3          = 4
	MinZParserT__4          = 5
	MinZParserT__5          = 6
	MinZParserT__6          = 7
	MinZParserT__7          = 8
	MinZParserT__8          = 9
	MinZParserT__9          = 10
	MinZParserT__10         = 11
	MinZParserT__11         = 12
	MinZParserT__12         = 13
	MinZParserT__13         = 14
	MinZParserT__14         = 15
	MinZParserT__15         = 16
	MinZParserT__16         = 17
	MinZParserT__17         = 18
	MinZParserT__18         = 19
	MinZParserT__19         = 20
	MinZParserT__20         = 21
	MinZParserT__21         = 22
	MinZParserT__22         = 23
	MinZParserT__23         = 24
	MinZParserT__24         = 25
	MinZParserT__25         = 26
	MinZParserT__26         = 27
	MinZParserT__27         = 28
	MinZParserT__28         = 29
	MinZParserT__29         = 30
	MinZParserT__30         = 31
	MinZParserT__31         = 32
	MinZParserT__32         = 33
	MinZParserT__33         = 34
	MinZParserT__34         = 35
	MinZParserT__35         = 36
	MinZParserT__36         = 37
	MinZParserT__37         = 38
	MinZParserT__38         = 39
	MinZParserT__39         = 40
	MinZParserT__40         = 41
	MinZParserT__41         = 42
	MinZParserT__42         = 43
	MinZParserT__43         = 44
	MinZParserT__44         = 45
	MinZParserT__45         = 46
	MinZParserT__46         = 47
	MinZParserT__47         = 48
	MinZParserT__48         = 49
	MinZParserT__49         = 50
	MinZParserT__50         = 51
	MinZParserT__51         = 52
	MinZParserT__52         = 53
	MinZParserT__53         = 54
	MinZParserT__54         = 55
	MinZParserT__55         = 56
	MinZParserT__56         = 57
	MinZParserT__57         = 58
	MinZParserT__58         = 59
	MinZParserT__59         = 60
	MinZParserT__60         = 61
	MinZParserT__61         = 62
	MinZParserT__62         = 63
	MinZParserT__63         = 64
	MinZParserT__64         = 65
	MinZParserT__65         = 66
	MinZParserT__66         = 67
	MinZParserT__67         = 68
	MinZParserT__68         = 69
	MinZParserT__69         = 70
	MinZParserT__70         = 71
	MinZParserT__71         = 72
	MinZParserT__72         = 73
	MinZParserT__73         = 74
	MinZParserT__74         = 75
	MinZParserT__75         = 76
	MinZParserT__76         = 77
	MinZParserT__77         = 78
	MinZParserT__78         = 79
	MinZParserT__79         = 80
	MinZParserT__80         = 81
	MinZParserT__81         = 82
	MinZParserT__82         = 83
	MinZParserT__83         = 84
	MinZParserT__84         = 85
	MinZParserT__85         = 86
	MinZParserT__86         = 87
	MinZParserT__87         = 88
	MinZParserT__88         = 89
	MinZParserT__89         = 90
	MinZParserT__90         = 91
	MinZParserT__91         = 92
	MinZParserT__92         = 93
	MinZParserT__93         = 94
	MinZParserT__94         = 95
	MinZParserT__95         = 96
	MinZParserT__96         = 97
	MinZParserT__97         = 98
	MinZParserT__98         = 99
	MinZParserT__99         = 100
	MinZParserT__100        = 101
	MinZParserIDENTIFIER    = 102
	MinZParserNUMBER        = 103
	MinZParserHEX_NUMBER    = 104
	MinZParserBINARY_NUMBER = 105
	MinZParserSTRING        = 106
	MinZParserLSTRING       = 107
	MinZParserCHAR          = 108
	MinZParserLUA_BLOCK     = 109
	MinZParserLINE_COMMENT  = 110
	MinZParserBLOCK_COMMENT = 111
	MinZParserWS            = 112
)

// MinZParser rules.
const (
	MinZParserRULE_sourceFile               = 0
	MinZParserRULE_importStatement          = 1
	MinZParserRULE_importPath               = 2
	MinZParserRULE_declaration              = 3
	MinZParserRULE_functionDeclaration      = 4
	MinZParserRULE_functionPrefix           = 5
	MinZParserRULE_visibility               = 6
	MinZParserRULE_genericParams            = 7
	MinZParserRULE_parameterList            = 8
	MinZParserRULE_parameter                = 9
	MinZParserRULE_returnType               = 10
	MinZParserRULE_errorReturnType          = 11
	MinZParserRULE_structDeclaration        = 12
	MinZParserRULE_fieldList                = 13
	MinZParserRULE_field                    = 14
	MinZParserRULE_enumDeclaration          = 15
	MinZParserRULE_enumMemberList           = 16
	MinZParserRULE_enumMember               = 17
	MinZParserRULE_typeAliasDeclaration     = 18
	MinZParserRULE_interfaceDeclaration     = 19
	MinZParserRULE_interfaceMethodList      = 20
	MinZParserRULE_interfaceMethod          = 21
	MinZParserRULE_implBlock                = 22
	MinZParserRULE_constDeclaration         = 23
	MinZParserRULE_globalVarDeclaration     = 24
	MinZParserRULE_compileTimeDeclaration   = 25
	MinZParserRULE_compileTimeIf            = 26
	MinZParserRULE_compileTimeMinz          = 27
	MinZParserRULE_compileTimeMir           = 28
	MinZParserRULE_mirBlock                 = 29
	MinZParserRULE_mirStatement             = 30
	MinZParserRULE_mirInstruction           = 31
	MinZParserRULE_mirOperand               = 32
	MinZParserRULE_mirRegister              = 33
	MinZParserRULE_mirImmediate             = 34
	MinZParserRULE_mirMemory                = 35
	MinZParserRULE_mirLabel                 = 36
	MinZParserRULE_targetBlock              = 37
	MinZParserRULE_statement                = 38
	MinZParserRULE_letStatement             = 39
	MinZParserRULE_varStatement             = 40
	MinZParserRULE_assignmentStatement      = 41
	MinZParserRULE_expressionStatement      = 42
	MinZParserRULE_returnStatement          = 43
	MinZParserRULE_ifStatement              = 44
	MinZParserRULE_whileStatement           = 45
	MinZParserRULE_forStatement             = 46
	MinZParserRULE_loopStatement            = 47
	MinZParserRULE_caseStatement            = 48
	MinZParserRULE_caseArm                  = 49
	MinZParserRULE_blockStatement           = 50
	MinZParserRULE_block                    = 51
	MinZParserRULE_breakStatement           = 52
	MinZParserRULE_continueStatement        = 53
	MinZParserRULE_deferStatement           = 54
	MinZParserRULE_asmStatement             = 55
	MinZParserRULE_asmBlock                 = 56
	MinZParserRULE_pattern                  = 57
	MinZParserRULE_literalPattern           = 58
	MinZParserRULE_identifierPattern        = 59
	MinZParserRULE_wildcardPattern          = 60
	MinZParserRULE_tuplePattern             = 61
	MinZParserRULE_structPattern            = 62
	MinZParserRULE_fieldPattern             = 63
	MinZParserRULE_expression               = 64
	MinZParserRULE_lambdaExpression         = 65
	MinZParserRULE_lambdaParams             = 66
	MinZParserRULE_lambdaParam              = 67
	MinZParserRULE_conditionalExpression    = 68
	MinZParserRULE_whenExpression           = 69
	MinZParserRULE_whenArm                  = 70
	MinZParserRULE_logicalOrExpression      = 71
	MinZParserRULE_logicalAndExpression     = 72
	MinZParserRULE_equalityExpression       = 73
	MinZParserRULE_relationalExpression     = 74
	MinZParserRULE_additiveExpression       = 75
	MinZParserRULE_multiplicativeExpression = 76
	MinZParserRULE_castExpression           = 77
	MinZParserRULE_unaryExpression          = 78
	MinZParserRULE_postfixExpression        = 79
	MinZParserRULE_postfixOperator          = 80
	MinZParserRULE_argumentList             = 81
	MinZParserRULE_primaryExpression        = 82
	MinZParserRULE_literal                  = 83
	MinZParserRULE_numberLiteral            = 84
	MinZParserRULE_stringLiteral            = 85
	MinZParserRULE_charLiteral              = 86
	MinZParserRULE_booleanLiteral           = 87
	MinZParserRULE_arrayLiteral             = 88
	MinZParserRULE_structLiteral            = 89
	MinZParserRULE_fieldInit                = 90
	MinZParserRULE_metafunction             = 91
	MinZParserRULE_luaBlock                 = 92
	MinZParserRULE_inlineAssembly           = 93
	MinZParserRULE_asmOperand               = 94
	MinZParserRULE_asmConstraint            = 95
	MinZParserRULE_type                     = 96
	MinZParserRULE_primitiveType            = 97
	MinZParserRULE_arrayType                = 98
	MinZParserRULE_pointerType              = 99
	MinZParserRULE_functionType             = 100
	MinZParserRULE_typeList                 = 101
	MinZParserRULE_structType               = 102
	MinZParserRULE_enumType                 = 103
	MinZParserRULE_bitStructType            = 104
	MinZParserRULE_bitFieldList             = 105
	MinZParserRULE_bitField                 = 106
	MinZParserRULE_typeIdentifier           = 107
	MinZParserRULE_errorType                = 108
)

// ISourceFileContext is an interface to support dynamic dispatch.
type ISourceFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllImportStatement() []IImportStatementContext
	ImportStatement(i int) IImportStatementContext
	AllDeclaration() []IDeclarationContext
	Declaration(i int) IDeclarationContext
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsSourceFileContext differentiates from other interfaces.
	IsSourceFileContext()
}

type SourceFileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceFileContext() *SourceFileContext {
	var p = new(SourceFileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_sourceFile
	return p
}

func InitEmptySourceFileContext(p *SourceFileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_sourceFile
}

func (*SourceFileContext) IsSourceFileContext() {}

func NewSourceFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceFileContext {
	var p = new(SourceFileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_sourceFile

	return p
}

func (s *SourceFileContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceFileContext) EOF() antlr.TerminalNode {
	return s.GetToken(MinZParserEOF, 0)
}

func (s *SourceFileContext) AllImportStatement() []IImportStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportStatementContext); ok {
			len++
		}
	}

	tst := make([]IImportStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportStatementContext); ok {
			tst[i] = t.(IImportStatementContext)
			i++
		}
	}

	return tst
}

func (s *SourceFileContext) ImportStatement(i int) IImportStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *SourceFileContext) AllDeclaration() []IDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationContext); ok {
			tst[i] = t.(IDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *SourceFileContext) Declaration(i int) IDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *SourceFileContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *SourceFileContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SourceFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterSourceFile(s)
	}
}

func (s *SourceFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitSourceFile(s)
	}
}

func (p *MinZParser) SourceFile() (localctx ISourceFileContext) {
	localctx = NewSourceFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, MinZParserRULE_sourceFile)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&24610822951800738) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&34909498372211) != 0) {
		p.SetState(221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(218)
				p.ImportStatement()
			}

		case 2:
			{
				p.SetState(219)
				p.Declaration()
			}

		case 3:
			{
				p.SetState(220)
				p.Statement()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(226)
		p.Match(MinZParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlias returns the alias token.
	GetAlias() antlr.Token

	// SetAlias sets the alias token.
	SetAlias(antlr.Token)

	// Getter signatures
	ImportPath() IImportPathContext
	IDENTIFIER() antlr.TerminalNode

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	alias  antlr.Token
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_importStatement
	return p
}

func InitEmptyImportStatementContext(p *ImportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_importStatement
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) GetAlias() antlr.Token { return s.alias }

func (s *ImportStatementContext) SetAlias(v antlr.Token) { s.alias = v }

func (s *ImportStatementContext) ImportPath() IImportPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportPathContext)
}

func (s *ImportStatementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterImportStatement(s)
	}
}

func (s *ImportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitImportStatement(s)
	}
}

func (p *MinZParser) ImportStatement() (localctx IImportStatementContext) {
	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, MinZParserRULE_importStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(228)
		p.Match(MinZParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(229)
		p.ImportPath()
	}
	p.SetState(232)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__1 {
		{
			p.SetState(230)
			p.Match(MinZParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(231)

			var _m = p.Match(MinZParserIDENTIFIER)

			localctx.(*ImportStatementContext).alias = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(234)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportPathContext is an interface to support dynamic dispatch.
type IImportPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode

	// IsImportPathContext differentiates from other interfaces.
	IsImportPathContext()
}

type ImportPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportPathContext() *ImportPathContext {
	var p = new(ImportPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_importPath
	return p
}

func InitEmptyImportPathContext(p *ImportPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_importPath
}

func (*ImportPathContext) IsImportPathContext() {}

func NewImportPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportPathContext {
	var p = new(ImportPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_importPath

	return p
}

func (s *ImportPathContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportPathContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ImportPathContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(MinZParserIDENTIFIER)
}

func (s *ImportPathContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, i)
}

func (s *ImportPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterImportPath(s)
	}
}

func (s *ImportPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitImportPath(s)
	}
}

func (p *MinZParser) ImportPath() (localctx IImportPathContext) {
	localctx = NewImportPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, MinZParserRULE_importPath)
	var _la int

	p.SetState(245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserSTRING, MinZParserLSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(236)
			p.StringLiteral()
		}

	case MinZParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(237)
			p.Match(MinZParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(242)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MinZParserT__3 {
			{
				p.SetState(238)
				p.Match(MinZParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(239)
				p.Match(MinZParserIDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(244)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionDeclaration() IFunctionDeclarationContext
	StructDeclaration() IStructDeclarationContext
	EnumDeclaration() IEnumDeclarationContext
	TypeAliasDeclaration() ITypeAliasDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	ImplBlock() IImplBlockContext
	ConstDeclaration() IConstDeclarationContext
	GlobalVarDeclaration() IGlobalVarDeclarationContext
	CompileTimeDeclaration() ICompileTimeDeclarationContext

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_declaration
	return p
}

func InitEmptyDeclarationContext(p *DeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_declaration
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *DeclarationContext) StructDeclaration() IStructDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructDeclarationContext)
}

func (s *DeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *DeclarationContext) TypeAliasDeclaration() ITypeAliasDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasDeclarationContext)
}

func (s *DeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *DeclarationContext) ImplBlock() IImplBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplBlockContext)
}

func (s *DeclarationContext) ConstDeclaration() IConstDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstDeclarationContext)
}

func (s *DeclarationContext) GlobalVarDeclaration() IGlobalVarDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalVarDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalVarDeclarationContext)
}

func (s *DeclarationContext) CompileTimeDeclaration() ICompileTimeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompileTimeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompileTimeDeclarationContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (p *MinZParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, MinZParserRULE_declaration)
	p.SetState(256)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(247)
			p.FunctionDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(248)
			p.StructDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(249)
			p.EnumDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(250)
			p.TypeAliasDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(251)
			p.InterfaceDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(252)
			p.ImplBlock()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(253)
			p.ConstDeclaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(254)
			p.GlobalVarDeclaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(255)
			p.CompileTimeDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionPrefix() IFunctionPrefixContext
	IDENTIFIER() antlr.TerminalNode
	Block() IBlockContext
	Visibility() IVisibilityContext
	GenericParams() IGenericParamsContext
	ParameterList() IParameterListContext
	ReturnType() IReturnTypeContext
	ErrorReturnType() IErrorReturnTypeContext

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_functionDeclaration
	return p
}

func InitEmptyFunctionDeclarationContext(p *FunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_functionDeclaration
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) FunctionPrefix() IFunctionPrefixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionPrefixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionPrefixContext)
}

func (s *FunctionDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *FunctionDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionDeclarationContext) Visibility() IVisibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *FunctionDeclarationContext) GenericParams() IGenericParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParamsContext)
}

func (s *FunctionDeclarationContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *FunctionDeclarationContext) ReturnType() IReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *FunctionDeclarationContext) ErrorReturnType() IErrorReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorReturnTypeContext)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (p *MinZParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, MinZParserRULE_functionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__10 {
		{
			p.SetState(258)
			p.Visibility()
		}

	}
	{
		p.SetState(261)
		p.FunctionPrefix()
	}
	{
		p.SetState(262)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__11 {
		{
			p.SetState(263)
			p.GenericParams()
		}

	}
	{
		p.SetState(266)
		p.Match(MinZParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserIDENTIFIER {
		{
			p.SetState(267)
			p.ParameterList()
		}

	}
	{
		p.SetState(270)
		p.Match(MinZParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__15 {
		{
			p.SetState(271)
			p.ReturnType()
		}

	}
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__16 {
		{
			p.SetState(274)
			p.ErrorReturnType()
		}

	}
	{
		p.SetState(277)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionPrefixContext is an interface to support dynamic dispatch.
type IFunctionPrefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFunctionPrefixContext differentiates from other interfaces.
	IsFunctionPrefixContext()
}

type FunctionPrefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionPrefixContext() *FunctionPrefixContext {
	var p = new(FunctionPrefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_functionPrefix
	return p
}

func InitEmptyFunctionPrefixContext(p *FunctionPrefixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_functionPrefix
}

func (*FunctionPrefixContext) IsFunctionPrefixContext() {}

func NewFunctionPrefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionPrefixContext {
	var p = new(FunctionPrefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_functionPrefix

	return p
}

func (s *FunctionPrefixContext) GetParser() antlr.Parser { return s.parser }
func (s *FunctionPrefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionPrefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionPrefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterFunctionPrefix(s)
	}
}

func (s *FunctionPrefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitFunctionPrefix(s)
	}
}

func (p *MinZParser) FunctionPrefix() (localctx IFunctionPrefixContext) {
	localctx = NewFunctionPrefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, MinZParserRULE_functionPrefix)
	p.SetState(285)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserT__6:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(279)
			p.Match(MinZParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__7:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(280)
			p.Match(MinZParserT__7)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__8:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(281)
			p.Match(MinZParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(282)
			p.Match(MinZParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__9:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(283)
			p.Match(MinZParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(284)
			p.Match(MinZParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVisibilityContext is an interface to support dynamic dispatch.
type IVisibilityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsVisibilityContext differentiates from other interfaces.
	IsVisibilityContext()
}

type VisibilityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVisibilityContext() *VisibilityContext {
	var p = new(VisibilityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_visibility
	return p
}

func InitEmptyVisibilityContext(p *VisibilityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_visibility
}

func (*VisibilityContext) IsVisibilityContext() {}

func NewVisibilityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VisibilityContext {
	var p = new(VisibilityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_visibility

	return p
}

func (s *VisibilityContext) GetParser() antlr.Parser { return s.parser }
func (s *VisibilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VisibilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterVisibility(s)
	}
}

func (s *VisibilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitVisibility(s)
	}
}

func (p *MinZParser) Visibility() (localctx IVisibilityContext) {
	localctx = NewVisibilityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, MinZParserRULE_visibility)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(287)
		p.Match(MinZParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericParamsContext is an interface to support dynamic dispatch.
type IGenericParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode

	// IsGenericParamsContext differentiates from other interfaces.
	IsGenericParamsContext()
}

type GenericParamsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericParamsContext() *GenericParamsContext {
	var p = new(GenericParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_genericParams
	return p
}

func InitEmptyGenericParamsContext(p *GenericParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_genericParams
}

func (*GenericParamsContext) IsGenericParamsContext() {}

func NewGenericParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericParamsContext {
	var p = new(GenericParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_genericParams

	return p
}

func (s *GenericParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericParamsContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(MinZParserIDENTIFIER)
}

func (s *GenericParamsContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, i)
}

func (s *GenericParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterGenericParams(s)
	}
}

func (s *GenericParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitGenericParams(s)
	}
}

func (p *MinZParser) GenericParams() (localctx IGenericParamsContext) {
	localctx = NewGenericParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, MinZParserRULE_genericParams)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(289)
		p.Match(MinZParserT__11)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(290)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__12 {
		{
			p.SetState(291)
			p.Match(MinZParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(292)
			p.Match(MinZParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(297)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(298)
		p.Match(MinZParserT__13)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterListContext is an interface to support dynamic dispatch.
type IParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParameter() []IParameterContext
	Parameter(i int) IParameterContext

	// IsParameterListContext differentiates from other interfaces.
	IsParameterListContext()
}

type ParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterListContext() *ParameterListContext {
	var p = new(ParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_parameterList
	return p
}

func InitEmptyParameterListContext(p *ParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_parameterList
}

func (*ParameterListContext) IsParameterListContext() {}

func NewParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterListContext {
	var p = new(ParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_parameterList

	return p
}

func (s *ParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterListContext) AllParameter() []IParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterContext); ok {
			len++
		}
	}

	tst := make([]IParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterContext); ok {
			tst[i] = t.(IParameterContext)
			i++
		}
	}

	return tst
}

func (s *ParameterListContext) Parameter(i int) IParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterContext)
}

func (s *ParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterParameterList(s)
	}
}

func (s *ParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitParameterList(s)
	}
}

func (p *MinZParser) ParameterList() (localctx IParameterListContext) {
	localctx = NewParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, MinZParserRULE_parameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(300)
		p.Parameter()
	}
	p.SetState(305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__12 {
		{
			p.SetState(301)
			p.Match(MinZParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(302)
			p.Parameter()
		}

		p.SetState(307)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterContext is an interface to support dynamic dispatch.
type IParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Type_() ITypeContext

	// IsParameterContext differentiates from other interfaces.
	IsParameterContext()
}

type ParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterContext() *ParameterContext {
	var p = new(ParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_parameter
	return p
}

func InitEmptyParameterContext(p *ParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_parameter
}

func (*ParameterContext) IsParameterContext() {}

func NewParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterContext {
	var p = new(ParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_parameter

	return p
}

func (s *ParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *ParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (p *MinZParser) Parameter() (localctx IParameterContext) {
	localctx = NewParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, MinZParserRULE_parameter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(308)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(309)
		p.Match(MinZParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(310)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnTypeContext is an interface to support dynamic dispatch.
type IReturnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext

	// IsReturnTypeContext differentiates from other interfaces.
	IsReturnTypeContext()
}

type ReturnTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnTypeContext() *ReturnTypeContext {
	var p = new(ReturnTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_returnType
	return p
}

func InitEmptyReturnTypeContext(p *ReturnTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_returnType
}

func (*ReturnTypeContext) IsReturnTypeContext() {}

func NewReturnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnTypeContext {
	var p = new(ReturnTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_returnType

	return p
}

func (s *ReturnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ReturnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterReturnType(s)
	}
}

func (s *ReturnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitReturnType(s)
	}
}

func (p *MinZParser) ReturnType() (localctx IReturnTypeContext) {
	localctx = NewReturnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, MinZParserRULE_returnType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(312)
		p.Match(MinZParserT__15)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(313)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorReturnTypeContext is an interface to support dynamic dispatch.
type IErrorReturnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext

	// IsErrorReturnTypeContext differentiates from other interfaces.
	IsErrorReturnTypeContext()
}

type ErrorReturnTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorReturnTypeContext() *ErrorReturnTypeContext {
	var p = new(ErrorReturnTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_errorReturnType
	return p
}

func InitEmptyErrorReturnTypeContext(p *ErrorReturnTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_errorReturnType
}

func (*ErrorReturnTypeContext) IsErrorReturnTypeContext() {}

func NewErrorReturnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorReturnTypeContext {
	var p = new(ErrorReturnTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_errorReturnType

	return p
}

func (s *ErrorReturnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorReturnTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ErrorReturnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorReturnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorReturnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterErrorReturnType(s)
	}
}

func (s *ErrorReturnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitErrorReturnType(s)
	}
}

func (p *MinZParser) ErrorReturnType() (localctx IErrorReturnTypeContext) {
	localctx = NewErrorReturnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, MinZParserRULE_errorReturnType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(315)
		p.Match(MinZParserT__16)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(317)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&34362097920) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&206154235905) != 0) {
		{
			p.SetState(316)
			p.Type_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructDeclarationContext is an interface to support dynamic dispatch.
type IStructDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Visibility() IVisibilityContext
	GenericParams() IGenericParamsContext
	FieldList() IFieldListContext

	// IsStructDeclarationContext differentiates from other interfaces.
	IsStructDeclarationContext()
}

type StructDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructDeclarationContext() *StructDeclarationContext {
	var p = new(StructDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_structDeclaration
	return p
}

func InitEmptyStructDeclarationContext(p *StructDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_structDeclaration
}

func (*StructDeclarationContext) IsStructDeclarationContext() {}

func NewStructDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructDeclarationContext {
	var p = new(StructDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_structDeclaration

	return p
}

func (s *StructDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StructDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *StructDeclarationContext) Visibility() IVisibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *StructDeclarationContext) GenericParams() IGenericParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParamsContext)
}

func (s *StructDeclarationContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *StructDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterStructDeclaration(s)
	}
}

func (s *StructDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitStructDeclaration(s)
	}
}

func (p *MinZParser) StructDeclaration() (localctx IStructDeclarationContext) {
	localctx = NewStructDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, MinZParserRULE_structDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__10 {
		{
			p.SetState(319)
			p.Visibility()
		}

	}
	{
		p.SetState(322)
		p.Match(MinZParserT__17)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(323)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__11 {
		{
			p.SetState(324)
			p.GenericParams()
		}

	}
	{
		p.SetState(327)
		p.Match(MinZParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserIDENTIFIER {
		{
			p.SetState(328)
			p.FieldList()
		}

	}
	{
		p.SetState(331)
		p.Match(MinZParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldListContext is an interface to support dynamic dispatch.
type IFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllField() []IFieldContext
	Field(i int) IFieldContext

	// IsFieldListContext differentiates from other interfaces.
	IsFieldListContext()
}

type FieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldListContext() *FieldListContext {
	var p = new(FieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_fieldList
	return p
}

func InitEmptyFieldListContext(p *FieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_fieldList
}

func (*FieldListContext) IsFieldListContext() {}

func NewFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldListContext {
	var p = new(FieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_fieldList

	return p
}

func (s *FieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldListContext) AllField() []IFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldContext); ok {
			len++
		}
	}

	tst := make([]IFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldContext); ok {
			tst[i] = t.(IFieldContext)
			i++
		}
	}

	return tst
}

func (s *FieldListContext) Field(i int) IFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *FieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterFieldList(s)
	}
}

func (s *FieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitFieldList(s)
	}
}

func (p *MinZParser) FieldList() (localctx IFieldListContext) {
	localctx = NewFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, MinZParserRULE_fieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(333)
		p.Field()
	}
	p.SetState(338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(334)
				p.Match(MinZParserT__12)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(335)
				p.Field()
			}

		}
		p.SetState(340)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__12 {
		{
			p.SetState(341)
			p.Match(MinZParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldContext is an interface to support dynamic dispatch.
type IFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Type_() ITypeContext

	// IsFieldContext differentiates from other interfaces.
	IsFieldContext()
}

type FieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldContext() *FieldContext {
	var p = new(FieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_field
	return p
}

func InitEmptyFieldContext(p *FieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_field
}

func (*FieldContext) IsFieldContext() {}

func NewFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldContext {
	var p = new(FieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_field

	return p
}

func (s *FieldContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *FieldContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *FieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterField(s)
	}
}

func (s *FieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitField(s)
	}
}

func (p *MinZParser) Field() (localctx IFieldContext) {
	localctx = NewFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, MinZParserRULE_field)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(344)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(345)
		p.Match(MinZParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(346)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Visibility() IVisibilityContext
	GenericParams() IGenericParamsContext
	EnumMemberList() IEnumMemberListContext

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_enumDeclaration
	return p
}

func InitEmptyEnumDeclarationContext(p *EnumDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_enumDeclaration
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *EnumDeclarationContext) Visibility() IVisibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *EnumDeclarationContext) GenericParams() IGenericParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParamsContext)
}

func (s *EnumDeclarationContext) EnumMemberList() IEnumMemberListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumMemberListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumMemberListContext)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitEnumDeclaration(s)
	}
}

func (p *MinZParser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, MinZParserRULE_enumDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__10 {
		{
			p.SetState(348)
			p.Visibility()
		}

	}
	{
		p.SetState(351)
		p.Match(MinZParserT__20)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(352)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__11 {
		{
			p.SetState(353)
			p.GenericParams()
		}

	}
	{
		p.SetState(356)
		p.Match(MinZParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserIDENTIFIER {
		{
			p.SetState(357)
			p.EnumMemberList()
		}

	}
	{
		p.SetState(360)
		p.Match(MinZParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumMemberListContext is an interface to support dynamic dispatch.
type IEnumMemberListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumMember() []IEnumMemberContext
	EnumMember(i int) IEnumMemberContext

	// IsEnumMemberListContext differentiates from other interfaces.
	IsEnumMemberListContext()
}

type EnumMemberListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumMemberListContext() *EnumMemberListContext {
	var p = new(EnumMemberListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_enumMemberList
	return p
}

func InitEmptyEnumMemberListContext(p *EnumMemberListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_enumMemberList
}

func (*EnumMemberListContext) IsEnumMemberListContext() {}

func NewEnumMemberListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumMemberListContext {
	var p = new(EnumMemberListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_enumMemberList

	return p
}

func (s *EnumMemberListContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumMemberListContext) AllEnumMember() []IEnumMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumMemberContext); ok {
			len++
		}
	}

	tst := make([]IEnumMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumMemberContext); ok {
			tst[i] = t.(IEnumMemberContext)
			i++
		}
	}

	return tst
}

func (s *EnumMemberListContext) EnumMember(i int) IEnumMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumMemberContext)
}

func (s *EnumMemberListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumMemberListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumMemberListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterEnumMemberList(s)
	}
}

func (s *EnumMemberListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitEnumMemberList(s)
	}
}

func (p *MinZParser) EnumMemberList() (localctx IEnumMemberListContext) {
	localctx = NewEnumMemberListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, MinZParserRULE_enumMemberList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(362)
		p.EnumMember()
	}
	p.SetState(367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(363)
				p.Match(MinZParserT__12)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(364)
				p.EnumMember()
			}

		}
		p.SetState(369)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(371)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__12 {
		{
			p.SetState(370)
			p.Match(MinZParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumMemberContext is an interface to support dynamic dispatch.
type IEnumMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Expression() IExpressionContext

	// IsEnumMemberContext differentiates from other interfaces.
	IsEnumMemberContext()
}

type EnumMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumMemberContext() *EnumMemberContext {
	var p = new(EnumMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_enumMember
	return p
}

func InitEmptyEnumMemberContext(p *EnumMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_enumMember
}

func (*EnumMemberContext) IsEnumMemberContext() {}

func NewEnumMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumMemberContext {
	var p = new(EnumMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_enumMember

	return p
}

func (s *EnumMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumMemberContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *EnumMemberContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnumMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterEnumMember(s)
	}
}

func (s *EnumMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitEnumMember(s)
	}
}

func (p *MinZParser) EnumMember() (localctx IEnumMemberContext) {
	localctx = NewEnumMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, MinZParserRULE_enumMember)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(373)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__21 {
		{
			p.SetState(374)
			p.Match(MinZParserT__21)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(375)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAliasDeclarationContext is an interface to support dynamic dispatch.
type ITypeAliasDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Type_() ITypeContext

	// IsTypeAliasDeclarationContext differentiates from other interfaces.
	IsTypeAliasDeclarationContext()
}

type TypeAliasDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasDeclarationContext() *TypeAliasDeclarationContext {
	var p = new(TypeAliasDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_typeAliasDeclaration
	return p
}

func InitEmptyTypeAliasDeclarationContext(p *TypeAliasDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_typeAliasDeclaration
}

func (*TypeAliasDeclarationContext) IsTypeAliasDeclarationContext() {}

func NewTypeAliasDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasDeclarationContext {
	var p = new(TypeAliasDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_typeAliasDeclaration

	return p
}

func (s *TypeAliasDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *TypeAliasDeclarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeAliasDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterTypeAliasDeclaration(s)
	}
}

func (s *TypeAliasDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitTypeAliasDeclaration(s)
	}
}

func (p *MinZParser) TypeAliasDeclaration() (localctx ITypeAliasDeclarationContext) {
	localctx = NewTypeAliasDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, MinZParserRULE_typeAliasDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(378)
		p.Match(MinZParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(379)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(380)
		p.Match(MinZParserT__21)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(381)
		p.Type_()
	}
	{
		p.SetState(382)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Visibility() IVisibilityContext
	GenericParams() IGenericParamsContext
	InterfaceMethodList() IInterfaceMethodListContext

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_interfaceDeclaration
	return p
}

func InitEmptyInterfaceDeclarationContext(p *InterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_interfaceDeclaration
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *InterfaceDeclarationContext) Visibility() IVisibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *InterfaceDeclarationContext) GenericParams() IGenericParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParamsContext)
}

func (s *InterfaceDeclarationContext) InterfaceMethodList() IInterfaceMethodListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodListContext)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}

func (p *MinZParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, MinZParserRULE_interfaceDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__10 {
		{
			p.SetState(384)
			p.Visibility()
		}

	}
	{
		p.SetState(387)
		p.Match(MinZParserT__23)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(388)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(390)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__11 {
		{
			p.SetState(389)
			p.GenericParams()
		}

	}
	{
		p.SetState(392)
		p.Match(MinZParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(394)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(393)
			p.InterfaceMethodList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(396)
		p.Match(MinZParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMethodListContext is an interface to support dynamic dispatch.
type IInterfaceMethodListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInterfaceMethod() []IInterfaceMethodContext
	InterfaceMethod(i int) IInterfaceMethodContext

	// IsInterfaceMethodListContext differentiates from other interfaces.
	IsInterfaceMethodListContext()
}

type InterfaceMethodListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodListContext() *InterfaceMethodListContext {
	var p = new(InterfaceMethodListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_interfaceMethodList
	return p
}

func InitEmptyInterfaceMethodListContext(p *InterfaceMethodListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_interfaceMethodList
}

func (*InterfaceMethodListContext) IsInterfaceMethodListContext() {}

func NewInterfaceMethodListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodListContext {
	var p = new(InterfaceMethodListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_interfaceMethodList

	return p
}

func (s *InterfaceMethodListContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodListContext) AllInterfaceMethod() []IInterfaceMethodContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMethodContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMethodContext); ok {
			tst[i] = t.(IInterfaceMethodContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceMethodListContext) InterfaceMethod(i int) IInterfaceMethodContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodContext)
}

func (s *InterfaceMethodListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterInterfaceMethodList(s)
	}
}

func (s *InterfaceMethodListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitInterfaceMethodList(s)
	}
}

func (p *MinZParser) InterfaceMethodList() (localctx IInterfaceMethodListContext) {
	localctx = NewInterfaceMethodListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, MinZParserRULE_interfaceMethodList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(401)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserIDENTIFIER {
		{
			p.SetState(398)
			p.InterfaceMethod()
		}

		p.SetState(403)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMethodContext is an interface to support dynamic dispatch.
type IInterfaceMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	ParameterList() IParameterListContext
	ReturnType() IReturnTypeContext
	ErrorReturnType() IErrorReturnTypeContext

	// IsInterfaceMethodContext differentiates from other interfaces.
	IsInterfaceMethodContext()
}

type InterfaceMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodContext() *InterfaceMethodContext {
	var p = new(InterfaceMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_interfaceMethod
	return p
}

func InitEmptyInterfaceMethodContext(p *InterfaceMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_interfaceMethod
}

func (*InterfaceMethodContext) IsInterfaceMethodContext() {}

func NewInterfaceMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodContext {
	var p = new(InterfaceMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_interfaceMethod

	return p
}

func (s *InterfaceMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *InterfaceMethodContext) ParameterList() IParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterListContext)
}

func (s *InterfaceMethodContext) ReturnType() IReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *InterfaceMethodContext) ErrorReturnType() IErrorReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorReturnTypeContext)
}

func (s *InterfaceMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterInterfaceMethod(s)
	}
}

func (s *InterfaceMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitInterfaceMethod(s)
	}
}

func (p *MinZParser) InterfaceMethod() (localctx IInterfaceMethodContext) {
	localctx = NewInterfaceMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, MinZParserRULE_interfaceMethod)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(404)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(405)
		p.Match(MinZParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserIDENTIFIER {
		{
			p.SetState(406)
			p.ParameterList()
		}

	}
	{
		p.SetState(409)
		p.Match(MinZParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__15 {
		{
			p.SetState(410)
			p.ReturnType()
		}

	}
	p.SetState(414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__16 {
		{
			p.SetState(413)
			p.ErrorReturnType()
		}

	}
	{
		p.SetState(416)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplBlockContext is an interface to support dynamic dispatch.
type IImplBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllFunctionDeclaration() []IFunctionDeclarationContext
	FunctionDeclaration(i int) IFunctionDeclarationContext

	// IsImplBlockContext differentiates from other interfaces.
	IsImplBlockContext()
}

type ImplBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplBlockContext() *ImplBlockContext {
	var p = new(ImplBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_implBlock
	return p
}

func InitEmptyImplBlockContext(p *ImplBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_implBlock
}

func (*ImplBlockContext) IsImplBlockContext() {}

func NewImplBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplBlockContext {
	var p = new(ImplBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_implBlock

	return p
}

func (s *ImplBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplBlockContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *ImplBlockContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ImplBlockContext) AllFunctionDeclaration() []IFunctionDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IFunctionDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionDeclarationContext); ok {
			tst[i] = t.(IFunctionDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ImplBlockContext) FunctionDeclaration(i int) IFunctionDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *ImplBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterImplBlock(s)
	}
}

func (s *ImplBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitImplBlock(s)
	}
}

func (p *MinZParser) ImplBlock() (localctx IImplBlockContext) {
	localctx = NewImplBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, MinZParserRULE_implBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(418)
		p.Match(MinZParserT__24)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(419)
		p.Type_()
	}
	{
		p.SetState(420)
		p.Match(MinZParserT__25)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(421)
		p.Type_()
	}
	{
		p.SetState(422)
		p.Match(MinZParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3968) != 0 {
		{
			p.SetState(423)
			p.FunctionDeclaration()
		}

		p.SetState(428)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(429)
		p.Match(MinZParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstDeclarationContext is an interface to support dynamic dispatch.
type IConstDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Type_() ITypeContext
	Expression() IExpressionContext
	Visibility() IVisibilityContext

	// IsConstDeclarationContext differentiates from other interfaces.
	IsConstDeclarationContext()
}

type ConstDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstDeclarationContext() *ConstDeclarationContext {
	var p = new(ConstDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_constDeclaration
	return p
}

func InitEmptyConstDeclarationContext(p *ConstDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_constDeclaration
}

func (*ConstDeclarationContext) IsConstDeclarationContext() {}

func NewConstDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstDeclarationContext {
	var p = new(ConstDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_constDeclaration

	return p
}

func (s *ConstDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *ConstDeclarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ConstDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConstDeclarationContext) Visibility() IVisibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *ConstDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterConstDeclaration(s)
	}
}

func (s *ConstDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitConstDeclaration(s)
	}
}

func (p *MinZParser) ConstDeclaration() (localctx IConstDeclarationContext) {
	localctx = NewConstDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, MinZParserRULE_constDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__10 {
		{
			p.SetState(431)
			p.Visibility()
		}

	}
	{
		p.SetState(434)
		p.Match(MinZParserT__26)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(435)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(436)
		p.Match(MinZParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(437)
		p.Type_()
	}
	{
		p.SetState(438)
		p.Match(MinZParserT__21)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(439)
		p.Expression()
	}
	{
		p.SetState(440)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGlobalVarDeclarationContext is an interface to support dynamic dispatch.
type IGlobalVarDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Type_() ITypeContext
	Visibility() IVisibilityContext
	Expression() IExpressionContext

	// IsGlobalVarDeclarationContext differentiates from other interfaces.
	IsGlobalVarDeclarationContext()
}

type GlobalVarDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalVarDeclarationContext() *GlobalVarDeclarationContext {
	var p = new(GlobalVarDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_globalVarDeclaration
	return p
}

func InitEmptyGlobalVarDeclarationContext(p *GlobalVarDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_globalVarDeclaration
}

func (*GlobalVarDeclarationContext) IsGlobalVarDeclarationContext() {}

func NewGlobalVarDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalVarDeclarationContext {
	var p = new(GlobalVarDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_globalVarDeclaration

	return p
}

func (s *GlobalVarDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalVarDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *GlobalVarDeclarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *GlobalVarDeclarationContext) Visibility() IVisibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *GlobalVarDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GlobalVarDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalVarDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalVarDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterGlobalVarDeclaration(s)
	}
}

func (s *GlobalVarDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitGlobalVarDeclaration(s)
	}
}

func (p *MinZParser) GlobalVarDeclaration() (localctx IGlobalVarDeclarationContext) {
	localctx = NewGlobalVarDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, MinZParserRULE_globalVarDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__10 {
		{
			p.SetState(442)
			p.Visibility()
		}

	}
	{
		p.SetState(445)
		p.Match(MinZParserT__27)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(446)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(447)
		p.Match(MinZParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(448)
		p.Type_()
	}
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__21 {
		{
			p.SetState(449)
			p.Match(MinZParserT__21)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(450)
			p.Expression()
		}

	}
	{
		p.SetState(453)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompileTimeDeclarationContext is an interface to support dynamic dispatch.
type ICompileTimeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CompileTimeIf() ICompileTimeIfContext
	CompileTimeMinz() ICompileTimeMinzContext
	CompileTimeMir() ICompileTimeMirContext
	TargetBlock() ITargetBlockContext

	// IsCompileTimeDeclarationContext differentiates from other interfaces.
	IsCompileTimeDeclarationContext()
}

type CompileTimeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompileTimeDeclarationContext() *CompileTimeDeclarationContext {
	var p = new(CompileTimeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_compileTimeDeclaration
	return p
}

func InitEmptyCompileTimeDeclarationContext(p *CompileTimeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_compileTimeDeclaration
}

func (*CompileTimeDeclarationContext) IsCompileTimeDeclarationContext() {}

func NewCompileTimeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompileTimeDeclarationContext {
	var p = new(CompileTimeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_compileTimeDeclaration

	return p
}

func (s *CompileTimeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *CompileTimeDeclarationContext) CompileTimeIf() ICompileTimeIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompileTimeIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompileTimeIfContext)
}

func (s *CompileTimeDeclarationContext) CompileTimeMinz() ICompileTimeMinzContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompileTimeMinzContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompileTimeMinzContext)
}

func (s *CompileTimeDeclarationContext) CompileTimeMir() ICompileTimeMirContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompileTimeMirContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompileTimeMirContext)
}

func (s *CompileTimeDeclarationContext) TargetBlock() ITargetBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetBlockContext)
}

func (s *CompileTimeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompileTimeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompileTimeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCompileTimeDeclaration(s)
	}
}

func (s *CompileTimeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCompileTimeDeclaration(s)
	}
}

func (p *MinZParser) CompileTimeDeclaration() (localctx ICompileTimeDeclarationContext) {
	localctx = NewCompileTimeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, MinZParserRULE_compileTimeDeclaration)
	p.SetState(459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserT__28:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(455)
			p.CompileTimeIf()
		}

	case MinZParserT__30:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(456)
			p.CompileTimeMinz()
		}

	case MinZParserT__31:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(457)
			p.CompileTimeMir()
		}

	case MinZParserT__36:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(458)
			p.TargetBlock()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompileTimeIfContext is an interface to support dynamic dispatch.
type ICompileTimeIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AllBlock() []IBlockContext
	Block(i int) IBlockContext

	// IsCompileTimeIfContext differentiates from other interfaces.
	IsCompileTimeIfContext()
}

type CompileTimeIfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompileTimeIfContext() *CompileTimeIfContext {
	var p = new(CompileTimeIfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_compileTimeIf
	return p
}

func InitEmptyCompileTimeIfContext(p *CompileTimeIfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_compileTimeIf
}

func (*CompileTimeIfContext) IsCompileTimeIfContext() {}

func NewCompileTimeIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompileTimeIfContext {
	var p = new(CompileTimeIfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_compileTimeIf

	return p
}

func (s *CompileTimeIfContext) GetParser() antlr.Parser { return s.parser }

func (s *CompileTimeIfContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CompileTimeIfContext) AllBlock() []IBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockContext); ok {
			len++
		}
	}

	tst := make([]IBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockContext); ok {
			tst[i] = t.(IBlockContext)
			i++
		}
	}

	return tst
}

func (s *CompileTimeIfContext) Block(i int) IBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CompileTimeIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompileTimeIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompileTimeIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCompileTimeIf(s)
	}
}

func (s *CompileTimeIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCompileTimeIf(s)
	}
}

func (p *MinZParser) CompileTimeIf() (localctx ICompileTimeIfContext) {
	localctx = NewCompileTimeIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, MinZParserRULE_compileTimeIf)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(461)
		p.Match(MinZParserT__28)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(462)
		p.Match(MinZParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(463)
		p.Expression()
	}
	{
		p.SetState(464)
		p.Match(MinZParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(465)
		p.Block()
	}
	p.SetState(468)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__29 {
		{
			p.SetState(466)
			p.Match(MinZParserT__29)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(467)
			p.Block()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompileTimeMinzContext is an interface to support dynamic dispatch.
type ICompileTimeMinzContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsCompileTimeMinzContext differentiates from other interfaces.
	IsCompileTimeMinzContext()
}

type CompileTimeMinzContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompileTimeMinzContext() *CompileTimeMinzContext {
	var p = new(CompileTimeMinzContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_compileTimeMinz
	return p
}

func InitEmptyCompileTimeMinzContext(p *CompileTimeMinzContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_compileTimeMinz
}

func (*CompileTimeMinzContext) IsCompileTimeMinzContext() {}

func NewCompileTimeMinzContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompileTimeMinzContext {
	var p = new(CompileTimeMinzContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_compileTimeMinz

	return p
}

func (s *CompileTimeMinzContext) GetParser() antlr.Parser { return s.parser }

func (s *CompileTimeMinzContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *CompileTimeMinzContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CompileTimeMinzContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CompileTimeMinzContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompileTimeMinzContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompileTimeMinzContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCompileTimeMinz(s)
	}
}

func (s *CompileTimeMinzContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCompileTimeMinz(s)
	}
}

func (p *MinZParser) CompileTimeMinz() (localctx ICompileTimeMinzContext) {
	localctx = NewCompileTimeMinzContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, MinZParserRULE_compileTimeMinz)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(470)
		p.Match(MinZParserT__30)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(471)
		p.Match(MinZParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(472)
		p.StringLiteral()
	}
	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__12 {
		{
			p.SetState(473)
			p.Match(MinZParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(474)
			p.Expression()
		}

		p.SetState(479)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(480)
		p.Match(MinZParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompileTimeMirContext is an interface to support dynamic dispatch.
type ICompileTimeMirContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MirBlock() IMirBlockContext

	// IsCompileTimeMirContext differentiates from other interfaces.
	IsCompileTimeMirContext()
}

type CompileTimeMirContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompileTimeMirContext() *CompileTimeMirContext {
	var p = new(CompileTimeMirContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_compileTimeMir
	return p
}

func InitEmptyCompileTimeMirContext(p *CompileTimeMirContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_compileTimeMir
}

func (*CompileTimeMirContext) IsCompileTimeMirContext() {}

func NewCompileTimeMirContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompileTimeMirContext {
	var p = new(CompileTimeMirContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_compileTimeMir

	return p
}

func (s *CompileTimeMirContext) GetParser() antlr.Parser { return s.parser }

func (s *CompileTimeMirContext) MirBlock() IMirBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirBlockContext)
}

func (s *CompileTimeMirContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompileTimeMirContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompileTimeMirContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCompileTimeMir(s)
	}
}

func (s *CompileTimeMirContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCompileTimeMir(s)
	}
}

func (p *MinZParser) CompileTimeMir() (localctx ICompileTimeMirContext) {
	localctx = NewCompileTimeMirContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, MinZParserRULE_compileTimeMir)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(482)
		p.Match(MinZParserT__31)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(483)
		p.MirBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirBlockContext is an interface to support dynamic dispatch.
type IMirBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMirStatement() []IMirStatementContext
	MirStatement(i int) IMirStatementContext

	// IsMirBlockContext differentiates from other interfaces.
	IsMirBlockContext()
}

type MirBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMirBlockContext() *MirBlockContext {
	var p = new(MirBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirBlock
	return p
}

func InitEmptyMirBlockContext(p *MirBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirBlock
}

func (*MirBlockContext) IsMirBlockContext() {}

func NewMirBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirBlockContext {
	var p = new(MirBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirBlock

	return p
}

func (s *MirBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *MirBlockContext) AllMirStatement() []IMirStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMirStatementContext); ok {
			len++
		}
	}

	tst := make([]IMirStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMirStatementContext); ok {
			tst[i] = t.(IMirStatementContext)
			i++
		}
	}

	return tst
}

func (s *MirBlockContext) MirStatement(i int) IMirStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirStatementContext)
}

func (s *MirBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirBlock(s)
	}
}

func (s *MirBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirBlock(s)
	}
}

func (p *MinZParser) MirBlock() (localctx IMirBlockContext) {
	localctx = NewMirBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, MinZParserRULE_mirBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Match(MinZParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserIDENTIFIER {
		{
			p.SetState(486)
			p.MirStatement()
		}

		p.SetState(491)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(492)
		p.Match(MinZParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirStatementContext is an interface to support dynamic dispatch.
type IMirStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MirInstruction() IMirInstructionContext

	// IsMirStatementContext differentiates from other interfaces.
	IsMirStatementContext()
}

type MirStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMirStatementContext() *MirStatementContext {
	var p = new(MirStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirStatement
	return p
}

func InitEmptyMirStatementContext(p *MirStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirStatement
}

func (*MirStatementContext) IsMirStatementContext() {}

func NewMirStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirStatementContext {
	var p = new(MirStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirStatement

	return p
}

func (s *MirStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MirStatementContext) MirInstruction() IMirInstructionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirInstructionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirInstructionContext)
}

func (s *MirStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirStatement(s)
	}
}

func (s *MirStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirStatement(s)
	}
}

func (p *MinZParser) MirStatement() (localctx IMirStatementContext) {
	localctx = NewMirStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, MinZParserRULE_mirStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(494)
		p.MirInstruction()
	}
	{
		p.SetState(495)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirInstructionContext is an interface to support dynamic dispatch.
type IMirInstructionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	AllMirOperand() []IMirOperandContext
	MirOperand(i int) IMirOperandContext

	// IsMirInstructionContext differentiates from other interfaces.
	IsMirInstructionContext()
}

type MirInstructionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMirInstructionContext() *MirInstructionContext {
	var p = new(MirInstructionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirInstruction
	return p
}

func InitEmptyMirInstructionContext(p *MirInstructionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirInstruction
}

func (*MirInstructionContext) IsMirInstructionContext() {}

func NewMirInstructionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirInstructionContext {
	var p = new(MirInstructionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirInstruction

	return p
}

func (s *MirInstructionContext) GetParser() antlr.Parser { return s.parser }

func (s *MirInstructionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *MirInstructionContext) AllMirOperand() []IMirOperandContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMirOperandContext); ok {
			len++
		}
	}

	tst := make([]IMirOperandContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMirOperandContext); ok {
			tst[i] = t.(IMirOperandContext)
			i++
		}
	}

	return tst
}

func (s *MirInstructionContext) MirOperand(i int) IMirOperandContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirOperandContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirOperandContext)
}

func (s *MirInstructionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirInstructionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirInstructionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirInstruction(s)
	}
}

func (s *MirInstructionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirInstruction(s)
	}
}

func (p *MinZParser) MirInstruction() (localctx IMirInstructionContext) {
	localctx = NewMirInstructionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, MinZParserRULE_mirInstruction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(497)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&60129542144) != 0) || _la == MinZParserIDENTIFIER {
		{
			p.SetState(498)
			p.MirOperand()
		}

		p.SetState(503)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirOperandContext is an interface to support dynamic dispatch.
type IMirOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MirRegister() IMirRegisterContext
	MirImmediate() IMirImmediateContext
	MirMemory() IMirMemoryContext
	MirLabel() IMirLabelContext

	// IsMirOperandContext differentiates from other interfaces.
	IsMirOperandContext()
}

type MirOperandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMirOperandContext() *MirOperandContext {
	var p = new(MirOperandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirOperand
	return p
}

func InitEmptyMirOperandContext(p *MirOperandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirOperand
}

func (*MirOperandContext) IsMirOperandContext() {}

func NewMirOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirOperandContext {
	var p = new(MirOperandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirOperand

	return p
}

func (s *MirOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *MirOperandContext) MirRegister() IMirRegisterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirRegisterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirRegisterContext)
}

func (s *MirOperandContext) MirImmediate() IMirImmediateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirImmediateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirImmediateContext)
}

func (s *MirOperandContext) MirMemory() IMirMemoryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirMemoryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirMemoryContext)
}

func (s *MirOperandContext) MirLabel() IMirLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMirLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMirLabelContext)
}

func (s *MirOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirOperand(s)
	}
}

func (s *MirOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirOperand(s)
	}
}

func (p *MinZParser) MirOperand() (localctx IMirOperandContext) {
	localctx = NewMirOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, MinZParserRULE_mirOperand)
	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserT__32:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(504)
			p.MirRegister()
		}

	case MinZParserT__33:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(505)
			p.MirImmediate()
		}

	case MinZParserT__34:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(506)
			p.MirMemory()
		}

	case MinZParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(507)
			p.MirLabel()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirRegisterContext is an interface to support dynamic dispatch.
type IMirRegisterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMBER() antlr.TerminalNode

	// IsMirRegisterContext differentiates from other interfaces.
	IsMirRegisterContext()
}

type MirRegisterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMirRegisterContext() *MirRegisterContext {
	var p = new(MirRegisterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirRegister
	return p
}

func InitEmptyMirRegisterContext(p *MirRegisterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirRegister
}

func (*MirRegisterContext) IsMirRegisterContext() {}

func NewMirRegisterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirRegisterContext {
	var p = new(MirRegisterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirRegister

	return p
}

func (s *MirRegisterContext) GetParser() antlr.Parser { return s.parser }

func (s *MirRegisterContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(MinZParserNUMBER, 0)
}

func (s *MirRegisterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirRegisterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirRegisterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirRegister(s)
	}
}

func (s *MirRegisterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirRegister(s)
	}
}

func (p *MinZParser) MirRegister() (localctx IMirRegisterContext) {
	localctx = NewMirRegisterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, MinZParserRULE_mirRegister)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(510)
		p.Match(MinZParserT__32)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(511)
		p.Match(MinZParserNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirImmediateContext is an interface to support dynamic dispatch.
type IMirImmediateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMBER() antlr.TerminalNode

	// IsMirImmediateContext differentiates from other interfaces.
	IsMirImmediateContext()
}

type MirImmediateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMirImmediateContext() *MirImmediateContext {
	var p = new(MirImmediateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirImmediate
	return p
}

func InitEmptyMirImmediateContext(p *MirImmediateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirImmediate
}

func (*MirImmediateContext) IsMirImmediateContext() {}

func NewMirImmediateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirImmediateContext {
	var p = new(MirImmediateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirImmediate

	return p
}

func (s *MirImmediateContext) GetParser() antlr.Parser { return s.parser }

func (s *MirImmediateContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(MinZParserNUMBER, 0)
}

func (s *MirImmediateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirImmediateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirImmediateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirImmediate(s)
	}
}

func (s *MirImmediateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirImmediate(s)
	}
}

func (p *MinZParser) MirImmediate() (localctx IMirImmediateContext) {
	localctx = NewMirImmediateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, MinZParserRULE_mirImmediate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)
		p.Match(MinZParserT__33)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(514)
		p.Match(MinZParserNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirMemoryContext is an interface to support dynamic dispatch.
type IMirMemoryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsMirMemoryContext differentiates from other interfaces.
	IsMirMemoryContext()
}

type MirMemoryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMirMemoryContext() *MirMemoryContext {
	var p = new(MirMemoryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirMemory
	return p
}

func InitEmptyMirMemoryContext(p *MirMemoryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirMemory
}

func (*MirMemoryContext) IsMirMemoryContext() {}

func NewMirMemoryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirMemoryContext {
	var p = new(MirMemoryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirMemory

	return p
}

func (s *MirMemoryContext) GetParser() antlr.Parser { return s.parser }

func (s *MirMemoryContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MirMemoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirMemoryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirMemoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirMemory(s)
	}
}

func (s *MirMemoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirMemory(s)
	}
}

func (p *MinZParser) MirMemory() (localctx IMirMemoryContext) {
	localctx = NewMirMemoryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, MinZParserRULE_mirMemory)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(516)
		p.Match(MinZParserT__34)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(517)
		p.Expression()
	}
	{
		p.SetState(518)
		p.Match(MinZParserT__35)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMirLabelContext is an interface to support dynamic dispatch.
type IMirLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode

	// IsMirLabelContext differentiates from other interfaces.
	IsMirLabelContext()
}

type MirLabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMirLabelContext() *MirLabelContext {
	var p = new(MirLabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirLabel
	return p
}

func InitEmptyMirLabelContext(p *MirLabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_mirLabel
}

func (*MirLabelContext) IsMirLabelContext() {}

func NewMirLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MirLabelContext {
	var p = new(MirLabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_mirLabel

	return p
}

func (s *MirLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *MirLabelContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *MirLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MirLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MirLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMirLabel(s)
	}
}

func (s *MirLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMirLabel(s)
	}
}

func (p *MinZParser) MirLabel() (localctx IMirLabelContext) {
	localctx = NewMirLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, MinZParserRULE_mirLabel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(520)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(521)
		p.Match(MinZParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetBlockContext is an interface to support dynamic dispatch.
type ITargetBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext
	Block() IBlockContext

	// IsTargetBlockContext differentiates from other interfaces.
	IsTargetBlockContext()
}

type TargetBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetBlockContext() *TargetBlockContext {
	var p = new(TargetBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_targetBlock
	return p
}

func InitEmptyTargetBlockContext(p *TargetBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_targetBlock
}

func (*TargetBlockContext) IsTargetBlockContext() {}

func NewTargetBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetBlockContext {
	var p = new(TargetBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_targetBlock

	return p
}

func (s *TargetBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetBlockContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TargetBlockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TargetBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterTargetBlock(s)
	}
}

func (s *TargetBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitTargetBlock(s)
	}
}

func (p *MinZParser) TargetBlock() (localctx ITargetBlockContext) {
	localctx = NewTargetBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, MinZParserRULE_targetBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(523)
		p.Match(MinZParserT__36)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(524)
		p.Match(MinZParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(525)
		p.StringLiteral()
	}
	{
		p.SetState(526)
		p.Match(MinZParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(527)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LetStatement() ILetStatementContext
	VarStatement() IVarStatementContext
	AssignmentStatement() IAssignmentStatementContext
	ExpressionStatement() IExpressionStatementContext
	ReturnStatement() IReturnStatementContext
	IfStatement() IIfStatementContext
	WhileStatement() IWhileStatementContext
	ForStatement() IForStatementContext
	LoopStatement() ILoopStatementContext
	CaseStatement() ICaseStatementContext
	BlockStatement() IBlockStatementContext
	BreakStatement() IBreakStatementContext
	ContinueStatement() IContinueStatementContext
	DeferStatement() IDeferStatementContext
	AsmStatement() IAsmStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) LetStatement() ILetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetStatementContext)
}

func (s *StatementContext) VarStatement() IVarStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarStatementContext)
}

func (s *StatementContext) AssignmentStatement() IAssignmentStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentStatementContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) LoopStatement() ILoopStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *StatementContext) CaseStatement() ICaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *StatementContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) DeferStatement() IDeferStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeferStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeferStatementContext)
}

func (s *StatementContext) AsmStatement() IAsmStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *MinZParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, MinZParserRULE_statement)
	p.SetState(544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(529)
			p.LetStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(530)
			p.VarStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(531)
			p.AssignmentStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(532)
			p.ExpressionStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(533)
			p.ReturnStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(534)
			p.IfStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(535)
			p.WhileStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(536)
			p.ForStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(537)
			p.LoopStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(538)
			p.CaseStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(539)
			p.BlockStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(540)
			p.BreakStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(541)
			p.ContinueStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(542)
			p.DeferStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(543)
			p.AsmStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetStatementContext is an interface to support dynamic dispatch.
type ILetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Expression() IExpressionContext
	Type_() ITypeContext

	// IsLetStatementContext differentiates from other interfaces.
	IsLetStatementContext()
}

type LetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetStatementContext() *LetStatementContext {
	var p = new(LetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_letStatement
	return p
}

func InitEmptyLetStatementContext(p *LetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_letStatement
}

func (*LetStatementContext) IsLetStatementContext() {}

func NewLetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetStatementContext {
	var p = new(LetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_letStatement

	return p
}

func (s *LetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LetStatementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *LetStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LetStatementContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *LetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLetStatement(s)
	}
}

func (s *LetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLetStatement(s)
	}
}

func (p *MinZParser) LetStatement() (localctx ILetStatementContext) {
	localctx = NewLetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, MinZParserRULE_letStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(546)
		p.Match(MinZParserT__37)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__38 {
		{
			p.SetState(547)
			p.Match(MinZParserT__38)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(550)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(553)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__14 {
		{
			p.SetState(551)
			p.Match(MinZParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(552)
			p.Type_()
		}

	}
	{
		p.SetState(555)
		p.Match(MinZParserT__21)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(556)
		p.Expression()
	}
	{
		p.SetState(557)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarStatementContext is an interface to support dynamic dispatch.
type IVarStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Expression() IExpressionContext
	Type_() ITypeContext

	// IsVarStatementContext differentiates from other interfaces.
	IsVarStatementContext()
}

type VarStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarStatementContext() *VarStatementContext {
	var p = new(VarStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_varStatement
	return p
}

func InitEmptyVarStatementContext(p *VarStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_varStatement
}

func (*VarStatementContext) IsVarStatementContext() {}

func NewVarStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarStatementContext {
	var p = new(VarStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_varStatement

	return p
}

func (s *VarStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *VarStatementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *VarStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VarStatementContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *VarStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterVarStatement(s)
	}
}

func (s *VarStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitVarStatement(s)
	}
}

func (p *MinZParser) VarStatement() (localctx IVarStatementContext) {
	localctx = NewVarStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, MinZParserRULE_varStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Match(MinZParserT__39)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(560)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__14 {
		{
			p.SetState(561)
			p.Match(MinZParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(562)
			p.Type_()
		}

	}
	{
		p.SetState(565)
		p.Match(MinZParserT__21)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(566)
		p.Expression()
	}
	{
		p.SetState(567)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentStatementContext is an interface to support dynamic dispatch.
type IAssignmentStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsAssignmentStatementContext differentiates from other interfaces.
	IsAssignmentStatementContext()
}

type AssignmentStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentStatementContext() *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_assignmentStatement
	return p
}

func InitEmptyAssignmentStatementContext(p *AssignmentStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_assignmentStatement
}

func (*AssignmentStatementContext) IsAssignmentStatementContext() {}

func NewAssignmentStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_assignmentStatement

	return p
}

func (s *AssignmentStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentStatementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentStatementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAssignmentStatement(s)
	}
}

func (p *MinZParser) AssignmentStatement() (localctx IAssignmentStatementContext) {
	localctx = NewAssignmentStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, MinZParserRULE_assignmentStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(569)
		p.Expression()
	}
	{
		p.SetState(570)
		p.Match(MinZParserT__21)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(571)
		p.Expression()
	}
	{
		p.SetState(572)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_expressionStatement
	return p
}

func InitEmptyExpressionStatementContext(p *ExpressionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_expressionStatement
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (p *MinZParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, MinZParserRULE_expressionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)
		p.Expression()
	}
	{
		p.SetState(575)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *MinZParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, MinZParserRULE_returnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(577)
		p.Match(MinZParserT__40)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&22522430543102496) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&34909498372211) != 0) {
		{
			p.SetState(578)
			p.Expression()
		}

	}
	{
		p.SetState(581)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AllBlock() []IBlockContext
	Block(i int) IBlockContext
	IfStatement() IIfStatementContext

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) AllBlock() []IBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockContext); ok {
			len++
		}
	}

	tst := make([]IBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockContext); ok {
			tst[i] = t.(IBlockContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Block(i int) IBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *IfStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (p *MinZParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, MinZParserRULE_ifStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(583)
		p.Match(MinZParserT__41)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(584)
		p.Expression()
	}
	{
		p.SetState(585)
		p.Block()
	}
	p.SetState(591)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__29 {
		{
			p.SetState(586)
			p.Match(MinZParserT__29)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MinZParserT__41:
			{
				p.SetState(587)
				p.IfStatement()
			}

		case MinZParserT__18:
			{
				p.SetState(588)
				p.Block()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Block() IBlockContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *MinZParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, MinZParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(593)
		p.Match(MinZParserT__42)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(594)
		p.Expression()
	}
	{
		p.SetState(595)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Expression() IExpressionContext
	Block() IBlockContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *ForStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *MinZParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, MinZParserRULE_forStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(597)
		p.Match(MinZParserT__25)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(598)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(599)
		p.Match(MinZParserT__43)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(600)
		p.Expression()
	}
	{
		p.SetState(601)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_loopStatement
	return p
}

func InitEmptyLoopStatementContext(p *LoopStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_loopStatement
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLoopStatement(s)
	}
}

func (s *LoopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLoopStatement(s)
	}
}

func (p *MinZParser) LoopStatement() (localctx ILoopStatementContext) {
	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, MinZParserRULE_loopStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(603)
		p.Match(MinZParserT__44)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(604)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AllCaseArm() []ICaseArmContext
	CaseArm(i int) ICaseArmContext

	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_caseStatement
	return p
}

func InitEmptyCaseStatementContext(p *CaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_caseStatement
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseStatementContext) AllCaseArm() []ICaseArmContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseArmContext); ok {
			len++
		}
	}

	tst := make([]ICaseArmContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseArmContext); ok {
			tst[i] = t.(ICaseArmContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) CaseArm(i int) ICaseArmContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseArmContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseArmContext)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCaseStatement(s)
	}
}

func (s *CaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCaseStatement(s)
	}
}

func (p *MinZParser) CaseStatement() (localctx ICaseStatementContext) {
	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, MinZParserRULE_caseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(606)
		p.Match(MinZParserT__45)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(607)
		p.Expression()
	}
	{
		p.SetState(608)
		p.Match(MinZParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__4 || _la == MinZParserT__50 || ((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&8522825731) != 0) {
		{
			p.SetState(609)
			p.CaseArm()
		}

		p.SetState(614)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(615)
		p.Match(MinZParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseArmContext is an interface to support dynamic dispatch.
type ICaseArmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pattern() IPatternContext
	Block() IBlockContext
	Expression() IExpressionContext

	// IsCaseArmContext differentiates from other interfaces.
	IsCaseArmContext()
}

type CaseArmContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseArmContext() *CaseArmContext {
	var p = new(CaseArmContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_caseArm
	return p
}

func InitEmptyCaseArmContext(p *CaseArmContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_caseArm
}

func (*CaseArmContext) IsCaseArmContext() {}

func NewCaseArmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseArmContext {
	var p = new(CaseArmContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_caseArm

	return p
}

func (s *CaseArmContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseArmContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *CaseArmContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CaseArmContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseArmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseArmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseArmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCaseArm(s)
	}
}

func (s *CaseArmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCaseArm(s)
	}
}

func (p *MinZParser) CaseArm() (localctx ICaseArmContext) {
	localctx = NewCaseArmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, MinZParserRULE_caseArm)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.Pattern()
	}
	{
		p.SetState(618)
		p.Match(MinZParserT__46)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(624)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserT__18:
		{
			p.SetState(619)
			p.Block()
		}

	case MinZParserT__4, MinZParserT__8, MinZParserT__34, MinZParserT__41, MinZParserT__51, MinZParserT__53, MinZParserT__63, MinZParserT__64, MinZParserT__67, MinZParserT__68, MinZParserT__69, MinZParserT__75, MinZParserT__76, MinZParserT__77, MinZParserT__78, MinZParserT__79, MinZParserT__80, MinZParserT__81, MinZParserT__82, MinZParserT__83, MinZParserT__84, MinZParserIDENTIFIER, MinZParserNUMBER, MinZParserHEX_NUMBER, MinZParserBINARY_NUMBER, MinZParserSTRING, MinZParserLSTRING, MinZParserCHAR:
		{
			p.SetState(620)
			p.Expression()
		}
		p.SetState(622)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MinZParserT__12 {
			{
				p.SetState(621)
				p.Match(MinZParserT__12)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_blockStatement
	return p
}

func InitEmptyBlockStatementContext(p *BlockStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_blockStatement
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBlockStatement(s)
	}
}

func (s *BlockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBlockStatement(s)
	}
}

func (p *MinZParser) BlockStatement() (localctx IBlockStatementContext) {
	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, MinZParserRULE_blockStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(626)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *MinZParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, MinZParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(628)
		p.Match(MinZParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&24610678069789216) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&34909498372211) != 0) {
		{
			p.SetState(629)
			p.Statement()
		}

		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(635)
		p.Match(MinZParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_breakStatement
	return p
}

func InitEmptyBreakStatementContext(p *BreakStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_breakStatement
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }
func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (p *MinZParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, MinZParserRULE_breakStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(637)
		p.Match(MinZParserT__47)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(638)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_continueStatement
	return p
}

func InitEmptyContinueStatementContext(p *ContinueStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_continueStatement
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }
func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (p *MinZParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, MinZParserRULE_continueStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.Match(MinZParserT__48)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(641)
		p.Match(MinZParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeferStatementContext is an interface to support dynamic dispatch.
type IDeferStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	Expression() IExpressionContext

	// IsDeferStatementContext differentiates from other interfaces.
	IsDeferStatementContext()
}

type DeferStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferStatementContext() *DeferStatementContext {
	var p = new(DeferStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_deferStatement
	return p
}

func InitEmptyDeferStatementContext(p *DeferStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_deferStatement
}

func (*DeferStatementContext) IsDeferStatementContext() {}

func NewDeferStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeferStatementContext {
	var p = new(DeferStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_deferStatement

	return p
}

func (s *DeferStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeferStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *DeferStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeferStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeferStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeferStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterDeferStatement(s)
	}
}

func (s *DeferStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitDeferStatement(s)
	}
}

func (p *MinZParser) DeferStatement() (localctx IDeferStatementContext) {
	localctx = NewDeferStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, MinZParserRULE_deferStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(643)
		p.Match(MinZParserT__49)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserT__18:
		{
			p.SetState(644)
			p.Block()
		}

	case MinZParserT__4, MinZParserT__8, MinZParserT__34, MinZParserT__41, MinZParserT__51, MinZParserT__53, MinZParserT__63, MinZParserT__64, MinZParserT__67, MinZParserT__68, MinZParserT__69, MinZParserT__75, MinZParserT__76, MinZParserT__77, MinZParserT__78, MinZParserT__79, MinZParserT__80, MinZParserT__81, MinZParserT__82, MinZParserT__83, MinZParserT__84, MinZParserIDENTIFIER, MinZParserNUMBER, MinZParserHEX_NUMBER, MinZParserBINARY_NUMBER, MinZParserSTRING, MinZParserLSTRING, MinZParserCHAR:
		{
			p.SetState(645)
			p.Expression()
		}
		{
			p.SetState(646)
			p.Match(MinZParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsmStatementContext is an interface to support dynamic dispatch.
type IAsmStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AsmBlock() IAsmBlockContext

	// IsAsmStatementContext differentiates from other interfaces.
	IsAsmStatementContext()
}

type AsmStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmStatementContext() *AsmStatementContext {
	var p = new(AsmStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmStatement
	return p
}

func InitEmptyAsmStatementContext(p *AsmStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmStatement
}

func (*AsmStatementContext) IsAsmStatementContext() {}

func NewAsmStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmStatementContext {
	var p = new(AsmStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_asmStatement

	return p
}

func (s *AsmStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmStatementContext) AsmBlock() IAsmBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmBlockContext)
}

func (s *AsmStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAsmStatement(s)
	}
}

func (s *AsmStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAsmStatement(s)
	}
}

func (p *MinZParser) AsmStatement() (localctx IAsmStatementContext) {
	localctx = NewAsmStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, MinZParserRULE_asmStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)
		p.Match(MinZParserT__8)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(651)
		p.AsmBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsmBlockContext is an interface to support dynamic dispatch.
type IAsmBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAsmBlockContext differentiates from other interfaces.
	IsAsmBlockContext()
}

type AsmBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmBlockContext() *AsmBlockContext {
	var p = new(AsmBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmBlock
	return p
}

func InitEmptyAsmBlockContext(p *AsmBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmBlock
}

func (*AsmBlockContext) IsAsmBlockContext() {}

func NewAsmBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmBlockContext {
	var p = new(AsmBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_asmBlock

	return p
}

func (s *AsmBlockContext) GetParser() antlr.Parser { return s.parser }
func (s *AsmBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAsmBlock(s)
	}
}

func (s *AsmBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAsmBlock(s)
	}
}

func (p *MinZParser) AsmBlock() (localctx IAsmBlockContext) {
	localctx = NewAsmBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, MinZParserRULE_asmBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(653)
		p.Match(MinZParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1048578) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&562949953421311) != 0) {
		{
			p.SetState(654)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == MinZParserT__19 {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(659)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(660)
		p.Match(MinZParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternContext is an interface to support dynamic dispatch.
type IPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LiteralPattern() ILiteralPatternContext
	IdentifierPattern() IIdentifierPatternContext
	WildcardPattern() IWildcardPatternContext
	TuplePattern() ITuplePatternContext
	StructPattern() IStructPatternContext

	// IsPatternContext differentiates from other interfaces.
	IsPatternContext()
}

type PatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternContext() *PatternContext {
	var p = new(PatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_pattern
	return p
}

func InitEmptyPatternContext(p *PatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_pattern
}

func (*PatternContext) IsPatternContext() {}

func NewPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternContext {
	var p = new(PatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_pattern

	return p
}

func (s *PatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternContext) LiteralPattern() ILiteralPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralPatternContext)
}

func (s *PatternContext) IdentifierPattern() IIdentifierPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierPatternContext)
}

func (s *PatternContext) WildcardPattern() IWildcardPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildcardPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildcardPatternContext)
}

func (s *PatternContext) TuplePattern() ITuplePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITuplePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITuplePatternContext)
}

func (s *PatternContext) StructPattern() IStructPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructPatternContext)
}

func (s *PatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterPattern(s)
	}
}

func (s *PatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitPattern(s)
	}
}

func (p *MinZParser) Pattern() (localctx IPatternContext) {
	localctx = NewPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, MinZParserRULE_pattern)
	p.SetState(667)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(662)
			p.LiteralPattern()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(663)
			p.IdentifierPattern()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(664)
			p.WildcardPattern()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(665)
			p.TuplePattern()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(666)
			p.StructPattern()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralPatternContext is an interface to support dynamic dispatch.
type ILiteralPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext

	// IsLiteralPatternContext differentiates from other interfaces.
	IsLiteralPatternContext()
}

type LiteralPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralPatternContext() *LiteralPatternContext {
	var p = new(LiteralPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_literalPattern
	return p
}

func InitEmptyLiteralPatternContext(p *LiteralPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_literalPattern
}

func (*LiteralPatternContext) IsLiteralPatternContext() {}

func NewLiteralPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralPatternContext {
	var p = new(LiteralPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_literalPattern

	return p
}

func (s *LiteralPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralPatternContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLiteralPattern(s)
	}
}

func (s *LiteralPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLiteralPattern(s)
	}
}

func (p *MinZParser) LiteralPattern() (localctx ILiteralPatternContext) {
	localctx = NewLiteralPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, MinZParserRULE_literalPattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(669)
		p.Literal()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierPatternContext is an interface to support dynamic dispatch.
type IIdentifierPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode

	// IsIdentifierPatternContext differentiates from other interfaces.
	IsIdentifierPatternContext()
}

type IdentifierPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierPatternContext() *IdentifierPatternContext {
	var p = new(IdentifierPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_identifierPattern
	return p
}

func InitEmptyIdentifierPatternContext(p *IdentifierPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_identifierPattern
}

func (*IdentifierPatternContext) IsIdentifierPatternContext() {}

func NewIdentifierPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierPatternContext {
	var p = new(IdentifierPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_identifierPattern

	return p
}

func (s *IdentifierPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierPatternContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *IdentifierPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterIdentifierPattern(s)
	}
}

func (s *IdentifierPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitIdentifierPattern(s)
	}
}

func (p *MinZParser) IdentifierPattern() (localctx IIdentifierPatternContext) {
	localctx = NewIdentifierPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, MinZParserRULE_identifierPattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(671)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWildcardPatternContext is an interface to support dynamic dispatch.
type IWildcardPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWildcardPatternContext differentiates from other interfaces.
	IsWildcardPatternContext()
}

type WildcardPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildcardPatternContext() *WildcardPatternContext {
	var p = new(WildcardPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_wildcardPattern
	return p
}

func InitEmptyWildcardPatternContext(p *WildcardPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_wildcardPattern
}

func (*WildcardPatternContext) IsWildcardPatternContext() {}

func NewWildcardPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildcardPatternContext {
	var p = new(WildcardPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_wildcardPattern

	return p
}

func (s *WildcardPatternContext) GetParser() antlr.Parser { return s.parser }
func (s *WildcardPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildcardPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildcardPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterWildcardPattern(s)
	}
}

func (s *WildcardPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitWildcardPattern(s)
	}
}

func (p *MinZParser) WildcardPattern() (localctx IWildcardPatternContext) {
	localctx = NewWildcardPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, MinZParserRULE_wildcardPattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(673)
		p.Match(MinZParserT__50)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITuplePatternContext is an interface to support dynamic dispatch.
type ITuplePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPattern() []IPatternContext
	Pattern(i int) IPatternContext

	// IsTuplePatternContext differentiates from other interfaces.
	IsTuplePatternContext()
}

type TuplePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTuplePatternContext() *TuplePatternContext {
	var p = new(TuplePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_tuplePattern
	return p
}

func InitEmptyTuplePatternContext(p *TuplePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_tuplePattern
}

func (*TuplePatternContext) IsTuplePatternContext() {}

func NewTuplePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TuplePatternContext {
	var p = new(TuplePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_tuplePattern

	return p
}

func (s *TuplePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *TuplePatternContext) AllPattern() []IPatternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPatternContext); ok {
			len++
		}
	}

	tst := make([]IPatternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPatternContext); ok {
			tst[i] = t.(IPatternContext)
			i++
		}
	}

	return tst
}

func (s *TuplePatternContext) Pattern(i int) IPatternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *TuplePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TuplePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TuplePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterTuplePattern(s)
	}
}

func (s *TuplePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitTuplePattern(s)
	}
}

func (p *MinZParser) TuplePattern() (localctx ITuplePatternContext) {
	localctx = NewTuplePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, MinZParserRULE_tuplePattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(675)
		p.Match(MinZParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(676)
		p.Pattern()
	}
	p.SetState(681)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__12 {
		{
			p.SetState(677)
			p.Match(MinZParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(678)
			p.Pattern()
		}

		p.SetState(683)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(684)
		p.Match(MinZParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructPatternContext is an interface to support dynamic dispatch.
type IStructPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	AllFieldPattern() []IFieldPatternContext
	FieldPattern(i int) IFieldPatternContext

	// IsStructPatternContext differentiates from other interfaces.
	IsStructPatternContext()
}

type StructPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructPatternContext() *StructPatternContext {
	var p = new(StructPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_structPattern
	return p
}

func InitEmptyStructPatternContext(p *StructPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_structPattern
}

func (*StructPatternContext) IsStructPatternContext() {}

func NewStructPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructPatternContext {
	var p = new(StructPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_structPattern

	return p
}

func (s *StructPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *StructPatternContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *StructPatternContext) AllFieldPattern() []IFieldPatternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldPatternContext); ok {
			len++
		}
	}

	tst := make([]IFieldPatternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldPatternContext); ok {
			tst[i] = t.(IFieldPatternContext)
			i++
		}
	}

	return tst
}

func (s *StructPatternContext) FieldPattern(i int) IFieldPatternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldPatternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldPatternContext)
}

func (s *StructPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterStructPattern(s)
	}
}

func (s *StructPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitStructPattern(s)
	}
}

func (p *MinZParser) StructPattern() (localctx IStructPatternContext) {
	localctx = NewStructPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, MinZParserRULE_structPattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(687)
		p.Match(MinZParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(688)
		p.FieldPattern()
	}
	p.SetState(693)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__12 {
		{
			p.SetState(689)
			p.Match(MinZParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(690)
			p.FieldPattern()
		}

		p.SetState(695)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(696)
		p.Match(MinZParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldPatternContext is an interface to support dynamic dispatch.
type IFieldPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Pattern() IPatternContext

	// IsFieldPatternContext differentiates from other interfaces.
	IsFieldPatternContext()
}

type FieldPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldPatternContext() *FieldPatternContext {
	var p = new(FieldPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_fieldPattern
	return p
}

func InitEmptyFieldPatternContext(p *FieldPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_fieldPattern
}

func (*FieldPatternContext) IsFieldPatternContext() {}

func NewFieldPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldPatternContext {
	var p = new(FieldPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_fieldPattern

	return p
}

func (s *FieldPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldPatternContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *FieldPatternContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *FieldPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterFieldPattern(s)
	}
}

func (s *FieldPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitFieldPattern(s)
	}
}

func (p *MinZParser) FieldPattern() (localctx IFieldPatternContext) {
	localctx = NewFieldPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, MinZParserRULE_fieldPattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(699)
		p.Match(MinZParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(700)
		p.Pattern()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LambdaExpression() ILambdaExpressionContext
	ConditionalExpression() IConditionalExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ExpressionContext) ConditionalExpression() IConditionalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *MinZParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, MinZParserRULE_expression)
	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(702)
			p.LambdaExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(703)
			p.ConditionalExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	LambdaParams() ILambdaParamsContext
	Type_() ITypeContext
	ConditionalExpression() IConditionalExpressionContext

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_lambdaExpression
	return p
}

func InitEmptyLambdaExpressionContext(p *LambdaExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_lambdaExpression
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *LambdaExpressionContext) LambdaParams() ILambdaParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParamsContext)
}

func (s *LambdaExpressionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *LambdaExpressionContext) ConditionalExpression() IConditionalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLambdaExpression(s)
	}
}

func (p *MinZParser) LambdaExpression() (localctx ILambdaExpressionContext) {
	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, MinZParserRULE_lambdaExpression)
	var _la int

	p.SetState(717)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserT__51:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(706)
			p.Match(MinZParserT__51)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MinZParserIDENTIFIER {
			{
				p.SetState(707)
				p.LambdaParams()
			}

		}
		{
			p.SetState(710)
			p.Match(MinZParserT__51)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(713)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MinZParserT__46 {
			{
				p.SetState(711)
				p.Match(MinZParserT__46)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(712)
				p.Type_()
			}

		}
		{
			p.SetState(715)
			p.Block()
		}

	case MinZParserT__4, MinZParserT__8, MinZParserT__34, MinZParserT__41, MinZParserT__53, MinZParserT__63, MinZParserT__64, MinZParserT__67, MinZParserT__68, MinZParserT__69, MinZParserT__75, MinZParserT__76, MinZParserT__77, MinZParserT__78, MinZParserT__79, MinZParserT__80, MinZParserT__81, MinZParserT__82, MinZParserT__83, MinZParserT__84, MinZParserIDENTIFIER, MinZParserNUMBER, MinZParserHEX_NUMBER, MinZParserBINARY_NUMBER, MinZParserSTRING, MinZParserLSTRING, MinZParserCHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(716)
			p.ConditionalExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaParamsContext is an interface to support dynamic dispatch.
type ILambdaParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLambdaParam() []ILambdaParamContext
	LambdaParam(i int) ILambdaParamContext

	// IsLambdaParamsContext differentiates from other interfaces.
	IsLambdaParamsContext()
}

type LambdaParamsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParamsContext() *LambdaParamsContext {
	var p = new(LambdaParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_lambdaParams
	return p
}

func InitEmptyLambdaParamsContext(p *LambdaParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_lambdaParams
}

func (*LambdaParamsContext) IsLambdaParamsContext() {}

func NewLambdaParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParamsContext {
	var p = new(LambdaParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_lambdaParams

	return p
}

func (s *LambdaParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParamsContext) AllLambdaParam() []ILambdaParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILambdaParamContext); ok {
			len++
		}
	}

	tst := make([]ILambdaParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILambdaParamContext); ok {
			tst[i] = t.(ILambdaParamContext)
			i++
		}
	}

	return tst
}

func (s *LambdaParamsContext) LambdaParam(i int) ILambdaParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaParamContext)
}

func (s *LambdaParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLambdaParams(s)
	}
}

func (s *LambdaParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLambdaParams(s)
	}
}

func (p *MinZParser) LambdaParams() (localctx ILambdaParamsContext) {
	localctx = NewLambdaParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, MinZParserRULE_lambdaParams)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(719)
		p.LambdaParam()
	}
	p.SetState(724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__12 {
		{
			p.SetState(720)
			p.Match(MinZParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(721)
			p.LambdaParam()
		}

		p.SetState(726)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaParamContext is an interface to support dynamic dispatch.
type ILambdaParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Type_() ITypeContext

	// IsLambdaParamContext differentiates from other interfaces.
	IsLambdaParamContext()
}

type LambdaParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParamContext() *LambdaParamContext {
	var p = new(LambdaParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_lambdaParam
	return p
}

func InitEmptyLambdaParamContext(p *LambdaParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_lambdaParam
}

func (*LambdaParamContext) IsLambdaParamContext() {}

func NewLambdaParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParamContext {
	var p = new(LambdaParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_lambdaParam

	return p
}

func (s *LambdaParamContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParamContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *LambdaParamContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *LambdaParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLambdaParam(s)
	}
}

func (s *LambdaParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLambdaParam(s)
	}
}

func (p *MinZParser) LambdaParam() (localctx ILambdaParamContext) {
	localctx = NewLambdaParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, MinZParserRULE_lambdaParam)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(727)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__14 {
		{
			p.SetState(728)
			p.Match(MinZParserT__14)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(729)
			p.Type_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalExpressionContext is an interface to support dynamic dispatch.
type IConditionalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WhenExpression() IWhenExpressionContext
	LogicalOrExpression() ILogicalOrExpressionContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsConditionalExpressionContext differentiates from other interfaces.
	IsConditionalExpressionContext()
}

type ConditionalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalExpressionContext() *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_conditionalExpression
	return p
}

func InitEmptyConditionalExpressionContext(p *ConditionalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_conditionalExpression
}

func (*ConditionalExpressionContext) IsConditionalExpressionContext() {}

func NewConditionalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_conditionalExpression

	return p
}

func (s *ConditionalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalExpressionContext) WhenExpression() IWhenExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenExpressionContext)
}

func (s *ConditionalExpressionContext) LogicalOrExpression() ILogicalOrExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOrExpressionContext)
}

func (s *ConditionalExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConditionalExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterConditionalExpression(s)
	}
}

func (s *ConditionalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitConditionalExpression(s)
	}
}

func (p *MinZParser) ConditionalExpression() (localctx IConditionalExpressionContext) {
	localctx = NewConditionalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, MinZParserRULE_conditionalExpression)
	var _la int

	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserT__53:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(732)
			p.WhenExpression()
		}

	case MinZParserT__4, MinZParserT__8, MinZParserT__34, MinZParserT__63, MinZParserT__64, MinZParserT__67, MinZParserT__68, MinZParserT__69, MinZParserT__75, MinZParserT__76, MinZParserT__77, MinZParserT__78, MinZParserT__79, MinZParserT__80, MinZParserT__81, MinZParserT__82, MinZParserT__83, MinZParserT__84, MinZParserIDENTIFIER, MinZParserNUMBER, MinZParserHEX_NUMBER, MinZParserBINARY_NUMBER, MinZParserSTRING, MinZParserLSTRING, MinZParserCHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(733)
			p.LogicalOrExpression()
		}
		p.SetState(739)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MinZParserT__16 {
			{
				p.SetState(734)
				p.Match(MinZParserT__16)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(735)
				p.Expression()
			}
			{
				p.SetState(736)
				p.Match(MinZParserT__14)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(737)
				p.Expression()
			}

		}

	case MinZParserT__41:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(741)
			p.Match(MinZParserT__41)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(742)
			p.LogicalOrExpression()
		}
		{
			p.SetState(743)
			p.Match(MinZParserT__52)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(744)
			p.Expression()
		}
		{
			p.SetState(745)
			p.Match(MinZParserT__29)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(746)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenExpressionContext is an interface to support dynamic dispatch.
type IWhenExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AllWhenArm() []IWhenArmContext
	WhenArm(i int) IWhenArmContext

	// IsWhenExpressionContext differentiates from other interfaces.
	IsWhenExpressionContext()
}

type WhenExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenExpressionContext() *WhenExpressionContext {
	var p = new(WhenExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_whenExpression
	return p
}

func InitEmptyWhenExpressionContext(p *WhenExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_whenExpression
}

func (*WhenExpressionContext) IsWhenExpressionContext() {}

func NewWhenExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenExpressionContext {
	var p = new(WhenExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_whenExpression

	return p
}

func (s *WhenExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenExpressionContext) AllWhenArm() []IWhenArmContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenArmContext); ok {
			len++
		}
	}

	tst := make([]IWhenArmContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenArmContext); ok {
			tst[i] = t.(IWhenArmContext)
			i++
		}
	}

	return tst
}

func (s *WhenExpressionContext) WhenArm(i int) IWhenArmContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenArmContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenArmContext)
}

func (s *WhenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterWhenExpression(s)
	}
}

func (s *WhenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitWhenExpression(s)
	}
}

func (p *MinZParser) WhenExpression() (localctx IWhenExpressionContext) {
	localctx = NewWhenExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, MinZParserRULE_whenExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(750)
		p.Match(MinZParserT__53)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(751)
		p.Expression()
	}
	{
		p.SetState(752)
		p.Match(MinZParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__4 || _la == MinZParserT__50 || ((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&8522825731) != 0) {
		{
			p.SetState(753)
			p.WhenArm()
		}

		p.SetState(758)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(759)
		p.Match(MinZParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenArmContext is an interface to support dynamic dispatch.
type IWhenArmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pattern() IPatternContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenArmContext differentiates from other interfaces.
	IsWhenArmContext()
}

type WhenArmContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenArmContext() *WhenArmContext {
	var p = new(WhenArmContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_whenArm
	return p
}

func InitEmptyWhenArmContext(p *WhenArmContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_whenArm
}

func (*WhenArmContext) IsWhenArmContext() {}

func NewWhenArmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenArmContext {
	var p = new(WhenArmContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_whenArm

	return p
}

func (s *WhenArmContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenArmContext) Pattern() IPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternContext)
}

func (s *WhenArmContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenArmContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenArmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenArmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenArmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterWhenArm(s)
	}
}

func (s *WhenArmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitWhenArm(s)
	}
}

func (p *MinZParser) WhenArm() (localctx IWhenArmContext) {
	localctx = NewWhenArmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, MinZParserRULE_whenArm)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(761)
		p.Pattern()
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__41 {
		{
			p.SetState(762)
			p.Match(MinZParserT__41)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(763)
			p.Expression()
		}

	}
	{
		p.SetState(766)
		p.Match(MinZParserT__46)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(767)
		p.Expression()
	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__12 {
		{
			p.SetState(768)
			p.Match(MinZParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalOrExpressionContext is an interface to support dynamic dispatch.
type ILogicalOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLogicalAndExpression() []ILogicalAndExpressionContext
	LogicalAndExpression(i int) ILogicalAndExpressionContext

	// IsLogicalOrExpressionContext differentiates from other interfaces.
	IsLogicalOrExpressionContext()
}

type LogicalOrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalOrExpressionContext() *LogicalOrExpressionContext {
	var p = new(LogicalOrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_logicalOrExpression
	return p
}

func InitEmptyLogicalOrExpressionContext(p *LogicalOrExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_logicalOrExpression
}

func (*LogicalOrExpressionContext) IsLogicalOrExpressionContext() {}

func NewLogicalOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOrExpressionContext {
	var p = new(LogicalOrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_logicalOrExpression

	return p
}

func (s *LogicalOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOrExpressionContext) AllLogicalAndExpression() []ILogicalAndExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILogicalAndExpressionContext); ok {
			len++
		}
	}

	tst := make([]ILogicalAndExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILogicalAndExpressionContext); ok {
			tst[i] = t.(ILogicalAndExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrExpressionContext) LogicalAndExpression(i int) ILogicalAndExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalAndExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalAndExpressionContext)
}

func (s *LogicalOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLogicalOrExpression(s)
	}
}

func (p *MinZParser) LogicalOrExpression() (localctx ILogicalOrExpressionContext) {
	localctx = NewLogicalOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, MinZParserRULE_logicalOrExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(771)
		p.LogicalAndExpression()
	}
	p.SetState(776)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__54 || _la == MinZParserT__55 {
		{
			p.SetState(772)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MinZParserT__54 || _la == MinZParserT__55) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(773)
			p.LogicalAndExpression()
		}

		p.SetState(778)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalAndExpressionContext is an interface to support dynamic dispatch.
type ILogicalAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEqualityExpression() []IEqualityExpressionContext
	EqualityExpression(i int) IEqualityExpressionContext

	// IsLogicalAndExpressionContext differentiates from other interfaces.
	IsLogicalAndExpressionContext()
}

type LogicalAndExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalAndExpressionContext() *LogicalAndExpressionContext {
	var p = new(LogicalAndExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_logicalAndExpression
	return p
}

func InitEmptyLogicalAndExpressionContext(p *LogicalAndExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_logicalAndExpression
}

func (*LogicalAndExpressionContext) IsLogicalAndExpressionContext() {}

func NewLogicalAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalAndExpressionContext {
	var p = new(LogicalAndExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_logicalAndExpression

	return p
}

func (s *LogicalAndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalAndExpressionContext) AllEqualityExpression() []IEqualityExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEqualityExpressionContext); ok {
			len++
		}
	}

	tst := make([]IEqualityExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEqualityExpressionContext); ok {
			tst[i] = t.(IEqualityExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndExpressionContext) EqualityExpression(i int) IEqualityExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityExpressionContext)
}

func (s *LogicalAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLogicalAndExpression(s)
	}
}

func (p *MinZParser) LogicalAndExpression() (localctx ILogicalAndExpressionContext) {
	localctx = NewLogicalAndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, MinZParserRULE_logicalAndExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		p.EqualityExpression()
	}
	p.SetState(784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__56 || _la == MinZParserT__57 {
		{
			p.SetState(780)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MinZParserT__56 || _la == MinZParserT__57) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(781)
			p.EqualityExpression()
		}

		p.SetState(786)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualityExpressionContext is an interface to support dynamic dispatch.
type IEqualityExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelationalExpression() []IRelationalExpressionContext
	RelationalExpression(i int) IRelationalExpressionContext

	// IsEqualityExpressionContext differentiates from other interfaces.
	IsEqualityExpressionContext()
}

type EqualityExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualityExpressionContext() *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_equalityExpression
	return p
}

func InitEmptyEqualityExpressionContext(p *EqualityExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_equalityExpression
}

func (*EqualityExpressionContext) IsEqualityExpressionContext() {}

func NewEqualityExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_equalityExpression

	return p
}

func (s *EqualityExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityExpressionContext) AllRelationalExpression() []IRelationalExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationalExpressionContext); ok {
			len++
		}
	}

	tst := make([]IRelationalExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationalExpressionContext); ok {
			tst[i] = t.(IRelationalExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExpressionContext) RelationalExpression(i int) IRelationalExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationalExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationalExpressionContext)
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}

func (p *MinZParser) EqualityExpression() (localctx IEqualityExpressionContext) {
	localctx = NewEqualityExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, MinZParserRULE_equalityExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(787)
		p.RelationalExpression()
	}
	p.SetState(792)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__58 || _la == MinZParserT__59 {
		{
			p.SetState(788)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MinZParserT__58 || _la == MinZParserT__59) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(789)
			p.RelationalExpression()
		}

		p.SetState(794)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationalExpressionContext is an interface to support dynamic dispatch.
type IRelationalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAdditiveExpression() []IAdditiveExpressionContext
	AdditiveExpression(i int) IAdditiveExpressionContext

	// IsRelationalExpressionContext differentiates from other interfaces.
	IsRelationalExpressionContext()
}

type RelationalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationalExpressionContext() *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_relationalExpression
	return p
}

func InitEmptyRelationalExpressionContext(p *RelationalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_relationalExpression
}

func (*RelationalExpressionContext) IsRelationalExpressionContext() {}

func NewRelationalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_relationalExpression

	return p
}

func (s *RelationalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationalExpressionContext) AllAdditiveExpression() []IAdditiveExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAdditiveExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditiveExpressionContext); ok {
			tst[i] = t.(IAdditiveExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RelationalExpressionContext) AdditiveExpression(i int) IAdditiveExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *RelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitRelationalExpression(s)
	}
}

func (p *MinZParser) RelationalExpression() (localctx IRelationalExpressionContext) {
	localctx = NewRelationalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, MinZParserRULE_relationalExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(795)
		p.AdditiveExpression()
	}
	p.SetState(800)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6917529027641102336) != 0 {
		{
			p.SetState(796)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6917529027641102336) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(797)
			p.AdditiveExpression()
		}

		p.SetState(802)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExpressionContext is an interface to support dynamic dispatch.
type IAdditiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMultiplicativeExpression() []IMultiplicativeExpressionContext
	MultiplicativeExpression(i int) IMultiplicativeExpressionContext

	// IsAdditiveExpressionContext differentiates from other interfaces.
	IsAdditiveExpressionContext()
}

type AdditiveExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExpressionContext() *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_additiveExpression
	return p
}

func InitEmptyAdditiveExpressionContext(p *AdditiveExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_additiveExpression
}

func (*AdditiveExpressionContext) IsAdditiveExpressionContext() {}

func NewAdditiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_additiveExpression

	return p
}

func (s *AdditiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExpressionContext) AllMultiplicativeExpression() []IMultiplicativeExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMultiplicativeExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplicativeExpressionContext); ok {
			tst[i] = t.(IMultiplicativeExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) MultiplicativeExpression(i int) IMultiplicativeExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (p *MinZParser) AdditiveExpression() (localctx IAdditiveExpressionContext) {
	localctx = NewAdditiveExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, MinZParserRULE_additiveExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(803)
		p.MultiplicativeExpression()
	}
	p.SetState(808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__62 || _la == MinZParserT__63 {
		{
			p.SetState(804)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MinZParserT__62 || _la == MinZParserT__63) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(805)
			p.MultiplicativeExpression()
		}

		p.SetState(810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExpressionContext is an interface to support dynamic dispatch.
type IMultiplicativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCastExpression() []ICastExpressionContext
	CastExpression(i int) ICastExpressionContext

	// IsMultiplicativeExpressionContext differentiates from other interfaces.
	IsMultiplicativeExpressionContext()
}

type MultiplicativeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExpressionContext() *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_multiplicativeExpression
	return p
}

func InitEmptyMultiplicativeExpressionContext(p *MultiplicativeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_multiplicativeExpression
}

func (*MultiplicativeExpressionContext) IsMultiplicativeExpressionContext() {}

func NewMultiplicativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_multiplicativeExpression

	return p
}

func (s *MultiplicativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExpressionContext) AllCastExpression() []ICastExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICastExpressionContext); ok {
			len++
		}
	}

	tst := make([]ICastExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICastExpressionContext); ok {
			tst[i] = t.(ICastExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) CastExpression(i int) ICastExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (p *MinZParser) MultiplicativeExpression() (localctx IMultiplicativeExpressionContext) {
	localctx = NewMultiplicativeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, MinZParserRULE_multiplicativeExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(811)
		p.CastExpression()
	}
	p.SetState(816)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&7) != 0 {
		{
			p.SetState(812)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&7) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(813)
			p.CastExpression()
		}

		p.SetState(818)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastExpressionContext is an interface to support dynamic dispatch.
type ICastExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnaryExpression() IUnaryExpressionContext
	Type_() ITypeContext

	// IsCastExpressionContext differentiates from other interfaces.
	IsCastExpressionContext()
}

type CastExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastExpressionContext() *CastExpressionContext {
	var p = new(CastExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_castExpression
	return p
}

func InitEmptyCastExpressionContext(p *CastExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_castExpression
}

func (*CastExpressionContext) IsCastExpressionContext() {}

func NewCastExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastExpressionContext {
	var p = new(CastExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_castExpression

	return p
}

func (s *CastExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *CastExpressionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCastExpression(s)
	}
}

func (s *CastExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCastExpression(s)
	}
}

func (p *MinZParser) CastExpression() (localctx ICastExpressionContext) {
	localctx = NewCastExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, MinZParserRULE_castExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(819)
		p.UnaryExpression()
	}
	p.SetState(822)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__1 {
		{
			p.SetState(820)
			p.Match(MinZParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(821)
			p.Type_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExpressionContext is an interface to support dynamic dispatch.
type IUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnaryExpression() IUnaryExpressionContext
	PostfixExpression() IPostfixExpressionContext

	// IsUnaryExpressionContext differentiates from other interfaces.
	IsUnaryExpressionContext()
}

type UnaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExpressionContext() *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_unaryExpression
	return p
}

func InitEmptyUnaryExpressionContext(p *UnaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_unaryExpression
}

func (*UnaryExpressionContext) IsUnaryExpressionContext() {}

func NewUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_unaryExpression

	return p
}

func (s *UnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *UnaryExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *UnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitUnaryExpression(s)
	}
}

func (p *MinZParser) UnaryExpression() (localctx IUnaryExpressionContext) {
	localctx = NewUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, MinZParserRULE_unaryExpression)
	var _la int

	p.SetState(827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserT__63, MinZParserT__64, MinZParserT__67, MinZParserT__68, MinZParserT__69:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(824)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&115) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(825)
			p.UnaryExpression()
		}

	case MinZParserT__4, MinZParserT__8, MinZParserT__34, MinZParserT__75, MinZParserT__76, MinZParserT__77, MinZParserT__78, MinZParserT__79, MinZParserT__80, MinZParserT__81, MinZParserT__82, MinZParserT__83, MinZParserT__84, MinZParserIDENTIFIER, MinZParserNUMBER, MinZParserHEX_NUMBER, MinZParserBINARY_NUMBER, MinZParserSTRING, MinZParserLSTRING, MinZParserCHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(826)
			p.PostfixExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExpressionContext is an interface to support dynamic dispatch.
type IPostfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpression() IPrimaryExpressionContext
	AllPostfixOperator() []IPostfixOperatorContext
	PostfixOperator(i int) IPostfixOperatorContext

	// IsPostfixExpressionContext differentiates from other interfaces.
	IsPostfixExpressionContext()
}

type PostfixExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExpressionContext() *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_postfixExpression
	return p
}

func InitEmptyPostfixExpressionContext(p *PostfixExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_postfixExpression
}

func (*PostfixExpressionContext) IsPostfixExpressionContext() {}

func NewPostfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_postfixExpression

	return p
}

func (s *PostfixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PostfixExpressionContext) AllPostfixOperator() []IPostfixOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPostfixOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPostfixOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPostfixOperatorContext); ok {
			tst[i] = t.(IPostfixOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PostfixExpressionContext) PostfixOperator(i int) IPostfixOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixOperatorContext)
}

func (s *PostfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterPostfixExpression(s)
	}
}

func (s *PostfixExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitPostfixExpression(s)
	}
}

func (p *MinZParser) PostfixExpression() (localctx IPostfixExpressionContext) {
	localctx = NewPostfixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, MinZParserRULE_postfixExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(829)
		p.PrimaryExpression()
	}
	p.SetState(833)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(830)
				p.PostfixOperator()
			}

		}
		p.SetState(835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixOperatorContext is an interface to support dynamic dispatch.
type IPostfixOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	IDENTIFIER() antlr.TerminalNode
	ArgumentList() IArgumentListContext
	LambdaExpression() ILambdaExpressionContext

	// IsPostfixOperatorContext differentiates from other interfaces.
	IsPostfixOperatorContext()
}

type PostfixOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixOperatorContext() *PostfixOperatorContext {
	var p = new(PostfixOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_postfixOperator
	return p
}

func InitEmptyPostfixOperatorContext(p *PostfixOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_postfixOperator
}

func (*PostfixOperatorContext) IsPostfixOperatorContext() {}

func NewPostfixOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixOperatorContext {
	var p = new(PostfixOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_postfixOperator

	return p
}

func (s *PostfixOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixOperatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PostfixOperatorContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *PostfixOperatorContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *PostfixOperatorContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *PostfixOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterPostfixOperator(s)
	}
}

func (s *PostfixOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitPostfixOperator(s)
	}
}

func (p *MinZParser) PostfixOperator() (localctx IPostfixOperatorContext) {
	localctx = NewPostfixOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, MinZParserRULE_postfixOperator)
	var _la int

	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserT__34:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(836)
			p.Match(MinZParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(837)
			p.Expression()
		}
		{
			p.SetState(838)
			p.Match(MinZParserT__35)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__3:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(840)
			p.Match(MinZParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(841)
			p.Match(MinZParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__4:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(842)
			p.Match(MinZParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(844)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&22522430543102496) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&34909498372211) != 0) {
			{
				p.SetState(843)
				p.ArgumentList()
			}

		}
		{
			p.SetState(846)
			p.Match(MinZParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__16:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(847)
			p.Match(MinZParserT__16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__70:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(848)
			p.Match(MinZParserT__70)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__71:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(849)
			p.Match(MinZParserT__71)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__72:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(850)
			p.Match(MinZParserT__72)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(851)
			p.Match(MinZParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(852)
			p.LambdaExpression()
		}
		{
			p.SetState(853)
			p.Match(MinZParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__73:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(855)
			p.Match(MinZParserT__73)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(856)
			p.Match(MinZParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(857)
			p.LambdaExpression()
		}
		{
			p.SetState(858)
			p.Match(MinZParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__74:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(860)
			p.Match(MinZParserT__74)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(861)
			p.Match(MinZParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(862)
			p.LambdaExpression()
		}
		{
			p.SetState(863)
			p.Match(MinZParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *MinZParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, MinZParserRULE_argumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(867)
		p.Expression()
	}
	p.SetState(872)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__12 {
		{
			p.SetState(868)
			p.Match(MinZParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(869)
			p.Expression()
		}

		p.SetState(874)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	IDENTIFIER() antlr.TerminalNode
	Expression() IExpressionContext
	ArrayLiteral() IArrayLiteralContext
	StructLiteral() IStructLiteralContext
	Metafunction() IMetafunctionContext
	InlineAssembly() IInlineAssemblyContext

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryExpressionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *PrimaryExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryExpressionContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *PrimaryExpressionContext) StructLiteral() IStructLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructLiteralContext)
}

func (s *PrimaryExpressionContext) Metafunction() IMetafunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMetafunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMetafunctionContext)
}

func (s *PrimaryExpressionContext) InlineAssembly() IInlineAssemblyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineAssemblyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineAssemblyContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

func (p *MinZParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, MinZParserRULE_primaryExpression)
	p.SetState(885)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(875)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(876)
			p.Match(MinZParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(877)
			p.Match(MinZParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(878)
			p.Expression()
		}
		{
			p.SetState(879)
			p.Match(MinZParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(881)
			p.ArrayLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(882)
			p.StructLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(883)
			p.Metafunction()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(884)
			p.InlineAssembly()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumberLiteral() INumberLiteralContext
	StringLiteral() IStringLiteralContext
	CharLiteral() ICharLiteralContext
	BooleanLiteral() IBooleanLiteralContext

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralContext) CharLiteral() ICharLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharLiteralContext)
}

func (s *LiteralContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *MinZParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, MinZParserRULE_literal)
	p.SetState(891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserNUMBER, MinZParserHEX_NUMBER, MinZParserBINARY_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(887)
			p.NumberLiteral()
		}

	case MinZParserSTRING, MinZParserLSTRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(888)
			p.StringLiteral()
		}

	case MinZParserCHAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(889)
			p.CharLiteral()
		}

	case MinZParserT__75, MinZParserT__76:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(890)
			p.BooleanLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMBER() antlr.TerminalNode
	HEX_NUMBER() antlr.TerminalNode
	BINARY_NUMBER() antlr.TerminalNode

	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_numberLiteral
	return p
}

func InitEmptyNumberLiteralContext(p *NumberLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_numberLiteral
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(MinZParserNUMBER, 0)
}

func (s *NumberLiteralContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(MinZParserHEX_NUMBER, 0)
}

func (s *NumberLiteralContext) BINARY_NUMBER() antlr.TerminalNode {
	return s.GetToken(MinZParserBINARY_NUMBER, 0)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitNumberLiteral(s)
	}
}

func (p *MinZParser) NumberLiteral() (localctx INumberLiteralContext) {
	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, MinZParserRULE_numberLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(893)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-103)) & ^0x3f) == 0 && ((int64(1)<<(_la-103))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	LSTRING() antlr.TerminalNode

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(MinZParserSTRING, 0)
}

func (s *StringLiteralContext) LSTRING() antlr.TerminalNode {
	return s.GetToken(MinZParserLSTRING, 0)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *MinZParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, MinZParserRULE_stringLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(895)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MinZParserSTRING || _la == MinZParserLSTRING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharLiteralContext is an interface to support dynamic dispatch.
type ICharLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHAR() antlr.TerminalNode

	// IsCharLiteralContext differentiates from other interfaces.
	IsCharLiteralContext()
}

type CharLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharLiteralContext() *CharLiteralContext {
	var p = new(CharLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_charLiteral
	return p
}

func InitEmptyCharLiteralContext(p *CharLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_charLiteral
}

func (*CharLiteralContext) IsCharLiteralContext() {}

func NewCharLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharLiteralContext {
	var p = new(CharLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_charLiteral

	return p
}

func (s *CharLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CharLiteralContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MinZParserCHAR, 0)
}

func (s *CharLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterCharLiteral(s)
	}
}

func (s *CharLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitCharLiteral(s)
	}
}

func (p *MinZParser) CharLiteral() (localctx ICharLiteralContext) {
	localctx = NewCharLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, MinZParserRULE_charLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(897)
		p.Match(MinZParserCHAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }
func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *MinZParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, MinZParserRULE_booleanLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(899)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MinZParserT__75 || _la == MinZParserT__76) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_arrayLiteral
	return p
}

func InitEmptyArrayLiteralContext(p *ArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_arrayLiteral
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayLiteralContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (p *MinZParser) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, MinZParserRULE_arrayLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(901)
		p.Match(MinZParserT__34)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&22522430543102496) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&34909498372211) != 0) {
		{
			p.SetState(902)
			p.Expression()
		}
		p.SetState(907)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MinZParserT__12 {
			{
				p.SetState(903)
				p.Match(MinZParserT__12)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(904)
				p.Expression()
			}

			p.SetState(909)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(912)
		p.Match(MinZParserT__35)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructLiteralContext is an interface to support dynamic dispatch.
type IStructLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	AllFieldInit() []IFieldInitContext
	FieldInit(i int) IFieldInitContext

	// IsStructLiteralContext differentiates from other interfaces.
	IsStructLiteralContext()
}

type StructLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructLiteralContext() *StructLiteralContext {
	var p = new(StructLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_structLiteral
	return p
}

func InitEmptyStructLiteralContext(p *StructLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_structLiteral
}

func (*StructLiteralContext) IsStructLiteralContext() {}

func NewStructLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructLiteralContext {
	var p = new(StructLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_structLiteral

	return p
}

func (s *StructLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StructLiteralContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *StructLiteralContext) AllFieldInit() []IFieldInitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldInitContext); ok {
			len++
		}
	}

	tst := make([]IFieldInitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldInitContext); ok {
			tst[i] = t.(IFieldInitContext)
			i++
		}
	}

	return tst
}

func (s *StructLiteralContext) FieldInit(i int) IFieldInitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldInitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldInitContext)
}

func (s *StructLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterStructLiteral(s)
	}
}

func (s *StructLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitStructLiteral(s)
	}
}

func (p *MinZParser) StructLiteral() (localctx IStructLiteralContext) {
	localctx = NewStructLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, MinZParserRULE_structLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(914)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(915)
		p.Match(MinZParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserIDENTIFIER {
		{
			p.SetState(916)
			p.FieldInit()
		}
		p.SetState(921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MinZParserT__12 {
			{
				p.SetState(917)
				p.Match(MinZParserT__12)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(918)
				p.FieldInit()
			}

			p.SetState(923)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(926)
		p.Match(MinZParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldInitContext is an interface to support dynamic dispatch.
type IFieldInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFieldInitContext differentiates from other interfaces.
	IsFieldInitContext()
}

type FieldInitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldInitContext() *FieldInitContext {
	var p = new(FieldInitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_fieldInit
	return p
}

func InitEmptyFieldInitContext(p *FieldInitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_fieldInit
}

func (*FieldInitContext) IsFieldInitContext() {}

func NewFieldInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldInitContext {
	var p = new(FieldInitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_fieldInit

	return p
}

func (s *FieldInitContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldInitContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *FieldInitContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FieldInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldInitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterFieldInit(s)
	}
}

func (s *FieldInitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitFieldInit(s)
	}
}

func (p *MinZParser) FieldInit() (localctx IFieldInitContext) {
	localctx = NewFieldInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, MinZParserRULE_fieldInit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(928)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(929)
		p.Match(MinZParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(930)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMetafunctionContext is an interface to support dynamic dispatch.
type IMetafunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	StringLiteral() IStringLiteralContext
	LuaBlock() ILuaBlockContext
	IDENTIFIER() antlr.TerminalNode

	// IsMetafunctionContext differentiates from other interfaces.
	IsMetafunctionContext()
}

type MetafunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMetafunctionContext() *MetafunctionContext {
	var p = new(MetafunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_metafunction
	return p
}

func InitEmptyMetafunctionContext(p *MetafunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_metafunction
}

func (*MetafunctionContext) IsMetafunctionContext() {}

func NewMetafunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MetafunctionContext {
	var p = new(MetafunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_metafunction

	return p
}

func (s *MetafunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *MetafunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MetafunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MetafunctionContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *MetafunctionContext) LuaBlock() ILuaBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILuaBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILuaBlockContext)
}

func (s *MetafunctionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *MetafunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MetafunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MetafunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterMetafunction(s)
	}
}

func (s *MetafunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitMetafunction(s)
	}
}

func (p *MinZParser) Metafunction() (localctx IMetafunctionContext) {
	localctx = NewMetafunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, MinZParserRULE_metafunction)
	var _la int

	p.SetState(982)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserT__77:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(932)
			p.Match(MinZParserT__77)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(933)
			p.Match(MinZParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(934)
			p.Expression()
		}
		p.SetState(939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MinZParserT__12 {
			{
				p.SetState(935)
				p.Match(MinZParserT__12)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(936)
				p.Expression()
			}

			p.SetState(941)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(942)
			p.Match(MinZParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__78:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(944)
			p.Match(MinZParserT__78)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(945)
			p.Match(MinZParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(946)
			p.Expression()
		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MinZParserT__12 {
			{
				p.SetState(947)
				p.Match(MinZParserT__12)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(948)
				p.Expression()
			}

		}
		{
			p.SetState(951)
			p.Match(MinZParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__79:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(953)
			p.Match(MinZParserT__79)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(954)
			p.Match(MinZParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(955)
			p.StringLiteral()
		}
		{
			p.SetState(956)
			p.Match(MinZParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__80:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(958)
			p.Match(MinZParserT__80)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(959)
			p.Match(MinZParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(960)
			p.StringLiteral()
		}
		{
			p.SetState(961)
			p.Match(MinZParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__81:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(963)
			p.Match(MinZParserT__81)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(964)
			p.LuaBlock()
		}

	case MinZParserT__82:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(965)
			p.Match(MinZParserT__82)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(966)
			p.Match(MinZParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(967)
			p.Expression()
		}
		{
			p.SetState(968)
			p.Match(MinZParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__83:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(970)
			p.Match(MinZParserT__83)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(971)
			p.Match(MinZParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(972)
			p.Match(MinZParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(973)
			p.Match(MinZParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(974)
			p.Expression()
		}
		{
			p.SetState(975)
			p.Match(MinZParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__84:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(977)
			p.Match(MinZParserT__84)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(978)
			p.Match(MinZParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(979)
			p.StringLiteral()
		}
		{
			p.SetState(980)
			p.Match(MinZParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILuaBlockContext is an interface to support dynamic dispatch.
type ILuaBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LUA_BLOCK() antlr.TerminalNode

	// IsLuaBlockContext differentiates from other interfaces.
	IsLuaBlockContext()
}

type LuaBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLuaBlockContext() *LuaBlockContext {
	var p = new(LuaBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_luaBlock
	return p
}

func InitEmptyLuaBlockContext(p *LuaBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_luaBlock
}

func (*LuaBlockContext) IsLuaBlockContext() {}

func NewLuaBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LuaBlockContext {
	var p = new(LuaBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_luaBlock

	return p
}

func (s *LuaBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *LuaBlockContext) LUA_BLOCK() antlr.TerminalNode {
	return s.GetToken(MinZParserLUA_BLOCK, 0)
}

func (s *LuaBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LuaBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LuaBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterLuaBlock(s)
	}
}

func (s *LuaBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitLuaBlock(s)
	}
}

func (p *MinZParser) LuaBlock() (localctx ILuaBlockContext) {
	localctx = NewLuaBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, MinZParserRULE_luaBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(984)
		p.Match(MinZParserLUA_BLOCK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineAssemblyContext is an interface to support dynamic dispatch.
type IInlineAssemblyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext
	AllAsmOperand() []IAsmOperandContext
	AsmOperand(i int) IAsmOperandContext

	// IsInlineAssemblyContext differentiates from other interfaces.
	IsInlineAssemblyContext()
}

type InlineAssemblyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineAssemblyContext() *InlineAssemblyContext {
	var p = new(InlineAssemblyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_inlineAssembly
	return p
}

func InitEmptyInlineAssemblyContext(p *InlineAssemblyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_inlineAssembly
}

func (*InlineAssemblyContext) IsInlineAssemblyContext() {}

func NewInlineAssemblyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineAssemblyContext {
	var p = new(InlineAssemblyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_inlineAssembly

	return p
}

func (s *InlineAssemblyContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineAssemblyContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *InlineAssemblyContext) AllAsmOperand() []IAsmOperandContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAsmOperandContext); ok {
			len++
		}
	}

	tst := make([]IAsmOperandContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAsmOperandContext); ok {
			tst[i] = t.(IAsmOperandContext)
			i++
		}
	}

	return tst
}

func (s *InlineAssemblyContext) AsmOperand(i int) IAsmOperandContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmOperandContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmOperandContext)
}

func (s *InlineAssemblyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineAssemblyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineAssemblyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterInlineAssembly(s)
	}
}

func (s *InlineAssemblyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitInlineAssembly(s)
	}
}

func (p *MinZParser) InlineAssembly() (localctx IInlineAssemblyContext) {
	localctx = NewInlineAssemblyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, MinZParserRULE_inlineAssembly)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(986)
		p.Match(MinZParserT__8)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(987)
		p.Match(MinZParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(988)
		p.StringLiteral()
	}
	p.SetState(993)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__12 {
		{
			p.SetState(989)
			p.Match(MinZParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(990)
			p.AsmOperand()
		}

		p.SetState(995)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(996)
		p.Match(MinZParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsmOperandContext is an interface to support dynamic dispatch.
type IAsmOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AsmConstraint() IAsmConstraintContext
	Expression() IExpressionContext

	// IsAsmOperandContext differentiates from other interfaces.
	IsAsmOperandContext()
}

type AsmOperandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmOperandContext() *AsmOperandContext {
	var p = new(AsmOperandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmOperand
	return p
}

func InitEmptyAsmOperandContext(p *AsmOperandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmOperand
}

func (*AsmOperandContext) IsAsmOperandContext() {}

func NewAsmOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmOperandContext {
	var p = new(AsmOperandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_asmOperand

	return p
}

func (s *AsmOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmOperandContext) AsmConstraint() IAsmConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmConstraintContext)
}

func (s *AsmOperandContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AsmOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAsmOperand(s)
	}
}

func (s *AsmOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAsmOperand(s)
	}
}

func (p *MinZParser) AsmOperand() (localctx IAsmOperandContext) {
	localctx = NewAsmOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, MinZParserRULE_asmOperand)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(998)
		p.Match(MinZParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(999)
		p.Match(MinZParserT__85)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1000)
		p.AsmConstraint()
	}
	{
		p.SetState(1001)
		p.Match(MinZParserT__85)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1002)
		p.Match(MinZParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1003)
		p.Expression()
	}
	{
		p.SetState(1004)
		p.Match(MinZParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsmConstraintContext is an interface to support dynamic dispatch.
type IAsmConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode

	// IsAsmConstraintContext differentiates from other interfaces.
	IsAsmConstraintContext()
}

type AsmConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmConstraintContext() *AsmConstraintContext {
	var p = new(AsmConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmConstraint
	return p
}

func InitEmptyAsmConstraintContext(p *AsmConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_asmConstraint
}

func (*AsmConstraintContext) IsAsmConstraintContext() {}

func NewAsmConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmConstraintContext {
	var p = new(AsmConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_asmConstraint

	return p
}

func (s *AsmConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmConstraintContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *AsmConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterAsmConstraint(s)
	}
}

func (s *AsmConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitAsmConstraint(s)
	}
}

func (p *MinZParser) AsmConstraint() (localctx IAsmConstraintContext) {
	localctx = NewAsmConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, MinZParserRULE_asmConstraint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1006)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimitiveType() IPrimitiveTypeContext
	ArrayType() IArrayTypeContext
	PointerType() IPointerTypeContext
	FunctionType() IFunctionTypeContext
	StructType() IStructTypeContext
	EnumType() IEnumTypeContext
	BitStructType() IBitStructTypeContext
	TypeIdentifier() ITypeIdentifierContext
	ErrorType() IErrorTypeContext

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeContext) PointerType() IPointerTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerTypeContext)
}

func (s *TypeContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *TypeContext) StructType() IStructTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructTypeContext)
}

func (s *TypeContext) EnumType() IEnumTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumTypeContext)
}

func (s *TypeContext) BitStructType() IBitStructTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitStructTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitStructTypeContext)
}

func (s *TypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *TypeContext) ErrorType() IErrorTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorTypeContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitType(s)
	}
}

func (p *MinZParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, MinZParserRULE_type)
	p.SetState(1017)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1008)
			p.PrimitiveType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1009)
			p.ArrayType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1010)
			p.PointerType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1011)
			p.FunctionType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1012)
			p.StructType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1013)
			p.EnumType()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1014)
			p.BitStructType()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1015)
			p.TypeIdentifier()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1016)
			p.ErrorType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_primitiveType
	return p
}

func InitEmptyPrimitiveTypeContext(p *PrimitiveTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_primitiveType
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }
func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (p *MinZParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, MinZParserRULE_primitiveType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1019)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&8191) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	Expression() IExpressionContext

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ArrayTypeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (p *MinZParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, MinZParserRULE_arrayType)
	p.SetState(1031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1021)
			p.Match(MinZParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1022)
			p.Type_()
		}
		{
			p.SetState(1023)
			p.Match(MinZParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1024)
			p.Expression()
		}
		{
			p.SetState(1025)
			p.Match(MinZParserT__35)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1027)
			p.Match(MinZParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1028)
			p.Type_()
		}
		{
			p.SetState(1029)
			p.Match(MinZParserT__35)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPointerTypeContext is an interface to support dynamic dispatch.
type IPointerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext

	// IsPointerTypeContext differentiates from other interfaces.
	IsPointerTypeContext()
}

type PointerTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerTypeContext() *PointerTypeContext {
	var p = new(PointerTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_pointerType
	return p
}

func InitEmptyPointerTypeContext(p *PointerTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_pointerType
}

func (*PointerTypeContext) IsPointerTypeContext() {}

func NewPointerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerTypeContext {
	var p = new(PointerTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_pointerType

	return p
}

func (s *PointerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *PointerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterPointerType(s)
	}
}

func (s *PointerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitPointerType(s)
	}
}

func (p *MinZParser) PointerType() (localctx IPointerTypeContext) {
	localctx = NewPointerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, MinZParserRULE_pointerType)
	var _la int

	p.SetState(1041)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1033)
			p.Match(MinZParserT__64)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1035)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MinZParserT__26 {
			{
				p.SetState(1034)
				p.Match(MinZParserT__26)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1037)
			p.Type_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1038)
			p.Match(MinZParserT__64)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1039)
			p.Match(MinZParserT__38)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1040)
			p.Type_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeList() ITypeListContext
	ReturnType() IReturnTypeContext

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_functionType
	return p
}

func InitEmptyFunctionTypeContext(p *FunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_functionType
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *FunctionTypeContext) ReturnType() IReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (p *MinZParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, MinZParserRULE_functionType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1043)
		p.Match(MinZParserT__7)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1044)
		p.Match(MinZParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1046)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&34362097920) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&206154235905) != 0) {
		{
			p.SetState(1045)
			p.TypeList()
		}

	}
	{
		p.SetState(1048)
		p.Match(MinZParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1050)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__15 {
		{
			p.SetState(1049)
			p.ReturnType()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (p *MinZParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, MinZParserRULE_typeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1052)
		p.Type_()
	}
	p.SetState(1057)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__12 {
		{
			p.SetState(1053)
			p.Match(MinZParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1054)
			p.Type_()
		}

		p.SetState(1059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructTypeContext is an interface to support dynamic dispatch.
type IStructTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldList() IFieldListContext

	// IsStructTypeContext differentiates from other interfaces.
	IsStructTypeContext()
}

type StructTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructTypeContext() *StructTypeContext {
	var p = new(StructTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_structType
	return p
}

func InitEmptyStructTypeContext(p *StructTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_structType
}

func (*StructTypeContext) IsStructTypeContext() {}

func NewStructTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructTypeContext {
	var p = new(StructTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_structType

	return p
}

func (s *StructTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StructTypeContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *StructTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterStructType(s)
	}
}

func (s *StructTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitStructType(s)
	}
}

func (p *MinZParser) StructType() (localctx IStructTypeContext) {
	localctx = NewStructTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, MinZParserRULE_structType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1060)
		p.Match(MinZParserT__17)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1061)
		p.Match(MinZParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1063)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserIDENTIFIER {
		{
			p.SetState(1062)
			p.FieldList()
		}

	}
	{
		p.SetState(1065)
		p.Match(MinZParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumTypeContext is an interface to support dynamic dispatch.
type IEnumTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnumMemberList() IEnumMemberListContext

	// IsEnumTypeContext differentiates from other interfaces.
	IsEnumTypeContext()
}

type EnumTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumTypeContext() *EnumTypeContext {
	var p = new(EnumTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_enumType
	return p
}

func InitEmptyEnumTypeContext(p *EnumTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_enumType
}

func (*EnumTypeContext) IsEnumTypeContext() {}

func NewEnumTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumTypeContext {
	var p = new(EnumTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_enumType

	return p
}

func (s *EnumTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumTypeContext) EnumMemberList() IEnumMemberListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumMemberListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumMemberListContext)
}

func (s *EnumTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterEnumType(s)
	}
}

func (s *EnumTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitEnumType(s)
	}
}

func (p *MinZParser) EnumType() (localctx IEnumTypeContext) {
	localctx = NewEnumTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, MinZParserRULE_enumType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1067)
		p.Match(MinZParserT__20)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1068)
		p.Match(MinZParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserIDENTIFIER {
		{
			p.SetState(1069)
			p.EnumMemberList()
		}

	}
	{
		p.SetState(1072)
		p.Match(MinZParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitStructTypeContext is an interface to support dynamic dispatch.
type IBitStructTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BitFieldList() IBitFieldListContext

	// IsBitStructTypeContext differentiates from other interfaces.
	IsBitStructTypeContext()
}

type BitStructTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitStructTypeContext() *BitStructTypeContext {
	var p = new(BitStructTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_bitStructType
	return p
}

func InitEmptyBitStructTypeContext(p *BitStructTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_bitStructType
}

func (*BitStructTypeContext) IsBitStructTypeContext() {}

func NewBitStructTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitStructTypeContext {
	var p = new(BitStructTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_bitStructType

	return p
}

func (s *BitStructTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BitStructTypeContext) BitFieldList() IBitFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitFieldListContext)
}

func (s *BitStructTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitStructTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitStructTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBitStructType(s)
	}
}

func (s *BitStructTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBitStructType(s)
	}
}

func (p *MinZParser) BitStructType() (localctx IBitStructTypeContext) {
	localctx = NewBitStructTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, MinZParserRULE_bitStructType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1074)
		p.Match(MinZParserT__99)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1075)
		p.Match(MinZParserT__18)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1077)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserIDENTIFIER {
		{
			p.SetState(1076)
			p.BitFieldList()
		}

	}
	{
		p.SetState(1079)
		p.Match(MinZParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitFieldListContext is an interface to support dynamic dispatch.
type IBitFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBitField() []IBitFieldContext
	BitField(i int) IBitFieldContext

	// IsBitFieldListContext differentiates from other interfaces.
	IsBitFieldListContext()
}

type BitFieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitFieldListContext() *BitFieldListContext {
	var p = new(BitFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_bitFieldList
	return p
}

func InitEmptyBitFieldListContext(p *BitFieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_bitFieldList
}

func (*BitFieldListContext) IsBitFieldListContext() {}

func NewBitFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitFieldListContext {
	var p = new(BitFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_bitFieldList

	return p
}

func (s *BitFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *BitFieldListContext) AllBitField() []IBitFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBitFieldContext); ok {
			len++
		}
	}

	tst := make([]IBitFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBitFieldContext); ok {
			tst[i] = t.(IBitFieldContext)
			i++
		}
	}

	return tst
}

func (s *BitFieldListContext) BitField(i int) IBitFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitFieldContext)
}

func (s *BitFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitFieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBitFieldList(s)
	}
}

func (s *BitFieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBitFieldList(s)
	}
}

func (p *MinZParser) BitFieldList() (localctx IBitFieldListContext) {
	localctx = NewBitFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, MinZParserRULE_bitFieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1081)
		p.BitField()
	}
	p.SetState(1086)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1082)
				p.Match(MinZParserT__12)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1083)
				p.BitField()
			}

		}
		p.SetState(1088)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1090)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MinZParserT__12 {
		{
			p.SetState(1089)
			p.Match(MinZParserT__12)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitFieldContext is an interface to support dynamic dispatch.
type IBitFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	NUMBER() antlr.TerminalNode

	// IsBitFieldContext differentiates from other interfaces.
	IsBitFieldContext()
}

type BitFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitFieldContext() *BitFieldContext {
	var p = new(BitFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_bitField
	return p
}

func InitEmptyBitFieldContext(p *BitFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_bitField
}

func (*BitFieldContext) IsBitFieldContext() {}

func NewBitFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitFieldContext {
	var p = new(BitFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_bitField

	return p
}

func (s *BitFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *BitFieldContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, 0)
}

func (s *BitFieldContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(MinZParserNUMBER, 0)
}

func (s *BitFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterBitField(s)
	}
}

func (s *BitFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitBitField(s)
	}
}

func (p *MinZParser) BitField() (localctx IBitFieldContext) {
	localctx = NewBitFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, MinZParserRULE_bitField)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1092)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1093)
		p.Match(MinZParserT__14)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1094)
		p.Match(MinZParserNUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeIdentifierContext is an interface to support dynamic dispatch.
type ITypeIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode

	// IsTypeIdentifierContext differentiates from other interfaces.
	IsTypeIdentifierContext()
}

type TypeIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIdentifierContext() *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_typeIdentifier
	return p
}

func InitEmptyTypeIdentifierContext(p *TypeIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_typeIdentifier
}

func (*TypeIdentifierContext) IsTypeIdentifierContext() {}

func NewTypeIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_typeIdentifier

	return p
}

func (s *TypeIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIdentifierContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(MinZParserIDENTIFIER)
}

func (s *TypeIdentifierContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(MinZParserIDENTIFIER, i)
}

func (s *TypeIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitTypeIdentifier(s)
	}
}

func (p *MinZParser) TypeIdentifier() (localctx ITypeIdentifierContext) {
	localctx = NewTypeIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, MinZParserRULE_typeIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1096)
		p.Match(MinZParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MinZParserT__100 {
		{
			p.SetState(1097)
			p.Match(MinZParserT__100)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1098)
			p.Match(MinZParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1103)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorTypeContext is an interface to support dynamic dispatch.
type IErrorTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimitiveType() IPrimitiveTypeContext
	ArrayType() IArrayTypeContext
	PointerType() IPointerTypeContext
	FunctionType() IFunctionTypeContext
	StructType() IStructTypeContext
	EnumType() IEnumTypeContext
	BitStructType() IBitStructTypeContext
	TypeIdentifier() ITypeIdentifierContext

	// IsErrorTypeContext differentiates from other interfaces.
	IsErrorTypeContext()
}

type ErrorTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorTypeContext() *ErrorTypeContext {
	var p = new(ErrorTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_errorType
	return p
}

func InitEmptyErrorTypeContext(p *ErrorTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MinZParserRULE_errorType
}

func (*ErrorTypeContext) IsErrorTypeContext() {}

func NewErrorTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorTypeContext {
	var p = new(ErrorTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MinZParserRULE_errorType

	return p
}

func (s *ErrorTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *ErrorTypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *ErrorTypeContext) PointerType() IPointerTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerTypeContext)
}

func (s *ErrorTypeContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *ErrorTypeContext) StructType() IStructTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructTypeContext)
}

func (s *ErrorTypeContext) EnumType() IEnumTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumTypeContext)
}

func (s *ErrorTypeContext) BitStructType() IBitStructTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitStructTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitStructTypeContext)
}

func (s *ErrorTypeContext) TypeIdentifier() ITypeIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ErrorTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.EnterErrorType(s)
	}
}

func (s *ErrorTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MinZListener); ok {
		listenerT.ExitErrorType(s)
	}
}

func (p *MinZParser) ErrorType() (localctx IErrorTypeContext) {
	localctx = NewErrorTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, MinZParserRULE_errorType)
	p.SetState(1128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MinZParserT__86, MinZParserT__87, MinZParserT__88, MinZParserT__89, MinZParserT__90, MinZParserT__91, MinZParserT__92, MinZParserT__93, MinZParserT__94, MinZParserT__95, MinZParserT__96, MinZParserT__97, MinZParserT__98:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1104)
			p.PrimitiveType()
		}
		{
			p.SetState(1105)
			p.Match(MinZParserT__16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__34:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1107)
			p.ArrayType()
		}
		{
			p.SetState(1108)
			p.Match(MinZParserT__16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__64:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1110)
			p.PointerType()
		}
		{
			p.SetState(1111)
			p.Match(MinZParserT__16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__7:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1113)
			p.FunctionType()
		}
		{
			p.SetState(1114)
			p.Match(MinZParserT__16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__17:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1116)
			p.StructType()
		}
		{
			p.SetState(1117)
			p.Match(MinZParserT__16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__20:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1119)
			p.EnumType()
		}
		{
			p.SetState(1120)
			p.Match(MinZParserT__16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserT__99:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1122)
			p.BitStructType()
		}
		{
			p.SetState(1123)
			p.Match(MinZParserT__16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MinZParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1125)
			p.TypeIdentifier()
		}
		{
			p.SetState(1126)
			p.Match(MinZParserT__16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
