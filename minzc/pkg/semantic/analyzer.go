package semantic

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/minz/minzc/pkg/ast"
	"github.com/minz/minzc/pkg/interpreter"
	"github.com/minz/minzc/pkg/ir"
	"github.com/minz/minzc/pkg/meta"
	"github.com/minz/minzc/pkg/metafunction"
	"github.com/minz/minzc/pkg/parser"
)

var debug = os.Getenv("DEBUG") != ""

// ModuleResolver is an interface for resolving module imports
type ModuleResolver interface {
	ResolveModule(path string) (*ModuleInfo, error)
}

// ModuleInfo contains information about an imported module
type ModuleInfo struct {
	Name    string
	Exports map[string]Symbol
}

// Analyzer performs semantic analysis on the AST
type Analyzer struct {
	currentScope          *Scope
	errors                []error
	module                *ir.Module
	moduleResolver        ModuleResolver
	moduleLoader          *ModuleLoader
	currentFile           string
	currentModule         string // Current module name for prefixing
	luaEvaluator          *meta.LuaEvaluator
	mirInterpreter        *interpreter.MIRInterpreter // MIR interpreter for @minz metaprogramming
	currentFunc           *ir.Function
	generatedDeclarations []ast.Declaration // Declarations generated by @minz blocks
	functionCalls         map[string][]string // Track which functions call which
	exprTypes             map[ast.Expression]ir.Type // Type information for expressions
	lambdaCounter         int // Counter for generating unique lambda names
	registeredModules     map[string]bool // Track already registered modules to prevent duplicates
	metafunctionProcessor *metafunction.Processor // Processor for @metafunction calls
	errorPropagationContext *ErrorPropagationContext // Track error propagation state
	targetBackend         string // Target backend for @target directive
	targetPlatform        string // Target platform (zxspectrum, cpm, etc.)
	// castInterfaces        map[string]*CastInterface // Cast interfaces for compile-time dispatch (future)
	simpleCastInterfaces  map[string]*SimpleCastInterface // Simplified cast interfaces (v0.11.0)
	builtinModules        map[string]*BuiltinModule // Built-in module registry
}

// NewAnalyzer creates a new semantic analyzer
func NewAnalyzer() *Analyzer {
	analyzer := &Analyzer{
		currentScope:      NewScope(nil),
		errors:            []error{},
		module:            ir.NewModule("main"),
		moduleLoader:      NewModuleLoader(),
		functionCalls:     make(map[string][]string),
		exprTypes:         make(map[ast.Expression]ir.Type),
		registeredModules: make(map[string]bool),
		luaEvaluator:      meta.NewLuaEvaluator(),
		mirInterpreter:    interpreter.NewMIRInterpreter(),
		targetBackend:     "z80", // Default backend
		targetPlatform:    "zxspectrum", // Default platform
		// castInterfaces:    make(map[string]*CastInterface), // future
		simpleCastInterfaces: make(map[string]*SimpleCastInterface),
		builtinModules:    InitBuiltinModules(),
	}
	
	return analyzer
}

// SetTargetBackend sets the target backend for @target directive processing
func (a *Analyzer) SetTargetBackend(backend string) {
	a.targetBackend = backend
}

// SetTargetPlatform sets the target platform (zxspectrum, cpm, etc.)
func (a *Analyzer) SetTargetPlatform(platform string) {
	a.targetPlatform = platform
}

// registerPredefinedConstants registers predefined constants like TARGET
func (a *Analyzer) registerPredefinedConstants() {
	// Register TARGET constant with the current platform
	// Convert platform string to a numeric value for ConstSymbol
	// For now, we'll register these as special string constants
	// TODO: Add proper string constant support to ConstSymbol
	
	// For now, skip registering these as constants
	// They can be used with @if directives instead
}

// Analyze performs semantic analysis on a file
func (a *Analyzer) Analyze(file *ast.File) (*ir.Module, error) {
	// Register predefined constants
	a.registerPredefinedConstants()
	
	// PREPROCESSING STEP 1: Expand @define templates (before everything else!)
	templateExpander := NewTemplateExpander()
	expandedFile, err := templateExpander.ExpandTemplates(file)
	if err != nil {
		return nil, fmt.Errorf("template expansion failed: %w", err)
	}
	file = expandedFile
	
	// Set current module name
	if file.ModuleName != "" {
		a.currentModule = file.ModuleName
	} else {
		// Use filename without extension as module name
		a.currentModule = strings.TrimSuffix(filepath.Base(file.Name), filepath.Ext(file.Name))
	}
	
	// Add built-in types and functions
	a.addBuiltins()

	// Process imports
	for _, imp := range file.Imports {
		if err := a.processImport(imp); err != nil {
			a.errors = append(a.errors, err)
		}
	}

	// First pass, phase 1a: Register all type names (without processing fields/members)
	// This allows for self-referential and mutually-referential types
	for _, decl := range file.Declarations {
		switch d := decl.(type) {
		case *ast.StructDecl:
			// Register just the struct name, not the fields yet
			if err := a.registerStructName(d); err != nil {
				a.errors = append(a.errors, err)
			}
		case *ast.EnumDecl:
			// Enums don't have forward reference issues, so we can fully register them
			if err := a.analyzeEnumDecl(d); err != nil {
				a.errors = append(a.errors, err)
			}
		case *ast.InterfaceDecl:
			if err := a.analyzeInterfaceDecl(d); err != nil {
				a.errors = append(a.errors, err)
			}
		}
	}

	// First pass, phase 1b: Now process struct fields and type aliases
	// All type names are now registered, so we can safely resolve field types
	for _, decl := range file.Declarations {
		switch d := decl.(type) {
		case *ast.StructDecl:
			// Now process the struct fields
			if err := a.analyzeStructDecl(d); err != nil {
				a.errors = append(a.errors, err)
			}
		case *ast.TypeDecl:
			// Register type aliases (including bit structs)
			if err := a.analyzeTypeDecl(d); err != nil {
				a.errors = append(a.errors, err)
			}
		case *ast.InterfaceDecl:
			// Interface already processed in first pass
			continue
		}
	}

	// First pass, phase 2: Process @minz blocks and expressions FIRST to generate code
	// MinZ blocks must be processed before everything else since they generate declarations
	for _, decl := range file.Declarations {
		switch d := decl.(type) {
		case *ast.MinzBlock:
			// Process MinZ blocks to generate code
			if err := a.analyzeMinzBlock(d); err != nil {
				a.errors = append(a.errors, err)
			}
		case *ast.ExpressionDecl:
			// Process top-level @minz expressions to generate code
			switch expr := d.Expression.(type) {
			case *ast.CompileTimeMinz:
				if _, err := a.analyzeMinzExpr(expr, nil); err != nil {
					a.errors = append(a.errors, err)
				}
			case *ast.MinzMetafunctionCall:
				if _, err := a.analyzeMinzMetafunctionCall(expr, nil); err != nil {
					a.errors = append(a.errors, err)
				}
			}
		}
	}
	
	// First pass, phase 3: Register function signatures, constants, and global variables
	// Now that all types are registered and @minz blocks have generated code, 
	// we can safely process function signatures
	for _, decl := range file.Declarations {
		switch d := decl.(type) {
		case *ast.FunctionDecl:
			if err := a.registerFunctionSignature(d); err != nil {
				a.errors = append(a.errors, err)
			}
		case *ast.VarDecl:
			// Register global variables early so functions can reference them
			if err := a.analyzeVarDecl(d); err != nil {
				a.errors = append(a.errors, err)
			}
		case *ast.ConstDecl:
			// Register constants early as well
			if err := a.analyzeConstDecl(d); err != nil {
				a.errors = append(a.errors, err)
			}
		case *ast.LuaBlock:
			// Process Lua blocks early so functions defined in them are available
			if err := a.analyzeLuaBlock(d); err != nil {
				a.errors = append(a.errors, err)
			}
		case *ast.MinzBlock:
			// Already processed in phase 2
			continue
		}
	}

	// Second pass: Process all declarations (including generated ones)
	for _, decl := range file.Declarations {
		if err := a.analyzeDeclaration(decl); err != nil {
			a.errors = append(a.errors, err)
		}
	}
	
	// Also process generated declarations from @minz blocks
	for _, decl := range a.generatedDeclarations {
		if err := a.analyzeDeclaration(decl); err != nil {
			a.errors = append(a.errors, err)
		}
	}

	if len(a.errors) > 0 {
		// Build detailed error message
		var errMsg string
		for i, err := range a.errors {
			if i > 0 {
				errMsg += "\n"
			}
			errMsg += fmt.Sprintf("  %d. %v", i+1, err)
		}
		return nil, fmt.Errorf("semantic analysis failed with %d errors:\n%s", len(a.errors), errMsg)
	}

	return a.module, nil
}

// prefixSymbol adds module prefix to a symbol name if needed
func (a *Analyzer) prefixSymbol(name string) string {
	// Don't prefix built-in types
	if name == "u8" || name == "u16" || name == "u24" || name == "i8" || name == "i16" || name == "i24" || name == "bool" || name == "void" || name == "f8.8" || name == "f.8" || name == "f.16" || name == "f16.8" || name == "f8.16" {
		return name
	}
	
	// Check if already prefixed with current module
	if a.currentModule != "" && strings.HasPrefix(name, a.currentModule+".") {
		return name
	}
	
	// Add module prefix
	if a.currentModule != "" && a.currentModule != "main" {
		return a.currentModule + "." + name
	}
	return name
}

// addBuiltins adds built-in types and functions
func (a *Analyzer) addBuiltins() {
	// Built-in types
	a.currentScope.Define("u8", &TypeSymbol{Type: &ir.BasicType{Kind: ir.TypeU8}})
	a.currentScope.Define("u16", &TypeSymbol{Type: &ir.BasicType{Kind: ir.TypeU16}})
	a.currentScope.Define("i8", &TypeSymbol{Type: &ir.BasicType{Kind: ir.TypeI8}})
	a.currentScope.Define("i16", &TypeSymbol{Type: &ir.BasicType{Kind: ir.TypeI16}})
	a.currentScope.Define("bool", &TypeSymbol{Type: &ir.BasicType{Kind: ir.TypeBool}})
	a.currentScope.Define("void", &TypeSymbol{Type: &ir.BasicType{Kind: ir.TypeVoid}})
	
	// Type aliases for C interoperability
	// cstr is a C-style string (pointer to null-terminated u8 array)
	a.currentScope.Define("cstr", &TypeSymbol{Type: &ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}}})
	
	// String types
	a.currentScope.Define("String", &TypeSymbol{Type: &ir.StringType{MaxLength: 255}})
	a.currentScope.Define("LString", &TypeSymbol{Type: &ir.LStringType{MaxLength: 65535}})
	
	// Built-in functions with overloading support
	// print - outputs a single character
	printU8Sym := &FuncSymbol{
		Name: "print$u8",
		Params: []*ast.Parameter{
			{Name: "ch", Type: &ast.PrimitiveType{Name: "u8"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{&ir.BasicType{Kind: ir.TypeU8}}, // char to print
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	}
	a.currentScope.Define("print$u8", printU8Sym)
	
	// Register print overload set
	printOverloadSet := &FunctionOverloadSet{
		BaseName:  "print",
		Overloads: map[string]*FuncSymbol{
			"print$u8": printU8Sym,
		},
	}
	a.currentScope.overloads["print"] = printOverloadSet
	a.currentScope.Define("print", printOverloadSet)
	
	// len - returns length of an array
	// Note: We'll handle type checking specially for len() since it's generic
	a.currentScope.Define("len", &FuncSymbol{
		Name: "len",
		Params: []*ast.Parameter{
			{Name: "arr", Type: &ast.PrimitiveType{Name: "void"}}, // Generic - checked specially
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{
				&ir.BasicType{Kind: ir.TypeVoid}, // Generic parameter
			},
			Return: &ir.BasicType{Kind: ir.TypeU16},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeU16},
		IsBuiltin: true,
	})
	
	// memcpy - copy memory
	a.currentScope.Define("memcpy", &FuncSymbol{
		Name: "memcpy",
		Params: []*ast.Parameter{
			{Name: "dest", Type: &ast.PointerType{BaseType: &ast.PrimitiveType{Name: "u8"}, IsMutable: true}},
			{Name: "src", Type: &ast.PointerType{BaseType: &ast.PrimitiveType{Name: "u8"}}},
			{Name: "size", Type: &ast.PrimitiveType{Name: "u16"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{
				&ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}, IsMutable: true}, // dest
				&ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}}, // src
				&ir.BasicType{Kind: ir.TypeU16}, // size
			},
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// print_u8 - print unsigned 8-bit value as decimal
	a.currentScope.Define("print_u8", &FuncSymbol{
		Name: "print_u8",
		Params: []*ast.Parameter{
			{Name: "value", Type: &ast.PrimitiveType{Name: "u8"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{&ir.BasicType{Kind: ir.TypeU8}},
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// print_u16 - print unsigned 16-bit value as decimal
	a.currentScope.Define("print_u16", &FuncSymbol{
		Name: "print_u16",
		Params: []*ast.Parameter{
			{Name: "value", Type: &ast.PrimitiveType{Name: "u16"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{&ir.BasicType{Kind: ir.TypeU16}},
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// memset - fill memory
	a.currentScope.Define("memset", &FuncSymbol{
		Name: "memset",
		Params: []*ast.Parameter{
			{Name: "dest", Type: &ast.PointerType{BaseType: &ast.PrimitiveType{Name: "u8"}, IsMutable: true}},
			{Name: "value", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "size", Type: &ast.PrimitiveType{Name: "u16"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{
				&ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}, IsMutable: true}, // dest
				&ir.BasicType{Kind: ir.TypeU8},  // value
				&ir.BasicType{Kind: ir.TypeU16}, // size
			},
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// === QUICK WIN STUB FUNCTIONS ===
	// These are the most commonly missing functions that block tests
	
	// print_number - generic number printing (alias for print_u16)
	a.currentScope.Define("print_number", &FuncSymbol{
		Name: "print_number",
		Params: []*ast.Parameter{
			{Name: "value", Type: &ast.PrimitiveType{Name: "u16"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{&ir.BasicType{Kind: ir.TypeU16}},
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// print_char - print a single character (alias for print u8)
	a.currentScope.Define("print_char", &FuncSymbol{
		Name: "print_char",
		Params: []*ast.Parameter{
			{Name: "ch", Type: &ast.PrimitiveType{Name: "u8"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{&ir.BasicType{Kind: ir.TypeU8}},
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// set_pixel - draw a pixel at x,y with color
	a.currentScope.Define("set_pixel", &FuncSymbol{
		Name: "set_pixel",
		Params: []*ast.Parameter{
			{Name: "x", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "y", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "color", Type: &ast.PrimitiveType{Name: "u8"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{
				&ir.BasicType{Kind: ir.TypeU8}, // x
				&ir.BasicType{Kind: ir.TypeU8}, // y
				&ir.BasicType{Kind: ir.TypeU8}, // color
			},
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// draw_sprite - draw a sprite at position
	a.currentScope.Define("draw_sprite", &FuncSymbol{
		Name: "draw_sprite",
		Params: []*ast.Parameter{
			{Name: "sprite", Type: &ast.PointerType{BaseType: &ast.PrimitiveType{Name: "u8"}}},
			{Name: "x", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "y", Type: &ast.PrimitiveType{Name: "u8"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{
				&ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}}, // sprite data
				&ir.BasicType{Kind: ir.TypeU8}, // x
				&ir.BasicType{Kind: ir.TypeU8}, // y
			},
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// rom_print_char - ROM routine for printing (stub)
	a.currentScope.Define("rom_print_char", &FuncSymbol{
		Name: "rom_print_char",
		Params: []*ast.Parameter{
			{Name: "ch", Type: &ast.PrimitiveType{Name: "u8"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{&ir.BasicType{Kind: ir.TypeU8}},
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// inc_and_return - increment and return value
	a.currentScope.Define("inc_and_return", &FuncSymbol{
		Name: "inc_and_return",
		Params: []*ast.Parameter{
			{Name: "value", Type: &ast.PrimitiveType{Name: "u8"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{&ir.BasicType{Kind: ir.TypeU8}},
			Return: &ir.BasicType{Kind: ir.TypeU8},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeU8},
		IsBuiltin: true,
	})
	
	// cls - clear screen
	a.currentScope.Define("cls", &FuncSymbol{
		Name: "cls",
		Params: []*ast.Parameter{},
		Type: &ir.FunctionType{
			Params: []ir.Type{},
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// hex - convert u8 to hex string
	a.currentScope.Define("hex", &FuncSymbol{
		Name: "hex",
		Params: []*ast.Parameter{
			{Name: "value", Type: &ast.PrimitiveType{Name: "u8"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{&ir.BasicType{Kind: ir.TypeU8}},
			Return: &ir.BasicType{Kind: ir.TypeVoid}, // Returns void for now (prints directly)
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// pad - pad a value to width
	a.currentScope.Define("pad", &FuncSymbol{
		Name: "pad",
		Params: []*ast.Parameter{
			{Name: "value", Type: &ast.PrimitiveType{Name: "u16"}},
			{Name: "width", Type: &ast.PrimitiveType{Name: "u8"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{&ir.BasicType{Kind: ir.TypeU16}, &ir.BasicType{Kind: ir.TypeU8}},
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// ln - print newline
	a.currentScope.Define("ln", &FuncSymbol{
		Name: "ln",
		Params: []*ast.Parameter{},
		Type: &ir.FunctionType{
			Params: []ir.Type{},
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// set_ink - set ink color (ZX Spectrum)
	a.currentScope.Define("set_ink", &FuncSymbol{
		Name: "set_ink",
		Params: []*ast.Parameter{
			{Name: "color", Type: &ast.PrimitiveType{Name: "u8"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{&ir.BasicType{Kind: ir.TypeU8}},
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// memcpy - copy memory
	a.currentScope.Define("memcpy", &FuncSymbol{
		Name: "memcpy",
		Params: []*ast.Parameter{
			{Name: "dest", Type: &ast.PointerType{BaseType: &ast.PrimitiveType{Name: "u8"}}},
			{Name: "src", Type: &ast.PointerType{BaseType: &ast.PrimitiveType{Name: "u8"}}},
			{Name: "size", Type: &ast.PrimitiveType{Name: "u16"}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{
				&ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}},
				&ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}},
				&ir.BasicType{Kind: ir.TypeU16},
			},
			Return: &ir.BasicType{Kind: ir.TypeVoid},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		IsBuiltin: true,
	})
	
	// strlen - get string length
	a.currentScope.Define("strlen", &FuncSymbol{
		Name: "strlen",
		Params: []*ast.Parameter{
			{Name: "str", Type: &ast.PointerType{BaseType: &ast.PrimitiveType{Name: "u8"}}},
		},
		Type: &ir.FunctionType{
			Params: []ir.Type{&ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}}},
			Return: &ir.BasicType{Kind: ir.TypeU16},
		},
		ReturnType: &ir.BasicType{Kind: ir.TypeU16},
		IsBuiltin: true,
	})
}

// processImport processes an import statement
func (a *Analyzer) processImport(imp *ast.ImportStmt) error {
	moduleName := imp.Path
	
	// Check if module is already loaded
	if a.registeredModules[moduleName] {
		// Module already loaded - no need to do anything for duplicate imports
		return nil
	}
	
	// First check built-in modules
	if builtinModule, ok := a.builtinModules[moduleName]; ok {
		// Register the built-in module
		if err := a.RegisterModule(builtinModule, imp.Alias); err != nil {
			return fmt.Errorf("failed to register module %s: %w", moduleName, err)
		}
		a.registeredModules[moduleName] = true
		return nil
	}
	
	// Handle legacy module names for compatibility
	legacyMap := map[string]string{
		"screen": "zx.screen",
		"input":  "zx.input",
		"io":     "zx.io",
		"sound":  "zx.sound",
	}
	
	if mappedName, ok := legacyMap[moduleName]; ok {
		if builtinModule, ok := a.builtinModules[mappedName]; ok {
			if err := a.RegisterModule(builtinModule, imp.Alias); err != nil {
				return fmt.Errorf("failed to register module %s: %w", mappedName, err)
			}
			a.registeredModules[mappedName] = true
			return nil
		}
	}
	
	// Try to load the module from file
	loadedModule, err := a.moduleLoader.LoadModule(moduleName)
	if err != nil {
		// Fall back to old hardcoded modules for backward compatibility
		if moduleName == "zx.screen" || moduleName == "screen" {
			// Check if screen module is already registered
			if !a.registeredModules["zx.screen"] {
				a.registerScreenModule()
				a.registeredModules["zx.screen"] = true
			}
			// Now register the alias if needed
			if imp.Alias != "" && imp.Alias != "zx.screen" {
				a.registerModuleAlias("zx.screen", imp.Alias)
			}
			return nil
		} else if moduleName == "zx.input" || moduleName == "input" {
			if !a.registeredModules["zx.input"] {
				a.registerInputModule()
				a.registeredModules["zx.input"] = true
			}
			if imp.Alias != "" && imp.Alias != "zx.input" {
				a.registerModuleAlias("zx.input", imp.Alias)
			}
			return nil
		} else if moduleName == "zx.io" || moduleName == "io" {
			if !a.registeredModules["zx.io"] {
				a.registerIOModule()
				a.registeredModules["zx.io"] = true
			}
			if imp.Alias != "" && imp.Alias != "zx.io" {
				a.registerModuleAlias("zx.io", imp.Alias)
			}
			return nil
		}
		return fmt.Errorf("failed to load module %s: %w", moduleName, err)
	}
	
	// Process the loaded module
	if err := a.processLoadedModule(loadedModule, imp); err != nil {
		return fmt.Errorf("failed to process module %s: %w", moduleName, err)
	}
	
	// Mark module as registered
	a.registeredModules[moduleName] = true
	
	return nil
}

// registerModuleAlias creates alias symbols for an already registered module
func (a *Analyzer) registerModuleAlias(originalModule, alias string) {
	// Register the module alias itself
	a.currentScope.Define(alias, &ModuleSymbol{
		Name: alias,
	})
	
	// Find all symbols that start with the original module prefix and create aliases
	aliasCount := 0
	for name, symbol := range a.currentScope.symbols {
		if strings.HasPrefix(name, originalModule+".") {
			// Extract the function/symbol name after the module prefix
			symbolName := strings.TrimPrefix(name, originalModule+".")
			aliasName := alias + "." + symbolName
			
			// Create an alias symbol pointing to the original
			a.currentScope.Define(aliasName, symbol)
			aliasCount++
			
			if os.Getenv("DEBUG") != "" {
				fmt.Printf("DEBUG: Created alias %s -> %s\n", aliasName, name)
			}
		}
	}
	
	// Debug: if no aliases created, something is wrong
	if aliasCount == 0 {
		fmt.Printf("Warning: No symbols found with prefix '%s.' to alias to '%s.'\n", originalModule, alias)
		fmt.Printf("Available symbols: ")
		count := 0
		for name := range a.currentScope.symbols {
			if count < 20 {  // Limit output
				fmt.Printf("%s ", name)
				count++
			}
		}
		if count >= 20 {
			fmt.Printf("... (and %d more)", len(a.currentScope.symbols)-20)
		}
		fmt.Printf("\n")
	} else if os.Getenv("DEBUG") != "" {
		fmt.Printf("DEBUG: Created %d aliases from %s to %s\n", aliasCount, originalModule, alias)
	}
}

// processLoadedModule analyzes a loaded module and registers its exports
func (a *Analyzer) processLoadedModule(module *LoadedModule, imp *ast.ImportStmt) error {
	// Always use the full path as the primary module prefix
	modulePrefix := imp.Path
	
	// Register the module itself
	a.currentScope.Define(modulePrefix, &ModuleSymbol{
		Name: modulePrefix,
	})
	
	// If an alias is specified, also register the alias
	if imp.Alias != "" {
		a.currentScope.Define(imp.Alias, &ModuleSymbol{
			Name: imp.Alias,
		})
	}
	
	// Save current module context
	prevModule := a.currentModule
	// Set current module to the prefix being used for symbols
	a.currentModule = modulePrefix
	defer func() { a.currentModule = prevModule }()
	
	// First pass: register all exported symbols
	for _, item := range module.File.Declarations {
		switch decl := item.(type) {
		case *ast.FunctionDecl:
			if decl.IsPublic || decl.IsExport {
				// Register exported function
				fnName := modulePrefix + "." + decl.Name
				returnType, err := a.convertType(decl.ReturnType)
				if err != nil {
					return fmt.Errorf("invalid return type for function %s: %w", decl.Name, err)
				}
				
				// Convert parameters to get proper type information
				var paramTypes []ir.Type
				for _, param := range decl.Params {
					paramType, err := a.convertType(param.Type)
					if err != nil {
						return fmt.Errorf("invalid parameter type for function %s: %w", decl.Name, err)
					}
					paramTypes = append(paramTypes, paramType)
				}
				
				funcSym := &FuncSymbol{
					Name:       fnName,
					ReturnType: returnType,
					Params:     decl.Params,
					Type: &ir.FunctionType{
						Params: paramTypes,
						Return: returnType,
					},
				}
				
				// Register with unmangled name for module access
				a.currentScope.Define(fnName, funcSym)
				
				// Also register with mangled name for overloading support
				mangledName := generateMangledNameFromTypes(fnName, paramTypes)
				a.currentScope.Define(mangledName, funcSym)
			}
		case *ast.ConstDecl:
			if decl.IsPublic {
				// Register exported constant
				constName := modulePrefix + "." + decl.Name
				constType, err := a.convertType(decl.Type)
				if err != nil {
					return fmt.Errorf("invalid type for constant %s: %w", decl.Name, err)
				}
				
				// For now, we can't evaluate the value without full analysis
				// So we'll just register the type
				a.currentScope.Define(constName, &ConstSymbol{
					Name: constName,
					Type: constType,
				})
			}
		case *ast.VarDecl:
			if decl.IsPublic {
				// Register exported variable
				varName := modulePrefix + "." + decl.Name
				varType, err := a.convertType(decl.Type)
				if err != nil {
					return fmt.Errorf("invalid type for variable %s: %w", decl.Name, err)
				}
				
				a.currentScope.Define(varName, &VarSymbol{
					Name: varName,
					Type: varType,
				})
			}
		}
	}
	
	// If an alias was specified, create alias symbols for all exported items
	if imp.Alias != "" {
		a.registerModuleAlias(imp.Path, imp.Alias)
	}
	
	// Second pass: analyze all module declarations (constants, types, etc.)
	// This ensures that module functions can reference module-level symbols
	for _, decl := range module.File.Declarations {
		switch d := decl.(type) {
		case *ast.ConstDecl:
			// Analyze all constants (not just public ones) so functions can use them
			if err := a.analyzeConstDecl(d); err != nil {
				// Log warning but continue
				fmt.Printf("Warning: failed to analyze constant %s: %v\n", d.Name, err)
			}
		case *ast.VarDecl:
			// Analyze all variables
			if err := a.analyzeVarDecl(d); err != nil {
				// Log warning but continue
				fmt.Printf("Warning: failed to analyze variable %s: %v\n", d.Name, err)
			}
		case *ast.StructDecl:
			// Analyze struct types
			if err := a.analyzeStructDecl(d); err != nil {
				// Log warning but continue
				fmt.Printf("Warning: failed to analyze struct %s: %v\n", d.Name, err)
			}
		case *ast.FunctionDecl:
			// Analyze function declarations (to generate code for them)
			if d.IsPublic || d.IsExport {
				// Temporarily adjust the function name to include module prefix
				originalName := d.Name
				d.Name = modulePrefix + "." + d.Name
				
				if err := a.analyzeFunctionDecl(d); err != nil {
					// Log warning but continue
					fmt.Printf("Warning: failed to analyze function %s: %v\n", d.Name, err)
				}
				
				// Restore original name
				d.Name = originalName
			}
		case *ast.EnumDecl:
			// Analyze enum types
			if err := a.analyzeEnumDecl(d); err != nil {
				// Log warning but continue
				fmt.Printf("Warning: failed to analyze enum %s: %v\n", d.Name, err)
			}
		}
	}
	
	// Third pass: analyze exported functions to generate IR
	for _, item := range module.File.Declarations {
		switch decl := item.(type) {
		case *ast.FunctionDecl:
			if decl.IsPublic || decl.IsExport {
				// Register the function in the symbol table first
				fnSym := a.currentScope.Lookup(modulePrefix + "." + decl.Name)
				if fnSym == nil {
					fmt.Printf("Warning: function %s.%s not found in symbol table\n", modulePrefix, decl.Name)
					continue
				}
				
				// Create a copy of the function decl with prefixed name
				// This ensures the IR function has the correct qualified name
				prefixedDecl := *decl
				prefixedDecl.Name = modulePrefix + "." + decl.Name
				
				// Analyze the function to generate IR
				if err := a.analyzeFunctionDecl(&prefixedDecl); err != nil {
					// Skip functions that fail to analyze (e.g., due to inline assembly)
					// but still allow the module to load
					fmt.Printf("Warning: skipping function %s due to analysis error: %v\n", decl.Name, err)
					continue
				}
			}
		}
	}
	
	return nil
}

// registerScreenModule registers screen module functions
func (a *Analyzer) registerScreenModule() {
	// Register screen as a module
	a.currentScope.Define("screen", &ModuleSymbol{
		Name: "screen",
	})
	
	// Register color constants
	a.currentScope.Define("screen.BLACK", &ConstSymbol{
		Name:  "screen.BLACK",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 0,
	})
	a.currentScope.Define("screen.BLUE", &ConstSymbol{
		Name:  "screen.BLUE",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 1,
	})
	a.currentScope.Define("screen.RED", &ConstSymbol{
		Name:  "screen.RED",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 2,
	})
	a.currentScope.Define("screen.MAGENTA", &ConstSymbol{
		Name:  "screen.MAGENTA",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 3,
	})
	a.currentScope.Define("screen.GREEN", &ConstSymbol{
		Name:  "screen.GREEN",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 4,
	})
	a.currentScope.Define("screen.CYAN", &ConstSymbol{
		Name:  "screen.CYAN",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 5,
	})
	a.currentScope.Define("screen.YELLOW", &ConstSymbol{
		Name:  "screen.YELLOW",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 6,
	})
	a.currentScope.Define("screen.WHITE", &ConstSymbol{
		Name:  "screen.WHITE",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 7,
	})
	a.currentScope.Define("screen.BRIGHT", &ConstSymbol{
		Name:  "screen.BRIGHT",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 0x40,
	})
	a.currentScope.Define("screen.FLASH", &ConstSymbol{
		Name:  "screen.FLASH",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 0x80,
	})
	
	// Register functions
	a.currentScope.Define("screen.set_pixel", &FuncSymbol{
		Name:       "screen.set_pixel",
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		Params: []*ast.Parameter{
			{Name: "x", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "y", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "color", Type: &ast.PrimitiveType{Name: "u8"}},
		},
	})
	
	a.currentScope.Define("screen.clear_pixel", &FuncSymbol{
		Name:       "screen.clear_pixel",
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		Params: []*ast.Parameter{
			{Name: "x", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "y", Type: &ast.PrimitiveType{Name: "u8"}},
		},
	})
	
	a.currentScope.Define("screen.attr_addr", &FuncSymbol{
		Name:       "screen.attr_addr",
		ReturnType: &ir.BasicType{Kind: ir.TypeU16},
		Params: []*ast.Parameter{
			{Name: "x", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "y", Type: &ast.PrimitiveType{Name: "u8"}},
		},
	})
	
	a.currentScope.Define("screen.set_attributes", &FuncSymbol{
		Name:       "screen.set_attributes",
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		Params: []*ast.Parameter{
			{Name: "x", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "y", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "ink", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "paper", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "bright", Type: &ast.PrimitiveType{Name: "bool"}},
			{Name: "flash", Type: &ast.PrimitiveType{Name: "bool"}},
		},
	})
	
	a.currentScope.Define("screen.set_border", &FuncSymbol{
		Name:       "screen.set_border",
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		Params: []*ast.Parameter{
			{Name: "color", Type: &ast.PrimitiveType{Name: "u8"}},
		},
	})
	
	a.currentScope.Define("screen.clear", &FuncSymbol{
		Name:       "screen.clear",
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		Params: []*ast.Parameter{
			{Name: "ink", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "paper", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "bright", Type: &ast.PrimitiveType{Name: "bool"}},
			{Name: "flash", Type: &ast.PrimitiveType{Name: "bool"}},
		},
	})
	
	a.currentScope.Define("screen.draw_rect", &FuncSymbol{
		Name:       "screen.draw_rect",
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		Params: []*ast.Parameter{
			{Name: "x", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "y", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "width", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "height", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "color", Type: &ast.PrimitiveType{Name: "u8"}},
			{Name: "fill", Type: &ast.PrimitiveType{Name: "bool"}},
		},
	})
}

// registerInputModule registers input module functions
func (a *Analyzer) registerInputModule() {
	// Register input as a module
	a.currentScope.Define("input", &ModuleSymbol{
		Name: "input",
	})
	
	// Register key constants
	a.currentScope.Define("input.KEY_Q", &ConstSymbol{
		Name:  "input.KEY_Q",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 10,  // From input.minz
	})
	a.currentScope.Define("input.KEY_A", &ConstSymbol{
		Name:  "input.KEY_A",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 5,   // From input.minz
	})
	a.currentScope.Define("input.KEY_O", &ConstSymbol{
		Name:  "input.KEY_O",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 26,  // From input.minz
	})
	a.currentScope.Define("input.KEY_P", &ConstSymbol{
		Name:  "input.KEY_P",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 25,  // From input.minz
	})
	a.currentScope.Define("input.KEY_SPACE", &ConstSymbol{
		Name:  "input.KEY_SPACE",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 30,  // From input.minz (KEY_SPC)
	})
	a.currentScope.Define("input.KEY_C", &ConstSymbol{
		Name:  "input.KEY_C",
		Type:  &ir.BasicType{Kind: ir.TypeU8},
		Value: 3,   // From input.minz
	})
	
	// Register input functions with module prefix
	a.currentScope.Define("input.read_key", &FuncSymbol{
		Name:       "input.read_key",
		ReturnType: &ir.BasicType{Kind: ir.TypeU8},
		Params:     []*ast.Parameter{}, // No parameters
	})
	
	a.currentScope.Define("input.key_pressed", &FuncSymbol{
		Name:       "input.key_pressed",
		ReturnType: &ir.BasicType{Kind: ir.TypeBool},
		Params: []*ast.Parameter{
			{Name: "key_code", Type: &ast.PrimitiveType{Name: "u8"}},
		},
	})
	
	a.currentScope.Define("input.is_key_pressed", &FuncSymbol{
		Name:       "input.is_key_pressed",
		ReturnType: &ir.BasicType{Kind: ir.TypeBool},
		Params: []*ast.Parameter{
			{Name: "key_code", Type: &ast.PrimitiveType{Name: "u8"}},
		},
	})
}

// registerIOModule registers I/O module functions
func (a *Analyzer) registerIOModule() {
	// Register io as a module
	a.currentScope.Define("io", &ModuleSymbol{
		Name: "io",
	})
	
	// print_char - prints a single character using RST 16
	a.currentScope.Define("io.print_char", &FuncSymbol{
		Name:       "io.print_char",
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		Params: []*ast.Parameter{
			{Name: "ch", Type: &ast.PrimitiveType{Name: "u8"}},
		},
	})
	
	// print_u8 - prints an unsigned 8-bit number
	a.currentScope.Define("io.print_u8", &FuncSymbol{
		Name:       "io.print_u8",
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		Params: []*ast.Parameter{
			{Name: "value", Type: &ast.PrimitiveType{Name: "u8"}},
		},
	})
	
	// print_u16 - prints an unsigned 16-bit number
	a.currentScope.Define("io.print_u16", &FuncSymbol{
		Name:       "io.print_u16",
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		Params: []*ast.Parameter{
			{Name: "value", Type: &ast.PrimitiveType{Name: "u16"}},
		},
	})
	
	// print_str - prints a string
	a.currentScope.Define("io.print_str", &FuncSymbol{
		Name:       "io.print_str",
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		Params: []*ast.Parameter{
			{Name: "str", Type: &ast.PointerType{BaseType: &ast.PrimitiveType{Name: "u8"}}},
		},
	})
	
	// print - generic print function (overloaded based on type)
	a.currentScope.Define("io.print", &FuncSymbol{
		Name:       "io.print",
		ReturnType: &ir.BasicType{Kind: ir.TypeVoid},
		Params: []*ast.Parameter{
			{Name: "value", Type: &ast.PrimitiveType{Name: "u8"}}, // Will be type-checked based on actual argument
		},
	})
}

// analyzeDeclaration analyzes a declaration
func (a *Analyzer) analyzeDeclaration(decl ast.Declaration) error {
	switch d := decl.(type) {
	case *ast.FunctionDecl:
		return a.analyzeFunctionDecl(d)
	case *ast.VarDecl:
		// Already processed in first pass
		return nil
	case *ast.ConstDecl:
		// Already processed in first pass
		return nil
	case *ast.StructDecl:
		// Already processed in first pass
		return nil
	case *ast.EnumDecl:
		// Already processed in first pass
		return nil
	case *ast.TypeDecl:
		// Already processed in first pass
		return nil
	case *ast.LuaBlock:
		// Already processed in first pass
		return nil
	case *ast.InterfaceDecl:
		// Already processed in first pass
		return nil
	case *ast.ImplBlock:
		// Process implementation blocks
		return a.analyzeImplBlock(d)
	case *ast.MinzBlock:
		// Process @minz[[[]]] blocks
		return a.analyzeMinzBlock(d)
	case *ast.MIRBlock:
		// Process @mir[[[]]] blocks
		return a.analyzeMIRBlock(d)
	case *ast.ExpressionDecl:
		// Already processed in first pass for @minz
		return nil
	case *ast.DefineTemplate:
		// Templates are already expanded in preprocessing - skip
		return nil
	case *ast.MetaExecutionBlock:
		// Process @lang[[[]]] blocks
		return a.analyzeMetaExecutionBlock(d)
	default:
		return fmt.Errorf("unsupported declaration type: %T", decl)
	}
}

// registerFunctionSignature registers a function's signature in the symbol table
// This is called in the first pass to allow forward references
func (a *Analyzer) registerFunctionSignature(fn *ast.FunctionDecl) error {
	// Convert return type
	returnType, err := a.convertType(fn.ReturnType)
	if err != nil {
		return fmt.Errorf("invalid return type for function %s: %w", fn.Name, err)
	}

	// Convert error type if present
	var errorType ir.Type
	if fn.ErrorType != nil {
		errorType, err = a.convertType(fn.ErrorType)
		if err != nil {
			return fmt.Errorf("invalid error type for function %s: %w", fn.Name, err)
		}
	}

	// Get prefixed name for the base function name
	prefixedName := fn.Name
	// Only add prefix if the name doesn't already contain a dot (module prefix)
	if !strings.Contains(fn.Name, ".") {
		prefixedName = a.prefixSymbol(fn.Name)
	}
	
	// Generate mangled name for overloading
	mangledName := generateMangledName(prefixedName, fn.Params)
	// fmt.Printf("DEBUG: registerFunctionSignature: %s -> %s\n", fn.Name, mangledName)
	
	// Convert parameter types
	paramTypes := make([]ir.Type, len(fn.Params))
	for i, param := range fn.Params {
		paramType, err := a.convertType(param.Type)
		if err != nil {
			// If conversion fails, use a placeholder but continue
			paramTypes[i] = &ir.BasicType{Kind: ir.TypeU8}
		} else {
			paramTypes[i] = paramType
		}
	}

	// Create function symbol
	funcSym := &FuncSymbol{
		Name:       mangledName,  // Use mangled name for unique identification
		ReturnType: returnType,
		ErrorType:  errorType,
		Params:     fn.Params,
		ParamTypes: paramTypes,
	}
	
	// Register the specific overload with its mangled name
	a.currentScope.Define(mangledName, funcSym)
	
	// Register in overload set
	overloadSet, exists := a.currentScope.overloads[prefixedName]
	if !exists {
		overloadSet = &FunctionOverloadSet{
			BaseName:  prefixedName,
			Overloads: make(map[string]*FuncSymbol),
		}
		a.currentScope.overloads[prefixedName] = overloadSet
		// Only register the overload set as a symbol if it's different from the mangled name
		// This prevents overwriting single functions that have no overloads
		if prefixedName != mangledName {
			a.currentScope.Define(prefixedName, overloadSet)
		}
	}
	overloadSet.Overloads[mangledName] = funcSym
	
	// Also register without prefix for local access
	if a.currentModule != "" && a.currentModule != "main" {
		// Register the overload set under the unprefixed name too
		unprefixedOverloadSet, exists := a.currentScope.overloads[fn.Name]
		if !exists {
			unprefixedOverloadSet = &FunctionOverloadSet{
				BaseName:  fn.Name,
				Overloads: make(map[string]*FuncSymbol),
			}
			a.currentScope.overloads[fn.Name] = unprefixedOverloadSet
			// Only define if different from mangled name
			if fn.Name != mangledName {
				a.currentScope.Define(fn.Name, unprefixedOverloadSet)
			}
		}
		unprefixedOverloadSet.Overloads[mangledName] = funcSym
	}

	return nil
}

// analyzeFunctionDecl analyzes a function declaration
func (a *Analyzer) analyzeFunctionDecl(fn *ast.FunctionDecl) error {
	// Get prefixed name
	prefixedName := fn.Name
	// Only add prefix if the name doesn't already contain a dot (module prefix)
	if !strings.Contains(fn.Name, ".") {
		prefixedName = a.prefixSymbol(fn.Name)
	}
	
	// Generate mangled name for this specific overload
	mangledName := generateMangledName(prefixedName, fn.Params)
	
	// Get the registered symbol by its mangled name
	sym := a.currentScope.Lookup(mangledName)
	if sym == nil {
		return fmt.Errorf("function %s (mangled: %s) not found in symbol table", fn.Name, mangledName)
	}
	funcSym, ok := sym.(*FuncSymbol)
	if !ok {
		// fmt.Printf("DEBUG: Symbol %s is %T, not FuncSymbol\n", mangledName, sym)
		return fmt.Errorf("symbol %s is not a function", mangledName)
	}
	
	// Create IR function with mangled name for unique identification
	irFunc := ir.NewFunction(mangledName, funcSym.ReturnType)
	
	// Process @abi attributes
	if err := a.processAbiAttributes(fn, irFunc); err != nil {
		return fmt.Errorf("error processing @abi attributes for %s: %v", fn.Name, err)
	}
	
	// Default to SMC unless overridden by attributes
	if irFunc.CallingConvention == "" {
		irFunc.IsSMCDefault = true
		irFunc.SMCParamOffsets = make(map[string]int)
	}
	
	// Debug: confirm SMC is enabled
	// fmt.Printf("DEBUG: After setting SMC for %s: IsSMCDefault=%v, IsSMCEnabled=%v, ptr=%p\n", fn.Name, irFunc.IsSMCDefault, irFunc.IsSMCEnabled, irFunc)
	
	// Allocate SMC parameter slots
	offset := 1 // Start after opcode
	for _, param := range fn.Params {
		// Get parameter type
		paramType, err := a.convertType(param.Type)
		if err != nil {
			// Default to u16 if type conversion fails
			paramType = &ir.BasicType{Kind: ir.TypeU16}
		}
		
		irFunc.SMCParamOffsets[param.Name] = offset
		
		// Calculate next offset based on parameter size
		if paramType.Size() == 1 {
			offset += 2 // LD A, #xx (2 bytes)
		} else {
			offset += 3 // LD HL, #xxxx (3 bytes)
		}
	}
	
	// Set current function for tracking
	prevFunc := a.currentFunc
	a.currentFunc = irFunc
	defer func() { a.currentFunc = prevFunc }()

	// Enter new scope for function
	a.currentScope = NewScope(a.currentScope)
	defer func() { a.currentScope = a.currentScope.parent }()

	// Bind function to its own scope for recursion
	// This allows the function to call itself within its body
	a.currentScope.Define(fn.Name, funcSym)

	// Process parameters
	for _, param := range fn.Params {
		paramType, err := a.convertType(param.Type)
		if err != nil {
			return fmt.Errorf("invalid parameter type for %s: %w", param.Name, err)
		}

		reg := irFunc.AddParam(param.Name, paramType)
		
		// Handle 'self' parameter specially - it's always the receiver
		paramName := param.Name
		if paramName == "self" {
			// 'self' is a valid parameter name for methods
			// It represents the receiver of the method
		}
		
		a.currentScope.Define(paramName, &VarSymbol{
			Name:        paramName,
			Type:        paramType,
			Reg:         reg,
			IsParameter: true,
			IsMutable:   true, // Parameters are mutable for TSMC references
		})
	}

	// Analyze function body
	if err := a.analyzeBlock(fn.Body, irFunc); err != nil {
		return fmt.Errorf("error in function %s: %w", fn.Name, err)
	}

	// Add implicit return if needed
	if len(irFunc.Instructions) == 0 || irFunc.Instructions[len(irFunc.Instructions)-1].Op != ir.OpReturn {
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{Op: ir.OpReturn})
	}

	// Finalize SMC decision based on function properties
	// ONLY if no explicit @abi attribute was set
	if irFunc.CallingConvention == "" {
		if irFunc.IsRecursive && len(irFunc.Params) > 3 {
			// Recursive functions with many parameters should use stack
			// (too much overhead to save/restore many SMC parameters)
			irFunc.IsSMCDefault = false
			irFunc.IsSMCEnabled = false
		} else if len(irFunc.Locals) > 6 {
			// Functions with many locals should use stack
			irFunc.IsSMCDefault = false
			irFunc.IsSMCEnabled = false
		} else if !irFunc.IsRecursive && len(irFunc.Params) > 4 {
			// Non-recursive functions with many parameters should use register passing
			// to avoid excessive SMC overhead
			irFunc.IsSMCDefault = false
			irFunc.IsSMCEnabled = false
		}
	}
	// Otherwise keep SMC (including for recursive functions with few parameters)

	// Debug output
	// Update parameter TSMC flags based on final SMC decision
	if irFunc.IsSMCEnabled {
		for i := range irFunc.Params {
			if _, isPtr := irFunc.Params[i].Type.(*ir.PointerType); isPtr {
				irFunc.Params[i].IsTSMCRef = true
			}
		}
	}
	
	if debug {
		fmt.Printf("Function %s (original: %s): IsRecursive=%v, Params=%d, SMC=%v\n", 
			mangledName, fn.Name, irFunc.IsRecursive, len(irFunc.Params), irFunc.IsSMCEnabled)
	}
	// fmt.Printf("  IR Function Name: %s\n", irFunc.Name)

	// Add function to module
	a.module.AddFunction(irFunc)
	
	// fmt.Printf("DEBUG: Before adding to module %s: IsSMCDefault=%v, IsSMCEnabled=%v, ptr=%p\n", fn.Name, irFunc.IsSMCDefault, irFunc.IsSMCEnabled, irFunc)

	return nil
}

// analyzeVarDecl analyzes a variable declaration
func (a *Analyzer) analyzeVarDecl(v *ast.VarDecl) error {
	// Determine type
	var varType ir.Type
	var inferredType ir.Type
	
	// Get the declared type if present
	if v.Type != nil {
		t, err := a.convertType(v.Type)
		if err != nil {
			return fmt.Errorf("invalid type for variable %s: %w", v.Name, err)
		}
		varType = t
	}
	
	// Get the inferred type from value if present
	if v.Value != nil {
		t, err := a.inferType(v.Value)
		if err != nil {
			// If we have an explicit type, use it even if inference fails
			if varType == nil {
				return fmt.Errorf("cannot infer type for variable %s: %w", v.Name, err)
			}
			// Otherwise, we'll use the explicit type
		} else {
			inferredType = t
		}
	}
	
	// Determine final type and check compatibility
	if varType != nil && inferredType != nil {
		// Both type annotation and initializer present - check compatibility
		if !a.typesCompatible(varType, inferredType) {
			return fmt.Errorf("type mismatch for variable %s: declared type %s but initializer has type %s", 
				v.Name, varType.String(), inferredType.String())
		}
		// Use the declared type
	} else if varType != nil {
		// Only type annotation, no initializer
	} else if inferredType != nil {
		// Only initializer, use inferred type
		varType = inferredType
	} else {
		return fmt.Errorf("variable %s must have either a type or an initial value", v.Name)
	}

	// Register variable with module prefix
	prefixedName := a.prefixSymbol(v.Name)
	varSymbol := &VarSymbol{
		Name:      prefixedName,
		Type:      varType,
		IsMutable: v.IsMutable,
	}
	a.currentScope.Define(prefixedName, varSymbol)
	
	// IMPORTANT: Also define without prefix for access within the same module
	// This allows code in the same module to use the unprefixed name
	if prefixedName != v.Name && a.currentModule != "" {
		// Create an alias symbol that points to the same variable
		a.currentScope.Define(v.Name, &VarSymbol{
			Name:      prefixedName,  // Point to the prefixed name in IR
			Type:      varType,
			IsMutable: v.IsMutable,
		})
	}

	// Add global variable to IR module
	// Create IR global variable
	global := ir.Global{
		Name: prefixedName,
		Type: varType,
	}
	
	// If there's an initializer, evaluate it
	if v.Value != nil {
		// Try to evaluate the initializer as a constant
		if val, err := a.evaluateConstExpr(v.Value); err == nil {
			global.Init = val
		} else {
			// For non-constant initializers, store the AST expression
			global.Value = v.Value
		}
	}
	
	// Add to module globals
	a.module.Globals = append(a.module.Globals, global)

	return nil
}

// analyzeConstDecl analyzes a constant declaration
func (a *Analyzer) analyzeConstDecl(c *ast.ConstDecl) error {
	// Constants must have a value
	if c.Value == nil {
		return fmt.Errorf("constant %s must have a value", c.Name)
	}
	
	// Determine type
	var constType ir.Type
	var inferredType ir.Type
	
	// Get the declared type if present
	if c.Type != nil {
		t, err := a.convertType(c.Type)
		if err != nil {
			return fmt.Errorf("invalid type for constant %s: %w", c.Name, err)
		}
		constType = t
	}
	
	// Get the inferred type from value
	t, err := a.inferType(c.Value)
	if err != nil {
		if constType == nil {
			return fmt.Errorf("cannot infer type for constant %s: %w", c.Name, err)
		}
		// Use the explicit type
	} else {
		inferredType = t
	}
	
	// Determine final type and check compatibility
	if constType != nil && inferredType != nil {
		// Both type annotation and initializer present - check compatibility
		if !a.typesCompatible(constType, inferredType) {
			return fmt.Errorf("type mismatch for constant %s: declared type %s but initializer has type %s", 
				c.Name, constType.String(), inferredType.String())
		}
		// Use the declared type
	} else if constType != nil {
		// Only type annotation
	} else if inferredType != nil {
		// Only initializer, use inferred type
		constType = inferredType
	} else {
		return fmt.Errorf("cannot determine type for constant %s", c.Name)
	}
	
	// Get prefixed name
	prefixedName := a.prefixSymbol(c.Name)
	
	// Evaluate the constant value
	var constValue interface{}
	if luaExpr, ok := c.Value.(*ast.LuaExpression); ok {
		// Evaluate Lua expression
		result, err := a.luaEvaluator.ProcessLuaExpr(&ast.LuaExpr{Code: luaExpr.Code})
		if err != nil {
			return fmt.Errorf("failed to evaluate Lua expression for constant %s: %w", c.Name, err)
		}
		
		// Convert result to appropriate type
		switch v := result.(type) {
		case float64:
			constValue = int64(v)
		case []interface{}:
			// For array constants, we need a different approach
			// TODO: Handle array constants
			return fmt.Errorf("array constants from Lua not yet supported")
		default:
			return fmt.Errorf("unsupported Lua result type for constant: %T", result)
		}
	} else if numLit, ok := c.Value.(*ast.NumberLiteral); ok {
		constValue = numLit.Value
	} else if boolLit, ok := c.Value.(*ast.BooleanLiteral); ok {
		constValue = boolLit.Value
	} else if strLit, ok := c.Value.(*ast.StringLiteral); ok {
		constValue = strLit.Value
		// Update type to string (pointer to u8)
		if constType == nil {
			constType = &ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}}
		}
	} else {
		// Try to evaluate the expression as a constant
		val, err := a.evaluateConstExpr(c.Value)
		if err != nil {
			return fmt.Errorf("cannot evaluate constant expression for %s: %w", c.Name, err)
		}
		// Store the value as-is (can be int64, bool, or string)
		constValue = val
	}
	
	// Define constant in current scope (should be global scope)
	a.currentScope.Define(c.Name, &ConstSymbol{
		Name:  c.Name,
		Type:  constType,
		Value: constValue,
	})
	
	// Also define with prefix if needed
	if prefixedName != c.Name {
		a.currentScope.Define(prefixedName, &ConstSymbol{
			Name:  c.Name, // Still use unprefixed name in the symbol
			Type:  constType,
			Value: constValue,
		})
	}
	
	
	// Generate global constant definition
	// TODO: For now, don't generate globals for constants
	// globalVar := ir.Global{
	// 	Name:     prefixedName,
	// 	Type:     constType,
	// 	Value:    c.Value, // Store AST expression for later evaluation
	// 	Constant: true,
	// }
	
	// a.module.Globals = append(a.module.Globals, globalVar)
	
	return nil
}

// registerStructName registers just the struct name without processing fields
// This allows for forward references and self-referential structs
func (a *Analyzer) registerStructName(s *ast.StructDecl) error {
	// Get prefixed name
	prefixedName := a.prefixSymbol(s.Name)
	
	// Create a placeholder struct type
	structType := &ir.StructType{
		Name:       prefixedName,
		Fields:     nil, // Will be filled in later
		FieldOrder: nil,
	}
	
	// Register struct type with prefixed name
	a.currentScope.Define(prefixedName, &TypeSymbol{
		Name: prefixedName,
		Type: structType,
	})
	
	// Also register without prefix for local access
	if a.currentModule != "" && a.currentModule != "main" {
		a.currentScope.Define(s.Name, &TypeSymbol{
			Name: prefixedName,
			Type: structType,
		})
	}
	
	return nil
}


// analyzeStructDecl analyzes a struct declaration (now assumes the name is already registered)
func (a *Analyzer) analyzeStructDecl(s *ast.StructDecl) error {
	// Get the already registered struct type
	prefixedName := a.prefixSymbol(s.Name)
	sym := a.currentScope.Lookup(prefixedName)
	if sym == nil {
		sym = a.currentScope.Lookup(s.Name)
	}
	if sym == nil {
		return fmt.Errorf("struct %s not found in symbol table", s.Name)
	}
	
	typeSym, ok := sym.(*TypeSymbol)
	if !ok {
		return fmt.Errorf("%s is not a type", s.Name)
	}
	
	structType, ok := typeSym.Type.(*ir.StructType)
	if !ok {
		return fmt.Errorf("%s is not a struct type", s.Name)
	}
	
	// Now process the fields
	fields := make(map[string]ir.Type)
	fieldOrder := []string{}
	
	for _, field := range s.Fields {
		fieldType, err := a.convertType(field.Type)
		if err != nil {
			return fmt.Errorf("invalid type for field %s in struct %s: %w", field.Name, s.Name, err)
		}
		
		if _, exists := fields[field.Name]; exists {
			return fmt.Errorf("duplicate field %s in struct %s", field.Name, s.Name)
		}
		
		fields[field.Name] = fieldType
		fieldOrder = append(fieldOrder, field.Name)
	}
	
	// Update the struct type with the processed fields
	structType.Fields = fields
	structType.FieldOrder = fieldOrder
	
	// Debug output
	if len(s.Fields) > 0 {
		// fmt.Printf("Struct %s has %d fields: %v\n", s.Name, len(fieldOrder), fieldOrder)
	}
	
	return nil
}

// analyzeEnumDecl analyzes an enum declaration
func (a *Analyzer) analyzeEnumDecl(e *ast.EnumDecl) error {
	// Create enum type
	enumType := &ir.EnumType{
		Name:     e.Name,
		Variants: make(map[string]int),
	}
	
	// Assign values to variants
	for i, variant := range e.Variants {
		if _, exists := enumType.Variants[variant]; exists {
			return fmt.Errorf("duplicate variant %s in enum %s", variant, e.Name)
		}
		enumType.Variants[variant] = i
	}
	
	// Register enum type
	a.currentScope.Define(e.Name, &TypeSymbol{
		Name: e.Name,
		Type: enumType,
	})
	
	return nil
}

// analyzeTypeDecl analyzes a type declaration (including bit structs)
func (a *Analyzer) analyzeTypeDecl(t *ast.TypeDecl) error {
	// Convert the underlying type
	underlyingType, err := a.convertType(t.Type)
	if err != nil {
		return fmt.Errorf("invalid type in type declaration %s: %w", t.Name, err)
	}
	
	// Register the type alias
	a.currentScope.Define(t.Name, &TypeSymbol{
		Name: t.Name,
		Type: underlyingType,
	})
	
	return nil
}

// isTSMCReference checks if a variable symbol is a TSMC reference parameter
func (a *Analyzer) isTSMCReference(sym *VarSymbol, irFunc *ir.Function) bool {
	if !sym.IsParameter {
		return false
	}
	
	if irFunc.CallingConvention != "smc" {
		return false
	}
	
	// Check if the parameter is marked as TSMC ref
	for _, param := range irFunc.Params {
		if param.Name == sym.Name {
			return param.IsTSMCRef
		}
	}
	
	return false
}

// analyzeTSMCAssignment generates code for TSMC reference assignment
func (a *Analyzer) analyzeTSMCAssignment(varName string, valueReg ir.Register, irFunc *ir.Function) {
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpStoreTSMCRef,
		Src1:    valueReg,
		Symbol:  varName,
		Comment: fmt.Sprintf("Update TSMC reference %s", varName),
	})
}

// registerLocalFunctionSignature registers just the signature of a local function
// This allows forward references to work correctly
func (a *Analyzer) registerLocalFunctionSignature(fn *ast.FunctionDecl, mangledName string) error {
	// Convert parameter types
	params := make([]*ast.Parameter, len(fn.Params))
	for i, p := range fn.Params {
		params[i] = &ast.Parameter{
			Name: p.Name,
			Type: p.Type,
		}
	}
	
	// Convert return type
	returnType, err := a.convertType(fn.ReturnType)
	if err != nil {
		return fmt.Errorf("invalid return type for local function %s: %w", fn.Name, err)
	}
	
	// Register the function symbol in current scope with original name
	// This allows calls using just the function name
	funcSymbol := &FuncSymbol{
		Name:         mangledName, // Use mangled name for IR generation
		OriginalName: fn.Name,     // Store original name for lookup
		ReturnType:   returnType,
		Params:       params,
		IsLocalFunc:  true,
	}
	
	// Define in current scope
	a.currentScope.Define(fn.Name, funcSymbol)
	
	if debug {
		fmt.Printf("DEBUG: Registered local function %s (mangled: %s) in scope\n", fn.Name, mangledName)
	}
	
	return nil
}

// analyzeBlock analyzes a block statement
func (a *Analyzer) analyzeBlock(block *ast.BlockStmt, irFunc *ir.Function) error {
	if debug {
		fmt.Printf("DEBUG: analyzeBlock called with %d statements for function %s\n", len(block.Statements), irFunc.Name)
	}
	
	// PASS 1: Register all local function declarations BEFORE creating new scope
	// This makes them visible in the parent scope
	for _, stmt := range block.Statements {
		if debug {
			fmt.Printf("DEBUG: Checking statement type %T\n", stmt)
		}
		if fnDecl, ok := stmt.(*ast.FunctionDecl); ok {
			if debug {
				fmt.Printf("DEBUG: Found local function declaration: %s\n", fnDecl.Name)
			}
			// Generate unique name for local function
			localFuncName := fmt.Sprintf("%s$%s", irFunc.Name, fnDecl.Name)
			// Register the function signature in CURRENT (parent) scope
			if err := a.registerLocalFunctionSignature(fnDecl, localFuncName); err != nil {
				return fmt.Errorf("failed to pre-register local function %s: %w", fnDecl.Name, err)
			}
		}
	}
	
	// Enter new scope for block-local variables
	prevScope := a.currentScope
	a.currentScope = NewScope(a.currentScope)
	defer func() { 
		a.currentScope = prevScope 
	}()

	// PASS 2: Process all statements (including analyzing function bodies)
	for i, stmt := range block.Statements {
		if debug {
			fmt.Printf("DEBUG: analyzeBlock processing statement %d of type %T\n", i, stmt)
		}
		if err := a.analyzeStatement(stmt, irFunc); err != nil {
			return err
		}
	}

	return nil
}

// analyzeStatement analyzes a statement
func (a *Analyzer) analyzeStatement(stmt ast.Statement, irFunc *ir.Function) error {
	if stmt == nil {
		return fmt.Errorf("encountered nil statement - likely a parsing error")
	}
	
	switch s := stmt.(type) {
	case *ast.VarDecl:
		return a.analyzeVarDeclInFunc(s, irFunc)
	case *ast.ConstDecl:
		return a.analyzeConstDeclInFunc(s, irFunc)
	case *ast.ReturnStmt:
		return a.analyzeReturnStmt(s, irFunc)
	case *ast.IfStmt:
		return a.analyzeIfStmt(s, irFunc)
	case *ast.WhileStmt:
		return a.analyzeWhileStmt(s, irFunc)
	case *ast.ForStmt:
		return a.analyzeForStmt(s, irFunc)
	case *ast.CaseStmt:
		return a.analyzeCaseStmt(s, irFunc)
	case *ast.BlockStmt:
		return a.analyzeBlock(s, irFunc)
	case *ast.AsmStmt:
		return a.analyzeAsmStmt(s, irFunc)
	case *ast.AsmBlockStmt:
		return a.analyzeAsmBlockStmt(s, irFunc)
	case *ast.TargetBlockStmt:
		return a.analyzeTargetBlockStmt(s, irFunc)
	case *ast.ExpressionStmt:
		// Analyze the expression but ignore the result
		_, err := a.analyzeExpression(s.Expression, irFunc)
		return err
	case *ast.AssignStmt:
		return a.analyzeAssignStmt(s, irFunc)
	case *ast.LoopStmt:
		return a.analyzeLoopStmt(s, irFunc)
	case *ast.DoTimesStmt:
		return a.analyzeDoTimesStmt(s, irFunc)
	case *ast.LoopAtStmt:
		return a.analyzeLoopAtStmt(s, irFunc)
	case *ast.FunctionDecl:
		if debug {
			fmt.Printf("DEBUG: Found local function declaration: %s\n", s.Name)
		}
		return a.analyzeLocalFunctionDecl(s, irFunc)
	default:
		return fmt.Errorf("unsupported statement type: %T", stmt)
	}
}

// analyzeVarDeclInFunc analyzes a variable declaration inside a function
func (a *Analyzer) analyzeVarDeclInFunc(v *ast.VarDecl, irFunc *ir.Function) error {
	if debug {
		fmt.Printf("DEBUG: analyzeVarDeclInFunc: %s\n", v.Name)
		fmt.Printf("  Value type: %T\n", v.Value)
	}
	
	// CRITICAL: Check for lambda assignment FIRST, before any type inference
	// Type inference would call analyzeLambdaExpr which creates runtime lambdas
	if lambdaExpr, ok := v.Value.(*ast.LambdaExpr); ok {
		if debug {
			fmt.Printf("DEBUG: Found lambda assignment for %s, calling transformLambdaAssignment\n", v.Name)
		}
		// Transform lambda assignment into a function
		// This completely handles the lambda - it creates a function and registers a FuncSymbol
		return a.transformLambdaAssignment(v, lambdaExpr, irFunc)
	}
	
	// Check for function reference copying: let f = someFunction;
	if identExpr, ok := v.Value.(*ast.Identifier); ok {
		if funcSymbol := a.currentScope.Lookup(identExpr.Name); funcSymbol != nil {
			if fs, ok := funcSymbol.(*FuncSymbol); ok {
				if debug {
					fmt.Printf("DEBUG: Found function reference copy: %s = %s\n", v.Name, identExpr.Name)
				}
				// Create a new FuncSymbol with the same properties
				a.currentScope.Define(v.Name, &FuncSymbol{
					Name:       fs.Name,       // Same underlying function
					ReturnType: fs.ReturnType,
					Params:     fs.Params,
				})
				return nil // Don't generate IR code for function reference copies
			}
		}
	}
	
	// Determine type
	var varType ir.Type
	
	// Get the declared type if present
	if v.Type != nil {
		t, err := a.convertType(v.Type)
		if err != nil {
			return fmt.Errorf("invalid type for variable %s: %w", v.Name, err)
		}
		varType = t
	}
	
	// If no explicit type, we need to infer from value
	// But we must be careful about when we do type inference
	if varType == nil && v.Value != nil {
		// For simple literals, lambda expressions, function calls, and case expressions, we can infer type safely
		switch v.Value.(type) {
		case *ast.NumberLiteral, *ast.BooleanLiteral, *ast.StringLiteral, *ast.LambdaExpr, *ast.ArrayInitializer, *ast.CallExpr, *ast.CaseExpr:
			t, err := a.inferType(v.Value)
			if err != nil {
				return fmt.Errorf("cannot infer type for variable %s: %w", v.Name, err)
			}
			varType = t
			if debug {
				fmt.Printf("DEBUG: Inferred type for variable %s: %T -> %s\n", v.Name, t, t.String())
			}
		default:
			// For complex expressions, we'll need to handle this after registration
			// Use a placeholder type for now
			varType = &ir.BasicType{Kind: ir.TypeU16} // Default type
		}
	}
	
	// Ensure we have a type
	if varType == nil {
		return fmt.Errorf("variable %s must have either a type or an initial value", v.Name)
	}
	
	

	// Allocate register for variable
	reg := irFunc.AddLocal(v.Name, varType)

	// CRITICAL FIX: Register variable in scope BEFORE analyzing value expression
	// This ensures the variable is available if referenced in complex expressions
	a.currentScope.Define(v.Name, &VarSymbol{
		Name:      v.Name,
		Type:      varType,
		Reg:       reg,
		IsMutable: v.IsMutable,
	})
	

	// Generate code for initial value if present
	if v.Value != nil {
		if debug {
			fmt.Printf("DEBUG: Variable %s has value of type %T\n", v.Name, v.Value)
		}
		// BUGFIX: Check for corrupted AST where the value expression contains the variable name itself
		if id, ok := v.Value.(*ast.Identifier); ok && id.Name == v.Name {
			// Corrupted AST: the variable's value expression is the variable name itself
			// This is a parsing bug, so we'll skip the value analysis and use the declared type
			if varType == nil {
				return fmt.Errorf("variable %s has corrupted AST (self-reference) and no explicit type", v.Name)
			}
			// Use a default value for the declared type
			valueReg := irFunc.AllocReg()
			// Generate a default literal based on type
			switch basicType := varType.(type) {
			case *ir.BasicType:
				switch basicType.Kind {
				case ir.TypeU8, ir.TypeI8:
					irFunc.Emit(ir.OpLoadConst, valueReg, 0, 0)
				case ir.TypeU16, ir.TypeI16:
					irFunc.Emit(ir.OpLoadConst, valueReg, 0, 0)
				case ir.TypeBool:
					irFunc.Emit(ir.OpLoadConst, valueReg, 0, 0)
				default:
					irFunc.Emit(ir.OpLoadConst, valueReg, 0, 0)
				}
			default:
				irFunc.Emit(ir.OpLoadConst, valueReg, 0, 0)
			}
			// Store the value to the variable
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:     ir.OpStoreVar,
				Dest:   reg,
				Src1:   valueReg,
				Symbol: v.Name,
				Type:   varType,
			})
		} else {
			valueReg, err := a.analyzeExpression(v.Value, irFunc)
			if err != nil {
				return err
			}
			
			// If we used a placeholder type, now we can check the actual type
			if v.Type == nil && varType.String() == "u16" {
				// Check if this is a lambda expression specifically
				if lambdaExpr, ok := v.Value.(*ast.LambdaExpr); ok {
					// This is a lambda - infer the lambda type
					lambdaType, err := a.inferType(lambdaExpr)
					if err == nil && lambdaType != nil {
						// Update the variable type to the lambda type
						varType = lambdaType
						
						// Update the variable symbol with the correct type
						if varSym := a.currentScope.Lookup(v.Name); varSym != nil {
							if vs, ok := varSym.(*VarSymbol); ok {
								vs.Type = varType
							}
						}
					}
				} else {
					// We used a default type, let's check if we need to update it
					// based on the actual expression type
					if exprType, ok := a.exprTypes[v.Value]; ok && exprType != nil {
						// Update the variable type to the actual expression type
						varType = exprType
						
						// Update the variable symbol with the correct type
						if varSym := a.currentScope.Lookup(v.Name); varSym != nil {
							if vs, ok := varSym.(*VarSymbol); ok {
								vs.Type = varType
							}
						}
						
						// Verify type compatibility if we had an explicit type
						if v.Type != nil && !a.typesCompatible(varType, exprType) {
							return fmt.Errorf("type mismatch for variable %s: declared type %s but initializer has type %s", 
								v.Name, varType.String(), exprType.String())
						}
					}
				}
			}
			
			// Check if this is an array initializer
			if arrayInit, ok := v.Value.(*ast.ArrayInitializer); ok {
				// Special handling for array initializers
				// The array space should already be allocated for the variable
				// Now we need to initialize each element
				if arrayType, ok := varType.(*ir.ArrayType); ok {
					// Generate element initialization code
					for i, elem := range arrayInit.Elements {
						// Analyze the element expression
						elemReg, err := a.analyzeExpression(elem, irFunc)
						if err != nil {
							return fmt.Errorf("error analyzing array element %d: %w", i, err)
						}
						
						// Generate code to store element at array[i]
						// First, get the array base address
						irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
							Op:      ir.OpLoadVar,
							Dest:    irFunc.AllocReg(),
							Symbol:  v.Name,
							Type:    &ir.PointerType{Base: arrayType.Element},
							Comment: fmt.Sprintf("Load array %s base address", v.Name),
						})
						baseReg := irFunc.LastAllocatedReg()
						
						// Calculate offset and store element
						if i == 0 {
							// First element - store directly
							irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
								Op:      ir.OpStoreIndex,
								Dest:    baseReg,
								Src1:    elemReg,
								Imm:     0,
								Type:    arrayType.Element,
								Comment: fmt.Sprintf("Store element %d", i),
							})
						} else {
							// Other elements - calculate offset
							offsetReg := irFunc.AllocReg()
							irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
								Op:      ir.OpLoadConst,
								Dest:    offsetReg,
								Imm:     int64(i * int(arrayType.Element.Size())),
								Type:    &ir.BasicType{Kind: ir.TypeU16},
							})
							
							// Add offset to base
							addrReg := irFunc.AllocReg()
							irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
								Op:      ir.OpAdd,
								Dest:    addrReg,
								Src1:    baseReg,
								Src2:    offsetReg,
								Type:    &ir.PointerType{Base: arrayType.Element},
							})
							
							// Store element at calculated address
							irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
								Op:      ir.OpStoreDirect,
								Dest:    addrReg,
								Src1:    elemReg,
								Type:    arrayType.Element,
								Comment: fmt.Sprintf("Store element %d", i),
							})
						}
					}
				}
			} else {
				// Check if we're storing a struct literal
				if structLit, ok := v.Value.(*ast.StructLiteral); ok {
					// The struct literal returns a pointer to the struct
					// But the variable should hold the struct value itself
					// So we need to update the variable's type info
					if structType, ok := a.exprTypes[structLit].(*ir.StructType); ok {
						// Update the variable symbol with the correct type
						if varSym, ok := a.currentScope.Lookup(v.Name).(*VarSymbol); ok {
							varSym.Type = structType
						}
					}
				}
				
				// Normal value assignment
				// Store the value to the variable
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:     ir.OpStoreVar,
				Dest:   reg,
				Src1:   valueReg,
				Symbol: v.Name,
				Type:   varType,
			})
			}
		}
	}

	return nil
}

// analyzeConstDeclInFunc analyzes a constant declaration inside a function
func (a *Analyzer) analyzeConstDeclInFunc(c *ast.ConstDecl, irFunc *ir.Function) error {
	if debug {
		fmt.Printf("DEBUG: analyzeConstDeclInFunc: %s\n", c.Name)
	}
	// Constants must have a value
	if c.Value == nil {
		return fmt.Errorf("constant %s must have a value", c.Name)
	}
	
	// Determine type
	var constType ir.Type
	var inferredType ir.Type
	
	// Get the declared type if present
	if c.Type != nil {
		t, err := a.convertType(c.Type)
		if err != nil {
			return fmt.Errorf("invalid type for constant %s: %w", c.Name, err)
		}
		constType = t
	}
	
	// Get the inferred type from value
	t, err := a.inferType(c.Value)
	if err != nil {
		if constType == nil {
			return fmt.Errorf("cannot infer type for constant %s: %w", c.Name, err)
		}
		// Use the explicit type
	} else {
		inferredType = t
	}
	
	// Determine final type and check compatibility
	if constType != nil && inferredType != nil {
		// Both type annotation and initializer present - check compatibility
		if !a.typesCompatible(constType, inferredType) {
			return fmt.Errorf("type mismatch for constant %s: declared type %s but initializer has type %s", 
				c.Name, constType.String(), inferredType.String())
		}
		// Use the declared type
	} else if constType != nil {
		// Only type annotation
	} else if inferredType != nil {
		// Only initializer, use inferred type
		constType = inferredType
	} else {
		return fmt.Errorf("cannot determine type for constant %s", c.Name)
	}
	
	// Evaluate the constant value
	var constValue interface{}
	if numLit, ok := c.Value.(*ast.NumberLiteral); ok {
		constValue = numLit.Value
	} else if boolLit, ok := c.Value.(*ast.BooleanLiteral); ok {
		constValue = boolLit.Value
	} else if strLit, ok := c.Value.(*ast.StringLiteral); ok {
		constValue = strLit.Value
		// Update type to string (pointer to u8)
		if constType == nil {
			constType = &ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}}
		}
	} else {
		// Try to evaluate the expression as a constant
		val, err := a.evaluateConstExpr(c.Value)
		if err != nil {
			return fmt.Errorf("cannot evaluate constant expression for %s: %w", c.Name, err)
		}
		// Store the value as-is (can be int64, bool, or string)
		constValue = val
	}
	
	// Define constant in current scope (function scope)
	a.currentScope.Define(c.Name, &ConstSymbol{
		Name:  c.Name,
		Type:  constType,
		Value: constValue,
	})
	
	// Constants don't generate any IR code - they're replaced at use sites
	return nil
}

// analyzeReturnStmt analyzes a return statement
func (a *Analyzer) analyzeReturnStmt(ret *ast.ReturnStmt, irFunc *ir.Function) error {
	if ret.Value != nil {
		reg, err := a.analyzeExpression(ret.Value, irFunc)
		if err != nil {
			return err
		}
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpReturn,
			Src1: reg,
		})
	} else {
		irFunc.Emit(ir.OpReturn, 0, 0, 0)
	}
	return nil
}

// analyzeIfStmt analyzes an if statement
func (a *Analyzer) analyzeIfStmt(ifStmt *ast.IfStmt, irFunc *ir.Function) error {
	// Generate code for condition
	condReg, err := a.analyzeExpression(ifStmt.Condition, irFunc)
	if err != nil {
		return err
	}

	// Generate labels
	elseLabel := a.generateLabel("else")
	endLabel := a.generateLabel("end_if")

	// Jump to else if condition is false
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:    ir.OpJumpIfNot,
		Src1:  condReg,
		Label: elseLabel,
	})

	// Generate then block
	if err := a.analyzeBlock(ifStmt.Then, irFunc); err != nil {
		return err
	}

	// Jump to end
	irFunc.EmitJump(endLabel)

	// Else label
	irFunc.EmitLabel(elseLabel)

	// Generate else block if present
	if ifStmt.Else != nil {
		if err := a.analyzeStatement(ifStmt.Else, irFunc); err != nil {
			return err
		}
	}

	// End label
	irFunc.EmitLabel(endLabel)

	return nil
}

// analyzeCaseStmt analyzes a case statement (pattern matching)
func (a *Analyzer) analyzeCaseStmt(caseStmt *ast.CaseStmt, irFunc *ir.Function) error {
	// Analyze the expression to match against
	exprReg, err := a.analyzeExpression(caseStmt.Value, irFunc)
	if err != nil {
		return err
	}
	
	// Get the type of the expression
	exprType := a.exprTypes[caseStmt.Value]
	
	// Generate labels for each arm and the end
	endLabel := a.generateLabel("case_end")
	armLabels := make([]string, len(caseStmt.Arms))
	for i := range caseStmt.Arms {
		armLabels[i] = a.generateLabel(fmt.Sprintf("case_arm_%d", i))
	}
	
	// Generate comparison and jump code for each pattern
	for i, arm := range caseStmt.Arms {
		nextArmLabel := endLabel
		if i < len(caseStmt.Arms)-1 {
			nextArmLabel = armLabels[i+1]
		}
		
		// Analyze the pattern and generate comparison
		if err := a.analyzePattern(arm.Pattern, exprReg, exprType, armLabels[i], nextArmLabel, irFunc); err != nil {
			return err
		}
	}
	
	// Generate code for each arm body
	for i, arm := range caseStmt.Arms {
		irFunc.EmitLabel(armLabels[i])
		
		// Create new scope for pattern variables
		prevScope := a.currentScope
		a.currentScope = NewScope(a.currentScope)
		
		// Bind pattern variables if this is an identifier pattern
		if idPattern, ok := arm.Pattern.(*ast.IdentifierPattern); ok && !strings.Contains(idPattern.Name, ".") {
			// This is a variable binding pattern
			// Create a new variable in the current scope with the matched value
			varReg := irFunc.AllocReg()
			irFunc.Emit(ir.OpMove, varReg, exprReg, 0)
			
			a.currentScope.Define(idPattern.Name, &VarSymbol{
				Name:      idPattern.Name,
				Type:      exprType,
				Reg:       varReg,
				IsMutable: false, // Pattern variables are immutable
			})
		}
		
		// If there's a guard, check it
		if arm.Guard != nil {
			// Analyze the guard expression
			guardReg, err := a.analyzeExpression(arm.Guard, irFunc)
			if err != nil {
				return err
			}
			
			// Check that guard is boolean
			guardType := a.exprTypes[arm.Guard]
			if guardType == nil || guardType.String() != "bool" {
				return fmt.Errorf("pattern guard must be of type bool, got %v", guardType)
			}
			
			// Jump to next arm if guard fails
			nextArmLabel := endLabel
			if i < len(caseStmt.Arms)-1 {
				nextArmLabel = armLabels[i+1]
			}
			
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:    ir.OpJumpIfNot,
				Src1:  guardReg,
				Label: nextArmLabel,
			})
		}
		
		// Analyze the arm body
		switch body := arm.Body.(type) {
		case ast.Expression:
			// Expression body - just analyze it
			_, err := a.analyzeExpression(body, irFunc)
			if err != nil {
				// Restore scope before returning error
				a.currentScope = prevScope
				return err
			}
		case *ast.BlockStmt:
			// Block body
			if err := a.analyzeBlock(body, irFunc); err != nil {
				// Restore scope before returning error
				a.currentScope = prevScope
				return err
			}
		}
		
		// Restore scope after analyzing arm
		a.currentScope = prevScope
		
		// Jump to end (unless this is the last arm)
		if i < len(caseStmt.Arms)-1 {
			irFunc.EmitJump(endLabel)
		}
	}
	
	// End label
	irFunc.EmitLabel(endLabel)
	return nil
}

// analyzeCaseExpr analyzes a case expression (returns a value)
func (a *Analyzer) analyzeCaseExpr(caseExpr *ast.CaseExpr, irFunc *ir.Function) (ir.Register, error) {
	// Analyze the expression to match against
	exprReg, err := a.analyzeExpression(caseExpr.Value, irFunc)
	if err != nil {
		return 0, err
	}
	
	// Get the type of the expression
	exprType := a.exprTypes[caseExpr.Value]
	
	// Determine result type from first arm
	var resultType ir.Type
	if len(caseExpr.Arms) > 0 {
		// Use the type of the first arm's body as the result type
		// In a proper implementation, we'd check all arms have the same type
		if _, ok := caseExpr.Arms[0].Body.(ast.Expression); ok {
			// For now, assume all arms return the same basic type
			// This is a simplified implementation
			resultType = &ir.BasicType{Kind: ir.TypeU8}
		}
	}
	
	// Register the type of the case expression
	a.exprTypes[caseExpr] = resultType
	
	// Allocate register for result
	resultReg := irFunc.NextRegister
	irFunc.NextRegister++
	
	// Generate labels for each arm and the end
	endLabel := a.generateLabel("case_expr_end")
	armLabels := make([]string, len(caseExpr.Arms))
	for i := range caseExpr.Arms {
		armLabels[i] = a.generateLabel(fmt.Sprintf("case_expr_arm_%d", i))
	}
	
	// Generate comparison and jump code for each pattern
	for i, arm := range caseExpr.Arms {
		// Generate matching code for pattern
		nextLabel := endLabel
		if i < len(caseExpr.Arms)-1 {
			nextLabel = armLabels[i+1]
		}
		
		if err := a.analyzePattern(arm.Pattern, exprReg, exprType, armLabels[i], nextLabel, irFunc); err != nil {
			return 0, err
		}
		
		// Label for this arm
		irFunc.EmitLabel(armLabels[i])
		
		// Check guard condition if present
		if arm.Guard != nil {
			guardReg, err := a.analyzeExpression(arm.Guard, irFunc)
			if err != nil {
				return 0, err
			}
			// Jump to next arm if guard fails
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:     ir.OpJumpIfNot,
				Src1:   guardReg,
				Symbol: nextLabel,
			})
		}
		
		// Evaluate arm body
		bodyReg, err := a.analyzeExpression(arm.Body.(ast.Expression), irFunc)
		if err != nil {
			return 0, err
		}
		
		// Move result to result register
		irFunc.Emit(ir.OpMove, resultReg, bodyReg, 0)
		
		// Jump to end (unless this is the last arm)
		if i < len(caseExpr.Arms)-1 {
			irFunc.EmitJump(endLabel)
		}
	}
	
	// End label
	irFunc.EmitLabel(endLabel)
	return resultReg, nil
}

// analyzePattern analyzes a pattern and generates comparison code
func (a *Analyzer) analyzePattern(pattern ast.Pattern, exprReg ir.Register, exprType ir.Type, 
                                  matchLabel, nextLabel string, irFunc *ir.Function) error {
	switch p := pattern.(type) {
	case *ast.WildcardPattern:
		// Wildcard pattern always matches - jump directly to arm
		irFunc.EmitJump(matchLabel)
		
	case *ast.IdentifierPattern:
		// For enum variants like Direction.North
		if strings.Contains(p.Name, ".") {
			// This is an enum variant
			parts := strings.Split(p.Name, ".")
			if len(parts) == 2 {
				variantName := parts[1]
				
				// Look up the enum type and variant value
				if enumType, ok := exprType.(*ir.EnumType); ok {
					variantValue, exists := enumType.Variants[variantName]
					if !exists {
						return fmt.Errorf("unknown enum variant: %s in enum %s", variantName, enumType.Name)
					}
					
					// Generate comparison: if (expr == variant_value) goto match_label
					irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
						Op:   ir.OpEq,
						Dest: irFunc.AllocReg(),
						Src1: exprReg,
						Imm:  int64(variantValue),
					})
					condReg := irFunc.LastAllocatedReg()
					
					irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
						Op:    ir.OpJumpIf,
						Src1:  condReg,
						Label: matchLabel,
					})
					
					// If not equal, continue to next pattern
					irFunc.EmitJump(nextLabel)
				} else {
					return fmt.Errorf("pattern %s is not an enum variant", p.Name)
				}
			}
		} else {
			// Simple identifier - treat as variable binding
			// This pattern always matches and binds the value to a variable
			// Jump directly to the match label
			irFunc.EmitJump(matchLabel)
		}
		
	case *ast.LiteralPattern:
		// Compare against literal value
		litReg, err := a.analyzeExpression(p.Value, irFunc)
		if err != nil {
			return err
		}
		
		// Generate comparison
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpEq,
			Dest: irFunc.AllocReg(),
			Src1: exprReg,
			Src2: litReg,
		})
		condReg := irFunc.LastAllocatedReg()
		
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:    ir.OpJumpIf,
			Src1:  condReg,
			Label: matchLabel,
		})
		
		// If not equal, continue to next pattern
		irFunc.EmitJump(nextLabel)
		
	case *ast.EnumPattern:
		// Enum pattern: EnumType.Variant
		// Look up the enum type
		symbol := a.currentScope.Lookup(p.EnumType)
		if symbol == nil {
			return fmt.Errorf("unknown enum type: %s", p.EnumType)
		}
		
		typeSymbol, ok := symbol.(*TypeSymbol)
		if !ok {
			return fmt.Errorf("%s is not a type", p.EnumType)
		}
		
		enumType, ok := typeSymbol.Type.(*ir.EnumType)
		if !ok {
			return fmt.Errorf("%s is not an enum type", p.EnumType)
		}
		
		// Find the variant value
		variantValue, exists := enumType.Variants[p.Variant]
		if !exists {
			return fmt.Errorf("enum %s has no variant %s", p.EnumType, p.Variant)
		}
		
		// Create literal for the enum value
		litReg := irFunc.AllocReg()
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpLoadImm,
			Dest: litReg,
			Imm:  int64(variantValue),
		})
		
		// Compare against the enum value
		condReg := irFunc.AllocReg()
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpEq,
			Dest: condReg,
			Src1: exprReg,
			Src2: litReg,
		})
		
		// Jump to match label if equal
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:    ir.OpJumpIf,
			Src1:  condReg,
			Label: matchLabel,
		})
		
		// Otherwise continue to next pattern
		irFunc.EmitJump(nextLabel)
		
	case *ast.RangePattern:
		// Range pattern: start..end
		// Generate: if (expr >= start && expr <= end) goto match_label
		
		// Evaluate start value
		startVal := int64(0)
		if numLit, ok := p.Start.(*ast.NumberLiteral); ok {
			startVal = numLit.Value
		} else {
			return fmt.Errorf("range pattern start must be a number literal")
		}
		
		// Evaluate end value
		endVal := int64(0)
		if numLit, ok := p.RangeEnd.(*ast.NumberLiteral); ok {
			endVal = numLit.Value
		} else {
			return fmt.Errorf("range pattern end must be a number literal")
		}
		
		// Check if expr >= start
		startReg := irFunc.AllocReg()
		irFunc.EmitImm(ir.OpLoadConst, startReg, startVal)
		
		cmpGeReg := irFunc.AllocReg()
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpGe,
			Dest: cmpGeReg,
			Src1: exprReg,
			Src2: startReg,
		})
		
		// If not >= start, jump to next pattern
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:     ir.OpJumpIfNot,
			Src1:   cmpGeReg,
			Symbol: nextLabel,
		})
		
		// Check if expr <= end
		endReg := irFunc.AllocReg()
		irFunc.EmitImm(ir.OpLoadConst, endReg, endVal)
		
		cmpLeReg := irFunc.AllocReg()
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpLe,
			Dest: cmpLeReg,
			Src1: exprReg,
			Src2: endReg,
		})
		
		// If <= end, jump to match label
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:     ir.OpJumpIf,
			Src1:   cmpLeReg,
			Symbol: matchLabel,
		})
		
		// Otherwise continue to next pattern
		irFunc.EmitJump(nextLabel)
		
	default:
		return fmt.Errorf("unsupported pattern type: %T", pattern)
	}
	
	return nil
}

// analyzeWhileStmt analyzes a while statement
func (a *Analyzer) analyzeWhileStmt(whileStmt *ast.WhileStmt, irFunc *ir.Function) error {
	// Generate labels
	loopLabel := a.generateLabel("loop")
	endLabel := a.generateLabel("end_loop")

	// Loop label
	irFunc.EmitLabel(loopLabel)

	// Generate code for condition
	condReg, err := a.analyzeExpression(whileStmt.Condition, irFunc)
	if err != nil {
		return err
	}

	// Jump to end if condition is false
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:    ir.OpJumpIfNot,
		Src1:  condReg,
		Label: endLabel,
	})

	// Generate body
	if err := a.analyzeBlock(whileStmt.Body, irFunc); err != nil {
		return err
	}

	// Jump back to loop
	irFunc.EmitJump(loopLabel)

	// End label
	irFunc.EmitLabel(endLabel)

	return nil
}

// analyzeForStmt analyzes a for-in statement
func (a *Analyzer) analyzeForStmt(forStmt *ast.ForStmt, irFunc *ir.Function) error {
	// Enter new scope for loop variable
	prevScope := a.currentScope
	a.currentScope = NewScope(a.currentScope)
	defer func() { a.currentScope = prevScope }()
	
	// Note: We don't need to analyze the whole range expression,
	// just check its structure
	
	// Check if the range is a binary expression with ".." operator
	binExpr, ok := forStmt.Range.(*ast.BinaryExpr)
	if !ok {
		return fmt.Errorf("for loop requires range expression, got %T", forStmt.Range)
	}
	if binExpr.Operator != ".." {
		return fmt.Errorf("for loop requires '..' operator, got '%s'", binExpr.Operator)
	}
	
	// Analyze start and end expressions
	startReg, err := a.analyzeExpression(binExpr.Left, irFunc)
	if err != nil {
		return fmt.Errorf("error analyzing range start: %w", err)
	}
	
	endReg, err := a.analyzeExpression(binExpr.Right, irFunc)
	if err != nil {
		return fmt.Errorf("error analyzing range end: %w", err)
	}
	
	// Create loop variable
	iteratorReg := irFunc.AllocReg()
	iteratorType := &ir.BasicType{Kind: ir.TypeU8} // Default to u8 for now
	
	// Define loop variable in scope
	a.currentScope.Define(forStmt.Iterator, &VarSymbol{
		Name:      forStmt.Iterator,
		Type:      iteratorType,
		Reg:       iteratorReg,
		IsMutable: true,
	})
	
	// Initialize iterator with start value
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpMove,
		Dest: iteratorReg,
		Src1: startReg,
		Type: iteratorType,
		Comment: fmt.Sprintf("Initialize loop variable %s", forStmt.Iterator),
	})
	
	// Generate loop structure
	loopLabel := a.generateLabel("for_loop")
	endLabel := a.generateLabel("for_end")
	
	// Loop start
	irFunc.EmitLabel(loopLabel)
	
	// Check if iterator < end
	condReg := irFunc.AllocReg()
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpLt,
		Dest: condReg,
		Src1: iteratorReg,
		Src2: endReg,
		Type: &ir.BasicType{Kind: ir.TypeBool},
		Comment: fmt.Sprintf("Check %s < end", forStmt.Iterator),
	})
	
	// Jump to end if condition is false
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:    ir.OpJumpIfNot,
		Src1:  condReg,
		Label: endLabel,
	})
	
	// Generate body
	if err := a.analyzeBlock(forStmt.Body, irFunc); err != nil {
		return err
	}
	
	// Increment iterator
	oneReg := irFunc.AllocReg()
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpLoadConst,
		Dest: oneReg,
		Imm:  1,
		Type: iteratorType,
	})
	
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpAdd,
		Dest: iteratorReg,
		Src1: iteratorReg,
		Src2: oneReg,
		Type: iteratorType,
		Comment: fmt.Sprintf("Increment %s", forStmt.Iterator),
	})
	
	// Jump back to loop
	irFunc.EmitJump(loopLabel)
	
	// End label
	irFunc.EmitLabel(endLabel)
	
	return nil
}

// analyzeAsmStmt analyzes an inline assembly statement
func (a *Analyzer) analyzeAsmStmt(asmStmt *ast.AsmStmt, irFunc *ir.Function) error {
	// Create IR instruction with OpAsm
	asmInst := ir.Instruction{
		Op:      ir.OpAsm,
		AsmCode: asmStmt.Code,
		AsmName: asmStmt.Name,
	}
	
	// If named, register in symbol table
	if asmStmt.Name != "" {
		// TODO: Add AsmSymbol type to symbols
		// For now, just track the name
	}
	
	// Add to function instructions
	irFunc.Instructions = append(irFunc.Instructions, asmInst)
	
	return nil
}

// analyzeAsmBlockStmt analyzes an @asm { ... } inline assembly block
func (a *Analyzer) analyzeAsmBlockStmt(asmBlock *ast.AsmBlockStmt, irFunc *ir.Function) error {
	// Create IR instruction with OpAsm
	asmInst := ir.Instruction{
		Op:      ir.OpAsm,
		AsmCode: asmBlock.Code,
		Comment: "Inline assembly from @asm block",
	}
	
	// Add to function instructions
	irFunc.Instructions = append(irFunc.Instructions, asmInst)
	
	return nil
}

func (a *Analyzer) analyzeTargetBlockStmt(tb *ast.TargetBlockStmt, irFunc *ir.Function) error {
	// Only process the block if the target matches the current backend
	if tb.Target == a.targetBackend {
		// Analyze the body statements
		return a.analyzeBlock(tb.Body, irFunc)
	}
	// If target doesn't match, skip the block entirely
	
	return nil
}

// analyzeAssignStmt analyzes an assignment statement
func (a *Analyzer) analyzeAssignStmt(stmt *ast.AssignStmt, irFunc *ir.Function) error {
	// Analyze the right-hand side first
	valueReg, err := a.analyzeExpression(stmt.Value, irFunc)
	if err != nil {
		return err
	}
	
	// Handle different types of assignment targets
	switch target := stmt.Target.(type) {
	case *ast.Identifier:
		// Simple variable assignment
		sym := a.currentScope.Lookup(target.Name)
		if sym == nil {
			// Try with module prefix
			prefixedName := a.prefixSymbol(target.Name)
			sym = a.currentScope.Lookup(prefixedName)
			if sym == nil {
				return fmt.Errorf("undefined variable: %s", target.Name)
			}
			target.Name = prefixedName
		}
		
		// Get the variable's register from the symbol
		varSym := sym.(*VarSymbol)
		
		// Check if this is a TSMC reference parameter
		if a.isTSMCReference(varSym, irFunc) {
			// For TSMC references, we need to update the immediate operand
			a.analyzeTSMCAssignment(target.Name, valueReg, irFunc)
		} else {
			// Regular variable store
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:     ir.OpStoreVar,
				Dest:   varSym.Reg,
				Src1:   valueReg,
				Symbol: target.Name, // Keep for debugging
			})
		}
		
	case *ast.IndexExpr:
		// Array element assignment
		// Analyze the array expression
		arrayReg, err := a.analyzeExpression(target.Array, irFunc)
		if err != nil {
			return err
		}
		
		// Analyze the index expression
		indexReg, err := a.analyzeExpression(target.Index, irFunc)
		if err != nil {
			return err
		}
		
		// Get the type of the array to validate and get element type
		arrayType, err := a.inferType(target.Array)
		if err != nil {
			return fmt.Errorf("cannot determine array type: %v", err)
		}
		
		// Validate that it's an array or pointer type
		var elementType ir.Type
		switch t := arrayType.(type) {
		case *ir.ArrayType:
			elementType = t.Element
		case *ir.PointerType:
			// For pointers, assume they point to u8 (byte arrays)
			elementType = &ir.BasicType{Kind: ir.TypeU8}
		default:
			return fmt.Errorf("cannot index non-array type %s", arrayType)
		}
		
		// Type check the value against the element type
		valueType, err := a.inferType(stmt.Value)
		if err != nil {
			return fmt.Errorf("cannot determine value type: %v", err)
		}
		
		if !a.typesCompatible(elementType, valueType) {
			return fmt.Errorf("type mismatch: array element is %s, value is %s", elementType, valueType)
		}
		
		// Generate IR using two instructions approach
		// First, calculate the address (array + index)
		tempReg := irFunc.AllocReg()
		
		// For byte arrays, index is already the offset
		// For larger elements, we'd need to multiply by element size
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpAdd,
			Dest: tempReg,
			Src1: arrayReg,
			Src2: indexReg,
			Type: &ir.PointerType{Base: elementType},
			Comment: "Calculate array element address",
		})
		
		// Store the value at the calculated address using pointer store
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpStorePtr,
			Src1: tempReg, // address in Src1
			Src2: valueReg, // value in Src2
			Type: elementType,
			Comment: fmt.Sprintf("Store to array[index] (%s)", elementType),
		})
		
	case *ast.FieldExpr:
		// Struct field assignment
		// Check if this is a buffer field (loop iterator in INTO mode)
		if id, ok := target.Object.(*ast.Identifier); ok {
			sym := a.currentScope.Lookup(id.Name)
			if varSym, ok := sym.(*VarSymbol); ok && varSym.BufferAddr != 0 {
				// This is a buffer field - use direct memory store
				structType, ok := varSym.Type.(*ir.StructType)
				if !ok {
					return fmt.Errorf("field access on non-struct iterator %s", id.Name)
				}
				
				// Find field offset
				offset := 0
				found := false
				for _, fname := range structType.FieldOrder {
					if fname == target.Field {
						found = true
						break
					}
					offset += structType.Fields[fname].Size()
				}
				
				if !found {
					return fmt.Errorf("struct %s has no field %s", structType.Name, target.Field)
				}
				
				// Generate direct memory store to buffer
				directAddr := varSym.BufferAddr + uint16(offset)
				
				irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
					Op:      ir.OpStoreDirect,
					Src1:    valueReg,
					Imm:     int64(directAddr),
					Type:    structType.Fields[target.Field],
					Comment: fmt.Sprintf("Store to %s.%s at buffer $%04X", id.Name, target.Field, directAddr),
				})
				
				return nil
			}
		}
		
		// Regular field assignment (struct.field = value)
		objReg, err := a.analyzeExpression(target.Object, irFunc)
		if err != nil {
			return fmt.Errorf("error analyzing field object: %v", err)
		}
		
		// Get the object type
		objType := a.exprTypes[target.Object]
		
		// Check if it's a bit struct
		if bitStructType, ok := objType.(*ir.BitStructType); ok {
			// Handle bit field assignment
			bitField, exists := bitStructType.Fields[target.Field]
			if !exists {
				return fmt.Errorf("bit struct has no field %s", target.Field)
			}
			
			// Generate bit field store instruction
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:      ir.OpStoreBitField,
				Src1:    objReg,
				Src2:    valueReg,
				Imm:     int64(bitField.BitOffset),
				Imm2:    int64(bitField.BitWidth),
				Type:    bitStructType.UnderlyingType,
				Comment: fmt.Sprintf("Store bit field %s (offset %d, width %d)", target.Field, bitField.BitOffset, bitField.BitWidth),
			})
			
			return nil
		}
		
		// Handle regular struct types
		var structType *ir.StructType
		
		// Handle both direct struct and pointer to struct
		switch t := objType.(type) {
		case *ir.StructType:
			structType = t
		case *ir.PointerType:
			if st, ok := t.Base.(*ir.StructType); ok {
				structType = st
			} else {
				return fmt.Errorf("field access on non-struct pointer")
			}
		default:
			return fmt.Errorf("field access on non-struct type: %T", objType)
		}
		
		// Find field offset
		offset := 0
		found := false
		for _, fname := range structType.FieldOrder {
			if fname == target.Field {
				found = true
				break
			}
			offset += structType.Fields[fname].Size()
		}
		
		if !found {
			return fmt.Errorf("struct %s has no field %s", structType.Name, target.Field)
		}
		
		// Generate store field instruction
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpStoreField,
			Src1:    objReg,     // struct pointer
			Src2:    valueReg,   // value to store
			Imm:     int64(offset),
			Type:    structType.Fields[target.Field],
			Comment: fmt.Sprintf("Store to field %s (offset %d)", target.Field, offset),
		})
		
		return nil
		
	case *ast.UnaryExpr:
		// Handle pointer dereference assignment (*ptr = value)
		if target.Operator != "*" {
			return fmt.Errorf("invalid assignment target: unary %s", target.Operator)
		}
		
		// Analyze the pointer expression
		ptrReg, err := a.analyzeExpression(target.Operand, irFunc)
		if err != nil {
			return err
		}
		
		// Verify it's a pointer type
		ptrType, err := a.inferType(target.Operand)
		if err != nil {
			return fmt.Errorf("cannot determine type of pointer expression: %v", err)
		}
		
		ptr, ok := ptrType.(*ir.PointerType)
		if !ok {
			return fmt.Errorf("cannot dereference non-pointer type: %s", ptrType.String())
		}
		
		// Type check the value against the pointed-to type
		valueType, err := a.inferType(stmt.Value)
		if err != nil {
			return fmt.Errorf("cannot determine type of value: %v", err)
		}
		
		if !a.typesCompatible(ptr.Base, valueType) {
			return fmt.Errorf("type mismatch: cannot assign %s to %s", 
				valueType.String(), ptr.Base.String())
		}
		
		// Generate store through pointer instruction
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpStore,
			Src1:    ptrReg,     // pointer
			Src2:    valueReg,   // value to store
			Type:    ptr.Base,
			Comment: "Store through pointer",
		})
		
		return nil
		
	default:
		return fmt.Errorf("invalid assignment target: %T", target)
	}
	
	return nil
}

// analyzeLoopStmt analyzes a loop statement
func (a *Analyzer) analyzeLoopStmt(loop *ast.LoopStmt, irFunc *ir.Function) error {
	// Analyze the table expression
	tableReg, err := a.analyzeExpression(loop.Table, irFunc)
	if err != nil {
		return fmt.Errorf("invalid table expression: %w", err)
	}
	
	// Get table type
	tableType := a.exprTypes[loop.Table]
	if tableType == nil {
		return fmt.Errorf("cannot determine type of table")
	}
	
	// Extract element type from array type
	var elementType ir.Type
	var elementSize int
	var tableSize int
	
	switch t := tableType.(type) {
	case *ir.ArrayType:
		elementType = t.Element
		elementSize = t.Element.Size()
		tableSize = t.Length
	case *ir.PointerType:
		// Pointer to array
		if arrType, ok := t.Base.(*ir.ArrayType); ok {
			elementType = arrType.Element
			elementSize = arrType.Element.Size()
			tableSize = arrType.Length
		} else {
			return fmt.Errorf("loop requires array type, got pointer to %s", t.Base.String())
		}
	default:
		return fmt.Errorf("loop requires array type, got %s", tableType.String())
	}
	
	// Generate loop labels
	startLabel := a.generateLabel("loop_start")
	endLabel := a.generateLabel("loop_end")
	
	// Allocate registers for loop control
	ptrReg := irFunc.AllocReg()      // Current element pointer
	endReg := irFunc.AllocReg()      // End pointer
	countReg := irFunc.AllocReg()    // Loop counter (for DJNZ)
	
	// Load table base address
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpLoadAddr,
		Dest:    ptrReg,
		Src1:    tableReg,
		Comment: "Load table base address",
	})
	
	// Calculate end address
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpLoadAddr,
		Dest:    endReg,
		Src1:    tableReg,
		Comment: "Load table base for end calculation",
	})
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpAddImm,
		Dest:    endReg,
		Src1:    endReg,
		Imm:     int64(tableSize * elementSize),
		Comment: fmt.Sprintf("Calculate table end (+ %d elements * %d bytes)", tableSize, elementSize),
	})
	
	// Load counter for DJNZ optimization
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpLoadImm,
		Dest:    countReg,
		Imm:     int64(tableSize),
		Comment: "Load loop counter",
	})
	
	// Create new scope for loop body
	loopScope := NewScope(a.currentScope)
	oldScope := a.currentScope
	a.currentScope = loopScope
	defer func() { a.currentScope = oldScope }()
	
	// Setup iterator variable based on mode
	if loop.Mode == ast.LoopInto {
		// INTO mode: Allocate static buffer
		bufferAddr := uint16(0xF000) // TODO: Make this configurable
		
		// Define iterator as a "virtual" variable pointing to buffer
		iteratorSym := &VarSymbol{
			Name:       loop.Iterator,
			Type:       elementType,
			Reg:        ir.Register(-1), // Special marker for static buffer
			IsMutable:  true,
			BufferAddr: bufferAddr,      // Store buffer address
		}
		a.currentScope.Define(loop.Iterator, iteratorSym)
		
		// Store buffer info in function metadata
		irFunc.SetMetadata("loop_buffer_addr", fmt.Sprintf("%d", bufferAddr))
		irFunc.SetMetadata("loop_element_size", fmt.Sprintf("%d", elementSize))
		
	} else {
		// REF TO mode: Iterator is a pointer
		iteratorSym := &VarSymbol{
			Name:      loop.Iterator,
			Type:      &ir.PointerType{Base: elementType},
			Reg:       ptrReg,
			IsMutable: false,
		}
		a.currentScope.Define(loop.Iterator, iteratorSym)
	}
	
	// Define index variable if present
	if loop.Index != "" {
		indexReg := irFunc.AllocReg()
		indexSym := &VarSymbol{
			Name:      loop.Index,
			Type:      &ir.BasicType{Kind: ir.TypeU8},
			Reg:       indexReg,
			IsMutable: false,
		}
		a.currentScope.Define(loop.Index, indexSym)
		
		// Initialize index to 0
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpLoadImm,
			Dest: indexReg,
			Imm:  0,
		})
	}
	
	// Loop start label
	irFunc.EmitLabel(startLabel)
	
	// Check if done (compare pointer with end)
	cmpReg := irFunc.AllocReg()
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpCmp,
		Dest:    cmpReg,
		Src1:    ptrReg,
		Src2:    endReg,
		Comment: "Check if reached end of table",
	})
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpJumpIf,
		Src1:    cmpReg,
		Label:   endLabel,
		Comment: "Exit if done",
	})
	
	// INTO mode: Copy element to buffer
	if loop.Mode == ast.LoopInto {
		bufferAddr := uint16(0xF000) // Same as above
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCopyToBuffer,
			Src1:    ptrReg,
			Imm:     int64(bufferAddr),
			Imm2:    int64(elementSize),
			Comment: fmt.Sprintf("Copy element to buffer at $%04X", bufferAddr),
		})
	}
	
	// Analyze loop body
	if err := a.analyzeBlock(loop.Body, irFunc); err != nil {
		return fmt.Errorf("error in loop body: %w", err)
	}
	
	// INTO mode: Copy buffer back if modified
	if loop.Mode == ast.LoopInto {
		bufferAddr := uint16(0xF000) // Same as above
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCopyFromBuffer,
			Dest:    ptrReg,
			Imm:     int64(bufferAddr),
			Imm2:    int64(elementSize),
			Comment: fmt.Sprintf("Copy buffer back to element at $%04X", bufferAddr),
		})
	}
	
	// Increment index if present
	if loop.Index != "" {
		indexSym := a.currentScope.Lookup(loop.Index).(*VarSymbol)
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpInc,
			Dest: indexSym.Reg,
			Src1: indexSym.Reg,
		})
	}
	
	// Advance pointer
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpAddImm,
		Dest:    ptrReg,
		Src1:    ptrReg,
		Imm:     int64(elementSize),
		Comment: fmt.Sprintf("Advance to next element (+%d bytes)", elementSize),
	})
	
	// Decrement counter and loop if not zero (DJNZ optimization)
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpDJNZ,
		Src1:    countReg,
		Label:   startLabel,
		Comment: "Decrement counter and loop if not zero",
	})
	
	// End label
	irFunc.EmitLabel(endLabel)
	
	return nil
}

// analyzeDoTimesStmt analyzes a "do N times" statement
func (a *Analyzer) analyzeDoTimesStmt(stmt *ast.DoTimesStmt, irFunc *ir.Function) error {
	// Analyze count expression
	countReg, err := a.analyzeExpression(stmt.Count, irFunc)
	if err != nil {
		return fmt.Errorf("invalid count expression: %w", err)
	}
	
	// Generate labels
	loopLabel := a.generateLabel("do_times")
	endLabel := a.generateLabel("do_end")
	
	// Allocate counter register
	counterReg := irFunc.AllocReg()
	
	// Initialize counter with count value
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpMove,
		Dest:    counterReg,
		Src1:    countReg,
		Comment: "Initialize loop counter",
	})
	
	// Check if count is zero (skip loop entirely)
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpJumpIfZero,
		Src1:    counterReg,
		Symbol:  endLabel,
		Comment: "Skip if count is zero",
	})
	
	// Loop start label
	irFunc.EmitLabel(loopLabel)
	
	// Analyze loop body
	if err := a.analyzeStatement(stmt.Body, irFunc); err != nil {
		return err
	}
	
	// Decrement counter and loop if not zero
	// This pattern will be optimized to DJNZ in code generation
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpDec,
		Dest:    counterReg,
		Src1:    counterReg,
		Comment: "Decrement counter",
	})
	
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpJumpIfNotZero,
		Src1:    counterReg,
		Symbol:  loopLabel,
		Comment: "Loop if counter not zero (DJNZ pattern)",
	})
	
	// End label
	irFunc.EmitLabel(endLabel)
	
	return nil
}

// analyzeLoopAtStmt analyzes a loop at array -> item statement
func (a *Analyzer) analyzeLoopAtStmt(stmt *ast.LoopAtStmt, irFunc *ir.Function) error {
	// Analyze the array/table expression
	arrayReg, err := a.analyzeExpression(stmt.Table, irFunc)
	if err != nil {
		return fmt.Errorf("invalid array expression: %w", err)
	}
	
	// Get array type information from the symbol table
	var arrayType ir.Type
	if ident, ok := stmt.Table.(*ast.Identifier); ok {
		// Look up the identifier in the symbol table
		sym := a.currentScope.Lookup(ident.Name)
		if sym == nil {
			// Try with module prefix
			prefixedName := a.prefixSymbol(ident.Name)
			sym = a.currentScope.Lookup(prefixedName)
			if sym == nil {
				return fmt.Errorf("undefined array variable: %s", ident.Name)
			}
		}
		
		if varSym, ok := sym.(*VarSymbol); ok {
			arrayType = varSym.Type
		} else {
			return fmt.Errorf("loop at requires a variable, got %T", sym)
		}
	} else {
		return fmt.Errorf("loop at currently only supports simple variable references")
	}
	
	// Verify it's an array type
	var elementType ir.Type
	var arraySize int
	switch t := arrayType.(type) {
	case *ir.ArrayType:
		elementType = t.Element
		arraySize = t.Length
	default:
		return fmt.Errorf("loop at requires an array type, got %T", arrayType)
	}
	
	// Generate labels
	loopLabel := a.generateLabel("loop_at")
	endLabel := a.generateLabel("loop_end")
	
	// Allocate registers for iteration
	indexReg := irFunc.AllocReg()     // Current index (counter)
	baseReg := irFunc.AllocReg()      // Array base address
	workAreaReg := irFunc.AllocReg()  // Work area for current element
	
	// Get array base address (for now, assume array is at arrayReg)
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpMove,
		Dest:    baseReg,
		Src1:    arrayReg,
		Comment: "Get array base address",
	})
	
	// Initialize index to array size (we'll decrement down to 0)
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpLoadImm,
		Dest:    indexReg,
		Imm:     int64(arraySize),
		Comment: "Initialize index to array size",
	})
	
	// Check if array is empty (skip loop entirely)
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpJumpIfZero,
		Src1:    indexReg,
		Symbol:  endLabel,
		Comment: "Skip if array is empty",
	})
	
	// Loop start label
	irFunc.EmitLabel(loopLabel)
	
	// Decrement index first (so we go from size-1 down to 0)
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpDec,
		Dest:    indexReg,
		Src1:    indexReg,
		Comment: "Decrement index",
	})
	
	// Calculate element address: base + (index * element_size)
	// For now, assume 1-byte elements, will be optimized later
	elementSize := a.getTypeSize(elementType)
	if elementSize > 1 {
		// Need to multiply index by element size
		offsetReg := irFunc.AllocReg()
		sizeReg := irFunc.AllocReg()
		
		// Load element size into register
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpLoadImm,
			Dest:    sizeReg,
			Imm:     int64(elementSize),
			Comment: "Load element size",
		})
		
		// Multiply index by element size
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpMul,
			Dest:    offsetReg,
			Src1:    indexReg,
			Src2:    sizeReg,
			Comment: "Calculate element offset",
		})
		
		// Add to base address
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpAdd,
			Dest:    workAreaReg,
			Src1:    baseReg,
			Src2:    offsetReg,
			Comment: "Calculate element address",
		})
	} else {
		// Simple case: 1-byte elements
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpAdd,
			Dest:    workAreaReg,
			Src1:    baseReg,
			Src2:    indexReg,
			Comment: "Calculate element address",
		})
	}
	
	// Load element into work area (for now, just use the address)
	// In a full implementation, this would copy the element data
	
	// Create a new scope for the loop body with the iterator variable
	a.currentScope = NewScope(a.currentScope)
	defer func() {
		a.currentScope = a.currentScope.parent
	}()
	
	// Add iterator variable to scope
	iteratorSym := &VarSymbol{
		Name:      stmt.Iterator,
		Type:      elementType,
		Reg:       workAreaReg,
		IsMutable: stmt.IsModifying, // Only mutable if ! modifier is used
	}
	a.currentScope.Define(stmt.Iterator, iteratorSym)
	
	// Analyze loop body
	if err := a.analyzeStatement(stmt.Body, irFunc); err != nil {
		return err
	}
	
	// If modifying (!), write back the work area to the array
	if stmt.IsModifying {
		// TODO: Implement write-back logic
		// For now, add a comment indicating where write-back would happen
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpNop,
			Comment: "TODO: Write back modified element",
		})
	}
	
	// Loop if index not zero (DJNZ pattern)
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpJumpIfNotZero,
		Src1:    indexReg,
		Symbol:  loopLabel,
		Comment: "Loop if more elements (DJNZ pattern)",
	})
	
	// End label
	irFunc.EmitLabel(endLabel)
	
	return nil
}

// getTypeSize returns the size in bytes of a type
func (a *Analyzer) getTypeSize(t ir.Type) int {
	switch typ := t.(type) {
	case *ir.BasicType:
		switch typ.Kind {
		case ir.TypeU8, ir.TypeI8, ir.TypeBool:
			return 1
		case ir.TypeU16, ir.TypeI16:
			return 2
		default:
			return 1 // Default to 1 byte
		}
	case *ir.ArrayType:
		return a.getTypeSize(typ.Element) * typ.Length
	case *ir.PointerType:
		return 2 // Pointers are 16-bit on Z80
	default:
		return 1 // Default fallback
	}
}

// analyzeExpression analyzes an expression and returns the register containing the result
func (a *Analyzer) analyzeExpression(expr ast.Expression, irFunc *ir.Function) (ir.Register, error) {
	// Handle nil expressions
	if expr == nil {
		return 0, fmt.Errorf("unsupported expression type: <nil>")
	}
	
	// Debug: print expression type
	if fieldExpr, ok := expr.(*ast.FieldExpr); ok {
		if id, ok := fieldExpr.Object.(*ast.Identifier); ok && id.Name == "screen" {
			// This is a screen.X expression - should be handled by analyzeFieldExpr
		}
	}
	
	if debug {
		fmt.Printf("DEBUG: analyzeExpression called with type: %T\n", expr)
	}
	
	switch e := expr.(type) {
	case *ast.Identifier:
		return a.analyzeIdentifier(e, irFunc)
	case *ast.NumberLiteral:
		return a.analyzeNumberLiteral(e, irFunc)
	case *ast.BooleanLiteral:
		return a.analyzeBooleanLiteral(e, irFunc)
	case *ast.BinaryExpr:
		return a.analyzeBinaryExpr(e, irFunc)
	case *ast.UnaryExpr:
		return a.analyzeUnaryExpr(e, irFunc)
	case *ast.CallExpr:
		return a.analyzeCallExpr(e, irFunc)
	case *ast.StructLiteral:
		return a.analyzeStructLiteral(e, irFunc)
	case *ast.FieldExpr:
		return a.analyzeFieldExpr(e, irFunc)
	case *ast.IndexExpr:
		return a.analyzeIndexExpr(e, irFunc)
	case *ast.EnumLiteral:
		return a.analyzeEnumLiteral(e, irFunc)
	case *ast.LuaExpression:
		return a.analyzeLuaExpression(e, irFunc)
	case *ast.StringLiteral:
		return a.analyzeStringLiteral(e, irFunc)
	case *ast.ArrayInitializer:
		return a.analyzeArrayInitializer(e, irFunc)
	case *ast.InlineAssembly:
		// Inline assembly expressions
		return a.analyzeInlineAssembly(e, irFunc)
	case *ast.CastExpr:
		return a.analyzeCastExpr(e, irFunc)
	case *ast.CompileTimePrint:
		return a.analyzePrintExpr(e, irFunc)
	case *ast.CompileTimeMinz:
		return a.analyzeMinzExpr(e, irFunc)
	case *ast.CompileTimeMIR:
		return a.analyzeMIRExpr(e, irFunc)
	case *ast.CompileTimeIf:
		return a.analyzeCompileTimeIf(e, irFunc)
	case *ast.CompileTimeError:
		return a.analyzeErrorExpr(e, irFunc)
	case *ast.MetafunctionCall:
		return a.analyzeMetafunctionCall(e, irFunc)
	case *ast.MinzMetafunctionCall:
		return a.analyzeMinzMetafunctionCall(e, irFunc)
	case *ast.LambdaExpr:
		return a.analyzeLambdaExpr(e, irFunc)
	case *ast.IteratorChainExpr:
		return a.analyzeIteratorChainExpr(e, irFunc)
	case *ast.NilCoalescingExpr:
		return a.analyzeNilCoalescingExpr(e, irFunc)
	case *ast.IfExpr:
		return a.analyzeIfExpr(e, irFunc)
	case *ast.TernaryExpr:
		return a.analyzeTernaryExpr(e, irFunc)
	case *ast.WhenExpr:
		return a.analyzeWhenExpr(e, irFunc)
	case *ast.TryExpr:
		return a.analyzeTryExpr(e, irFunc)
	case *ast.BlockStmt:
		return a.analyzeBlockExpression(e, irFunc)
	case *ast.CaseExpr:
		return a.analyzeCaseExpr(e, irFunc)
	default:
		return 0, fmt.Errorf("unsupported expression type: %T", expr)
	}
}

// analyzeInlineAssembly analyzes inline assembly
func (a *Analyzer) analyzeInlineAssembly(asm *ast.InlineAssembly, irFunc *ir.Function) (ir.Register, error) {
	// Create an IR instruction for inline assembly
	inst := &ir.Instruction{
		Op:      ir.OpAsm,
		AsmCode: asm.Code,
	}
	
	// Process input operands
	for _, input := range asm.Inputs {
		// Analyze the input expression
		reg, err := a.analyzeExpression(input.Expr, irFunc)
		if err != nil {
			return 0, fmt.Errorf("failed to analyze inline assembly input: %w", err)
		}
		
		// For now, we'll store the register in the instruction
		// In a full implementation, we'd need to handle constraints properly
		if inst.Src1 == 0 {
			inst.Src1 = reg
		} else if inst.Src2 == 0 {
			inst.Src2 = reg
		}
	}
	
	// Process output operands
	var outputReg ir.Register
	for range asm.Outputs {
		// For outputs, we need to allocate a register
		outputReg = irFunc.NextRegister
		irFunc.NextRegister++
		
		// Store the output register
		if inst.Dest == 0 {
			inst.Dest = outputReg
		}
	}
	
	// Add the instruction
	irFunc.Instructions = append(irFunc.Instructions, *inst)
	
	// Return the output register if any, otherwise 0
	return outputReg, nil
}

// analyzeIdentifier analyzes an identifier
func (a *Analyzer) analyzeIdentifier(id *ast.Identifier, irFunc *ir.Function) (ir.Register, error) {
	
	// First try direct lookup
	sym := a.currentScope.Lookup(id.Name)
	
	// If not found, try with module prefix
	if sym == nil && a.currentModule != "" {
		// Try with module prefix
		prefixedName := a.prefixSymbol(id.Name)
		sym = a.currentScope.Lookup(prefixedName)
	}
	
	// If not found and name contains a dot, it might be a module reference
	if sym == nil && strings.Contains(id.Name, ".") {
		// Try looking up the full dotted name
		sym = a.currentScope.Lookup(id.Name)
	}
	
	if sym == nil {
		
		// Provide helpful error messages for common mistakes
		if id.Name == "screen" {
			return 0, fmt.Errorf("undefined identifier '%s' - did you mean to import a screen module?", id.Name)
		}
		
		// Suggest similar identifiers if available
		suggestions := a.findSimilarIdentifiers(id.Name)
		if len(suggestions) > 0 {
			return 0, fmt.Errorf("undefined identifier '%s' - did you mean '%s'?", id.Name, suggestions[0])
		}
		
		return 0, fmt.Errorf("undefined identifier '%s'", id.Name)
	}

	switch s := sym.(type) {
	case *ModuleSymbol:
		// Module identifiers are not values - they're only used in field expressions
		return 0, fmt.Errorf("module %s cannot be used as a value", s.Name)
	case *VarSymbol:
		// Store the type for later use
		a.exprTypes[id] = s.Type
		
		// Load variable value
		reg := irFunc.AllocReg()
		
		// Check if this is a parameter in an SMC function
		if s.IsParameter && irFunc.IsSMCDefault {
			// Find the parameter index
			paramIndex := -1
			for i, param := range irFunc.Params {
				if param.Name == s.Name {
					paramIndex = i
					break
				}
			}
			
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:     ir.OpLoadParam,
				Dest:   reg,
				Src1:   ir.Register(paramIndex), // Store parameter index in Src1
				Symbol: s.Name, // Use the symbol's actual name (prefixed)
				Type:   s.Type,
			})
		} else {
			// Check if this is an array type
			if arrayType, isArray := s.Type.(*ir.ArrayType); isArray {
				// For arrays, we need to load the address, not the value
				// Check if this is a global array
				isGlobal := false
				for _, global := range a.module.Globals {
					if global.Name == s.Name {
						isGlobal = true
						break
					}
				}
				
				if isGlobal {
					// For global arrays, load the address directly
					irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
						Op:     ir.OpLoadAddr,
						Dest:   reg,
						Symbol: s.Name,
						Type:   arrayType,
					})
				} else {
					// For local arrays, use regular load
					irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
						Op:     ir.OpLoadVar,
						Dest:   reg,
						Symbol: s.Name,
					})
				}
			} else {
				// Regular variable load
				irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
					Op:     ir.OpLoadVar,
					Dest:   reg,
					Symbol: s.Name, // Use the symbol's actual name (prefixed)
				})
			}
		}
		return reg, nil
	case *ConstSymbol:
		// Store the type for later use
		a.exprTypes[id] = s.Type
		
		// Load constant value
		reg := irFunc.AllocReg()
		
		// Handle different constant value types
		switch v := s.Value.(type) {
		case int64:
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:   ir.OpLoadConst,
				Dest: reg,
				Imm:  v,
				Type: s.Type,
			})
		case bool:
			val := int64(0)
			if v {
				val = 1
			}
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:   ir.OpLoadConst,
				Dest: reg,
				Imm:  val,
				Type: s.Type,
			})
		case string:
			// For string constants, create a string literal and load its address
			stringLabel := fmt.Sprintf("str_%d", len(a.module.Strings))
			a.module.Strings = append(a.module.Strings, &ir.String{
				Label: stringLabel,
				Value: v,
				IsLong: len(v) > 255,
			})
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:      ir.OpLoadString,
				Dest:    reg,
				Symbol:  stringLabel,
				Type:    s.Type,
			})
		default:
			return 0, fmt.Errorf("unsupported constant value type: %T", v)
		}
		return reg, nil
	case *FuncSymbol:
		// Function identifiers can only be used with address-of operator
		// Return a special marker register that will be handled by OpAddr
		reg := irFunc.AllocReg()
		// Store the function symbol for address-of handling
		if s.Type != nil {
			a.exprTypes[id] = s.Type
		} else {
			// Create a basic function type if not available
			a.exprTypes[id] = &ir.FunctionType{
				Params: []ir.Type{},
				Return: s.ReturnType,
			}
		}
		// Mark this register as holding a function reference
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpLoadLabel,
			Dest:    reg,
			Symbol:  s.Name,
			Comment: fmt.Sprintf("Function reference: %s", s.Name),
		})
		return reg, nil
	default:
		return 0, fmt.Errorf("cannot use %s as value", id.Name)
	}
}

// analyzeNumberLiteral analyzes a number literal
func (a *Analyzer) analyzeNumberLiteral(num *ast.NumberLiteral, irFunc *ir.Function) (ir.Register, error) {
	reg := irFunc.AllocReg()
	
	// Infer type based on value
	var numType ir.Type
	if num.Value >= 0 && num.Value <= 255 {
		numType = &ir.BasicType{Kind: ir.TypeU8}
	} else if num.Value >= -128 && num.Value <= 127 {
		numType = &ir.BasicType{Kind: ir.TypeI8}
	} else if num.Value >= 0 && num.Value <= 65535 {
		numType = &ir.BasicType{Kind: ir.TypeU16}
	} else {
		numType = &ir.BasicType{Kind: ir.TypeI16}
	}
	
	// Store the type
	a.exprTypes[num] = numType
	
	// Emit typed instruction
	inst := ir.Instruction{
		Op:   ir.OpLoadConst,
		Dest: reg,
		Imm:  num.Value,
		Type: numType,
	}
	irFunc.Instructions = append(irFunc.Instructions, inst)
	
	return reg, nil
}

// analyzeBooleanLiteral analyzes a boolean literal
func (a *Analyzer) analyzeBooleanLiteral(b *ast.BooleanLiteral, irFunc *ir.Function) (ir.Register, error) {
	reg := irFunc.AllocReg()
	val := int64(0)
	if b.Value {
		val = 1
	}
	irFunc.EmitImm(ir.OpLoadConst, reg, val)
	return reg, nil
}

// analyzeBinaryExpr analyzes a binary expression
func (a *Analyzer) analyzeBinaryExpr(bin *ast.BinaryExpr, irFunc *ir.Function) (ir.Register, error) {
	// Check if this is an assignment first (including compound assignments)
	if bin.Operator == "=" {
		// Assignment is handled specially - don't analyze operands here
		return a.analyzeAssignment(bin, irFunc)
	}
	if bin.Operator == "+=" || bin.Operator == "-=" || bin.Operator == "*=" || 
	   bin.Operator == "/=" || bin.Operator == "%=" {
		// Compound assignment is handled specially
		return a.analyzeCompoundAssignment(bin, irFunc)
	}
	
	// Analyze operands
	leftReg, err := a.analyzeExpression(bin.Left, irFunc)
	if err != nil {
		return 0, err
	}

	rightReg, err := a.analyzeExpression(bin.Right, irFunc)
	if err != nil {
		return 0, err
	}

	// Generate operation
	resultReg := irFunc.AllocReg()
	var op ir.Opcode

	switch bin.Operator {
	case "+":
		op = ir.OpAdd
	case "-":
		op = ir.OpSub
	case "*":
		op = ir.OpMul
	case "/":
		op = ir.OpDiv
	case "%":
		op = ir.OpMod
	case "==":
		op = ir.OpEq
	case "!=":
		op = ir.OpNe
	case "<":
		op = ir.OpLt
	case ">":
		op = ir.OpGt
	case "<=":
		op = ir.OpLe
	case ">=":
		op = ir.OpGe
	case "&":
		op = ir.OpAnd
	case "|":
		op = ir.OpOr
	case "^":
		op = ir.OpXor
	case "<<":
		op = ir.OpShl
	case ">>":
		op = ir.OpShr
	case "&&", "and":
		op = ir.OpLogicalAnd
	case "||", "or":
		op = ir.OpLogicalOr
	case "??":
		// Nil coalescing operator - if left is error/nil, return right, else return left
		// This sets up the error propagation context for @error()
		leftType := a.exprTypes[bin.Left]
		a.enterErrorPropagationContext(rightReg, leftType)
		defer a.exitErrorPropagationContext()
		
		// For now, just implement as: left ?? right = right
		// This allows @error() to work in the right-hand expression
		// TODO: Implement proper nil/error checking when error types are fully implemented
		
		// Simply return the right value for now
		// This makes the ?? operator work as a context marker for @error()
		return rightReg, nil
	default:
		return 0, fmt.Errorf("unsupported binary operator: %s", bin.Operator)
	}

	// Determine result type
	leftType := a.exprTypes[bin.Left]
	rightType := a.exprTypes[bin.Right]
	
	// For now, use the left operand's type as the result type
	// TODO: Implement proper type promotion rules
	resultType := leftType
	if resultType == nil && rightType != nil {
		resultType = rightType
	}
	
	// Store the result type
	a.exprTypes[bin] = resultType
	
	// Emit typed instruction
	if resultType != nil {
		irFunc.EmitTyped(op, resultReg, leftReg, rightReg, resultType)
	} else {
		irFunc.Emit(op, resultReg, leftReg, rightReg)
	}
	
	return resultReg, nil
}

// analyzeUnaryExpr analyzes a unary expression
func (a *Analyzer) analyzeUnaryExpr(un *ast.UnaryExpr, irFunc *ir.Function) (ir.Register, error) {
	// Analyze operand
	operandReg, err := a.analyzeExpression(un.Operand, irFunc)
	if err != nil {
		return 0, err
	}

	// Get operand type for result type inference
	operandType := a.exprTypes[un.Operand]

	// Generate operation
	resultReg := irFunc.AllocReg()

	switch un.Operator {
	case "-":
		irFunc.Emit(ir.OpNeg, resultReg, operandReg, 0)
		// Negation preserves the numeric type (i8 -> i8, u8 -> u8, etc.)
		if operandType != nil {
			a.exprTypes[un] = operandType
		}
	case "!":
		irFunc.Emit(ir.OpNot, resultReg, operandReg, 0)
		// Logical not always returns bool
		a.exprTypes[un] = &ir.BasicType{Kind: ir.TypeBool}
	case "~":
		// Bitwise not
		irFunc.Emit(ir.OpNot, resultReg, operandReg, 0)
		// Bitwise not preserves the type
		if operandType != nil {
			a.exprTypes[un] = operandType
		}
	case "&":
		// Address-of operator
		irFunc.Emit(ir.OpAddr, resultReg, operandReg, 0)
		// Address-of returns pointer to operand type
		if operandType != nil {
			a.exprTypes[un] = &ir.PointerType{Base: operandType}
		}
	case "*":
		// Dereference operator
		// First check that operand is a pointer type
		operandType := a.exprTypes[un.Operand]
		if operandType == nil {
			return 0, fmt.Errorf("cannot determine type of expression to dereference")
		}
		ptrType, ok := operandType.(*ir.PointerType)
		if !ok {
			return 0, fmt.Errorf("cannot dereference non-pointer type: %s", operandType.String())
		}
		// Set the result type to the pointed-to type
		a.exprTypes[un] = ptrType.Base
		// Emit load through pointer with type information
		irFunc.EmitTyped(ir.OpLoad, resultReg, operandReg, 0, ptrType.Base)
	default:
		return 0, fmt.Errorf("unsupported unary operator: %s", un.Operator)
	}

	return resultReg, nil
}

// analyzeAssignment analyzes an assignment expression
func (a *Analyzer) analyzeAssignment(bin *ast.BinaryExpr, irFunc *ir.Function) (ir.Register, error) {
	// Analyze the right-hand side first
	valueReg, err := a.analyzeExpression(bin.Right, irFunc)
	if err != nil {
		return 0, err
	}
	
	// Handle different types of assignment targets
	switch target := bin.Left.(type) {
	case *ast.Identifier:
		// Simple variable assignment
		sym := a.currentScope.Lookup(target.Name)
		if sym == nil {
			// Try with module prefix
			prefixedName := a.prefixSymbol(target.Name)
			sym = a.currentScope.Lookup(prefixedName)
			if sym == nil {
				return 0, fmt.Errorf("undefined variable: %s", target.Name)
			}
			target.Name = prefixedName
		}
		
		// Check if variable is mutable (unless it's a pointer that will be auto-deref'd)
		varSym := sym.(*VarSymbol)
		
		// First check if this is a TSMC reference parameter
		isTSMCRef := a.isTSMCReference(varSym, irFunc)
		
		// Check if this is a pointer that needs auto-dereferencing
		// But NOT if it's a TSMC reference (those are special)
		needsAutoDeref := false
		if !isTSMCRef {
			if ptrType, ok := varSym.Type.(*ir.PointerType); ok {
				// Check if the value type matches the pointed-to type
				valueType := a.exprTypes[bin.Right]
				if valueType != nil && a.typesCompatible(ptrType.Base, valueType) {
					needsAutoDeref = true
				} else if valueType == nil {
					// If we couldn't determine the type, check if it's a literal that matches
					if _, ok := bin.Right.(*ast.NumberLiteral); ok {
						// Number literal being assigned to pointer - auto-deref
						needsAutoDeref = true
					}
				}
			}
		}
		
		if needsAutoDeref {
			// Auto-deref: p = 42 becomes *p = 42
			// Get the pointer value
			ptrReg := varSym.Reg
			if !varSym.IsParameter {
				// For local variables, need to load first
				ptrReg = irFunc.AllocReg()
				irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
					Op:     ir.OpLoadVar,
					Dest:   ptrReg,
					Symbol: target.Name,
				})
			}
			
			// Then store through the pointer
			ptrType := varSym.Type.(*ir.PointerType)
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:      ir.OpStore,
				Dest:    ptrReg,
				Src1:    valueReg,
				Type:    ptrType.Base,
				Comment: "Auto-deref assignment",
			})
			
			// Assignment expressions return the assigned value
			return valueReg, nil
		}
		
		// Check mutability for regular assignments
		if !varSym.IsMutable && !isTSMCRef {
			return 0, fmt.Errorf("cannot assign to immutable variable: %s", target.Name)
		}
		
		if isTSMCRef {
			// For TSMC references, we need to update the immediate operand
			a.analyzeTSMCAssignment(target.Name, valueReg, irFunc)
		} else {
			// Regular variable store
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:     ir.OpStoreVar,
				Dest:   varSym.Reg,
				Src1:   valueReg,
				Symbol: target.Name, // Keep for debugging
			})
		}
		
		// Assignment expressions return the assigned value
		return valueReg, nil
		
	case *ast.IndexExpr:
		// Array element assignment
		// Analyze the array expression
		arrayReg, err := a.analyzeExpression(target.Array, irFunc)
		if err != nil {
			return 0, err
		}
		
		// Analyze the index expression
		indexReg, err := a.analyzeExpression(target.Index, irFunc)
		if err != nil {
			return 0, err
		}
		
		// Get the type of the array to validate and get element type
		arrayType, err := a.inferType(target.Array)
		if err != nil {
			return 0, fmt.Errorf("cannot determine array type: %v", err)
		}
		
		// Validate that it's an array or pointer type
		var elementType ir.Type
		switch t := arrayType.(type) {
		case *ir.ArrayType:
			elementType = t.Element
		case *ir.PointerType:
			// For pointers, assume they point to u8 (byte arrays)
			elementType = &ir.BasicType{Kind: ir.TypeU8}
		default:
			return 0, fmt.Errorf("cannot index non-array type %s", arrayType)
		}
		
		// Type check the value against the element type
		valueType, err := a.inferType(bin.Right)
		if err != nil {
			return 0, fmt.Errorf("cannot determine value type: %v", err)
		}
		
		if !a.typesCompatible(elementType, valueType) {
			return 0, fmt.Errorf("type mismatch: array element is %s, value is %s", elementType, valueType)
		}
		
		// Generate IR using two instructions approach
		// First, calculate the address (array + index)
		tempReg := irFunc.AllocReg()
		
		// For byte arrays, index is already the offset
		// For larger elements, we'd need to multiply by element size
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpAdd,
			Dest: tempReg,
			Src1: arrayReg,
			Src2: indexReg,
			Type: &ir.PointerType{Base: elementType},
			Comment: "Calculate array element address",
		})
		
		// Store the value at the calculated address using pointer store
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpStorePtr,
			Src1: tempReg, // address in Src1
			Src2: valueReg, // value in Src2
			Type: elementType,
			Comment: fmt.Sprintf("Store to array[index] (%s)", elementType),
		})
		
		// Assignment expressions return the assigned value
		return valueReg, nil
		
	case *ast.FieldExpr:
		// Struct field assignment
		objReg, err := a.analyzeExpression(target.Object, irFunc)
		if err != nil {
			return 0, fmt.Errorf("error analyzing field object: %v", err)
		}
		
		// Get the object type
		objType := a.exprTypes[target.Object]
		
		// Check if it's a bit struct
		if bitStructType, ok := objType.(*ir.BitStructType); ok {
			// Handle bit field assignment
			bitField, exists := bitStructType.Fields[target.Field]
			if !exists {
				return 0, fmt.Errorf("bit struct has no field %s", target.Field)
			}
			
			// Generate bit field store instruction
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:      ir.OpStoreBitField,
				Src1:    objReg,
				Src2:    valueReg,
				Imm:     int64(bitField.BitOffset),
				Imm2:    int64(bitField.BitWidth),
				Type:    bitStructType.UnderlyingType,
				Comment: fmt.Sprintf("Store bit field %s (offset %d, width %d)", target.Field, bitField.BitOffset, bitField.BitWidth),
			})
			
			// Assignment expressions return the assigned value
			return valueReg, nil
		}
		
		// Handle regular struct types
		var structType *ir.StructType
		
		// Handle both direct struct and pointer to struct
		switch t := objType.(type) {
		case *ir.StructType:
			structType = t
		case *ir.PointerType:
			if st, ok := t.Base.(*ir.StructType); ok {
				structType = st
			} else {
				return 0, fmt.Errorf("field access on non-struct pointer")
			}
		default:
			return 0, fmt.Errorf("field access on non-struct type: %T", objType)
		}
		
		// Find field offset
		offset := 0
		found := false
		for _, fname := range structType.FieldOrder {
			if fname == target.Field {
				found = true
				break
			}
			offset += structType.Fields[fname].Size()
		}
		
		if !found {
			// Debug: print available fields
			availableFields := []string{}
			for _, fname := range structType.FieldOrder {
				availableFields = append(availableFields, fname)
			}
			return 0, fmt.Errorf("struct %s has no field %s (available: %v)", structType.Name, target.Field, availableFields)
		}
		
		// Generate store field instruction
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpStoreField,
			Src1:    objReg,     // struct pointer
			Src2:    valueReg,   // value to store
			Imm:     int64(offset),
			Type:    structType.Fields[target.Field],
			Comment: fmt.Sprintf("Store to field %s (offset %d)", target.Field, offset),
		})
		
		// Assignment expressions return the assigned value
		return valueReg, nil
		
	case *ast.UnaryExpr:
		// Handle pointer dereference assignment (*ptr = value)
		if target.Operator != "*" {
			return 0, fmt.Errorf("invalid assignment target: unary %s", target.Operator)
		}
		
		// Analyze the pointer expression
		ptrReg, err := a.analyzeExpression(target.Operand, irFunc)
		if err != nil {
			return 0, err
		}
		
		// Verify it's a pointer type
		ptrType, err := a.inferType(target.Operand)
		if err != nil {
			return 0, fmt.Errorf("cannot determine type of pointer expression: %v", err)
		}
		
		ptr, ok := ptrType.(*ir.PointerType)
		if !ok {
			return 0, fmt.Errorf("cannot dereference non-pointer type: %s", ptrType.String())
		}
		
		// Type check the value against the pointed-to type
		valueType, err := a.inferType(bin.Right)
		if err != nil {
			return 0, fmt.Errorf("cannot determine type of value: %v", err)
		}
		
		if !a.typesCompatible(ptr.Base, valueType) {
			return 0, fmt.Errorf("type mismatch: cannot assign %s to %s", 
				valueType.String(), ptr.Base.String())
		}
		
		// Generate store through pointer instruction
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpStore,
			Src1:    ptrReg,     // pointer
			Src2:    valueReg,   // value to store
			Type:    ptr.Base,
			Comment: "Store through pointer",
		})
		
		// Assignment expressions return the assigned value
		return valueReg, nil
		
	case *ast.BinaryExpr:
		// Handle pointer field access assignment (ptr->field = value)
		if target.Operator != "->" {
			return 0, fmt.Errorf("unsupported binary assignment target: %s", target.Operator)
		}
		
		// Analyze the pointer expression
		ptrReg, err := a.analyzeExpression(target.Left, irFunc)
		if err != nil {
			return 0, fmt.Errorf("error analyzing pointer in field access: %v", err)
		}
		
		// Get the field name
		fieldExpr, ok := target.Right.(*ast.Identifier)
		if !ok {
			return 0, fmt.Errorf("right side of -> must be an identifier, got %T", target.Right)
		}
		
		// Verify the left side is a pointer type
		ptrType, err := a.inferType(target.Left)
		if err != nil {
			return 0, fmt.Errorf("cannot determine type of pointer expression: %v", err)
		}
		
		ptr, ok := ptrType.(*ir.PointerType)
		if !ok {
			return 0, fmt.Errorf("left side of -> must be a pointer, got %s", ptrType.String())
		}
		
		// Verify the pointed-to type is a struct
		structType, ok := ptr.Base.(*ir.StructType)
		if !ok {
			return 0, fmt.Errorf("cannot access field of non-struct type: %s", ptr.Base.String())
		}
		
		// Find field offset
		fieldName := fieldExpr.Name
		offset := 0
		found := false
		var fieldType ir.Type
		
		for _, fname := range structType.FieldOrder {
			if fname == fieldName {
				found = true
				fieldType = structType.Fields[fname]
				break
			}
			offset += structType.Fields[fname].Size()
		}
		
		if !found {
			availableFields := []string{}
			for _, fname := range structType.FieldOrder {
				availableFields = append(availableFields, fname)
			}
			return 0, fmt.Errorf("struct %s has no field %s (available: %v)", structType.Name, fieldName, availableFields)
		}
		
		// Type check the value against the field type
		valueType, err := a.inferType(bin.Right)
		if err != nil {
			return 0, fmt.Errorf("cannot determine type of value: %v", err)
		}
		
		if !a.typesCompatible(fieldType, valueType) {
			return 0, fmt.Errorf("type mismatch: field %s is %s, value is %s", fieldName, fieldType.String(), valueType.String())
		}
		
		// Generate pointer field store instruction
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpStoreField,
			Src1:    ptrReg,     // pointer to struct
			Src2:    valueReg,   // value to store
			Imm:     int64(offset),
			Type:    fieldType,
			Comment: fmt.Sprintf("Store to ptr->%s (offset %d)", fieldName, offset),
		})
		
		// Assignment expressions return the assigned value
		return valueReg, nil
		
	default:
		return 0, fmt.Errorf("unsupported assignment target: %T", target)
	}
}

// analyzeCompoundAssignment analyzes compound assignment expressions (+=, -=, etc)
func (a *Analyzer) analyzeCompoundAssignment(bin *ast.BinaryExpr, irFunc *ir.Function) (ir.Register, error) {
	// Compound assignment: x += y is equivalent to x = x + y
	// But we need to evaluate the left side only once (important for array/field access)
	
	// Get the base operator (+ from +=, - from -=, etc)
	baseOp := bin.Operator[:len(bin.Operator)-1]  // Remove '='
	
	// Only support simple variable targets for now
	target, ok := bin.Left.(*ast.Identifier)
	if !ok {
		return 0, fmt.Errorf("compound assignment only supports simple variables, got %T", bin.Left)
	}
	
	// Look up the variable
	sym := a.currentScope.Lookup(target.Name)
	if sym == nil {
		// Try with module prefix
		prefixedName := a.prefixSymbol(target.Name)
		sym = a.currentScope.Lookup(prefixedName)
		if sym == nil {
			return 0, fmt.Errorf("undefined variable: %s", target.Name)
		}
		target.Name = prefixedName
	}
	
	varSym := sym.(*VarSymbol)
	
	// Check mutability
	if !varSym.IsMutable {
		return 0, fmt.Errorf("cannot assign to immutable variable: %s", target.Name)
	}
	
	// Analyze the right-hand side
	rightReg, err := a.analyzeExpression(bin.Right, irFunc)
	if err != nil {
		return 0, err
	}
	
	// Load the current value of the variable
	currentReg := irFunc.AllocReg()
	if varSym.IsParameter {
		// Parameter values are already in registers
		currentReg = varSym.Reg
	} else {
		// Local variables need OpLoadVar
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:     ir.OpLoadVar,
			Dest:   currentReg,
			Symbol: target.Name,
		})
	}
	
	// Perform the operation
	resultReg := irFunc.AllocReg()
	var op ir.Opcode
	switch baseOp {
	case "+":
		op = ir.OpAdd
	case "-":
		op = ir.OpSub
	case "*":
		op = ir.OpMul
	case "/":
		op = ir.OpDiv
	case "%":
		op = ir.OpMod
	default:
		return 0, fmt.Errorf("unsupported compound assignment operator: %s", bin.Operator)
	}
	
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   op,
		Dest: resultReg,
		Src1: currentReg,
		Src2: rightReg,
		Type: varSym.Type,
		Comment: fmt.Sprintf("Compound assignment %s %s", target.Name, bin.Operator),
	})
	
	// Store the result back to the variable
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:     ir.OpStoreVar,
		Dest:   varSym.Reg,
		Src1:   resultReg,
		Symbol: target.Name,
	})
	
	// Compound assignment expressions return the new value
	return resultReg, nil
}

// analyzeCallExpr analyzes a function call
// buildQualifiedName builds a qualified name from a field expression chain
func (a *Analyzer) buildQualifiedName(expr ast.Expression) string {
	switch e := expr.(type) {
	case *ast.Identifier:
		return e.Name
	case *ast.FieldExpr:
		objName := a.buildQualifiedName(e.Object)
		if objName == "" {
			// If we can't get a name from the object (e.g., it's a CallExpr),
			// just return the field name without a dot
			return e.Field
		}
		return objName + "." + e.Field
	case *ast.CallExpr:
		// For call expressions, try to get the function name
		return a.buildQualifiedName(e.Function)
	default:
		return ""
	}
}

func (a *Analyzer) analyzeCallExpr(call *ast.CallExpr, irFunc *ir.Function) (ir.Register, error) {
	if debug {
		fmt.Printf("DEBUG: analyzeCallExpr called\n")
		fmt.Printf("  call.Function type: %T\n", call.Function)
		if call.Function != nil {
			if ident, ok := call.Function.(*ast.Identifier); ok {
				fmt.Printf("  Calling function: %s\n", ident.Name)
			}
		} else {
			fmt.Printf("  call.Function is nil!\n")
		}
	}
	var funcName string
	var sym Symbol
	var isMethodCall bool
	var methodReceiver ast.Expression
	
	switch fn := call.Function.(type) {
	case *ast.Identifier:
		// Direct function call
		funcName = fn.Name
		
		// First try to lookup without prefix (for local functions)
		sym = a.currentScope.Lookup(funcName)
		
		// If found and it's a local function, use it directly
		if sym != nil {
			if funcSym, ok := sym.(*FuncSymbol); ok && funcSym.IsLocalFunc {
				// Local function found, use its mangled name
				funcName = funcSym.Name
			}
		}
		
		// If not a local function, try overload resolution
		isLocalFunc := false
		if sym != nil {
			if funcSym, ok := sym.(*FuncSymbol); ok {
				isLocalFunc = funcSym.IsLocalFunc
			}
		}
		
		if sym == nil || !isLocalFunc {
			// Try to resolve overload first
			prefixedName := funcName
			if !strings.Contains(funcName, ".") {
				prefixedName = a.prefixSymbol(funcName)
			}
			
			// Try to resolve as an overloaded function
			funcSym, err := a.resolveOverload(prefixedName, call.Arguments, irFunc)
			if err == nil {
				sym = funcSym
				funcName = funcSym.Name  // Use the mangled name
			} else if sym == nil {
				// Fall back to simple lookup with prefix if not found
				sym = a.currentScope.Lookup(funcName)
			}
			
			// If not found, try with module prefix
			if sym == nil && a.currentModule != "" && a.currentModule != "main" {
				sym = a.currentScope.Lookup(prefixedName)
				if sym != nil {
					funcName = prefixedName
					// Update the AST node to use the prefixed name
					fn.Name = prefixedName
				}
			}
		}
		
		// Check if it's a builtin function
		if sym == nil {
			// Check builtin functions
			var funcType *ir.FunctionType
			switch funcName {
			case "memcpy":
				// memcpy(dest: *mut u8, src: *u8, size: u16)
				funcType = &ir.FunctionType{
					Params: []ir.Type{
						&ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}}, // dest
						&ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}}, // src
						&ir.BasicType{Kind: ir.TypeU16},                       // size
					},
					Return: &ir.BasicType{Kind: ir.TypeVoid},
				}
			case "memset":
				// memset(dest: *mut u8, value: u8, size: u16)
				funcType = &ir.FunctionType{
					Params: []ir.Type{
						&ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}}, // dest
						&ir.BasicType{Kind: ir.TypeU8},                        // value
						&ir.BasicType{Kind: ir.TypeU16},                       // size
					},
					Return: &ir.BasicType{Kind: ir.TypeVoid},
				}
			case "print_u8":
				// print_u8(value: u8)
				funcType = &ir.FunctionType{
					Params: []ir.Type{
						&ir.BasicType{Kind: ir.TypeU8}, // value
					},
					Return: &ir.BasicType{Kind: ir.TypeVoid},
				}
			case "print_i8":
				// print_i8(value: i8)
				funcType = &ir.FunctionType{
					Params: []ir.Type{
						&ir.BasicType{Kind: ir.TypeI8}, // value
					},
					Return: &ir.BasicType{Kind: ir.TypeVoid},
				}
			case "print_u16":
				// print_u16(value: u16)
				funcType = &ir.FunctionType{
					Params: []ir.Type{
						&ir.BasicType{Kind: ir.TypeU16}, // value
					},
					Return: &ir.BasicType{Kind: ir.TypeVoid},
				}
			case "print_i16":
				// print_i16(value: i16)
				funcType = &ir.FunctionType{
					Params: []ir.Type{
						&ir.BasicType{Kind: ir.TypeI16}, // value
					},
					Return: &ir.BasicType{Kind: ir.TypeVoid},
				}
			case "print_bool":
				// print_bool(value: bool)
				funcType = &ir.FunctionType{
					Params: []ir.Type{
						&ir.BasicType{Kind: ir.TypeBool}, // value
					},
					Return: &ir.BasicType{Kind: ir.TypeVoid},
				}
			case "print_string":
				// print_string accepts String, LString, or *u8
				// We'll handle type checking specially for this polymorphic function
				funcType = &ir.FunctionType{
					Params: []ir.Type{
						nil, // We'll accept multiple types
					},
					Return: &ir.BasicType{Kind: ir.TypeVoid},
				}
			}
			
			if funcType != nil {
				sym = &FuncSymbol{
					Name:       funcName,
					IsBuiltin:  true,
					Type:       funcType,
					ReturnType: funcType.Return,
					Params:     []*ast.Parameter{}, // Will be ignored for builtins
				}
			}
		}
		
		if sym == nil {
			// Try to find similar function names
			suggestions := a.findSimilarIdentifiers(funcName)
			if len(suggestions) > 0 {
				return 0, fmt.Errorf("undefined function: %s - did you mean '%s'?", funcName, suggestions[0])
			}
			return 0, fmt.Errorf("undefined function: %s", funcName)
		}
		
		if debug {
			fmt.Printf("DEBUG: Found symbol %s of type %T\n", funcName, sym)
		}
		
		// Check if it's an overload set
		if _, ok := sym.(*FunctionOverloadSet); ok {
			// Try to resolve the overload
			funcSym, err := a.resolveOverload(funcName, call.Arguments, irFunc)
			if err != nil {
				return 0, fmt.Errorf("error in function %s: %v", a.currentFunc.Name, err)
			}
			sym = funcSym
			funcName = funcSym.Name  // Use the mangled name
		}
		
		// Check if this is a lambda variable before treating as function
		if varSymbol, ok := sym.(*VarSymbol); ok {
			if debug {
				fmt.Printf("DEBUG: Found variable %s, type: %T\n", funcName, varSymbol.Type)
				if varSymbol.Type != nil {
					fmt.Printf("  Type string: %s\n", varSymbol.Type.String())
				}
			}
			if lambdaType, ok := varSymbol.Type.(*ir.LambdaType); ok {
				if debug {
					fmt.Printf("DEBUG: Variable %s is a lambda!\n", funcName)
				}
				// This is a lambda call - treat it as indirect function call
				return a.analyzeLambdaCall(call, lambdaType, funcName, irFunc)
			} else {
				if debug {
					fmt.Printf("DEBUG: Variable %s is NOT a lambda, type assertion failed\n", funcName)
				}
			}
		}
		
	case *ast.FieldExpr:
		// Build the full qualified name by traversing the field expression chain
		funcName = a.buildQualifiedName(fn)
		sym = a.currentScope.Lookup(funcName)
		
		if sym == nil {
			// Try as instance method call (obj.method())
			if id, ok := fn.Object.(*ast.Identifier); ok {
				// Look up the variable to get its type
				varSym := a.currentScope.Lookup(id.Name)
				if varSymbol, ok := varSym.(*VarSymbol); ok {
					// Find interface implementations for this type
					// First check if there's an overload set for this method
					methodBaseName := a.getMethodBaseName(varSymbol.Type, fn.Field)
					if methodBaseName != "" {
						// Try to find the overload set
						if overloadSet, ok := a.currentScope.Lookup(methodBaseName).(*FunctionOverloadSet); ok {
							// We have an overload set - we'll resolve it later with arguments
							sym = overloadSet
							funcName = methodBaseName
							isMethodCall = true
							methodReceiver = fn.Object  // Store the full receiver expression
						} else {
							// Try single method lookup
							methodFunc := a.findInterfaceMethod(varSymbol.Type, fn.Field)
							if methodFunc != nil {
								sym = methodFunc
								funcName = methodFunc.Name
								isMethodCall = true
								methodReceiver = fn.Object  // Store the receiver for self parameter
								
								if debug {
									fmt.Printf("DEBUG: Resolved interface method %s.%s to %s\n", id.Name, fn.Field, funcName)
								}
							}
						}
					}
				}
				
				// Fallback: Try as type method if it's a simple field expression
				if sym == nil {
					typeSym := a.currentScope.Lookup(id.Name)
					if typeSym != nil {
						if typeSymbol, ok := typeSym.(*TypeSymbol); ok {
							// This is a Type.method() call
							sym = a.findTypeMethod(typeSymbol.Type, fn.Field)
							if sym == nil {
								return 0, fmt.Errorf("type %s has no method %s", id.Name, fn.Field)
							}
							// Update funcName to the actual method name for proper function call
							if funcSym, ok := sym.(*FuncSymbol); ok {
								funcName = funcSym.Name
							}
						}
					}
				}
			}
		}
		
		if sym == nil {
			// Check if this looks like a nested public function call
			if strings.Contains(funcName, ".") {
				parts := strings.Split(funcName, ".")
				if len(parts) == 2 {
					// Check if the first part is a function that was called
					// Try both unprefixed and prefixed names
					baseName := parts[0]
					prefixedName := a.prefixSymbol(baseName)
					
					// Try with unprefixed name first
					funcSym := a.currentScope.Lookup(baseName)
					if funcSym == nil {
						// Try with prefixed name
						funcSym = a.currentScope.Lookup(prefixedName)
					}
					
					if funcSym != nil {
						// Check if it's a function or overload set
						_, isFunc := funcSym.(*FuncSymbol)
						_, isOverloadSet := funcSym.(*FunctionOverloadSet)
						
						if isFunc || isOverloadSet {
							return 0, fmt.Errorf("nested public functions (pub fun inside functions) are not yet implemented\n" +
								"    Found: %s.%s()\n" +
								"    This feature would allow encapsulated modules with public/private methods.\n" +
								"    Workaround: Use structs with associated functions or separate top-level functions.\n" +
								"    Example: fun %s_%s(...) instead of %s.%s(...)",
								parts[0], parts[1], parts[0], parts[1], parts[0], parts[1])
						}
					}
				}
			}
			// Try to find similar function names
			suggestions := a.findSimilarIdentifiers(funcName)
			if len(suggestions) > 0 {
				return 0, fmt.Errorf("undefined function: %s - did you mean '%s'?", funcName, suggestions[0])
			}
			return 0, fmt.Errorf("undefined function: %s", funcName)
		}
		
	case *ast.TryExpr:
		// Function call with ? suffix (error propagation)
		// The actual function is inside the TryExpr
		if ident, ok := fn.Expression.(*ast.Identifier); ok {
			funcName = ident.Name
			sym = a.currentScope.Lookup(funcName)
			
			// If not found, try with module prefix
			if sym == nil && a.currentModule != "" && a.currentModule != "main" {
				prefixedName := a.prefixSymbol(funcName)
				sym = a.currentScope.Lookup(prefixedName)
				if sym != nil {
					funcName = prefixedName
					// Update the AST node to use the prefixed name
					ident.Name = prefixedName
				}
			}
			
			if sym == nil {
				// Try to find similar function names
				suggestions := a.findSimilarIdentifiers(funcName)
				if len(suggestions) > 0 {
					return 0, fmt.Errorf("undefined function: %s - did you mean '%s'?", funcName, suggestions[0])
				}
				return 0, fmt.Errorf("undefined function: %s", funcName)
			}
			
			if debug {
				fmt.Printf("DEBUG: Found function with ? suffix: %s of type %T\n", funcName, sym)
			}
		} else {
			return 0, fmt.Errorf("unsupported expression in try operator: %T", fn.Expression)
		}
		
	default:
		return 0, fmt.Errorf("unsupported function call expression: %T", call.Function)
	}

	// Handle overload sets for method calls
	var funcSym *FuncSymbol
	if _, ok := sym.(*FunctionOverloadSet); ok {
		// For method calls, we need to include self in the arguments for resolution
		resolveArgs := call.Arguments
		if isMethodCall && methodReceiver != nil {
			// Create a temporary argument list with self as first parameter
			resolveArgs = make([]ast.Expression, len(call.Arguments)+1)
			resolveArgs[0] = methodReceiver
			copy(resolveArgs[1:], call.Arguments)
		}
		
		// Resolve the overload
		resolved, err := a.resolveOverload(funcName, resolveArgs, irFunc)
		if err != nil {
			return 0, fmt.Errorf("error resolving method overload: %v", err)
		}
		funcSym = resolved
		funcName = funcSym.Name  // Update to mangled name
	} else if fs, ok := sym.(*FuncSymbol); ok {
		funcSym = fs
	} else {
		if debug {
			fmt.Printf("DEBUG: Symbol %s is not a FuncSymbol, it's %T\n", funcName, sym)
		}
		// Check if it's a variable that should be a function
		if varSym, ok := sym.(*VarSymbol); ok {
			return 0, fmt.Errorf("%s is not a function - it's a variable of type %s. For lambda parameters that are functions, use explicit type annotation like: |%s: fn(u8) -> u8, ...|", funcName, varSym.Type.String(), funcName)
		}
		return 0, fmt.Errorf("%s is not a function", funcName)
	}
	
	// Track function calls for recursion detection
	if a.currentFunc != nil {
		a.functionCalls[a.currentFunc.Name] = append(a.functionCalls[a.currentFunc.Name], funcName)
		
		// Check if this is a recursive call
		// Need to check both simple name and prefixed name since function calls
		// might use simple names but currentFunc.Name is prefixed
		isRecursiveCall := false
		if funcName == a.currentFunc.Name {
			// Direct match (prefixed name)
			isRecursiveCall = true
		} else if a.currentModule != "" && a.currentModule != "main" {
			// Check if funcName is the simple name of current function
			expectedSimpleName := strings.TrimPrefix(a.currentFunc.Name, a.currentModule+".")
			if funcName == expectedSimpleName {
				isRecursiveCall = true
			}
		}
		
		if isRecursiveCall {
			a.currentFunc.IsRecursive = true
			a.currentFunc.RequiresContext = true
		}
	}

	// Handle built-in functions specially
	if funcSym.IsBuiltin {
		return a.analyzeBuiltinCall(funcName, funcSym, call, irFunc)
	}

	// Prepare arguments (inject self for method calls)
	actualArgs := call.Arguments
	if isMethodCall && methodReceiver != nil {
		// For method calls, inject the receiver as the first argument (self parameter)
		actualArgs = make([]ast.Expression, len(call.Arguments)+1)
		actualArgs[0] = methodReceiver
		copy(actualArgs[1:], call.Arguments)
		
		if debug {
			fmt.Printf("DEBUG: Injected self parameter for method call, now %d args\n", len(actualArgs))
		}
	}

	// Check argument count for regular functions
	if len(actualArgs) != len(funcSym.Params) {
		return 0, fmt.Errorf("function %s expects %d arguments, got %d", 
			funcName, len(funcSym.Params), len(actualArgs))
	}

	// Analyze arguments
	argRegs := []ir.Register{}
	for _, arg := range actualArgs {
		reg, err := a.analyzeExpression(arg, irFunc)
		if err != nil {
			return 0, err
		}
		argRegs = append(argRegs, reg)
	}

	// Check if this function should use instruction patching
	useInstructionPatching := a.shouldUseInstructionPatching(funcSym, call)
	
	// Debug: Print patching decision
	// fmt.Printf("DEBUG: Function %s, IsBuiltin=%v, ReturnType=%v, UsePatching=%v\n", 
	//	funcSym.Name, funcSym.IsBuiltin, funcSym.ReturnType, useInstructionPatching)
	
	if useInstructionPatching {
		// Generate instruction patching sequence
		// fmt.Printf("DEBUG: Generating instruction patching call for %s\n", funcSym.Name)
		return a.generateInstructionPatchingCall(funcSym, call, argRegs, irFunc)
	}

	// Generate regular call
	resultReg := irFunc.AllocReg()
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:     ir.OpCall,
		Dest:   resultReg,
		Symbol: funcSym.Name,  // Use actual function name (mangled for lambdas)
		Args:   argRegs,  // Store argument registers for TRUE SMC patching
	})

	// Store the return type in expression types map
	a.exprTypes[call] = funcSym.ReturnType

	return resultReg, nil
}

// analyzeBuiltinCall analyzes a built-in function call
func (a *Analyzer) analyzeBuiltinCall(funcName string, funcSym *FuncSymbol, call *ast.CallExpr, irFunc *ir.Function) (ir.Register, error) {
	// Strip module prefix if present (e.g., "std.cls" -> "cls")
	baseFuncName := funcName
	if idx := strings.LastIndex(funcName, "."); idx >= 0 {
		baseFuncName = funcName[idx+1:]
	}
	
	// Get function type (may be nil for polymorphic functions like print_string)
	funcType := funcSym.Type
	
	// Special handling for print_string which accepts multiple types
	if baseFuncName == "print_string" {
		if len(call.Arguments) != 1 {
			return 0, fmt.Errorf("print_string expects 1 argument, got %d", len(call.Arguments))
		}
	} else {
		// Check argument count based on built-in function type
		if funcType == nil {
			return 0, fmt.Errorf("built-in function %s has no type information", funcName)
		}
		
		expectedArgs := len(funcType.Params)
		if len(call.Arguments) != expectedArgs {
			return 0, fmt.Errorf("function %s expects %d arguments, got %d", 
				funcName, expectedArgs, len(call.Arguments))
		}
	}
	
	// Analyze arguments
	argRegs := []ir.Register{}
	for i, arg := range call.Arguments {
		reg, err := a.analyzeExpression(arg, irFunc)
		if err != nil {
			return 0, err
		}
		argRegs = append(argRegs, reg)
		
		// Type check the argument
		argType, err := a.inferType(arg)
		if err != nil {
			return 0, fmt.Errorf("cannot infer type of argument %d to %s: %v", i, funcName, err)
		}
		
		// Special handling for built-in functions
		if baseFuncName == "print_string" && i == 0 {
			// print_string accepts String, LString, or *u8
			validType := false
			switch t := argType.(type) {
			case *ir.StringType, *ir.LStringType:
				validType = true
			case *ir.PointerType:
				if basic, ok := t.Base.(*ir.BasicType); ok && basic.Kind == ir.TypeU8 {
					validType = true
				}
			}
			if !validType {
				return 0, fmt.Errorf("argument to print_string must be String, LString, or *u8, got %s", argType)
			}
		} else if baseFuncName == "len" && i == 0 {
			// Accept pointer to array or array directly
			switch argType.(type) {
			case *ir.ArrayType:
				// Direct array is OK
			case *ir.PointerType:
				// Pointer to array is OK
			default:
				return 0, fmt.Errorf("argument to len must be an array or pointer to array, got %s", argType)
			}
		} else if (baseFuncName == "memset" || baseFuncName == "memcpy") && i == 0 {
			// First argument to memset/memcpy should be a pointer
			// Accept *[N]T as *T for compatibility
			if ptr, ok := argType.(*ir.PointerType); ok {
				if arr, ok := ptr.Base.(*ir.ArrayType); ok {
					// Pointer to array - check if element type matches
					if funcType != nil && i < len(funcType.Params) {
						expectedPtr := funcType.Params[i].(*ir.PointerType)
						if !a.typesCompatible(expectedPtr.Base, arr.Element) {
							return 0, fmt.Errorf("argument %d to %s: expected %s, got pointer to array of %s", 
								i, funcName, funcType.Params[i], arr.Element)
						}
					}
					// Type is compatible
				} else {
					// Regular pointer - normal type check
					if funcType != nil && i < len(funcType.Params) {
						if !a.typesCompatible(funcType.Params[i], argType) {
							return 0, fmt.Errorf("argument %d to %s: expected %s, got %s", 
								i, funcName, funcType.Params[i], argType)
						}
					}
				}
			} else {
				return 0, fmt.Errorf("argument %d to %s must be a pointer, got %s", 
					i, funcName, argType)
			}
		} else if baseFuncName == "memcpy" && i == 1 {
			// Second argument to memcpy (src) - similar handling but without mutability requirement
			if ptr, ok := argType.(*ir.PointerType); ok {
				if arr, ok := ptr.Base.(*ir.ArrayType); ok {
					// Pointer to array - check element type
					if funcType != nil && i < len(funcType.Params) {
						expectedPtr := funcType.Params[i].(*ir.PointerType)
						if !a.typesCompatible(expectedPtr.Base, arr.Element) {
							return 0, fmt.Errorf("argument %d to %s: expected %s, got pointer to array of %s", 
								i, funcName, funcType.Params[i], arr.Element)
						}
					}
				} else {
					// Regular pointer - normal check
					if funcType != nil && i < len(funcType.Params) {
						if !a.typesCompatible(funcType.Params[i], argType) {
							return 0, fmt.Errorf("argument %d to %s: expected %s, got %s", 
								i, funcName, funcType.Params[i], argType)
						}
					}
				}
			} else {
				return 0, fmt.Errorf("argument %d to %s must be a pointer, got %s", 
					i, funcName, argType)
			}
		} else {
			// Normal type checking for other arguments
			if funcType != nil && i < len(funcType.Params) {
				expectedType := funcType.Params[i]
				if !a.typesCompatible(expectedType, argType) {
					return 0, fmt.Errorf("argument %d to %s: expected %s, got %s", 
						i, funcName, expectedType, argType)
				}
			}
		}
	}
	
	// Generate appropriate IR for each built-in function
	switch baseFuncName {
	case "print":
		// For print, we'll generate a special OpPrint instruction
		// The code generator will handle the Z80 implementation
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpPrint,
			Src1:    argRegs[0],
			Comment: "Built-in print function",
		})
		// print returns void, so return a dummy register
		return 0, nil
		
	case "len":
		// For len, we need to get the length of an array or string
		resultReg := irFunc.AllocReg()
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpLen,
			Dest:    resultReg,
			Src1:    argRegs[0],
			Comment: "Built-in len function",
		})
		return resultReg, nil
		
	case "memcpy":
		// memcpy(dest: *mut u8, src: *u8, size: u16)
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpMemcpy,
			Src1:    argRegs[0], // dest
			Src2:    argRegs[1], // src
			Args:    []ir.Register{argRegs[2]}, // size
			Comment: "Built-in memcpy function",
		})
		return 0, nil
		
	case "memset":
		// memset(dest: *mut u8, value: u8, size: u16)
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpMemset,
			Src1:    argRegs[0], // dest
			Src2:    argRegs[1], // value
			Args:    []ir.Register{argRegs[2]}, // size
			Comment: "Built-in memset function",
		})
		return 0, nil
		
	case "print_u8":
		// print_u8(value: u8)
		// Generate a call to the runtime print_u8_decimal function
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "print_u8_decimal",
			Args:    []ir.Register{argRegs[0]},
			Comment: "Call runtime print_u8_decimal",
		})
		return 0, nil
		
	case "print_i8":
		// print_i8(value: i8)
		// Generate a call to the runtime print_i8_decimal function
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "print_i8_decimal",
			Args:    []ir.Register{argRegs[0]},
			Comment: "Call runtime print_i8_decimal",
		})
		return 0, nil
		
	case "print_u16":
		// print_u16(value: u16)
		// Generate a call to the runtime print_u16_decimal function
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "print_u16_decimal",
			Args:    []ir.Register{argRegs[0]},
			Comment: "Call runtime print_u16_decimal",
		})
		return 0, nil
		
	case "print_i16":
		// print_i16(value: i16)
		// Generate a call to the runtime print_i16_decimal function
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "print_i16_decimal",
			Args:    []ir.Register{argRegs[0]},
			Comment: "Call runtime print_i16_decimal",
		})
		return 0, nil
		
	case "print_bool":
		// print_bool(value: bool)
		// Generate a call to the runtime print_bool function
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "print_bool",
			Args:    []ir.Register{argRegs[0]},
			Comment: "Call runtime print_bool",
		})
		return 0, nil
		
	case "print_string":
		// print_string(str: *u8) - prints null-terminated string
		// Generate a call to the runtime print_string function
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "print_string",
			Args:    []ir.Register{argRegs[0]},
			Comment: "Call runtime print_string",
		})
		return 0, nil
		
	case "cls":
		// cls() - clear screen
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "cls",
			Comment: "Clear screen",
		})
		return 0, nil
		
	case "println":
		// println(value) - print with newline
		// Polymorphic - print the value then a newline
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpPrint,
			Src1:    argRegs[0],
			Comment: "Print value",
		})
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "print_newline",
			Comment: "Print newline",
		})
		return 0, nil
		
	case "hex":
		// hex(value: u8) - print as hexadecimal
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "print_hex_u8",
			Args:    []ir.Register{argRegs[0]},
			Comment: "Print as hex",
		})
		return 0, nil
		
	case "abs":
		// abs(value: i8) -> u8
		resultReg := irFunc.AllocReg()
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Dest:    resultReg,
			Symbol:  "abs",
			Args:    []ir.Register{argRegs[0]},
			Comment: "Absolute value",
		})
		return resultReg, nil
		
	case "min":
		// min(a: u8, b: u8) -> u8
		resultReg := irFunc.AllocReg()
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Dest:    resultReg,
			Symbol:  "min",
			Args:    []ir.Register{argRegs[0], argRegs[1]},
			Comment: "Minimum value",
		})
		return resultReg, nil
		
	case "max":
		// max(a: u8, b: u8) -> u8
		resultReg := irFunc.AllocReg()
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Dest:    resultReg,
			Symbol:  "max",
			Args:    []ir.Register{argRegs[0], argRegs[1]},
			Comment: "Maximum value",
		})
		return resultReg, nil
		
	// ZX Spectrum screen functions
	case "set_border":
		// set_border(color: u8)
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "zx_set_border",
			Args:    []ir.Register{argRegs[0]},
			Comment: "Set border color",
		})
		return 0, nil
		
	case "clear":
		// clear() - clear screen (ZX Spectrum specific)
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "zx_clear_screen",
			Comment: "Clear ZX Spectrum screen",
		})
		return 0, nil
		
	case "set_pixel":
		// set_pixel(x: u8, y: u8)
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "zx_set_pixel",
			Args:    []ir.Register{argRegs[0], argRegs[1]},
			Comment: "Set pixel at x,y",
		})
		return 0, nil
		
	case "set_ink":
		// set_ink(color: u8)
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "zx_set_ink",
			Args:    []ir.Register{argRegs[0]},
			Comment: "Set ink color",
		})
		return 0, nil
		
	case "set_paper":
		// set_paper(color: u8)
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "zx_set_paper",
			Args:    []ir.Register{argRegs[0]},
			Comment: "Set paper color",
		})
		return 0, nil
		
	// Input functions
	case "read_keyboard":
		// read_keyboard() -> u8
		resultReg := irFunc.AllocReg()
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Dest:    resultReg,
			Symbol:  "zx_read_keyboard",
			Comment: "Read keyboard state",
		})
		return resultReg, nil
		
	case "wait_key":
		// wait_key() -> u8
		resultReg := irFunc.AllocReg()
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Dest:    resultReg,
			Symbol:  "zx_wait_key",
			Comment: "Wait for key press",
		})
		return resultReg, nil
		
	case "is_key_pressed":
		// is_key_pressed(key: u8) -> bool
		resultReg := irFunc.AllocReg()
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Dest:    resultReg,
			Symbol:  "zx_is_key_pressed",
			Args:    []ir.Register{argRegs[0]},
			Comment: "Check if key is pressed",
		})
		return resultReg, nil
		
	// Sound functions
	case "beep":
		// beep(duration: u16, pitch: u16)
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "zx_beep",
			Args:    []ir.Register{argRegs[0], argRegs[1]},
			Comment: "Play beep sound",
		})
		return 0, nil
		
	case "click":
		// click()
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpCall,
			Symbol:  "zx_click",
			Comment: "Play click sound",
		})
		return 0, nil
		
	default:
		return 0, fmt.Errorf("unknown built-in function: %s", funcName)
	}
}

// analyzeStructLiteral analyzes a struct literal expression
func (a *Analyzer) analyzeStructLiteral(lit *ast.StructLiteral, irFunc *ir.Function) (ir.Register, error) {
	// Look up the struct type
	sym := a.currentScope.Lookup(lit.TypeName)
	if sym == nil {
		return 0, fmt.Errorf("undefined type: %s", lit.TypeName)
	}
	
	typeSym, ok := sym.(*TypeSymbol)
	if !ok {
		return 0, fmt.Errorf("%s is not a type", lit.TypeName)
	}
	
	structType, ok := typeSym.Type.(*ir.StructType)
	if !ok {
		return 0, fmt.Errorf("%s is not a struct type", lit.TypeName)
	}
	
	// Allocate space for the struct
	resultReg := irFunc.AllocReg()
	
	// Store the type information for the result
	a.exprTypes[lit] = structType
	
	// Generate IR for struct allocation
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpAlloc,
		Dest: resultReg,
		Imm:  int64(structType.Size()),
		Type: structType,
		Comment: fmt.Sprintf("Allocate struct %s", lit.TypeName),
	})
	
	// Initialize fields
	for _, fieldInit := range lit.Fields {
		// Check field exists
		fieldType, exists := structType.Fields[fieldInit.Name]
		if !exists {
			return 0, fmt.Errorf("no field %s in struct %s", fieldInit.Name, lit.TypeName)
		}
		
		// Analyze field value
		valueReg, err := a.analyzeExpression(fieldInit.Value, irFunc)
		if err != nil {
			return 0, err
		}
		
		// Calculate field offset
		offset := 0
		for _, fname := range structType.FieldOrder {
			if fname == fieldInit.Name {
				break
			}
			offset += structType.Fields[fname].Size()
		}
		
		// Store to field
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpStoreField,
			Src1: resultReg,
			Src2: valueReg,
			Imm:  int64(offset),
			Type: fieldType,
			Comment: fmt.Sprintf("Store to %s.%s", lit.TypeName, fieldInit.Name),
		})
	}
	
	return resultReg, nil
}

// analyzeFieldExpr analyzes a field access expression
func (a *Analyzer) analyzeFieldExpr(field *ast.FieldExpr, irFunc *ir.Function) (ir.Register, error) {
	// Special handling for module field access (e.g., screen.set_pixel)
	// Check this FIRST before trying to analyze the object as an expression
	if id, ok := field.Object.(*ast.Identifier); ok {
		// Check if the identifier is a module or type
		sym := a.currentScope.Lookup(id.Name)
		if sym != nil {
			// Check if it's an enum type (for both . and :: syntax)
			if typeSym, isType := sym.(*TypeSymbol); isType {
				// Check if the type is an enum
				if _, isEnum := typeSym.Type.(*ir.EnumType); isEnum {
					// Convert to enum literal
					enumLit := &ast.EnumLiteral{
						EnumName: id.Name,
						Variant:  field.Field,
						StartPos: field.StartPos,
						EndPos:   field.EndPos,
					}
					reg, err := a.analyzeEnumLiteral(enumLit, irFunc)
					if err != nil {
						return 0, err
					}
					// Store the type information for this field expression
					// Use the actual enum type, not just u8
					a.exprTypes[field] = typeSym.Type
					return reg, nil
				}
			}
			
			if _, isModule := sym.(*ModuleSymbol); isModule {
				// This is a module - look up the full qualified name
				fullName := id.Name + "." + field.Field
				sym := a.currentScope.Lookup(fullName)
				if sym != nil {
					// Check if this is a constant or function
					if constSym, ok := sym.(*ConstSymbol); ok {
						// This is a module constant - load its value
						reg := irFunc.AllocReg()
						
						// Handle different constant value types
						switch v := constSym.Value.(type) {
						case int64:
							irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
								Op:      ir.OpLoadConst,
								Dest:    reg,
								Imm:     v,
								Type:    constSym.Type,
								Comment: fmt.Sprintf("Load constant %s = %d", fullName, v),
							})
						case bool:
							val := int64(0)
							if v {
								val = 1
							}
							irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
								Op:      ir.OpLoadConst,
								Dest:    reg,
								Imm:     val,
								Type:    constSym.Type,
								Comment: fmt.Sprintf("Load constant %s = %v", fullName, v),
							})
						case string:
							// For string constants, create a string literal and load its address
							stringLabel := fmt.Sprintf("str_%d", len(a.module.Strings))
							a.module.Strings = append(a.module.Strings, &ir.String{
								Label: stringLabel,
								Value: v,
								IsLong: len(v) > 255,
							})
							irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
								Op:      ir.OpLoadString,
								Dest:    reg,
								Symbol:  stringLabel,
								Type:    constSym.Type,
								Comment: fmt.Sprintf("Load string constant %s = \"%s\"", fullName, v),
							})
						default:
							return 0, fmt.Errorf("unsupported constant value type: %T", v)
						}
						
						// Store type information for this expression
						a.exprTypes[field] = constSym.Type
						return reg, nil
					} else if _, ok := sym.(*FuncSymbol); ok {
						// This is a module function - treat it as a function identifier
						// Return a special register that indicates this is a function reference
						// The actual call will be handled by analyzeCallExpr
						reg := irFunc.AllocReg()
						irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
							Op:      ir.OpLoadLabel,
							Dest:    reg,
							Symbol:  fullName,
							Comment: fmt.Sprintf("Load function %s", fullName),
						})
						return reg, nil
					}
				}
				// If we get here, the module member was not found
				return 0, fmt.Errorf("undefined module member: %s", fullName)
			}
		}
		
		// Special handling for loop iterator field access in INTO mode
		if sym != nil {
			if varSym, ok := sym.(*VarSymbol); ok && varSym.BufferAddr != 0 {
			// This is a loop iterator in INTO mode - use direct buffer address
			structType, ok := varSym.Type.(*ir.StructType)
			if !ok {
				return 0, fmt.Errorf("field access on non-struct iterator %s", id.Name)
			}
			
			// Find field offset
			offset := 0
			found := false
			for _, fname := range structType.FieldOrder {
				if fname == field.Field {
					found = true
					break
				}
				offset += structType.Fields[fname].Size()
			}
			
			if !found {
				return 0, fmt.Errorf("struct %s has no field %s", structType.Name, field.Field)
			}
			
			// Generate direct memory access to buffer
			resultReg := irFunc.AllocReg()
			directAddr := varSym.BufferAddr + uint16(offset)
			
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:      ir.OpLoadDirect,
				Dest:    resultReg,
				Imm:     int64(directAddr),
				Type:    structType.Fields[field.Field],
				Comment: fmt.Sprintf("Load %s.%s from buffer at $%04X", id.Name, field.Field, directAddr),
			})
			
			// Store type information
			a.exprTypes[field] = structType.Fields[field.Field]
			
			return resultReg, nil
			}
		}
	}
	
	// Normal field access - analyze the object
	objReg, err := a.analyzeExpression(field.Object, irFunc)
	if err != nil {
		return 0, err
	}
	
	// Get the object type
	objType := a.exprTypes[field.Object]
	if objType == nil {
		return 0, fmt.Errorf("cannot determine type of field object")
	}
	
	
	var structType *ir.StructType
	var fieldType ir.Type
	
	// Handle both direct struct and pointer to struct
	switch t := objType.(type) {
	case *ir.StructType:
		structType = t
	case *ir.PointerType:
		if st, ok := t.Base.(*ir.StructType); ok {
			structType = st
		} else {
			return 0, fmt.Errorf("field access on non-struct pointer")
		}
	case *ir.BitStructType:
		// Handle bit struct field access
		bitField, exists := t.Fields[field.Field]
		if !exists {
			return 0, fmt.Errorf("bit struct has no field %s", field.Field)
		}
		
		// For bit field access, we need to generate bit manipulation code
		// For now, just allocate a register and mark it for special handling
		resultReg := irFunc.AllocReg()
		
		// Store type information - bit fields are treated as their underlying type
		a.exprTypes[field] = t.UnderlyingType
		
		// Generate bit field load instruction
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpLoadBitField,
			Dest:    resultReg,
			Src1:    objReg,
			Imm:     int64(bitField.BitOffset),
			Imm2:    int64(bitField.BitWidth),
			Type:    t.UnderlyingType,
			Comment: fmt.Sprintf("Load bit field %s (offset %d, width %d)", field.Field, bitField.BitOffset, bitField.BitWidth),
		})
		
		return resultReg, nil
	default:
		return 0, fmt.Errorf("field access on non-struct type: %T", objType)
	}
	
	// Find field offset and type
	offset := 0
	found := false
	for _, fname := range structType.FieldOrder {
		if fname == field.Field {
			fieldType = structType.Fields[fname]
			found = true
			break
		}
		offset += structType.Fields[fname].Size()
	}
	
	if !found {
		return 0, fmt.Errorf("struct %s has no field %s", structType.Name, field.Field)
	}
	
	// Store type information for the field expression
	a.exprTypes[field] = fieldType
	
	// Allocate result register
	resultReg := irFunc.AllocReg()
	
	// Generate field load
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpLoadField,
		Dest:    resultReg,
		Src1:    objReg,
		Imm:     int64(offset),
		Type:    fieldType,
		Comment: fmt.Sprintf("Load field %s (offset %d)", field.Field, offset),
	})
	
	return resultReg, nil
}


// analyzeInlineAsmExpr analyzes inline assembly as an expression
func (a *Analyzer) analyzeInlineAsmExpr(asm *ast.InlineAsmExpr, irFunc *ir.Function) (ir.Register, error) {
	// For now, inline assembly expressions don't have a return value
	// Just emit the assembly code
	resolvedCode := asm.Code
	
	// Generate inline assembly instruction
	// Inline asm expressions don't return a value, so we return a dummy register
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpAsm,
		AsmCode: resolvedCode,
		Comment: "Inline assembly expression",
	})
	
	// Return register 0 as a placeholder (inline asm has no return value)
	return 0, nil
}

// analyzeIndexExpr analyzes an array index expression
func (a *Analyzer) analyzeIndexExpr(index *ast.IndexExpr, irFunc *ir.Function) (ir.Register, error) {
	// Analyze the array expression
	arrayReg, err := a.analyzeExpression(index.Array, irFunc)
	if err != nil {
		return 0, err
	}
	
	// Analyze the index expression
	indexReg, err := a.analyzeExpression(index.Index, irFunc)
	if err != nil {
		return 0, err
	}
	
	// Get the type of the array expression
	arrayType, err := a.inferType(index.Array)
	if err != nil {
		return 0, fmt.Errorf("cannot determine array type: %v", err)
	}
	
	
	// Validate that it's an array or pointer type
	var elementType ir.Type
	switch t := arrayType.(type) {
	case *ir.ArrayType:
		elementType = t.Element
	case *ir.PointerType:
		// For pointers, assume they point to u8 (byte arrays)
		elementType = &ir.BasicType{Kind: ir.TypeU8}
	default:
		return 0, fmt.Errorf("cannot index non-array type %s", arrayType)
	}
	
	// Allocate result register
	resultReg := irFunc.AllocReg()
	
	// Generate indexed load with element type info
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpLoadIndex,
		Dest: resultReg,
		Src1: arrayReg,
		Src2: indexReg,
		Type: elementType,
		Comment: fmt.Sprintf("Load array element (%s)", elementType),
	})
	
	// Store the type of this expression for later use
	a.exprTypes[index] = elementType
	
	return resultReg, nil
}

// analyzeStringLiteral analyzes a string literal
func (a *Analyzer) analyzeStringLiteral(str *ast.StringLiteral, irFunc *ir.Function) (ir.Register, error) {
	// Create a unique label for the string
	label := fmt.Sprintf("str_%d", len(a.module.Strings))
	
	// Determine if this is a long string (LString)
	isLong := str.IsLong || len(str.Value) > 255
	
	// Add string to module's string table
	a.module.Strings = append(a.module.Strings, &ir.String{
		Label:  label,
		Value:  str.Value,
		IsLong: isLong,
	})
	
	if debug {
		fmt.Printf("DEBUG: Added string to module: label=%s, value=\"%s\", isLong=%v\n", label, str.Value, isLong)
		fmt.Printf("  Total strings in module: %d\n", len(a.module.Strings))
	}
	
	// Allocate register for the pointer
	reg := irFunc.AllocReg()
	
	// Generate instruction to load string address
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpLoadLabel,
		Dest:    reg,
		Symbol:  label,
		Comment: fmt.Sprintf("Load string \"%s\"", str.Value),
	})
	
	return reg, nil
}

// analyzeEnumLiteral analyzes an enum literal
func (a *Analyzer) analyzeEnumLiteral(lit *ast.EnumLiteral, irFunc *ir.Function) (ir.Register, error) {
	// Look up the enum type
	sym := a.currentScope.Lookup(lit.EnumName)
	if sym == nil {
		return 0, fmt.Errorf("undefined enum: %s", lit.EnumName)
	}
	
	typeSym, ok := sym.(*TypeSymbol)
	if !ok {
		return 0, fmt.Errorf("%s is not a type", lit.EnumName)
	}
	
	enumType, ok := typeSym.Type.(*ir.EnumType)
	if !ok {
		return 0, fmt.Errorf("%s is not an enum type", lit.EnumName)
	}
	
	// Get variant value
	value, exists := enumType.Variants[lit.Variant]
	if !exists {
		return 0, fmt.Errorf("no variant %s in enum %s", lit.Variant, lit.EnumName)
	}
	
	// Generate constant load
	resultReg := irFunc.AllocReg()
	irFunc.EmitImm(ir.OpLoadConst, resultReg, int64(value))
	
	// Store the enum type information
	a.exprTypes[lit] = typeSym.Type
	
	return resultReg, nil
}

// analyzeLuaBlock analyzes a @lua[[[ ... ]]] block
func (a *Analyzer) analyzeLuaBlock(block *ast.LuaBlock) error {
	// Execute the Lua code block
	err := a.luaEvaluator.EvaluateLuaBlock(block.Code)
	if err != nil {
		return fmt.Errorf("failed to evaluate Lua block: %w", err)
	}
	return nil
}

// analyzeLuaExpression analyzes a Lua expression
func (a *Analyzer) analyzeLuaExpression(expr *ast.LuaExpression, irFunc *ir.Function) (ir.Register, error) {
	// Evaluate the Lua expression at compile time
	result, err := a.luaEvaluator.ProcessLuaExpr(&ast.LuaExpr{Code: expr.Code})
	if err != nil {
		return 0, fmt.Errorf("failed to evaluate Lua expression: %w", err)
	}
	
	// Allocate register for result
	resultReg := irFunc.AllocReg()
	
	// Convert the result to an IR constant
	switch v := result.(type) {
	case float64:
		// Lua numbers are always float64, convert to int
		irFunc.EmitImm(ir.OpLoadConst, resultReg, int64(v))
		// Determine type based on value
		if v >= 0 && v <= 255 {
			a.exprTypes[expr] = &ir.BasicType{Kind: ir.TypeU8}
		} else {
			a.exprTypes[expr] = &ir.BasicType{Kind: ir.TypeU16}
		}
	case []interface{}:
		// Array literal - for now just return error
		// TODO: Implement array literal support
		return 0, fmt.Errorf("Lua array literals not yet supported in expressions")
	case string:
		// String literal - for now just return error
		// TODO: Implement string literal support
		return 0, fmt.Errorf("Lua string literals not yet supported in expressions")
	default:
		return 0, fmt.Errorf("unsupported Lua expression result type: %T", result)
	}
	
	return resultReg, nil
}

// analyzePrintExpr analyzes @print expressions with string interpolation
func (a *Analyzer) analyzePrintExpr(print *ast.CompileTimePrint, irFunc *ir.Function) (ir.Register, error) {
	if debug {
		fmt.Printf("DEBUG: analyzePrintExpr called with expr type: %T\n", print.Expr)
	}
	
	// Check if the expression is a string literal for interpolation
	if strLit, ok := print.Expr.(*ast.StringLiteral); ok {
		if debug {
			fmt.Printf("DEBUG: String literal value: %q\n", strLit.Value)
		}
		// Use enhanced interpolation with { constant } support
		err := a.processEnhancedStringInterpolation(strLit.Value, irFunc)
		if err != nil {
			if debug {
				fmt.Printf("DEBUG: Enhanced interpolation failed: %v, falling back\n", err)
			}
			// Fall back to old implementation if enhanced fails
			err = a.processStringInterpolation(strLit.Value, irFunc)
			if err != nil {
				return 0, fmt.Errorf("failed to process string interpolation: %w", err)
			}
		}
	} else {
		// For non-string expressions, evaluate and print the value
		reg, err := a.analyzeExpression(print.Expr, irFunc)
		if err != nil {
			return 0, err
		}
		
		// Generate print instruction based on type
		exprType := a.exprTypes[print.Expr]
		a.generatePrintValue(reg, exprType, irFunc)
	}
	
	// @print doesn't return a value
	return 0, nil
}


// analyzeCompileTimeIf analyzes @if compile-time conditional expressions
func (a *Analyzer) analyzeCompileTimeIf(ifExpr *ast.CompileTimeIf, irFunc *ir.Function) (ir.Register, error) {
	// Evaluate condition at compile time
	conditionValue, err := a.evaluateConstantExpression(ifExpr.Condition)
	if err != nil {
		return 0, fmt.Errorf("@if condition must be constant: %w", err)
	}
	
	// Check if condition is true (any non-zero value is true)
	var isTrue bool
	switch v := conditionValue.(type) {
	case int64:
		isTrue = v != 0
	case bool:
		isTrue = v
	case string:
		isTrue = v != ""
	default:
		return 0, fmt.Errorf("@if condition must evaluate to boolean, number, or string, got %T", conditionValue)
	}
	
	// Choose which branch to evaluate
	var chosenExpr ast.Expression
	if isTrue {
		chosenExpr = ifExpr.ThenExpr
	} else {
		if ifExpr.ElseExpr != nil {
			chosenExpr = ifExpr.ElseExpr
		} else {
			// No else branch and condition is false - return zero constant
			reg := irFunc.AllocReg()
			irFunc.EmitImm(ir.OpLoadConst, reg, 0)
			a.exprTypes[ifExpr] = &ir.BasicType{Kind: ir.TypeU8}
			return reg, nil
		}
	}
	
	// Check if chosen expression is a constant that we can emit directly
	if constValue, err := a.evaluateConstantExpression(chosenExpr); err == nil {
		// Emit constant directly
		resultReg := irFunc.AllocReg()
		
		switch v := constValue.(type) {
		case int64:
			irFunc.EmitImm(ir.OpLoadConst, resultReg, v)
			// Determine appropriate type based on value
			if v >= 0 && v <= 255 {
				a.exprTypes[ifExpr] = &ir.BasicType{Kind: ir.TypeU8}
			} else if v >= -128 && v <= 127 {
				a.exprTypes[ifExpr] = &ir.BasicType{Kind: ir.TypeI8}
			} else if v >= 0 && v <= 65535 {
				a.exprTypes[ifExpr] = &ir.BasicType{Kind: ir.TypeU16}
			} else {
				a.exprTypes[ifExpr] = &ir.BasicType{Kind: ir.TypeI16}
			}
		case bool:
			val := int64(0)
			if v {
				val = 1
			}
			irFunc.EmitImm(ir.OpLoadConst, resultReg, val)
			a.exprTypes[ifExpr] = &ir.BasicType{Kind: ir.TypeBool}
		case string:
			// For strings, we need to create a string literal
			return 0, fmt.Errorf("string literals in @if not yet supported")
		default:
			return 0, fmt.Errorf("unsupported constant type in @if: %T", constValue)
		}
		
		return resultReg, nil
	}
	
	// Fall back to regular expression evaluation if not constant
	resultReg, err := a.analyzeExpression(chosenExpr, irFunc)
	if err != nil {
		return 0, fmt.Errorf("failed to evaluate @if branch: %w", err)
	}
	
	// Propagate the type from the chosen expression
	a.exprTypes[ifExpr] = a.exprTypes[chosenExpr]
	
	return resultReg, nil
}

// evaluateConstantExpression evaluates an expression at compile time
// Returns the constant value if the expression can be evaluated at compile time
func (a *Analyzer) evaluateConstantExpression(expr ast.Expression) (interface{}, error) {
	switch e := expr.(type) {
	case *ast.NumberLiteral:
		return e.Value, nil
	case *ast.BooleanLiteral:
		return e.Value, nil
	case *ast.StringLiteral:
		return e.Value, nil
	case *ast.Identifier:
		// Look up constant identifiers
		sym := a.currentScope.Lookup(e.Name)
		if sym == nil {
			return nil, fmt.Errorf("undefined identifier: %s", e.Name)
		}
		
		if constSym, ok := sym.(*ConstSymbol); ok {
			// Return the constant value
			return constSym.Value, nil
		}
		return nil, fmt.Errorf("identifier %s is not a compile-time constant", e.Name)
	case *ast.BinaryExpr:
		// Evaluate binary expressions with constant operands
		left, err := a.evaluateConstantExpression(e.Left)
		if err != nil {
			return nil, err
		}
		right, err := a.evaluateConstantExpression(e.Right)
		if err != nil {
			return nil, err
		}
		
		return a.evaluateConstantBinaryOp(left, e.Operator, right)
	case *ast.UnaryExpr:
		// Evaluate unary expressions
		operand, err := a.evaluateConstantExpression(e.Operand)
		if err != nil {
			return nil, err
		}
		
		return a.evaluateConstantUnaryOp(e.Operator, operand)
	case *ast.CompileTimeIf:
		// Evaluate @if at compile time
		conditionValue, err := a.evaluateConstantExpression(e.Condition)
		if err != nil {
			return nil, fmt.Errorf("@if condition must be constant: %w", err)
		}
		
		// Check if condition is true
		var isTrue bool
		switch v := conditionValue.(type) {
		case int64:
			isTrue = v != 0
		case bool:
			isTrue = v
		case string:
			isTrue = v != ""
		default:
			return nil, fmt.Errorf("@if condition must evaluate to boolean, number, or string, got %T", conditionValue)
		}
		
		// Choose and evaluate the appropriate branch
		if isTrue {
			return a.evaluateConstantExpression(e.ThenExpr)
		} else if e.ElseExpr != nil {
			return a.evaluateConstantExpression(e.ElseExpr)
		} else {
			// No else branch and condition is false - return 0
			return int64(0), nil
		}
	default:
		return nil, fmt.Errorf("expression type %T cannot be evaluated at compile time", expr)
	}
}

// evaluateConstantBinaryOp evaluates binary operations on constant values
func (a *Analyzer) evaluateConstantBinaryOp(left interface{}, op string, right interface{}) (interface{}, error) {
	// Convert to common types
	leftInt, leftIsInt := left.(int64)
	rightInt, rightIsInt := right.(int64)
	leftBool, leftIsBool := left.(bool)
	rightBool, rightIsBool := right.(bool)
	leftStr, leftIsStr := left.(string)
	rightStr, rightIsStr := right.(string)
	
	switch op {
	case "+":
		if leftIsInt && rightIsInt {
			return leftInt + rightInt, nil
		}
		if leftIsStr && rightIsStr {
			return leftStr + rightStr, nil
		}
	case "-":
		if leftIsInt && rightIsInt {
			return leftInt - rightInt, nil
		}
	case "*":
		if leftIsInt && rightIsInt {
			return leftInt * rightInt, nil
		}
	case "/":
		if leftIsInt && rightIsInt {
			if rightInt == 0 {
				return nil, fmt.Errorf("division by zero in constant expression")
			}
			return leftInt / rightInt, nil
		}
	case "%":
		if leftIsInt && rightIsInt {
			if rightInt == 0 {
				return nil, fmt.Errorf("modulo by zero in constant expression")
			}
			return leftInt % rightInt, nil
		}
	case "==":
		return left == right, nil
	case "!=":
		return left != right, nil
	case "<":
		if leftIsInt && rightIsInt {
			return leftInt < rightInt, nil
		}
		if leftIsStr && rightIsStr {
			return leftStr < rightStr, nil
		}
	case "<=":
		if leftIsInt && rightIsInt {
			return leftInt <= rightInt, nil
		}
		if leftIsStr && rightIsStr {
			return leftStr <= rightStr, nil
		}
	case ">":
		if leftIsInt && rightIsInt {
			return leftInt > rightInt, nil
		}
		if leftIsStr && rightIsStr {
			return leftStr > rightStr, nil
		}
	case ">=":
		if leftIsInt && rightIsInt {
			return leftInt >= rightInt, nil
		}
		if leftIsStr && rightIsStr {
			return leftStr >= rightStr, nil
		}
	case "&&":
		if leftIsBool && rightIsBool {
			return leftBool && rightBool, nil
		}
		// For non-boolean values, use truthiness
		return a.isTruthy(left) && a.isTruthy(right), nil
	case "||":
		if leftIsBool && rightIsBool {
			return leftBool || rightBool, nil
		}
		// For non-boolean values, use truthiness
		return a.isTruthy(left) || a.isTruthy(right), nil
	}
	
	return nil, fmt.Errorf("unsupported constant binary operation: %T %s %T", left, op, right)
}

// evaluateConstantUnaryOp evaluates unary operations on constant values
func (a *Analyzer) evaluateConstantUnaryOp(op string, operand interface{}) (interface{}, error) {
	switch op {
	case "!":
		return !a.isTruthy(operand), nil
	case "-":
		if val, ok := operand.(int64); ok {
			return -val, nil
		}
		return nil, fmt.Errorf("unary minus not supported for type %T", operand)
	case "+":
		if val, ok := operand.(int64); ok {
			return val, nil
		}
		return nil, fmt.Errorf("unary plus not supported for type %T", operand)
	}
	
	return nil, fmt.Errorf("unsupported constant unary operation: %s %T", op, operand)
}

// isTruthy determines if a value is "truthy" for boolean context
func (a *Analyzer) isTruthy(value interface{}) bool {
	switch v := value.(type) {
	case bool:
		return v
	case int64:
		return v != 0
	case string:
		return v != ""
	default:
		return false
	}
}

// analyzeMetafunctionCall analyzes general @metafunction(...) calls
func (a *Analyzer) analyzeMetafunctionCall(call *ast.MetafunctionCall, irFunc *ir.Function) (ir.Register, error) {
	// Create metafunction processor if not already created
	if a.metafunctionProcessor == nil {
		// For now, assume we can find the project root
		// In practice, this would be passed from the compiler
		a.metafunctionProcessor = metafunction.New(".")
		err := a.metafunctionProcessor.LoadMetafunctions()
		if err != nil {
			return 0, fmt.Errorf("failed to load metafunctions: %w", err)
		}
	}
	
	// For @to_string, we handle arguments specially
	var analyzedArgs []ir.Register
	if call.Name != "to_string" {
		// Analyze arguments normally
		for _, arg := range call.Arguments {
			reg, err := a.analyzeExpression(arg, irFunc)
			if err != nil {
				return 0, fmt.Errorf("failed to analyze metafunction argument: %w", err)
			}
			analyzedArgs = append(analyzedArgs, reg)
		}
	}
	
	// Create compilation context
	context := &metafunction.CompilationContext{
		CurrentFunction: irFunc.Name,
		Variables:       make(map[string]metafunction.VariableInfo),
		Constants:       make(map[string]interface{}),
		LabelCounter:    0,
	}
	
	// Populate variables from current scope
	for name, symb := range a.currentScope.symbols {
		switch s := symb.(type) {
		case *VarSymbol:
			if s.Type != nil {
				context.Variables[name] = metafunction.VariableInfo{
					Type:    s.Type.String(),
					Address: name,
				}
			}
		case *ConstSymbol:
			if s.Type != nil {
				context.Variables[name] = metafunction.VariableInfo{
					Type:    s.Type.String(),
					Address: name,
				}
			}
		}
	}
	
	// Handle built-in metafunctions
	switch call.Name {
	case "ptr":
		// Handle @ptr(variable) - get the address of a variable
		if len(call.Arguments) != 1 {
			return 0, fmt.Errorf("@ptr requires exactly one argument")
		}
		
		// The argument should be an identifier
		if id, ok := call.Arguments[0].(*ast.Identifier); ok {
			// Look up the variable
			sym := a.currentScope.Lookup(id.Name)
			if sym == nil {
				return 0, fmt.Errorf("@ptr: undefined identifier %s", id.Name)
			}
			
			varSym, ok := sym.(*VarSymbol)
			if !ok {
				return 0, fmt.Errorf("@ptr: %s is not a variable", id.Name)
			}
			
			// Allocate a register for the address
			reg := irFunc.AllocReg()
			
			// Generate LoadAddr instruction
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:      ir.OpLoadAddr,
				Dest:    reg,
				Symbol:  varSym.Name,
				Type:    &ir.PointerType{Base: varSym.Type},
				Comment: fmt.Sprintf("@ptr(%s) - get address", id.Name),
			})
			
			// Store the type as a pointer type
			a.exprTypes[call] = &ir.PointerType{Base: varSym.Type}
			
			return reg, nil
		} else {
			return 0, fmt.Errorf("@ptr requires a variable name")
		}
		
	case "to_string":
		// Handle @to_string for string interpolation
		if len(call.Arguments) != 1 {
			return 0, fmt.Errorf("@to_string requires exactly one argument (format string)")
		}
		
		// Get the format string directly without analyzing it
		// (we don't want to create the original string)
		if strLit, ok := call.Arguments[0].(*ast.StringLiteral); ok {
			// Build the interpolated string at compile time if possible
			interpolatedStr, err := a.buildInterpolatedString(strLit.Value, irFunc)
			if err != nil {
				return 0, fmt.Errorf("@to_string interpolation failed: %w", err)
			}
			
			// Create string literal and add to module
			stringLabel := fmt.Sprintf("str_%d", len(a.module.Strings))
			a.module.Strings = append(a.module.Strings, &ir.String{
				Label: stringLabel,
				Value: interpolatedStr,
				IsLong: len(interpolatedStr) > 255,
			})
			
			// Allocate register and load string address
			resultReg := irFunc.AllocReg()
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:      ir.OpLoadString,
				Dest:    resultReg,
				Symbol:  stringLabel,
				Comment: fmt.Sprintf("@to_string result: \"%s\"", interpolatedStr),
			})
			
			// Set type as string pointer
			a.exprTypes[call] = &ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}}
			
			return resultReg, nil
		} else {
			return 0, fmt.Errorf("@to_string requires a string literal argument")
		}
		
	case "asm":
		// Handle @asm for inline assembly
		if len(call.Arguments) == 0 {
			return 0, fmt.Errorf("@asm requires at least one argument (assembly code)")
		}
		
		// Get the assembly code from the first argument (should be a string literal)
		if strLit, ok := call.Arguments[0].(*ast.StringLiteral); ok {
			// Create inline assembly instruction
			inst := &ir.Instruction{
				Op:      ir.OpAsm,
				AsmCode: strLit.Value,
				Comment: "Inline assembly from @asm",
			}
			irFunc.Instructions = append(irFunc.Instructions, *inst)
		} else {
			return 0, fmt.Errorf("@asm requires a string literal as the first argument")
		}
		return 0, nil
		
	case "println":
		// Handle @println as @print with a newline
		// First analyze all arguments like @print does
		if len(call.Arguments) > 0 {
			// Check if the first argument is a string literal for interpolation
			if strLit, ok := call.Arguments[0].(*ast.StringLiteral); ok && len(call.Arguments) == 1 {
				// Use enhanced interpolation with { constant } support
				err := a.processEnhancedStringInterpolation(strLit.Value, irFunc)
				if err != nil {
					// Fall back to old implementation if enhanced fails
					err = a.processStringInterpolation(strLit.Value, irFunc)
					if err != nil {
						return 0, fmt.Errorf("failed to process string interpolation: %w", err)
					}
				}
			} else if strLit, ok := call.Arguments[0].(*ast.StringLiteral); ok && len(call.Arguments) > 1 {
				// Handle format string with arguments
				// First, extract expressions from remaining arguments
				var args []ast.Expression
				for i := 1; i < len(call.Arguments); i++ {
					args = append(args, call.Arguments[i])
				}
				
				// Process the format string with the provided arguments
				err := a.processFormatString(strLit.Value, args, irFunc)
				if err != nil {
					return 0, fmt.Errorf("failed to process format string: %w", err)
				}
			} else {
				// Single expression - print its value
				reg, err := a.analyzeExpression(call.Arguments[0], irFunc)
				if err != nil {
					return 0, fmt.Errorf("failed to analyze expression: %w", err)
				}
				// Generate print instruction based on type
				exprType := a.exprTypes[call.Arguments[0]]
				a.generatePrintValue(reg, exprType, irFunc)
			}
		}
		// Add a newline after the print
		a.generatePrintString("\n", irFunc)
		return 0, nil
		
	default:
		// Process other metafunctions using the Lua processor
		asmCode, err := a.metafunctionProcessor.ProcessMetafunctionCall(call, context)
		if err != nil {
			return 0, fmt.Errorf("metafunction processing failed: %w", err)
		}
		
		// Create inline assembly instruction with the generated code
		inst := &ir.Instruction{
			Op:      ir.OpAsm,
			AsmCode: asmCode,
			Comment: fmt.Sprintf("Generated by @%s metafunction", call.Name),
		}
		
		irFunc.Instructions = append(irFunc.Instructions, *inst)
	}
	
	// Most metafunctions don't return a value
	// Special handling for metafunctions that do return values could be added here
	return 0, nil
}

// analyzeMinzMetafunctionCall analyzes @minz("code", args...) calls for compile-time metaprogramming
func (a *Analyzer) analyzeMinzMetafunctionCall(call *ast.MinzMetafunctionCall, irFunc *ir.Function) (ir.Register, error) {
	// Prepare arguments for the MIR interpreter
	args := make([]interface{}, 0, len(call.Arguments))
	
	// Evaluate arguments at compile time
	for _, arg := range call.Arguments {
		switch argTyped := arg.(type) {
		case *ast.StringLiteral:
			args = append(args, argTyped.Value)
		case *ast.NumberLiteral:
			args = append(args, int64(argTyped.Value))
		case *ast.BooleanLiteral:
			args = append(args, argTyped.Value)
		case *ast.Identifier:
			// Try to resolve constants
			if sym := a.currentScope.Lookup(argTyped.Name); sym != nil {
				if constSym, isConst := sym.(*ConstSymbol); isConst {
					// Use the constant value
					args = append(args, constSym.Value)
				} else {
					return 0, fmt.Errorf("@minz: argument %s must be a compile-time constant", argTyped.Name)
				}
			} else {
				return 0, fmt.Errorf("@minz: undefined identifier %s", argTyped.Name)
			}
		default:
			// For complex expressions, we'd need a compile-time evaluator
			return 0, fmt.Errorf("@minz: unsupported argument type for compile-time evaluation: %T", arg)
		}
	}
	
	// Check if this is a template substitution or immediate execution
	isTemplate := false
	for i := range args {
		placeholder := fmt.Sprintf("{%d}", i)
		if strings.Contains(call.Code, placeholder) {
			isTemplate = true
			break
		}
	}
	
	var generatedCode string
	
	if isTemplate {
		// Template substitution mode (like @define)
		generatedCode = call.Code
		
		// Simple placeholder replacement for numbered arguments {0}, {1}, etc.
		for i, arg := range args {
			placeholder := fmt.Sprintf("{%d}", i)
			var replacement string
			switch v := arg.(type) {
			case string:
				replacement = v
			case int64:
				replacement = fmt.Sprintf("%d", v)
			case bool:
				replacement = fmt.Sprintf("%v", v)
			default:
				replacement = fmt.Sprintf("%v", v)
			}
			generatedCode = strings.ReplaceAll(generatedCode, placeholder, replacement)
		}
	} else {
		// Immediate execution mode - execute the code and collect @emit output
		// TODO: Implement actual MIR interpreter execution
		// For now, just return empty
		generatedCode = ""
	}
	
	if debug {
		fmt.Printf("DEBUG: @minz template: %s\n", call.Code)
		fmt.Printf("DEBUG: @minz args: %v\n", args)
		fmt.Printf("DEBUG: @minz generated: %s\n", generatedCode)
	}
	
	// Add debug comment showing the generated code (only if in a function context)
	if debug && irFunc != nil {
		commentInst := &ir.Instruction{
			Op:      ir.OpNop,
			Comment: fmt.Sprintf("@minz generated: %s", generatedCode),
		}
		irFunc.Instructions = append(irFunc.Instructions, *commentInst)
	}
	
	// Parse and integrate the generated MinZ code
	parser := parser.New()
	declarations, err := parser.ParseString(generatedCode, "@minz")
	if err != nil {
		// Fall back to inline assembly if parsing fails
		if debug {
			fmt.Printf("Warning: Could not parse @minz generated code: %v\n", err)
		}
		if irFunc != nil {
			inst := &ir.Instruction{
				Op:      ir.OpAsm,
				AsmCode: fmt.Sprintf("; @minz metafunction output\n; Generated code: %s\n; Parse failed: %v", generatedCode, err),
				Comment: "Metaprogramming output (parse failed)",
			}
			irFunc.Instructions = append(irFunc.Instructions, *inst)
		}
		return 0, nil
	}
	
	// Process the generated declarations
	for _, decl := range declarations {
		// Analyze each generated declaration
		if err := a.analyzeDeclaration(decl); err != nil {
			return 0, fmt.Errorf("@minz: failed to analyze generated code: %w", err)
		}
	}
	
	// @minz metafunctions don't return values in the current implementation
	// Future enhancement could support return values from generated code
	return 0, nil
}

// processFormatString handles format strings with explicit arguments
func (a *Analyzer) processFormatString(format string, args []ast.Expression, irFunc *ir.Function) error {
	// Split the string by {} placeholders
	parts := []struct {
		isExpr bool
		value  string
		argIdx int
	}{}
	
	current := ""
	i := 0
	argIdx := 0
	for i < len(format) {
		if i+1 < len(format) && format[i] == '{' && format[i+1] == '}' {
			// Found placeholder
			if current != "" {
				parts = append(parts, struct {
					isExpr bool
					value  string
					argIdx int
				}{false, current, 0})
				current = ""
			}
			if argIdx < len(args) {
				parts = append(parts, struct {
					isExpr bool
					value  string
					argIdx int
				}{true, "", argIdx})
				argIdx++
			}
			i += 2
		} else {
			current += string(format[i])
			i++
		}
	}
	
	// Add remaining string
	if current != "" {
		parts = append(parts, struct {
			isExpr bool
			value  string
			argIdx int
		}{false, current, 0})
	}
	
	// Generate code for each part
	for _, part := range parts {
		if part.isExpr {
			// Evaluate and print the argument
			reg, err := a.analyzeExpression(args[part.argIdx], irFunc)
			if err != nil {
				return fmt.Errorf("failed to evaluate argument %d: %w", part.argIdx, err)
			}
			exprType := a.exprTypes[args[part.argIdx]]
			a.generatePrintValue(reg, exprType, irFunc)
		} else {
			// Print string literal
			a.generatePrintString(part.value, irFunc)
		}
	}
	
	return nil
}

// processStringInterpolation handles string interpolation for @print
func (a *Analyzer) processStringInterpolation(format string, irFunc *ir.Function) error {
	// TODO: Use Lua to parse the format string and generate optimal print code
	// For now, implement a simple version without full Lua integration
	// Split the string by {} placeholders
	parts := []struct {
		isExpr bool
		value  string
	}{}
	
	current := ""
	i := 0
	for i < len(format) {
		if i+1 < len(format) && format[i] == '{' && format[i+1] == '{' {
			// Escaped brace
			current += "{"
			i += 2
		} else if i+1 < len(format) && format[i] == '}' && format[i+1] == '}' {
			// Escaped brace
			current += "}"
			i += 2
		} else if format[i] == '{' {
			// Start of expression
			if current != "" {
				parts = append(parts, struct{isExpr bool; value string}{false, current})
				current = ""
			}
			i++
			// Find matching }
			exprStart := i
			for i < len(format) && format[i] != '}' {
				i++
			}
			if i < len(format) {
				expr := format[exprStart:i]
				parts = append(parts, struct{isExpr bool; value string}{true, expr})
				i++
			}
		} else {
			current += string(format[i])
			i++
		}
	}
	if current != "" {
		parts = append(parts, struct{isExpr bool; value string}{false, current})
	}
	
	// Generate print instructions for each part
	for _, part := range parts {
		if part.isExpr {
			// Parse and evaluate the expression
			// For now, just handle simple identifiers
			expr := a.parseSimpleExpression(part.value, irFunc)
			if expr != nil {
				reg, err := a.analyzeExpression(expr, irFunc)
				if err != nil {
					return fmt.Errorf("failed to evaluate expression %s: %w", part.value, err)
				}
				exprType := a.exprTypes[expr]
				a.generatePrintValue(reg, exprType, irFunc)
			}
		} else {
			// Print string literal
			a.generatePrintString(part.value, irFunc)
		}
	}
	
	return nil
}

// parseSimpleExpression creates an AST node from a simple expression string
func (a *Analyzer) parseSimpleExpression(expr string, irFunc *ir.Function) ast.Expression {
	// For now, just handle identifiers and field access
	// TODO: Use proper expression parser
	expr = strings.TrimSpace(expr)
	if expr == "" {
		return nil
	}
	
	// Check for field access (e.g., self.x, obj.field)
	if idx := strings.Index(expr, "."); idx > 0 {
		objName := expr[:idx]
		fieldName := expr[idx+1:]
		
		// Both parts must be valid identifiers
		if isValidIdentifier(objName) && isValidIdentifier(fieldName) {
			return &ast.FieldExpr{
				Object: &ast.Identifier{Name: objName},
				Field:  fieldName,
			}
		}
	}
	
	// Simple identifier
	if isValidIdentifier(expr) {
		return &ast.Identifier{
			Name: expr,
		}
	}
	
	// TODO: Handle more complex expressions (numbers, function calls, etc.)
	return nil
}

// isValidIdentifier checks if a string is a valid identifier
func isValidIdentifier(s string) bool {
	if len(s) == 0 {
		return false
	}
	// First character must be letter or underscore
	if !((s[0] >= 'a' && s[0] <= 'z') || (s[0] >= 'A' && s[0] <= 'Z') || s[0] == '_') {
		return false
	}
	// Rest can be letters, digits, or underscore
	for i := 1; i < len(s); i++ {
		if !((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z') || 
		     (s[i] >= '0' && s[i] <= '9') || s[i] == '_') {
			return false
		}
	}
	return true
}

// buildInterpolatedString processes string interpolation for @to_string
// It returns the final interpolated string if all values are compile-time known
// Otherwise it generates runtime concatenation code
func (a *Analyzer) buildInterpolatedString(format string, irFunc *ir.Function) (string, error) {
	// Parse the format string to extract literal parts and expressions
	parts := []struct {
		isExpr bool
		value  string
	}{}
	
	current := ""
	i := 0
	for i < len(format) {
		if i+1 < len(format) && format[i] == '{' && format[i+1] == '{' {
			// Escaped brace
			current += "{"
			i += 2
		} else if i+1 < len(format) && format[i] == '}' && format[i+1] == '}' {
			// Escaped brace
			current += "}"
			i += 2
		} else if format[i] == '{' {
			// Start of expression
			if current != "" {
				parts = append(parts, struct{isExpr bool; value string}{false, current})
				current = ""
			}
			i++
			// Find matching }
			exprStart := i
			for i < len(format) && format[i] != '}' {
				i++
			}
			if i < len(format) {
				expr := format[exprStart:i]
				parts = append(parts, struct{isExpr bool; value string}{true, expr})
				i++
			}
		} else {
			current += string(format[i])
			i++
		}
	}
	if current != "" {
		parts = append(parts, struct{isExpr bool; value string}{false, current})
	}
	
	// Try to build the string at compile-time
	result := ""
	
	for _, part := range parts {
		if part.isExpr {
			// Try to evaluate at compile-time
			expr := a.parseSimpleExpression(part.value, irFunc)
			if expr != nil {
				// Try to get compile-time value
				if id, ok := expr.(*ast.Identifier); ok {
					sym := a.currentScope.Lookup(id.Name)
					if constSym, ok := sym.(*ConstSymbol); ok {
						// It's a constant! Add its value to the result
						result += fmt.Sprintf("%v", constSym.Value)
						continue
					}
				}
				// Not a compile-time constant - will need runtime concatenation
				// For now, just add a placeholder
				result += fmt.Sprintf("{%s}", part.value)
			} else {
				// Could not parse expression
				result += fmt.Sprintf("{%s}", part.value)
			}
		} else {
			// Literal string part
			result += part.value
		}
	}
	
	// Always return the processed result
	// If we couldn't resolve some placeholders at compile-time,
	// they remain as {name} in the result
	return result, nil
}

// generatePrintString generates instructions to print a string literal
func (a *Analyzer) generatePrintString(str string, irFunc *ir.Function) {
	// Smart string optimization: for short strings, use direct RST 16 calls
	// This avoids the overhead of loops for strings <= 8 characters
	const DIRECT_PRINT_THRESHOLD = 8
	
	if len(str) <= DIRECT_PRINT_THRESHOLD && len(str) > 0 {
		// Use direct print for short strings - ultra-fast!
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpPrintStringDirect,
			Symbol:  str, // Pass the string directly
			Comment: fmt.Sprintf("Direct print \"%s\" (%d chars)", str, len(str)),
		})
	} else {
		// Use loop-based print for longer strings
		// Create string literal and add to module
		stringLabel := fmt.Sprintf("str_%d", len(a.module.Strings))
		a.module.Strings = append(a.module.Strings, &ir.String{
			Label: stringLabel,
			Value: str,
			IsLong: len(str) > 255, // Mark as LString if > 255 chars
		})
		
		// Create a string constant
		strReg := irFunc.AllocReg()
		
		// Generate instruction to load string address
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:     ir.OpLoadString,
			Dest:   strReg,
			Symbol: stringLabel,
		})
		
		// Generate print instruction with symbol info for type checking
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpPrintString,
			Src1:    strReg,
			Symbol:  stringLabel, // Pass the label so codegen can check if IsLong
			Comment: fmt.Sprintf("Print \"%s\" (%d chars via loop)", str, len(str)),
		})
	}
}

// generatePrintValue generates instructions to print a value based on its type
func (a *Analyzer) generatePrintValue(reg ir.Register, typ ir.Type, irFunc *ir.Function) {
	// Determine print opcode based on type
	var op ir.Opcode
	
	if typ == nil {
		op = ir.OpPrintU8 // Default to u8
	} else {
		switch t := typ.(type) {
		case *ir.BasicType:
			switch t.Kind {
			case ir.TypeU8, ir.TypeI8:
				op = ir.OpPrintU8
			case ir.TypeU16, ir.TypeI16:
				op = ir.OpPrintU16
			case ir.TypeBool:
				op = ir.OpPrintBool
			default:
				op = ir.OpPrintU8
			}
		case *ir.PointerType:
			// For string pointers, use print string
			if basicType, ok := t.Base.(*ir.BasicType); ok && basicType.Kind == ir.TypeU8 {
				op = ir.OpPrintString
			} else {
				op = ir.OpPrintU16 // Print pointer as u16
			}
		default:
			op = ir.OpPrintU8
		}
	}
	
	// Generate print instruction
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   op,
		Src1: reg,
	})
}

// analyzeCastExpr analyzes a type cast expression
func (a *Analyzer) analyzeCastExpr(cast *ast.CastExpr, irFunc *ir.Function) (ir.Register, error) {
	
	// Analyze the expression being cast
	exprReg, err := a.analyzeExpression(cast.Expr, irFunc)
	if err != nil {
		return 0, err
	}
	
	// Convert the target type
	targetType, err := a.convertType(cast.TargetType)
	if err != nil {
		return 0, fmt.Errorf("invalid cast target type: %w", err)
	}
	
	// Get the source type
	sourceType := a.exprTypes[cast.Expr]
	if sourceType == nil {
		return 0, fmt.Errorf("cannot determine type of expression being cast")
	}
	
	// Check if cast is valid
	if !a.isValidCast(sourceType, targetType) {
		return 0, fmt.Errorf("invalid cast from %s to %s", sourceType, targetType)
	}
	
	// For now, casts between compatible types are no-ops at the IR level
	// The type system ensures safety, but the bits are the same
	// Store the target type for the cast expression
	a.exprTypes[cast] = targetType
	
	// In most cases, the cast is just a reinterpretation of the bits
	// Special handling may be needed for:
	// - Widening conversions (u8 -> u16)
	// - Sign extensions (i8 -> i16)
	// - Bit struct conversions
	
	// For bit structs, the underlying representation is the same as the base type
	if _, ok := targetType.(*ir.BitStructType); ok {
		// Bit struct cast - just change the type interpretation
		return exprReg, nil
	}
	if _, ok := sourceType.(*ir.BitStructType); ok {
		// Cast from bit struct - just use the underlying value
		return exprReg, nil
	}
	
	// For basic type conversions, we might need actual conversion code
	// For now, return the same register - the code generator will handle it
	return exprReg, nil
}

// isValidCast checks if a cast from source to target type is valid
func (a *Analyzer) isValidCast(source, target ir.Type) bool {
	// Allow casts between bit structs and their underlying types
	if bitStruct, ok := source.(*ir.BitStructType); ok {
		return a.typesEqual(bitStruct.UnderlyingType, target)
	}
	if bitStruct, ok := target.(*ir.BitStructType); ok {
		return a.typesEqual(source, bitStruct.UnderlyingType)
	}
	
	// Allow casts from enum types to integer types
	if _, ok := source.(*ir.EnumType); ok {
		if targetBasic, ok := target.(*ir.BasicType); ok {
			switch targetBasic.Kind {
			case ir.TypeU8, ir.TypeU16, ir.TypeI8, ir.TypeI16:
				return true
			}
		}
	}
	
	// Allow casts from pointer types to integer types (pointer address to integer)
	if _, ok := source.(*ir.PointerType); ok {
		if targetBasic, ok := target.(*ir.BasicType); ok {
			switch targetBasic.Kind {
			case ir.TypeU8, ir.TypeU16, ir.TypeI8, ir.TypeI16:
				return true
			}
		}
	}
	
	// Allow casts between compatible basic types
	sourceBasic, sourceOk := source.(*ir.BasicType)
	targetBasic, targetOk := target.(*ir.BasicType)
	if sourceOk && targetOk {
		// Allow casts between integer types
		switch sourceBasic.Kind {
		case ir.TypeU8, ir.TypeU16, ir.TypeI8, ir.TypeI16:
			switch targetBasic.Kind {
			case ir.TypeU8, ir.TypeU16, ir.TypeI8, ir.TypeI16:
				return true
			}
		}
	}
	
	return false
}

// typesEqual checks if two types are equal
func (a *Analyzer) typesEqual(t1, t2 ir.Type) bool {
	// Simple comparison for basic types
	b1, ok1 := t1.(*ir.BasicType)
	b2, ok2 := t2.(*ir.BasicType)
	if ok1 && ok2 {
		return b1.Kind == b2.Kind
	}
	
	// For other types, use string comparison (not ideal but works for now)
	return t1.String() == t2.String()
}

// evaluateConstExpr evaluates a constant expression and returns its value
func (a *Analyzer) evaluateConstExpr(expr ast.Expression) (interface{}, error) {
	switch e := expr.(type) {
	case *ast.NumberLiteral:
		return e.Value, nil
	case *ast.StringLiteral:
		return e.Value, nil
	case *ast.BooleanLiteral:
		return e.Value, nil
	case *ast.UnaryExpr:
		// Handle unary operators on constants
		operand, err := a.evaluateConstExpr(e.Operand)
		if err != nil {
			return nil, err
		}
		switch e.Operator {
		case "-":
			if val, ok := operand.(int64); ok {
				return -val, nil
			} else if val, ok := operand.(int); ok {
				return -val, nil
			}
		case "!":
			if val, ok := operand.(bool); ok {
				return !val, nil
			}
		case "~":
			if val, ok := operand.(int64); ok {
				return ^val, nil
			} else if val, ok := operand.(int); ok {
				return ^val, nil
			}
		}
		return nil, fmt.Errorf("cannot evaluate unary operator %s on constant", e.Operator)
	case *ast.BinaryExpr:
		// Handle binary operators on constants
		left, err := a.evaluateConstExpr(e.Left)
		if err != nil {
			return nil, err
		}
		right, err := a.evaluateConstExpr(e.Right)
		if err != nil {
			return nil, err
		}
		
		// Try integer operations - handle both int and int64
		var lInt, rInt int64
		switch l := left.(type) {
		case int64:
			lInt = l
		case int:
			lInt = int64(l)
		default:
			return nil, fmt.Errorf("left operand is not an integer")
		}
		
		switch r := right.(type) {
		case int64:
			rInt = r
		case int:
			rInt = int64(r)
		default:
			return nil, fmt.Errorf("right operand is not an integer")
		}
		
		switch e.Operator {
		case "+":
			return lInt + rInt, nil
		case "-":
			return lInt - rInt, nil
		case "*":
			return lInt * rInt, nil
		case "/":
			if rInt != 0 {
				return lInt / rInt, nil
			}
			return nil, fmt.Errorf("division by zero")
		case "%":
			if rInt != 0 {
				return lInt % rInt, nil
			}
			return nil, fmt.Errorf("modulo by zero")
		case "&":
			return lInt & rInt, nil
		case "|":
			return lInt | rInt, nil
		case "^":
			return lInt ^ rInt, nil
		case "<<":
			return lInt << uint(rInt), nil
		case ">>":
			return lInt >> uint(rInt), nil
		case ">":
			return lInt > rInt, nil
		case ">=":
			return lInt >= rInt, nil
		case "<":
			return lInt < rInt, nil
		case "<=":
			return lInt <= rInt, nil
		case "==":
			return lInt == rInt, nil
		case "!=":
			return lInt != rInt, nil
		}
		
		// Try boolean operations
		if e.Operator == "&&" || e.Operator == "||" || e.Operator == "and" || e.Operator == "or" {
			lBool := a.isTruthy(left)
			rBool := a.isTruthy(right)
			if e.Operator == "&&" || e.Operator == "and" {
				return lBool && rBool, nil
			} else {
				return lBool || rBool, nil
			}
		}
		
		return nil, fmt.Errorf("cannot evaluate binary operator %s on constants", e.Operator)
	case *ast.CompileTimeIf:
		// Evaluate @if at compile time
		conditionValue, err := a.evaluateConstExpr(e.Condition)
		if err != nil {
			return nil, fmt.Errorf("@if condition must be constant: %w", err)
		}
		
		// Check if condition is true
		var isTrue bool
		switch v := conditionValue.(type) {
		case int64:
			isTrue = v != 0
		case int:
			isTrue = v != 0
		case bool:
			isTrue = v
		case string:
			isTrue = v != ""
		default:
			return nil, fmt.Errorf("@if condition must evaluate to boolean, number, or string, got %T", conditionValue)
		}
		
		// Choose and evaluate the appropriate branch
		if isTrue {
			return a.evaluateConstExpr(e.ThenExpr)
		} else if e.ElseExpr != nil {
			return a.evaluateConstExpr(e.ElseExpr)
		} else {
			// No else branch and condition is false - return 0
			return int64(0), nil
		}
	case *ast.Identifier:
		// Look up constant value
		sym := a.currentScope.Lookup(e.Name)
		if sym == nil {
			// Try with module prefix
			if a.currentModule != "" && a.currentModule != "main" {
				prefixedName := a.prefixSymbol(e.Name)
				sym = a.currentScope.Lookup(prefixedName)
			}
		}
		if sym == nil {
			return nil, fmt.Errorf("undefined constant: %s", e.Name)
		}
		if constSym, ok := sym.(*ConstSymbol); ok {
			return constSym.Value, nil
		}
		return nil, fmt.Errorf("%s is not a constant", e.Name)
	default:
		return nil, fmt.Errorf("expression is not a constant")
	}
}

// Close cleans up resources
func (a *Analyzer) Close() {
	// if a.luaEvaluator != nil {
	// 	a.luaEvaluator.Close()
	// }
}

// convertType converts an AST type to an IR type
func (a *Analyzer) convertType(astType ast.Type) (ir.Type, error) {
	if debug {
		fmt.Printf("DEBUG: convertType called with type: %T\n", astType)
	}
	switch t := astType.(type) {
	case *ast.PrimitiveType:
		switch t.Name {
		case "void":
			return &ir.BasicType{Kind: ir.TypeVoid}, nil
		case "bool":
			return &ir.BasicType{Kind: ir.TypeBool}, nil
		case "u8":
			return &ir.BasicType{Kind: ir.TypeU8}, nil
		case "u16":
			return &ir.BasicType{Kind: ir.TypeU16}, nil
		case "u24":
			return &ir.BasicType{Kind: ir.TypeU24}, nil
		case "i8":
			return &ir.BasicType{Kind: ir.TypeI8}, nil
		case "i16":
			return &ir.BasicType{Kind: ir.TypeI16}, nil
		case "i24":
			return &ir.BasicType{Kind: ir.TypeI24}, nil
		case "f8.8":
			return &ir.BasicType{Kind: ir.TypeF8_8}, nil
		case "f.8":
			return &ir.BasicType{Kind: ir.TypeF_8}, nil
		case "f.16":
			return &ir.BasicType{Kind: ir.TypeF_16}, nil
		case "f16.8":
			return &ir.BasicType{Kind: ir.TypeF16_8}, nil
		case "f8.16":
			return &ir.BasicType{Kind: ir.TypeF8_16}, nil
		default:
			// Check if this is a user-defined type (enum, struct, or type alias)
			sym := a.currentScope.Lookup(t.Name)
			if typeSym, ok := sym.(*TypeSymbol); ok {
				return typeSym.Type, nil
			}
			return nil, fmt.Errorf("unknown primitive type: %s", t.Name)
		}
	case *ast.FunctionType:
		// Convert function type for lambda parameters
		paramTypes := []ir.Type{}
		for _, pt := range t.ParamTypes {
			pType, err := a.convertType(pt)
			if err != nil {
				return nil, err
			}
			paramTypes = append(paramTypes, pType)
		}
		retType, err := a.convertType(t.ReturnType)
		if err != nil {
			return nil, err
		}
		return &ir.FunctionType{
			Params: paramTypes,
			Return: retType,
		}, nil
	case *ast.PointerType:
		base, err := a.convertType(t.BaseType)
		if err != nil {
			return nil, err
		}
		return &ir.PointerType{Base: base}, nil
	case *ast.ArrayType:
		elem, err := a.convertType(t.ElementType)
		if err != nil {
			return nil, err
		}
		// Try to evaluate the size as a constant expression
		if t.Size != nil {
			val, err := a.evaluateConstExpr(t.Size)
			if err == nil && val != nil {
				// Convert the value to an integer
				var size int
				switch v := val.(type) {
				case int64:
					size = int(v)
				case int:
					size = v
				default:
					return nil, fmt.Errorf("array size must be an integer, got %T", val)
				}
				return &ir.ArrayType{
					Element: elem,
					Length:  size,
				}, nil
			}
		}
		// Fall back to checking for a number literal
		if num, ok := t.Size.(*ast.NumberLiteral); ok {
			return &ir.ArrayType{
				Element: elem,
				Length:  int(num.Value),
			}, nil
		}
		// Check if it's nil (which shouldn't happen but let's be safe)
		if t.Size == nil {
			return nil, fmt.Errorf("array size is nil")
		}
		return nil, fmt.Errorf("array size must be a constant, got %T", t.Size)
	case *ast.TypeIdentifier:
		// Look up the type in the symbol table
		sym := a.currentScope.Lookup(t.Name)
		
		// Debug output for String/LString/cstr
		if debug && (t.Name == "String" || t.Name == "LString" || t.Name == "cstr") {
			fmt.Printf("DEBUG: Looking up type %s, found: %v\n", t.Name, sym != nil)
			if sym != nil {
				fmt.Printf("DEBUG: Symbol type: %T\n", sym)
			}
			// Also debug the scope hierarchy
			fmt.Printf("DEBUG: Current scope symbols:\n")
			scope := a.currentScope
			for scope != nil {
				for name, symbol := range scope.symbols {
					if name == "cstr" || name == "String" || name == "LString" {
						fmt.Printf("  %s: %T\n", name, symbol)
					}
				}
				scope = scope.parent
			}
		}
		
		// If not found, try with module prefix
		if sym == nil && a.currentModule != "" && a.currentModule != "main" {
			prefixedName := a.prefixSymbol(t.Name)
			sym = a.currentScope.Lookup(prefixedName)
		}
		
		if sym == nil {
			return nil, fmt.Errorf("undefined type: %s", t.Name)
		}
		typeSym, ok := sym.(*TypeSymbol)
		if !ok {
			return nil, fmt.Errorf("%s is not a type", t.Name)
		}
		return typeSym.Type, nil
	case *ast.BitStructType:
		// Determine underlying type (default to u8)
		var underlyingKind ir.TypeKind = ir.TypeU8
		if t.UnderlyingType != nil {
			// Get the underlying type
			if prim, ok := t.UnderlyingType.(*ast.PrimitiveType); ok && prim.Name == "u16" {
				underlyingKind = ir.TypeU16
			}
		}
		
		// Create bit struct type
		bitStruct := &ir.BitStructType{
			UnderlyingType: &ir.BasicType{Kind: underlyingKind},
			Fields: make(map[string]*ir.BitField),
			FieldOrder: []string{},
		}
		
		// Process fields
		bitOffset := 0
		for _, field := range t.Fields {
			if _, exists := bitStruct.Fields[field.Name]; exists {
				return nil, fmt.Errorf("duplicate field %s in bit struct", field.Name)
			}
			
			// Validate bit width
			maxBits := 8
			if underlyingKind == ir.TypeU16 {
				maxBits = 16
			}
			if field.BitWidth < 1 || field.BitWidth > maxBits {
				return nil, fmt.Errorf("bit field %s width %d out of range (1-%d)", field.Name, field.BitWidth, maxBits)
			}
			
			// Check if field fits
			if bitOffset + field.BitWidth > maxBits {
				return nil, fmt.Errorf("bit field %s exceeds %d-bit boundary", field.Name, maxBits)
			}
			
			// Add field
			bitStruct.Fields[field.Name] = &ir.BitField{
				Name:      field.Name,
				BitOffset: bitOffset,
				BitWidth:  field.BitWidth,
			}
			bitStruct.FieldOrder = append(bitStruct.FieldOrder, field.Name)
			bitOffset += field.BitWidth
		}
		
		return bitStruct, nil
	default:
		return nil, fmt.Errorf("unsupported type: %T", astType)
	}
}

// inferType infers the type of an expression
func (a *Analyzer) inferType(expr ast.Expression) (ir.Type, error) {
	switch e := expr.(type) {
	case *ast.NumberLiteral:
		// Infer type based on value
		if e.Value >= 0 && e.Value <= 255 {
			// Small positive values default to u8
			return &ir.BasicType{Kind: ir.TypeU8}, nil
		} else if e.Value >= -128 && e.Value <= 127 {
			// Small signed values default to i8
			return &ir.BasicType{Kind: ir.TypeI8}, nil
		} else if e.Value >= 0 && e.Value <= 65535 {
			// Larger positive values default to u16
			return &ir.BasicType{Kind: ir.TypeU16}, nil
		} else {
			// Default to i16 for negative or large values
			return &ir.BasicType{Kind: ir.TypeI16}, nil
		}
	case *ast.BooleanLiteral:
		return &ir.BasicType{Kind: ir.TypeBool}, nil
	case *ast.CaseExpr:
		// Infer type from the first arm's body
		// In a proper implementation, we'd check all arms have compatible types
		if len(e.Arms) > 0 {
			if bodyExpr, ok := e.Arms[0].Body.(ast.Expression); ok {
				return a.inferType(bodyExpr)
			}
		}
		// Default to u8 if we can't determine
		return &ir.BasicType{Kind: ir.TypeU8}, nil
	case *ast.LuaExpression:
		// Evaluate the Lua expression to determine its type
		result, err := a.luaEvaluator.ProcessLuaExpr(&ast.LuaExpr{Code: e.Code})
		if err != nil {
			return nil, fmt.Errorf("failed to evaluate Lua expression: %w", err)
		}
		
		// Infer type based on the result
		switch v := result.(type) {
		case float64:
			// Lua numbers are always float64, infer based on value
			if v >= 0 && v <= 255 {
				return &ir.BasicType{Kind: ir.TypeU8}, nil
			} else if v >= 0 && v <= 65535 {
				return &ir.BasicType{Kind: ir.TypeU16}, nil
			} else {
				return &ir.BasicType{Kind: ir.TypeI16}, nil
			}
		case []interface{}:
			// Array literal - need to determine element type
			if len(v) == 0 {
				return nil, fmt.Errorf("cannot infer type of empty Lua array")
			}
			// For now, assume u8 array
			return &ir.ArrayType{
				Element: &ir.BasicType{Kind: ir.TypeU8},
				Length:  len(v),
			}, nil
		case string:
			// String literal
			return &ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}}, nil
		default:
			return nil, fmt.Errorf("unsupported Lua expression result type: %T", result)
		}
	case *ast.Identifier:
		sym := a.currentScope.Lookup(e.Name)
		
		// If not found, try with module prefix
		if sym == nil && a.currentModule != "" && a.currentModule != "main" {
			prefixedName := a.prefixSymbol(e.Name)
			sym = a.currentScope.Lookup(prefixedName)
		}
		
		if sym == nil {
			// Debug for screen
			if e.Name == "screen" {
				return nil, fmt.Errorf("undefined identifier: %s (inferType - module should have been found)", e.Name)
			}
			if debug {
				fmt.Printf("DEBUG: Failed to find identifier %s in inferType\n", e.Name)
				fmt.Printf("DEBUG: Current scope: %v\n", a.currentScope)
			}
			return nil, fmt.Errorf("undefined identifier: %s (inferType)", e.Name)
		}
		switch s := sym.(type) {
		case *VarSymbol:
			return s.Type, nil
		case *ConstSymbol:
			return s.Type, nil
		case *ModuleSymbol:
			return nil, fmt.Errorf("module %s cannot be used as a value", s.Name)
		default:
			return nil, fmt.Errorf("cannot infer type from %s", e.Name)
		}
	case *ast.CallExpr:
		// Infer type from function return type
		var funcName string
		var sym Symbol
		
		switch fn := e.Function.(type) {
		case *ast.Identifier:
			funcName = fn.Name
			sym = a.currentScope.Lookup(funcName)
			
			// If not found, try with module prefix
			if sym == nil && a.currentModule != "" && a.currentModule != "main" {
				prefixedName := a.prefixSymbol(funcName)
				sym = a.currentScope.Lookup(prefixedName)
				funcName = prefixedName
			}
			
		case *ast.FieldExpr:
			// Module function call
			if id, ok := fn.Object.(*ast.Identifier); ok {
				funcName = id.Name + "." + fn.Field
				sym = a.currentScope.Lookup(funcName)
			}
			
		default:
			return nil, fmt.Errorf("indirect function calls not yet supported for type inference")
		}
		
		if sym == nil {
			// Try to find similar function names
			suggestions := a.findSimilarIdentifiers(funcName)
			if len(suggestions) > 0 {
				return nil, fmt.Errorf("undefined function: %s - did you mean '%s'?", funcName, suggestions[0])
			}
			return nil, fmt.Errorf("undefined function: %s", funcName)
		}
		
		// Handle both single functions and overload sets
		switch s := sym.(type) {
		case *FuncSymbol:
			if debug {
				fmt.Printf("DEBUG: Found FuncSymbol %s with return type %v\n", s.Name, s.ReturnType)
			}
			return s.ReturnType, nil
		case *FunctionOverloadSet:
			// For type inference, we need to resolve the overload
			// This is a simplified approach - we pick the first overload
			// In a full implementation, we'd resolve based on arguments
			if debug {
				fmt.Printf("DEBUG: Found FunctionOverloadSet for %s with %d overloads\n", funcName, len(s.Overloads))
			}
			if len(s.Overloads) > 0 {
				// Get the first overload from the map
				for mangledName, overload := range s.Overloads {
					if debug {
						fmt.Printf("DEBUG: Using overload %s with return type %v\n", mangledName, overload.ReturnType)
					}
					return overload.ReturnType, nil
				}
			}
			return nil, fmt.Errorf("function %s has no overloads", funcName)
		default:
			return nil, fmt.Errorf("cannot infer type from %s (type %T)", funcName, sym)
		}
	case *ast.BinaryExpr:
		// Infer type from binary expression
		leftType, err := a.inferType(e.Left)
		if err != nil {
			return nil, err
		}
		
		rightType, err := a.inferType(e.Right)
		if err != nil {
			return nil, err
		}
		
		// For arithmetic operations, use the larger type
		// For comparison operations, return bool
		switch e.Operator {
		case "==", "!=", "<", ">", "<=", ">=":
			return &ir.BasicType{Kind: ir.TypeBool}, nil
		case "+", "-":
			// Special handling for pointer arithmetic
			if ptrType, ok := leftType.(*ir.PointerType); ok {
				// Pointer + integer or pointer - integer is valid
				if basicType, ok := rightType.(*ir.BasicType); ok {
					switch basicType.Kind {
					case ir.TypeU8, ir.TypeU16, ir.TypeI8, ir.TypeI16:
						// Valid pointer arithmetic
						return ptrType, nil
					}
				}
			} else if ptrType, ok := rightType.(*ir.PointerType); ok {
				// Integer + pointer is also valid (commutative)
				if e.Operator == "+" {
					if basicType, ok := leftType.(*ir.BasicType); ok {
						switch basicType.Kind {
						case ir.TypeU8, ir.TypeU16, ir.TypeI8, ir.TypeI16:
							// Valid pointer arithmetic
							return ptrType, nil
						}
					}
				}
			}
			// For non-pointer arithmetic, check type compatibility
			if !a.typesCompatible(leftType, rightType) {
				return nil, fmt.Errorf("type mismatch in binary expression: %s vs %s", 
					leftType.String(), rightType.String())
			}
			return leftType, nil
		case "*", "/", "%", "&", "|", "^", "<<", ">>":
			// Check if types match
			if !a.typesCompatible(leftType, rightType) {
				return nil, fmt.Errorf("type mismatch in binary expression: %s vs %s", 
					leftType.String(), rightType.String())
			}
			// For now, just return the left type
			// TODO: Implement proper type promotion rules
			return leftType, nil
		case "=":
			// Assignment returns the type of the assigned value
			return rightType, nil
		case "+=", "-=", "*=", "/=", "%=":
			// Compound assignment returns the type of the left operand
			return leftType, nil
		default:
			return nil, fmt.Errorf("cannot infer type for binary operator %s", e.Operator)
		}
	case *ast.UnaryExpr:
		// Infer type from unary expression
		operandType, err := a.inferType(e.Operand)
		if err != nil {
			return nil, err
		}
		
		switch e.Operator {
		case "-", "~":
			// Negation and bitwise not preserve the type
			return operandType, nil
		case "!":
			// Logical not returns bool
			return &ir.BasicType{Kind: ir.TypeBool}, nil
		case "&":
			// Address-of returns pointer to operand type
			return &ir.PointerType{Base: operandType}, nil
		case "*":
			// Dereference returns the pointed-to type
			if ptrType, ok := operandType.(*ir.PointerType); ok {
				return ptrType.Base, nil
			}
			return nil, fmt.Errorf("cannot dereference non-pointer type: %s", operandType.String())
		default:
			return nil, fmt.Errorf("cannot infer type for unary operator %s", e.Operator)
		}
	case *ast.IndexExpr:
		// Infer element type from array type
		arrayType, err := a.inferType(e.Array)
		if err != nil {
			return nil, err
		}
		
		// Check if it's an array type
		if arrType, ok := arrayType.(*ir.ArrayType); ok {
			return arrType.Element, nil
		}
		
		// Check if it's a pointer type (for pointer indexing like ptr[i])
		if ptrType, ok := arrayType.(*ir.PointerType); ok {
			// For pointers, return the base type they point to
			return ptrType.Base, nil
		}
		
		return nil, fmt.Errorf("cannot index non-array type %s", arrayType.String())
	case *ast.StringLiteral:
		// Determine string type based on length and prefix
		strLen := len(e.Value)
		
		// Check for LString prefix (l"..." or L"...")
		if e.IsLong {
			// Long string type (u16 length)
			return &ir.LStringType{MaxLength: 65535}, nil
		} else if strLen > 255 {
			// Automatically promote to LString if too long for String
			return &ir.LStringType{MaxLength: 65535}, nil
		} else {
			// Short string type (u8 length)
			return &ir.StringType{MaxLength: 255}, nil
		}
	case *ast.FieldExpr:
		// Check if this is a module field access or enum variant access
		if id, ok := e.Object.(*ast.Identifier); ok {
			sym := a.currentScope.Lookup(id.Name)
			
			// Check if the object is a module
			if _, isModule := sym.(*ModuleSymbol); isModule {
				// This is a module member - look up the full qualified name
				fullName := id.Name + "." + e.Field
				memberSym := a.currentScope.Lookup(fullName)
				if memberSym != nil {
					// Check if this is a constant
					if constSym, ok := memberSym.(*ConstSymbol); ok {
						return constSym.Type, nil
					} else if _, ok := memberSym.(*FuncSymbol); ok {
						// This is a module function - it's not a value by itself
						// The type will be determined by the CallExpr that uses it
						return nil, fmt.Errorf("module function %s must be called, not used as a value", fullName)
					}
				}
				return nil, fmt.Errorf("undefined module member: %s", fullName)
			}
			
			// Check if the object is an enum type
			if typeSym, isType := sym.(*TypeSymbol); isType {
				if enumType, isEnum := typeSym.Type.(*ir.EnumType); isEnum {
					// This is an enum variant access - check if variant exists
					_, exists := enumType.Variants[e.Field]
					if !exists {
						return nil, fmt.Errorf("no variant %s in enum %s", e.Field, id.Name)
					}
					return enumType, nil
				}
			}
		}
		
		// Normal struct field access - infer type from struct field
		objType, err := a.inferType(e.Object)
		if err != nil {
			return nil, err
		}
		
		// Handle pointer dereferencing
		actualType := objType
		if ptrType, ok := objType.(*ir.PointerType); ok {
			actualType = ptrType.Base
		}
		
		// Check if it's a struct type
		structType, ok := actualType.(*ir.StructType)
		if !ok {
			return nil, fmt.Errorf("cannot access field %s on non-struct type %s", e.Field, actualType.String())
		}
		
		// Look up field type
		fieldType, exists := structType.Fields[e.Field]
		if !exists {
			return nil, fmt.Errorf("struct %s has no field %s", structType.Name, e.Field)
		}
		
		return fieldType, nil
	case *ast.CastExpr:
		// The type of a cast expression is its target type
		targetType, err := a.convertType(e.TargetType)
		if err != nil {
			return nil, fmt.Errorf("invalid cast target type: %w", err)
		}
		return targetType, nil
	case *ast.LambdaExpr:
		// DEBUG: Lambda type inference
		if debug {
			fmt.Printf("DEBUG: Inferring type for lambda expression\n")
		}
		// Infer lambda type from its parameters and return type
		paramTypes := make([]ir.Type, len(e.Params))
		for i, param := range e.Params {
			if param.Type == nil {
				return nil, fmt.Errorf("lambda parameter %s must have explicit type", param.Name)
			}
			paramType, err := a.convertType(param.Type)
			if err != nil {
				return nil, fmt.Errorf("invalid lambda parameter type for %s: %w", param.Name, err)
			}
			paramTypes[i] = paramType
		}
		
		var returnType ir.Type
		if e.ReturnType != nil {
			var err error
			returnType, err = a.convertType(e.ReturnType)
			if err != nil {
				return nil, fmt.Errorf("invalid lambda return type: %w", err)
			}
		} else {
			// Try to infer return type from body if it's an expression
			if expr, ok := e.Body.(ast.Expression); ok {
				var err error
				returnType, err = a.inferType(expr)
				if err != nil {
					return nil, fmt.Errorf("cannot infer lambda return type: %w", err)
				}
			} else {
				// Block body - assume void for now
				returnType = &ir.BasicType{Kind: ir.TypeVoid}
			}
		}
		
		return &ir.LambdaType{
			ParamTypes: paramTypes,
			ReturnType: returnType,
		}, nil
	case *ast.IteratorChainExpr:
		// Infer type of iterator chain
		return a.analyzeIteratorChainType(e)
	case *ast.EnumLiteral:
		// Look up the enum type
		sym := a.currentScope.Lookup(e.EnumName)
		if sym == nil {
			return nil, fmt.Errorf("undefined enum: %s", e.EnumName)
		}
		
		typeSym, ok := sym.(*TypeSymbol)
		if !ok {
			return nil, fmt.Errorf("%s is not a type", e.EnumName)
		}
		
		enumType, ok := typeSym.Type.(*ir.EnumType)
		if !ok {
			return nil, fmt.Errorf("%s is not an enum type", e.EnumName)
		}
		
		// Check if variant exists
		_, exists := enumType.Variants[e.Variant]
		if !exists {
			return nil, fmt.Errorf("no variant %s in enum %s", e.Variant, e.EnumName)
		}
		
		return enumType, nil
	case *ast.ArrayInitializer:
		// Infer array type from elements
		if len(e.Elements) == 0 {
			// Empty array - default to u8 array
			return &ir.ArrayType{
				Element: &ir.BasicType{Kind: ir.TypeU8},
				Length:  0,
			}, nil
		}
		
		// Infer type from first element
		elementType, err := a.inferType(e.Elements[0])
		if err != nil {
			return nil, fmt.Errorf("cannot infer array element type: %w", err)
		}
		
		// Verify all elements have compatible types
		for i := 1; i < len(e.Elements); i++ {
			elemType, err := a.inferType(e.Elements[i])
			if err != nil {
				return nil, fmt.Errorf("cannot infer type of array element %d: %w", i, err)
			}
			if !a.typesCompatible(elementType, elemType) {
				return nil, fmt.Errorf("array element %d has incompatible type", i)
			}
		}
		
		return &ir.ArrayType{
			Element: elementType,
			Length:  len(e.Elements),
		}, nil
	case *ast.MetafunctionCall:
		// Handle type inference for metafunction calls
		switch e.Name {
		case "to_string":
			// @to_string always returns a string pointer (str type)
			return &ir.PointerType{Base: &ir.BasicType{Kind: ir.TypeU8}}, nil
		case "print":
			// @print returns void
			return &ir.BasicType{Kind: ir.TypeVoid}, nil
		case "error":
			// @error doesn't return (never type) - but for type inference, use void
			return &ir.BasicType{Kind: ir.TypeVoid}, nil
		default:
			// For other metafunctions, try to evaluate them to determine the type
			// For now, default to void
			return &ir.BasicType{Kind: ir.TypeVoid}, nil
		}
	default:
		return nil, fmt.Errorf("cannot infer type from expression of type %T", expr)
	}
}

// typesCompatible checks if two types are compatible for assignment
func (a *Analyzer) typesCompatible(declared, inferred ir.Type) bool {
	// Handle nil types (for polymorphic functions)
	if declared == nil || inferred == nil {
		return true // Allow any type for polymorphic parameters
	}
	
	// Handle basic types
	declBasic, declOk := declared.(*ir.BasicType)
	infBasic, infOk := inferred.(*ir.BasicType)
	
	if declOk && infOk {
		// Same type is always compatible
		if declBasic.Kind == infBasic.Kind {
			return true
		}
		
		// Check for numeric compatibility
		// Allow implicit conversions that don't lose data
		switch declBasic.Kind {
		case ir.TypeU8:
			// u8 can accept values from other types if they fit
			return infBasic.Kind == ir.TypeU8
		case ir.TypeU16:
			// u16 can accept u8 and u16
			return infBasic.Kind == ir.TypeU8 || infBasic.Kind == ir.TypeU16
		case ir.TypeI8:
			// i8 can only accept i8
			return infBasic.Kind == ir.TypeI8
		case ir.TypeI16:
			// i16 can accept i8, i16, u8
			return infBasic.Kind == ir.TypeI8 || infBasic.Kind == ir.TypeI16 || infBasic.Kind == ir.TypeU8
		case ir.TypeVoid:
			// Void matches void
			return infBasic.Kind == ir.TypeVoid
		}
	}
	
	// Handle pointer types
	declPtr, declPtrOk := declared.(*ir.PointerType)
	infPtr, infPtrOk := inferred.(*ir.PointerType)
	
	if declPtrOk && infPtrOk {
		// Check mutability - mutable pointer can't be assigned to immutable
		if !declPtr.IsMutable && infPtr.IsMutable {
			return false
		}
		// Check base types
		return a.typesCompatible(declPtr.Base, infPtr.Base)
	}
	
	// Handle array-to-pointer conversion
	if declPtrOk {
		if infArray, ok := inferred.(*ir.ArrayType); ok {
			// Can convert array to pointer if element types match
			return a.typesCompatible(declPtr.Base, infArray.Element)
		}
	}
	
	// Handle array types
	declArray, declArrayOk := declared.(*ir.ArrayType)
	infArray, infArrayOk := inferred.(*ir.ArrayType)
	
	if declArrayOk && infArrayOk {
		// Arrays must have same length and element type
		return declArray.Length == infArray.Length && 
			a.typesCompatible(declArray.Element, infArray.Element)
	}
	
	// For other types, use exact match
	return declared.String() == inferred.String()
}

var labelCounter int

// generateLabel generates a unique label
func (a *Analyzer) generateLabel(prefix string) string {
	labelCounter++
	return fmt.Sprintf("%s_%d", prefix, labelCounter)
}

// processAbiAttributes processes @abi attributes on function declarations
func (a *Analyzer) processAbiAttributes(fn *ast.FunctionDecl, irFunc *ir.Function) error {
	for _, attr := range fn.Attributes {
		if attr.Name == "abi" {
			return a.processAbiAttribute(attr, irFunc)
		}
	}
	return nil
}

// processAbiAttribute processes a single @abi attribute
func (a *Analyzer) processAbiAttribute(attr *ast.Attribute, irFunc *ir.Function) error {
	// Extract the value from the first argument
	var value string
	if len(attr.Arguments) > 0 {
		if strLit, ok := attr.Arguments[0].(*ast.StringLiteral); ok {
			value = strLit.Value
		} else {
			return fmt.Errorf("@abi attribute expects a string argument")
		}
	} else {
		return fmt.Errorf("@abi attribute requires an argument")
	}
	
	switch value {
	case "smc":
		irFunc.CallingConvention = "smc"
		irFunc.IsSMCDefault = true
		irFunc.IsSMCEnabled = true
		irFunc.SMCParamOffsets = make(map[string]int)
	case "register":
		irFunc.CallingConvention = "register"
		irFunc.IsSMCDefault = false
		irFunc.IsSMCEnabled = false
	case "stack":
		irFunc.CallingConvention = "stack"
		irFunc.IsSMCDefault = false
		irFunc.IsSMCEnabled = false
	case "shadow":
		irFunc.CallingConvention = "shadow"
		irFunc.IsSMCDefault = false
		irFunc.IsSMCEnabled = false
	case "virtual":
		irFunc.CallingConvention = "virtual"
		irFunc.IsSMCDefault = false
		irFunc.IsSMCEnabled = false
	case "naked":
		irFunc.CallingConvention = "naked"
		irFunc.IsSMCDefault = false
		irFunc.IsSMCEnabled = false
	default:
		// Handle complex register mappings like "register: A=x, HL=ptr"
		if strings.HasPrefix(value, "register:") {
			irFunc.CallingConvention = "register_mapped"
			irFunc.IsSMCDefault = false
			irFunc.IsSMCEnabled = false
			// Parse register mappings and store in metadata
			mappings := strings.TrimPrefix(value, "register:")
			mappings = strings.TrimSpace(mappings)
			if irFunc.Metadata == nil {
				irFunc.Metadata = make(map[string]string)
			}
			irFunc.Metadata["register_mappings"] = mappings
		} else {
			return fmt.Errorf("unsupported @abi value: %s", value)
		}
	}
	return nil
}

// analyzeArrayInitializer analyzes an array initializer expression
func (a *Analyzer) analyzeArrayInitializer(arr *ast.ArrayInitializer, irFunc *ir.Function) (ir.Register, error) {
	// Allocate a register for the array
	reg := irFunc.AllocReg()
	
	// If no elements, this is an empty array
	if len(arr.Elements) == 0 {
		// Store type info for empty array
		a.exprTypes[arr] = &ir.ArrayType{
			Element: &ir.BasicType{Kind: ir.TypeU8}, // Default to u8 for empty arrays
			Length:  0,
		}
		return reg, nil
	}
	
	// Analyze all elements to determine their types
	elementRegs := make([]ir.Register, len(arr.Elements))
	var elementType ir.Type
	
	for i, elem := range arr.Elements {
		elemReg, err := a.analyzeExpression(elem, irFunc)
		if err != nil {
			return 0, fmt.Errorf("error analyzing array element %d: %w", i, err)
		}
		elementRegs[i] = elemReg
		
		// Get the type of the element
		elemType := a.exprTypes[elem]
		if elemType == nil {
			return 0, fmt.Errorf("unable to determine type of array element %d", i)
		}
		
		// For the first element, set the expected type
		if i == 0 {
			elementType = elemType
		} else {
			// Check type consistency
			// TODO: Implement type compatibility check
			if elementType.String() != elemType.String() {
				return 0, fmt.Errorf("array element %d has incompatible type: expected %s, got %s", 
					i, elementType.String(), elemType.String())
			}
		}
	}
	
	// Create array type
	arrayType := &ir.ArrayType{
		Element: elementType,
		Length:  len(arr.Elements),
	}
	
	// Store the type
	a.exprTypes[arr] = arrayType
	
	// Generate IR for array initialization
	// This will be handled during code generation
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpArrayInit,
		Dest:    reg,
		Type:    arrayType,
		Comment: fmt.Sprintf("Array initializer with %d elements", len(arr.Elements)),
	})
	
	// Store element registers in metadata for code generation
	for i, elemReg := range elementRegs {
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpArrayElement,
			Dest:    reg,
			Src1:    elemReg,
			Imm:     int64(i),
			Type:    elementType,
			Comment: fmt.Sprintf("Initialize array[%d]", i),
		})
	}
	
	return reg, nil
}

// analyzeStringLiteral analyzes a string literal
// Duplicate method removed - see line 3686

// analyzeInterfaceDecl analyzes an interface declaration
func (a *Analyzer) analyzeInterfaceDecl(decl *ast.InterfaceDecl) error {
	if debug {
		fmt.Printf("DEBUG: Analyzing interface %s with %d methods and %d cast blocks\n", 
			decl.Name, len(decl.Methods), len(decl.CastBlocks))
	}

	// NEW: Analyze cast interfaces if present
	if len(decl.CastBlocks) > 0 {
		a.analyzeSimpleCastInterface(decl)
	}
	
	// Create interface symbol
	methods := make(map[string]*InterfaceMethod)
	
	for _, method := range decl.Methods {
		// Convert parameter types
		params := make([]*ast.Parameter, len(method.Params))
		for i, p := range method.Params {
			params[i] = p
		}
		
		// Convert return type
		returnType, err := a.convertType(method.ReturnType)
		if err != nil {
			return fmt.Errorf("invalid return type for method %s in interface %s: %w", 
				method.Name, decl.Name, err)
		}
		
		methods[method.Name] = &InterfaceMethod{
			Name:       method.Name,
			Params:     params,
			ReturnType: returnType,
		}
	}
	
	// Get prefixed name
	prefixedName := a.prefixSymbol(decl.Name)
	
	// Register interface in scope
	interfaceSym := &InterfaceSymbol{
		Name:    prefixedName,
		Methods: methods,
	}
	
	a.currentScope.Define(prefixedName, interfaceSym)
	
	// Also register without prefix for local access
	if a.currentModule != "" && a.currentModule != "main" {
		a.currentScope.Define(decl.Name, interfaceSym)
	}
	
	if debug {
		fmt.Printf("DEBUG: Registered interface %s (prefixed: %s) with %d methods\n", decl.Name, prefixedName, len(methods))
	}
	
	return nil
}

// analyzeImplBlock analyzes an implementation block
func (a *Analyzer) analyzeImplBlock(impl *ast.ImplBlock) error {
	// Look up the interface
	interfaceSym := a.currentScope.Lookup(impl.InterfaceName)
	if interfaceSym == nil {
		return fmt.Errorf("unknown interface: %s", impl.InterfaceName)
	}
	
	iface, ok := interfaceSym.(*InterfaceSymbol)
	if !ok {
		return fmt.Errorf("%s is not an interface", impl.InterfaceName)
	}
	
	// Get the implementing type
	implType, err := a.convertType(impl.ForType)
	if err != nil {
		return fmt.Errorf("invalid type in impl block: %w", err)
	}
	
	// Create implementation symbol
	implSym := &ImplSymbol{
		InterfaceName: impl.InterfaceName,
		TypeName:      implType.String(),
		Methods:       make(map[string]*FuncSymbol),
	}
	
	// Process each method implementation
	for _, method := range impl.Methods {
		// Check if this method is required by the interface
		ifaceMethod, ok := iface.Methods[method.Name]
		if !ok {
			return fmt.Errorf("method %s is not part of interface %s", method.Name, impl.InterfaceName)
		}
		
		// Verify method signature matches interface
		if len(method.Params) != len(ifaceMethod.Params) {
			return fmt.Errorf("method %s has wrong number of parameters: expected %d, got %d", 
				method.Name, len(ifaceMethod.Params), len(method.Params))
		}
		
		// Check first parameter is 'self'
		if len(method.Params) == 0 || !method.Params[0].IsSelf {
			return fmt.Errorf("method %s must have 'self' as first parameter", method.Name)
		}
		
		// Give the method a unique name based on the implementing type to avoid conflicts
		implTypeIR, err := a.convertType(impl.ForType)
		if err != nil {
			return fmt.Errorf("invalid type in impl block: %w", err)
		}
		
		// For methods with 'self', we need to set the self parameter type
		if len(method.Params) > 0 && method.Params[0].IsSelf {
			// Set the type of 'self' to the implementing type
			method.Params[0].Type = impl.ForType
			// Also set the name explicitly to "self"
			method.Params[0].Name = "self"
			// fmt.Printf("DEBUG: Set self parameter type to %T for method %s\n", impl.ForType, method.Name)
			// if impl.ForType != nil {
			// 	fmt.Printf("  ForType: %v\n", impl.ForType)
			// }
		}
		
		// Create a unique method name for registration
		originalMethodName := method.Name
		uniqueMethodName := implTypeIR.String() + "." + originalMethodName
		
		// Register the method function with a unique name
		returnType, err := a.convertType(method.ReturnType)
		if err != nil {
			return fmt.Errorf("invalid return type for method %s: %w", originalMethodName, err)
		}
		
		methodSymbol := &FuncSymbol{
			Name:       uniqueMethodName,
			ReturnType: returnType,
			Params:     method.Params,
		}
		
		// Register in the current scope
		a.currentScope.Define(uniqueMethodName, methodSymbol)
		
		// Temporarily change the method name for IR generation
		method.Name = uniqueMethodName
		
		// Register the method signature first (since it wasn't done in the first pass)
		if err := a.registerFunctionSignature(method); err != nil {
			return fmt.Errorf("error registering method %s: %w", originalMethodName, err)
		}
		
		// Analyze the method as a regular function
		if err := a.analyzeFunctionDecl(method); err != nil {
			return fmt.Errorf("error analyzing method %s: %w", originalMethodName, err)
		}
		
		// Restore original name but add to implementation with the unique function symbol
		method.Name = originalMethodName
		implSym.Methods[originalMethodName] = methodSymbol
	}
	
	// Verify all interface methods are implemented
	for methodName := range iface.Methods {
		if _, ok := implSym.Methods[methodName]; !ok {
			return fmt.Errorf("type %s does not implement method %s of interface %s", 
				implType.String(), methodName, impl.InterfaceName)
		}
	}
	
	// Register the implementation
	implKey := fmt.Sprintf("%s_for_%s", impl.InterfaceName, implType.String())
	a.currentScope.Define(implKey, implSym)
	
	return nil
}

// findTypeMethod searches for a method implementation for the given type
func (a *Analyzer) findTypeMethod(targetType ir.Type, methodName string) Symbol {
	// Iterate through all symbols in the current scope to find impl blocks
	// We need to check all scopes, not just current
	scope := a.currentScope
	for scope != nil {
		for _, sym := range scope.symbols {
			if implSym, ok := sym.(*ImplSymbol); ok {
				// Check if this impl block is for the target type
				if implSym.TypeName == targetType.String() {
					// Check if this impl block has the requested method
					if methodSym, exists := implSym.Methods[methodName]; exists {
						return methodSym
					}
				}
			}
		}
		scope = scope.parent
	}
	return nil
}

// transformLambdaAssignment transforms a lambda assignment into a function
func (a *Analyzer) transformLambdaAssignment(varDecl *ast.VarDecl, lambda *ast.LambdaExpr, parentFunc *ir.Function) error {
	if debug {
		fmt.Printf("DEBUG: transformLambdaAssignment called for %s\n", varDecl.Name)
		fmt.Printf("  Lambda body type: %T\n", lambda.Body)
	}
	
	// Check for captures first
	if err := a.checkLambdaCaptures(lambda); err != nil {
		return err
	}
	
	// Generate unique function name
	funcName := fmt.Sprintf("%s$%s_%d", parentFunc.Name, varDecl.Name, a.lambdaCounter)
	a.lambdaCounter++
	
	// Create IR function - use same conventions as traditional functions
	lambdaFunc := &ir.Function{
		Name:              funcName,
		CallingConvention: "smc",    // TRUE SMC like traditional functions
		IsSMCDefault:      true,     // Enable SMC by default
		IsSMCEnabled:      true,     // Full SMC support
	}
	
	// Add parameters
	for _, param := range lambda.Params {
		paramType := ir.Type(&ir.BasicType{Kind: ir.TypeU8}) // Default type
		if param.Type != nil {
			var err error
			paramType, err = a.convertType(param.Type)
			if err != nil {
				return fmt.Errorf("lambda param type: %w", err)
			}
		}
		lambdaFunc.Params = append(lambdaFunc.Params, ir.Parameter{
			Name: param.Name,
			Type: paramType,
		})
	}
	
	// Set return type
	if lambda.ReturnType != nil {
		retType, err := a.convertType(lambda.ReturnType)
		if err != nil {
			return fmt.Errorf("lambda return type: %w", err)
		}
		lambdaFunc.ReturnType = retType
	} else {
		// Default to u8 for now
		lambdaFunc.ReturnType = &ir.BasicType{Kind: ir.TypeU8}
	}
	
	// Analyze lambda body in new scope
	lambdaScope := NewScope(a.currentScope)
	prevFunc := a.currentFunc
	a.currentFunc = lambdaFunc
	
	// Add parameters to scope (parameters already added to lambdaFunc.Params above)
	for _, param := range lambdaFunc.Params {
		reg := lambdaFunc.AllocReg() // Just allocate register, don't re-add parameter
		lambdaScope.Define(param.Name, &VarSymbol{
			Name:        param.Name,
			Type:        param.Type,
			Reg:         reg,
			IsParameter: true,
		})
	}
	
	// Analyze body
	prevScope := a.currentScope
	a.currentScope = lambdaScope
	
	// Handle lambda body - it should be a BlockStmt
	var err error
	if blockStmt, ok := lambda.Body.(*ast.BlockStmt); ok {
		err = a.analyzeBlock(blockStmt, lambdaFunc)
	} else {
		// Single expression body - analyze it directly
		if _, err = a.analyzeExpression(lambda.Body.(ast.Expression), lambdaFunc); err == nil {
			// Add implicit return for expression body
			lambdaFunc.Instructions = append(lambdaFunc.Instructions, ir.Instruction{
				Op: ir.OpReturn,
			})
		}
	}
	
	a.currentScope = prevScope
	a.currentFunc = prevFunc
	
	if err != nil {
		return fmt.Errorf("analyzing lambda body: %w", err)
	}
	
	// Add implicit return if needed (basic implementation)
	// TODO: Check if function already has return
	if lambdaFunc.ReturnType != nil {
		// Add default return if no explicit return was added
		needsReturn := true
		if len(lambdaFunc.Instructions) > 0 {
			lastInstr := lambdaFunc.Instructions[len(lambdaFunc.Instructions)-1]
			if lastInstr.Op == ir.OpReturn {
				needsReturn = false
			}
		}
		
		if needsReturn {
			lambdaFunc.Instructions = append(lambdaFunc.Instructions, ir.Instruction{
				Op: ir.OpReturn,
			})
		}
	}
	
	// Add to module
	a.module.Functions = append(a.module.Functions, lambdaFunc)
	
	// Register in parent scope as function reference
	// Convert ir.Parameter to ast.Parameter for compatibility
	astParams := make([]*ast.Parameter, len(lambdaFunc.Params))
	for i, irParam := range lambdaFunc.Params {
		// Convert ir.Type back to ast.Type for the symbol
		var astType ast.Type
		if basicType, ok := irParam.Type.(*ir.BasicType); ok {
			switch basicType.Kind {
			case ir.TypeU8:
				astType = &ast.PrimitiveType{Name: "u8"}
			case ir.TypeU16:
				astType = &ast.PrimitiveType{Name: "u16"}
			case ir.TypeI8:
				astType = &ast.PrimitiveType{Name: "i8"}
			case ir.TypeI16:
				astType = &ast.PrimitiveType{Name: "i16"}
			case ir.TypeBool:
				astType = &ast.PrimitiveType{Name: "bool"}
			default:
				astType = &ast.PrimitiveType{Name: "u8"}
			}
		} else {
			astType = &ast.PrimitiveType{Name: "u8"} // fallback
		}
		
		astParams[i] = &ast.Parameter{
			Name: irParam.Name,
			Type: astType,
		}
	}
	
	funcSymbol := &FuncSymbol{
		Name:       funcName,
		ReturnType: lambdaFunc.ReturnType,
		Params:     astParams,
	}
	
	if debug {
		fmt.Printf("DEBUG: Created FuncSymbol for %s with %d parameters\n", varDecl.Name, len(astParams))
		for i, param := range astParams {
			fmt.Printf("  Param %d: %s %s\n", i, param.Name, param.Type.(*ast.PrimitiveType).Name)
		}
	}
	
	a.currentScope.Define(varDecl.Name, funcSymbol)
	
	return nil
}

// getMethodBaseName returns the base name for a method on a given type
func (a *Analyzer) getMethodBaseName(objType ir.Type, methodName string) string {
	// Extract the type name
	var typeName string
	switch t := objType.(type) {
	case *ir.StructType:
		typeName = t.Name
	case *ir.EnumType:
		typeName = t.Name
	default:
		return ""
	}
	
	if typeName == "" {
		return ""
	}
	
	// Return the base method name (e.g., "Circle.draw")
	return typeName + "." + methodName
}

// findInterfaceMethod finds the concrete implementation function for an interface method
// This is the core of zero-cost interfaces - compile-time method resolution
func (a *Analyzer) findInterfaceMethod(objType ir.Type, methodName string) *FuncSymbol {
	if debug {
		fmt.Printf("DEBUG: findInterfaceMethod called for type %s, method %s\n", objType.String(), methodName)
	}
	
	// Convert IR type back to type name for lookup
	var typeName string
	switch t := objType.(type) {
	case *ir.StructType:
		typeName = t.Name
		// Remove module prefix if present for local lookups
		if idx := strings.LastIndex(typeName, "."); idx >= 0 {
			baseTypeName := typeName[idx+1:]
			// We'll try both with and without module prefix
			typeName = baseTypeName
		}
	case *ir.BasicType:
		// Basic types don't have interface implementations for now
		return nil
	default:
		if debug {
			fmt.Printf("DEBUG: Unsupported type for interface method: %T\n", objType)
		}
		return nil
	}
	
	if debug {
		fmt.Printf("DEBUG: Looking for implementations of %s.%s\n", typeName, methodName)
	}
	
	// Look for implementation functions
	// Implementation functions are named: TypeName_InterfaceName_MethodName or TypeName_MethodName
	possibleNames := []string{
		fmt.Sprintf("%s_%s", typeName, methodName),  // Simple naming: Circle_draw
		fmt.Sprintf("%s.%s", typeName, methodName),  // Dot notation: Circle.draw
	}
	
	for _, name := range possibleNames {
		if sym := a.currentScope.Lookup(name); sym != nil {
			if funcSym, ok := sym.(*FuncSymbol); ok {
				if debug {
					fmt.Printf("DEBUG: Found implementation function: %s\n", name)
				}
				return funcSym
			}
		}
		
		// Try with module prefix
		if a.currentModule != "" && a.currentModule != "main" {
			prefixedName := a.prefixSymbol(name)
			if sym := a.currentScope.Lookup(prefixedName); sym != nil {
				if funcSym, ok := sym.(*FuncSymbol); ok {
					if debug {
						fmt.Printf("DEBUG: Found prefixed implementation function: %s\n", prefixedName)
					}
					return funcSym
				}
			}
		}
	}
	
	if debug {
		fmt.Printf("DEBUG: No implementation found for %s.%s\n", typeName, methodName)
	}
	return nil
}

// checkLambdaCaptures ensures lambda doesn't capture variables (for now)
func (a *Analyzer) checkLambdaCaptures(lambda *ast.LambdaExpr) error {
	// For now, just return nil - no capture detection
	// TODO: Implement proper capture detection
	return nil
}

// analyzeLambdaExpr analyzes lambda expressions
func (a *Analyzer) analyzeLambdaExpr(lambda *ast.LambdaExpr, irFunc *ir.Function) (ir.Register, error) {
	if debug {
		fmt.Printf("DEBUG: analyzeLambdaExpr called\n")
	}
	// Generate unique lambda name
	lambdaName := fmt.Sprintf("lambda_%s_%d", irFunc.Name, a.lambdaCounter)
	a.lambdaCounter++
	
	// Create a new function for the lambda template
	lambdaFunc := &ir.Function{
		Name:             lambdaName,
		Params:           []ir.Parameter{},
		ReturnType:       &ir.BasicType{Kind: ir.TypeU8}, // Default for now
		Instructions:     []ir.Instruction{},
		IsSMCDefault:     false, // Lambdas use stack parameters for now
		IsSMCEnabled:     false,
		CallingConvention: "stack", // Explicitly use stack calling convention
	}
	
	// Add lambda parameters to function
	for _, param := range lambda.Params {
		paramType := ir.Type(&ir.BasicType{Kind: ir.TypeU8}) // Default type
		if param.Type != nil {
			var err error
			paramType, err = a.convertType(param.Type)
			if err != nil {
				return 0, fmt.Errorf("failed to convert parameter type: %w", err)
			}
		}
		lambdaFunc.Params = append(lambdaFunc.Params, ir.Parameter{
			Name: param.Name,
			Type: paramType,
		})
	}
	
	// Create a new scope for lambda analysis
	lambdaScope := NewScope(a.currentScope)
	prevScope := a.currentScope
	prevFunc := a.currentFunc
	a.currentScope = lambdaScope
	a.currentFunc = lambdaFunc
	
	// Add lambda parameters to scope
	for _, param := range lambda.Params {
		paramType := ir.Type(&ir.BasicType{Kind: ir.TypeU8})
		if param.Type != nil {
			var err error
			paramType, err = a.convertType(param.Type)
			if err != nil {
				a.currentScope = prevScope
				a.currentFunc = prevFunc
				return 0, fmt.Errorf("failed to convert parameter type: %w", err)
			}
		}
		symbol := &VarSymbol{
			Name: param.Name,
			Type: paramType,
		}
		lambdaScope.Define(param.Name, symbol)
	}
	
	// Analyze lambda body - this will automatically capture variables by absolute address!
	var bodyReg ir.Register
	var err error
	
	if debug {
		fmt.Printf("DEBUG: Lambda body type: %T\n", lambda.Body)
	}
	
	switch body := lambda.Body.(type) {
	case ast.Expression:
		if debug {
			fmt.Printf("DEBUG: Analyzing lambda expression body\n")
		}
		bodyReg, err = a.analyzeExpression(body, lambdaFunc)
		if err != nil {
			a.currentScope = prevScope
			a.currentFunc = prevFunc
			return 0, fmt.Errorf("failed to analyze lambda body: %w", err)
		}
		// Return the result
		lambdaFunc.Instructions = append(lambdaFunc.Instructions, ir.Instruction{
			Op:   ir.OpReturn,
			Src1: bodyReg,
		})
	case *ast.BlockStmt:
		if debug {
			fmt.Printf("DEBUG: Analyzing lambda block body with %d statements\n", len(body.Statements))
		}
		err = a.analyzeBlock(body, lambdaFunc)
		if err != nil {
			a.currentScope = prevScope
			a.currentFunc = prevFunc
			return 0, fmt.Errorf("failed to analyze lambda block: %w", err)
		}
		// Check if block ends with an expression that should be returned
		if len(body.Statements) > 0 {
			if exprStmt, ok := body.Statements[len(body.Statements)-1].(*ast.ExpressionStmt); ok {
				if debug {
					fmt.Printf("DEBUG: Lambda block ends with expression, analyzing for implicit return\n")
				}
				// Re-analyze the last expression to get its register
				exprReg, err := a.analyzeExpression(exprStmt.Expression, lambdaFunc)
				if err == nil {
					// Add implicit return
					lambdaFunc.Instructions = append(lambdaFunc.Instructions, ir.Instruction{
						Op:   ir.OpReturn,
						Src1: exprReg,
					})
				}
			}
		}
	}
	
	// Restore previous scope and function
	a.currentScope = prevScope
	a.currentFunc = prevFunc
	
	// Add lambda function to module
	a.module.Functions = append(a.module.Functions, lambdaFunc)
	
	// Return address of lambda function
	resultReg := irFunc.AllocReg()
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:    ir.OpLoadAddr,
		Dest:  resultReg,
		Label: lambdaName,
	})
	
	// Store the lambda type for the expression so variable declaration can use it
	// Build parameter types list
	paramTypes := make([]ir.Type, len(lambda.Params))
	for i, param := range lambda.Params {
		if param.Type != nil {
			// Convert the parameter type
			pType, err := a.convertType(param.Type)
			if err != nil {
				paramTypes[i] = &ir.BasicType{Kind: ir.TypeU8} // Fallback
			} else {
				paramTypes[i] = pType
			}
		} else {
			paramTypes[i] = &ir.BasicType{Kind: ir.TypeU8} // Default for now
		}
	}
	
	lambdaType := &ir.LambdaType{
		ParamTypes: paramTypes,
		ReturnType: lambdaFunc.ReturnType,
	}
	a.exprTypes[lambda] = lambdaType
	
	return resultReg, nil
}

// analyzeLambdaCall handles calling a lambda variable as a function pointer
func (a *Analyzer) analyzeLambdaCall(call *ast.CallExpr, lambdaType *ir.LambdaType, varName string, irFunc *ir.Function) (ir.Register, error) {
	// Analyze arguments
	if len(call.Arguments) != len(lambdaType.ParamTypes) {
		return 0, fmt.Errorf("lambda call argument count mismatch: expected %d, got %d", 
			len(lambdaType.ParamTypes), len(call.Arguments))
	}
	
	// Evaluate arguments
	argRegs := make([]ir.Register, len(call.Arguments))
	for i, arg := range call.Arguments {
		argReg, err := a.analyzeExpression(arg, irFunc)
		if err != nil {
			return 0, fmt.Errorf("failed to analyze lambda call argument %d: %w", i, err)
		}
		argRegs[i] = argReg
	}
	
	// Get lambda function address
	lambdaAddrReg := irFunc.AllocReg()
	varSym := a.currentScope.Lookup(varName)
	varSymbol := varSym.(*VarSymbol)
	
	// Load lambda function address from variable
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpLoadVar,
		Dest: lambdaAddrReg,
		Src1: varSymbol.Reg,
	})
	
	// Make indirect call through lambda address with arguments
	resultReg := irFunc.AllocReg()
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpCallIndirect,
		Dest: resultReg,
		Src1: lambdaAddrReg,
		Args: argRegs,  // Pass the arguments for SMC patching
	})
	
	// Store the return type in expression types map
	a.exprTypes[call] = lambdaType.ReturnType
	
	return resultReg, nil
}

// analyzeLocalFunctionDecl analyzes a local function declaration within another function
func (a *Analyzer) analyzeLocalFunctionDecl(fn *ast.FunctionDecl, parentFunc *ir.Function) error {
	if debug {
		fmt.Printf("DEBUG: analyzeLocalFunctionDecl: %s in parent %s\n", fn.Name, parentFunc.Name)
	}
	
	// Generate unique name for local function
	// Format: parentFunc$localFunc
	localFuncName := fmt.Sprintf("%s$%s", parentFunc.Name, fn.Name)
	
	// First register the function signature in current scope
	// Local functions are accessible within their parent function's scope
	if err := a.registerLocalFunctionSignature(fn, localFuncName); err != nil {
		return fmt.Errorf("failed to register local function %s: %w", localFuncName, err)
	}
	
	// Create IR function for the local function
	returnType, err := a.convertType(fn.ReturnType)
	if err != nil {
		return fmt.Errorf("invalid return type for local function %s: %w", fn.Name, err)
	}
	
	localIRFunc := ir.NewFunction(localFuncName, returnType)
	
	// Process @abi attributes
	if err := a.processAbiAttributes(fn, localIRFunc); err != nil {
		return fmt.Errorf("error processing @abi attributes for local function %s: %v", fn.Name, err)
	}
	
	// Enable SMC by default for local functions too
	if localIRFunc.CallingConvention == "" {
		localIRFunc.IsSMCDefault = true
		localIRFunc.SMCParamOffsets = make(map[string]int)
	}
	
	// Set up parent function context for lexical scope access
	localIRFunc.ParentFunction = parentFunc.Name
	localIRFunc.CapturedVars = make(map[string]*ir.CapturedVar)
	
	// Save the parent function's scope where the local function was just registered
	parentScope := a.currentScope
	
	// Enter new scope for local function, but keep parent scope accessible
	prevFunc := a.currentFunc
	a.currentFunc = localIRFunc
	defer func() { a.currentFunc = prevFunc }()
	
	// Create new scope that can see parent scopes
	a.currentScope = NewScope(parentScope)
	defer func() { a.currentScope = parentScope }()
	
	// Process parameters
	for _, param := range fn.Params {
		paramType, err := a.convertType(param.Type)
		if err != nil {
			return fmt.Errorf("invalid parameter type for %s: %w", param.Name, err)
		}

		reg := localIRFunc.AddParam(param.Name, paramType)
		a.currentScope.Define(param.Name, &VarSymbol{
			Name:        param.Name,
			Type:        paramType,
			Reg:         reg,
			IsParameter: true,
			IsMutable:   true,
		})
	}
	
	// Analyze function body - this will capture variables from parent scopes automatically
	if err := a.analyzeBlock(fn.Body, localIRFunc); err != nil {
		return fmt.Errorf("error in local function %s: %w", fn.Name, err)
	}
	
	// Add implicit return if needed
	if len(localIRFunc.Instructions) == 0 || localIRFunc.Instructions[len(localIRFunc.Instructions)-1].Op != ir.OpReturn {
		localIRFunc.Instructions = append(localIRFunc.Instructions, ir.Instruction{Op: ir.OpReturn})
	}
	
	// Add the local function to the module
	a.module.Functions = append(a.module.Functions, localIRFunc)
	
	if debug {
		fmt.Printf("DEBUG: Local function %s compiled successfully with %d captured vars\n", 
			localFuncName, len(localIRFunc.CapturedVars))
	}
	
	return nil
}

// analyzeNilCoalescingExpr analyzes nil coalescing operator (??)
// Semantic: left ?? right returns left if CY is clear, right if CY is set
func (a *Analyzer) analyzeNilCoalescingExpr(expr *ast.NilCoalescingExpr, irFunc *ir.Function) (ir.Register, error) {
	// Analyze left expression (the one that might set CY flag or throw errors)
	leftReg, err := a.analyzeExpression(expr.Left, irFunc)
	if err != nil {
		return 0, fmt.Errorf("nil coalescing left operand: %w", err)
	}
	
	// Determine source error type from left expression
	var sourceErrorType ir.Type
	if callExpr, ok := expr.Left.(*ast.CallExpr); ok {
		// Check if left side is a function call that can return errors
		if ident, ok := callExpr.Function.(*ast.Identifier); ok {
			if funcSym := a.currentScope.Lookup(ident.Name); funcSym != nil {
				if fs, ok := funcSym.(*FuncSymbol); ok && fs.ErrorType != nil {
					sourceErrorType = fs.ErrorType
				}
			}
		}
	}
	
	// Set error propagation context for right operand analysis
	oldContext := a.errorPropagationContext
	a.errorPropagationContext = &ErrorPropagationContext{
		InPropagation:   true,
		SourceErrorType: sourceErrorType,
		TargetErrorType: irFunc.ErrorType,
	}
	
	// Create result register
	resultReg := irFunc.AllocReg()
	
	// Create labels for conditional jump
	elseLabel := a.generateLabel("nil_coalescing_else")
	endLabel := a.generateLabel("nil_coalescing_end")
	
	// Test carry flag (proper error checking for functions with ? return type)
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpCheckError,
		Comment: "Check carry flag for error condition",
	})
	
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:      ir.OpJumpIf,
		Label:   elseLabel,
		Comment: "Jump to error handler if CY flag set",
	})
	// Test if leftReg is zero (error case)
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpTest,
		Src1: leftReg,
	})
	
	// Jump to else if left is zero (error case)
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:    ir.OpJumpIfZero,
		Label: elseLabel,
	})
	
	// Success path - move left value to result
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpMove,
		Dest: resultReg,
		Src1: leftReg,
	})
	
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:    ir.OpJump,
		Label: endLabel,
	})
	
	// Error path - evaluate right expression
	irFunc.EmitLabel(elseLabel)
	
	// Analyze right expression
	rightReg, err := a.analyzeExpression(expr.Right, irFunc)
	if err != nil {
		return 0, fmt.Errorf("nil coalescing right operand: %w", err)
	}
	
	// Move right value to result
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpMove,
		Dest: resultReg,
		Src1: rightReg,
	})
	
	// End label
	irFunc.EmitLabel(endLabel)
	
	// Restore previous error propagation context
	a.errorPropagationContext = oldContext
	
	return resultReg, nil
}

// analyzeIfExpr analyzes if expressions (if cond { val1 } else { val2 })
// analyzeTryExpr analyzes the ? operator for error propagation
func (a *Analyzer) analyzeTryExpr(expr *ast.TryExpr, irFunc *ir.Function) (ir.Register, error) {
	// The ? operator is used for error propagation
	// For now, we simply analyze the inner expression
	// In a complete implementation, this would handle error propagation logic
	
	if expr.Expression == nil {
		return 0, fmt.Errorf("try expression has no inner expression")
	}
	
	// Analyze the inner expression
	reg, err := a.analyzeExpression(expr.Expression, irFunc)
	if err != nil {
		return 0, fmt.Errorf("try expression: %w", err)
	}
	
	// TODO: Add error propagation logic here
	// For now, we just pass through the result
	// In Z80, this would typically check the carry flag and return early on error
	
	return reg, nil
}

// analyzeBlockExpression analyzes a block statement as an expression
// The block's value is determined by its last statement
func (a *Analyzer) analyzeBlockExpression(block *ast.BlockStmt, irFunc *ir.Function) (ir.Register, error) {
	// Push new scope for the block
	a.currentScope = NewScope(a.currentScope)
	defer func() { a.currentScope = a.currentScope.parent }()
	
	// Handle empty block - returns void/unit
	if len(block.Statements) == 0 {
		return 0, nil
	}
	
	// Analyze all statements except the last
	for i := 0; i < len(block.Statements)-1; i++ {
		if err := a.analyzeStatement(block.Statements[i], irFunc); err != nil {
			return 0, fmt.Errorf("block statement %d: %w", i, err)
		}
	}
	
	// The last statement determines the block's value
	lastStmt := block.Statements[len(block.Statements)-1]
	
	// Check if it's an expression statement
	if exprStmt, ok := lastStmt.(*ast.ExpressionStmt); ok {
		return a.analyzeExpression(exprStmt.Expression, irFunc)
	}
	
	// If it's a return statement, use its value
	if retStmt, ok := lastStmt.(*ast.ReturnStmt); ok && retStmt.Value != nil {
		return a.analyzeExpression(retStmt.Value, irFunc)
	}
	
	// Otherwise, analyze as a regular statement (block has no value)
	if err := a.analyzeStatement(lastStmt, irFunc); err != nil {
		return 0, err
	}
	
	// Block has no expression value (void)
	return 0, nil
}

func (a *Analyzer) analyzeIfExpr(expr *ast.IfExpr, irFunc *ir.Function) (ir.Register, error) {
	// Analyze condition
	condReg, err := a.analyzeExpression(expr.Condition, irFunc)
	if err != nil {
		return 0, fmt.Errorf("if expression condition: %w", err)
	}
	
	// Create result register
	resultReg := irFunc.AllocReg()
	
	// Create labels
	elseLabel := a.generateLabel("if_expr_else")
	endLabel := a.generateLabel("if_expr_end")
	
	// Test condition (assuming 0 = false, non-zero = true)
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpTest,
		Src1: condReg,
	})
	
	// Jump to else if condition is false
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:    ir.OpJumpIfZero,
		Label: elseLabel,
	})
	
	// Then branch
	thenReg, err := a.analyzeExpression(expr.ThenBranch, irFunc)
	if err != nil {
		return 0, fmt.Errorf("if expression then branch: %w", err)
	}
	
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpMove,
		Dest: resultReg,
		Src1: thenReg,
	})
	
	irFunc.EmitJump(endLabel)
	
	// Else branch
	irFunc.EmitLabel(elseLabel)
	
	if expr.ElseBranch != nil {
		elseReg, err := a.analyzeExpression(expr.ElseBranch, irFunc)
		if err != nil {
			return 0, fmt.Errorf("if expression else branch: %w", err)
		}
		
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpMove,
			Dest: resultReg,
			Src1: elseReg,
		})
	} else {
		// No else branch - use zero/void value
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:   ir.OpLoadConst,
			Dest: resultReg,
			Imm:  0,
		})
	}
	
	// End label
	irFunc.EmitLabel(endLabel)
	
	return resultReg, nil
}

// analyzeTernaryExpr analyzes Python-style ternary (value_if_true if condition else value_if_false)
func (a *Analyzer) analyzeTernaryExpr(expr *ast.TernaryExpr, irFunc *ir.Function) (ir.Register, error) {
	// Analyze condition
	condReg, err := a.analyzeExpression(expr.Condition, irFunc)
	if err != nil {
		return 0, fmt.Errorf("ternary condition: %w", err)
	}
	
	// Create result register
	resultReg := irFunc.AllocReg()
	
	// Create labels
	falseLabel := a.generateLabel("ternary_false")
	endLabel := a.generateLabel("ternary_end")
	
	// Test condition
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpTest,
		Src1: condReg,
	})
	
	// Jump to false branch if condition is false
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:    ir.OpJumpIfZero,
		Label: falseLabel,
	})
	
	// True branch
	trueReg, err := a.analyzeExpression(expr.TrueExpr, irFunc)
	if err != nil {
		return 0, fmt.Errorf("ternary true expression: %w", err)
	}
	
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpMove,
		Dest: resultReg,
		Src1: trueReg,
	})
	
	irFunc.EmitJump(endLabel)
	
	// False branch
	irFunc.EmitLabel(falseLabel)
	
	falseReg, err := a.analyzeExpression(expr.FalseExpr, irFunc)
	if err != nil {
		return 0, fmt.Errorf("ternary false expression: %w", err)
	}
	
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpMove,
		Dest: resultReg,
		Src1: falseReg,
	})
	
	// End label
	irFunc.EmitLabel(endLabel)
	
	return resultReg, nil
}

// analyzeWhenExpr analyzes pattern matching expressions
func (a *Analyzer) analyzeWhenExpr(expr *ast.WhenExpr, irFunc *ir.Function) (ir.Register, error) {
	// For now, return a simple implementation
	// TODO: Implement full pattern matching
	
	resultReg := irFunc.AllocReg()
	
	// Load default value (0) for now
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpLoadConst,
		Dest: resultReg,
		Imm:  0,
	})
	
	return resultReg, nil
}

// Helper methods

// isErrorType checks if a type is an error type (ends with ?)
func (a *Analyzer) isErrorType(t ir.Type) bool {
	// For now, return false - need to implement error type checking
	// TODO: Add proper error type detection
	return false
}

// getFunctionType extracts function type from call expression  
func (a *Analyzer) getFunctionType(call *ast.CallExpr) *ir.FunctionType {
	if id, ok := call.Function.(*ast.Identifier); ok {
		if sym := a.currentScope.Lookup(id.Name); sym != nil {
			if funcSym, ok := sym.(*FuncSymbol); ok {
				return funcSym.Type
			}
		}
	}
	return nil
}

// analyzeErrorExpr analyzes @error(value) expressions
// Sets CY flag and returns from function with error value
func (a *Analyzer) analyzeErrorExpr(errorExpr *ast.CompileTimeError, irFunc *ir.Function) (ir.Register, error) {
	if errorExpr.ErrorValue == nil {
		// This is @error or @error() - error propagation
		return a.analyzeErrorPropagation(irFunc)
	} else {
		// This is @error(value) - explicit error
		return a.analyzeExplicitError(errorExpr, irFunc)
	}
}

func (a *Analyzer) analyzeExplicitError(errorExpr *ast.CompileTimeError, irFunc *ir.Function) (ir.Register, error) {
	// Get the current function's symbol to check its error type
	var currentFuncSym *FuncSymbol
	for name, sym := range a.currentScope.symbols {
		if funcSym, ok := sym.(*FuncSymbol); ok && strings.HasSuffix(name, irFunc.Name) {
			currentFuncSym = funcSym
			break
		}
	}
	
	// If no current function found, walk up the scope hierarchy
	if currentFuncSym == nil {
		scope := a.currentScope.parent
		for scope != nil {
			for name, sym := range scope.symbols {
				if funcSym, ok := sym.(*FuncSymbol); ok && strings.HasSuffix(name, irFunc.Name) {
					currentFuncSym = funcSym
					break
				}
			}
			if currentFuncSym != nil {
				break
			}
			scope = scope.parent
		}
	}
	
	// Validate error type if function has declared error type
	if currentFuncSym != nil && currentFuncSym.ErrorType != nil {
		// Infer the type of the error expression
		errorType, err := a.inferType(errorExpr.ErrorValue)
		if err != nil {
			return 0, fmt.Errorf("cannot determine type of @error expression: %w", err)
		}
		
		// Check if error type matches declared error type
		if !a.typesCompatible(currentFuncSym.ErrorType, errorType) {
			return 0, fmt.Errorf("@error type mismatch: function declares error type %s but got %s", 
				currentFuncSym.ErrorType.String(), errorType.String())
		}
	}
	
	// Analyze the error value expression
	errorReg, err := a.analyzeExpression(errorExpr.ErrorValue, irFunc)
	if err != nil {
		return 0, fmt.Errorf("@error value: %w", err)
	}
	
	// Set CY flag (carry flag indicates error in Z80)
	// For now, use a placeholder operation - we'll implement OpSetCarry later
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpLoadConst,  // Placeholder: set error flag in a register
		Dest: ir.Register(-10), // Special register to indicate error state
		Imm:  1,               // Error = 1
	})
	
	// Return the error value
	// The error value should be in register A for Z80 convention
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:   ir.OpMove,
		Dest: ir.Register(0), // Move to register 0 (convention)
		Src1: errorReg,
	})
	
	// Generate return instruction
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op: ir.OpReturn,
	})
	
	// Return dummy register (this code path won't continue)
	return errorReg, nil
}

// analyzeErrorPropagation handles @error without arguments - propagates current error
func (a *Analyzer) analyzeErrorPropagation(irFunc *ir.Function) (ir.Register, error) {
	// Check if we're in an error propagation context (after ?? operator)
	if !a.isInErrorPropagationContext() {
		return 0, fmt.Errorf("@error without arguments can only be used after ?? operator in error propagation context")
	}
	
	// Return the error register from the context
	// This allows @error to be used in expressions after ??
	if a.errorPropagationContext.ErrorRegister != 0 {
		return a.errorPropagationContext.ErrorRegister, nil
	}
	
	// Fallback to old behavior for compatibility
	// Get the source and target error types from context
	sourceErrorType := a.getCurrentErrorSourceType()
	targetErrorType := irFunc.ErrorType
	
	if sourceErrorType != nil && targetErrorType != nil {
		// Check if types match for zero-overhead propagation
		if a.areErrorTypesEqual(sourceErrorType, targetErrorType) {
			// Zero-overhead propagation: just return (CY already set, A has error code)
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:      ir.OpReturn,
				Comment: "Zero-overhead error propagation (same type)",
			})
		} else {
			// Cross-type propagation: convert error type
			convertedReg := irFunc.AllocReg()
			
			// Load source error code from return register
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:      ir.OpMove,
				Dest:    convertedReg,
				Src1:    ir.RegRet, // Error code is in return register
				Comment: "Load source error code for conversion",
			})
			
			// Convert error type (implementation depends on error mapping)
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:      ir.OpCall,
				Symbol:  a.getErrorConversionFunction(sourceErrorType, targetErrorType),
				Src1:    convertedReg,
				Dest:    ir.RegRet, // Result back to return register
				Comment: fmt.Sprintf("Convert error: %s -> %s", 
					a.getErrorTypeName(sourceErrorType), 
					a.getErrorTypeName(targetErrorType)),
			})
			
			// Set carry flag and return
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:      ir.OpSetError,
				Src1:    ir.RegRet, // Error code is in return register
				Comment: "Set error flag",
			})
			
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:      ir.OpReturn,
				Comment: "Cross-type error propagation with conversion",
			})
		}
	} else {
		// Fallback: basic error propagation
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:      ir.OpReturn,
			Comment: "Basic error propagation: @error without arguments",
		})
	}
	
	return 0, nil  // This code path won't continue
}

// Error propagation context tracking

// ErrorPropagationContext tracks the current error propagation state
type ErrorPropagationContext struct {
	InPropagation   bool
	SourceErrorType ir.Type
	TargetErrorType ir.Type
	ErrorRegister   ir.Register // The register containing the error value
}

// isInErrorPropagationContext checks if we're currently in an error propagation context
func (a *Analyzer) isInErrorPropagationContext() bool {
	return a.errorPropagationContext != nil && a.errorPropagationContext.InPropagation
}

// getCurrentErrorSourceType gets the error type from the failed expression
func (a *Analyzer) getCurrentErrorSourceType() ir.Type {
	if a.errorPropagationContext != nil {
		return a.errorPropagationContext.SourceErrorType
	}
	return nil
}

// enterErrorPropagationContext enters an error propagation context (after ?? operator)
func (a *Analyzer) enterErrorPropagationContext(errorReg ir.Register, errorType ir.Type) {
	a.errorPropagationContext = &ErrorPropagationContext{
		InPropagation:   true,
		SourceErrorType: errorType,
		ErrorRegister:   errorReg,
	}
}

// exitErrorPropagationContext exits the error propagation context
func (a *Analyzer) exitErrorPropagationContext() {
	a.errorPropagationContext = nil
}

// areErrorTypesEqual checks if two error types are the same
func (a *Analyzer) areErrorTypesEqual(source, target ir.Type) bool {
	if source == nil || target == nil {
		return false
	}
	
	// Simple type equality check
	sourceStr := a.getErrorTypeName(source)
	targetStr := a.getErrorTypeName(target)
	return sourceStr == targetStr
}

// getErrorTypeName gets the string name of an error type
func (a *Analyzer) getErrorTypeName(errorType ir.Type) string {
	if errorType == nil {
		return "unknown"
	}
	
	// Handle different error type representations
	switch t := errorType.(type) {
	case *ir.BasicType:
		return fmt.Sprintf("BasicType_%d", t.Kind)
	case *ir.EnumType:
		return t.Name
	default:
		return fmt.Sprintf("%T", errorType)
	}
}

// getErrorConversionFunction generates the name of an error conversion function
func (a *Analyzer) getErrorConversionFunction(source, target ir.Type) string {
	sourceName := a.getErrorTypeName(source)
	targetName := a.getErrorTypeName(target)
	return fmt.Sprintf("convert_error_%s_to_%s", sourceName, targetName)
}

// analyzeExpressionDecl analyzes top-level metaprogramming expressions
func (a *Analyzer) analyzeExpressionDecl(decl *ast.ExpressionDecl) error {
	switch expr := decl.Expression.(type) {
	case *ast.CompileTimeMinz:
		// Execute the @minz metafunction
		_, err := a.analyzeMinzExpr(expr, nil) // nil irFunc for top-level
		return err
	case *ast.MinzMetafunctionCall:
		// Execute the @minz("template", args...) metafunction
		_, err := a.analyzeMinzMetafunctionCall(expr, nil) // nil irFunc for top-level
		return err
	default:
		return fmt.Errorf("unsupported top-level expression: %T", decl.Expression)
	}
}

// analyzeMinzExpr analyzes @minz[[[...]]](...) metafunction calls
func (a *Analyzer) analyzeMinzExpr(minz *ast.CompileTimeMinz, irFunc *ir.Function) (ir.Register, error) {
	// Evaluate arguments at compile time
	args := make([]interface{}, len(minz.Arguments))
	for i, arg := range minz.Arguments {
		// Try to evaluate as constant
		if val, err := a.evaluateConstantExpression(arg); err == nil {
			args[i] = val
		} else {
			// If not constant, it needs to be a string literal for now
			if str, ok := arg.(*ast.StringLiteral); ok {
				args[i] = str.Value
			} else {
				return 0, fmt.Errorf("@minz argument %d must be a compile-time constant or string literal", i+1)
			}
		}
	}
	
	// Create MIR interpreter instance
	interp := interpreter.NewMIRInterpreter()
	
	// Execute the MinZ template with arguments
	generatedCode, err := interp.ExecuteMinzMetafunction(minz.Code, args)
	if err != nil {
		return 0, fmt.Errorf("@minz execution error: %w", err)
	}
	
	// For now, just print the generated code as a debug measure
	if debug {
		fmt.Printf("DEBUG: @minz generated code:\n%s\n", generatedCode)
	}
	
	// Parse the generated MinZ code
	tempParser := parser.New()
	generatedDecls, err := tempParser.ParseString(generatedCode, "<@minz generated>")
	if err != nil {
		return 0, fmt.Errorf("@minz: failed to parse generated code: %w", err)
	}
	
	// Inject the declarations into the current module
	for _, decl := range generatedDecls {
		// For function declarations, register the signature first
		if funcDecl, ok := decl.(*ast.FunctionDecl); ok {
			if err := a.registerFunctionSignature(funcDecl); err != nil {
				return 0, fmt.Errorf("@minz: failed to register function %s: %w", funcDecl.Name, err)
			}
		}
	}
	
	// Now analyze the function bodies
	for _, decl := range generatedDecls {
		if err := a.analyzeDeclaration(decl); err != nil {
			return 0, fmt.Errorf("@minz: failed to analyze generated code: %w", err)
		}
		// The declaration is now analyzed and added to the IR module automatically
	}
	
	// For top-level @minz, we don't return a register value
	if irFunc == nil {
		// At top level, just execute and generate code
		return 0, nil
	}
	
	// For expression-level @minz (future), return a dummy value
	reg := irFunc.AllocReg()
	irFunc.EmitImm(ir.OpLoadConst, reg, 0)
	a.exprTypes[minz] = &ir.BasicType{Kind: ir.TypeU8}
	
	return reg, nil
}


// analyzeMIRExpr analyzes @mir[[[...]]] expressions
func (a *Analyzer) analyzeMIRExpr(mir *ast.CompileTimeMIR, irFunc *ir.Function) (ir.Register, error) {
	// Parse and inject MIR instructions directly
	if err := a.parseMIRCode(mir.Code, irFunc); err != nil {
		return 0, fmt.Errorf("@mir: %w", err)
	}
	
	// MIR expressions don't return values
	return 0, nil
}

// parseMIRCode parses MIR syntax and generates IR instructions
func (a *Analyzer) parseMIRCode(code string, irFunc *ir.Function) error {
	if irFunc == nil {
		return fmt.Errorf("@mir can only be used inside functions")
	}
	
	if debug {
		fmt.Printf("DEBUG: @mir code to parse:\n%s\n", code)
	}
	
	// Simple line-based MIR parser
	lines := strings.Split(strings.TrimSpace(code), "\n")
	
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		
		// Remove comments
		if idx := strings.Index(line, ";"); idx >= 0 {
			line = strings.TrimSpace(line[:idx])
		}
		if line == "" {
			continue
		}
		
		// Parse MIR instruction
		if err := a.parseMIRInstruction(line, irFunc); err != nil {
			return fmt.Errorf("MIR parse error on line '%s': %w", line, err)
		}
	}
	
	return nil
}

// parseMIRInstruction parses a single MIR instruction
func (a *Analyzer) parseMIRInstruction(line string, irFunc *ir.Function) error {
	parts := strings.Fields(line)
	if len(parts) == 0 {
		return nil
	}
	
	// Handle different instruction formats
	if len(parts) >= 3 && parts[1] == "=" {
		// Assignment format: r1 = operation ...
		destReg := a.parseMIRRegister(parts[0])
		op := parts[2]
		
		switch op {
		case "load_const":
			if len(parts) < 4 {
				return fmt.Errorf("load_const requires a value")
			}
			value, err := strconv.ParseInt(parts[3], 0, 64)
			if err != nil {
				return fmt.Errorf("invalid constant: %s", parts[3])
			}
			irFunc.EmitImm(ir.OpLoadConst, destReg, value)
			
		case "load_param":
			if len(parts) < 4 {
				return fmt.Errorf("load_param requires an index")
			}
			index, err := strconv.ParseInt(parts[3], 0, 64)
			if err != nil {
				return fmt.Errorf("invalid parameter index: %s", parts[3])
			}
			// Get parameter name from function signature
			if int(index) >= len(irFunc.Params) {
				return fmt.Errorf("parameter index %d out of bounds", index)
			}
			paramName := irFunc.Params[index].Name
			// Emit load parameter instruction
			inst := ir.Instruction{
				Op:     ir.OpLoadParam,
				Dest:   destReg,
				Symbol: paramName,
			}
			irFunc.Instructions = append(irFunc.Instructions, inst)
			
		case "add":
			if len(parts) < 5 {
				return fmt.Errorf("add requires two operands")
			}
			src1 := a.parseMIRRegister(parts[3])
			src2 := a.parseMIRRegister(parts[4])
			irFunc.Emit(ir.OpAdd, destReg, src1, src2)
			
		case "sub":
			if len(parts) < 5 {
				return fmt.Errorf("sub requires two operands")
			}
			src1 := a.parseMIRRegister(parts[3])
			src2 := a.parseMIRRegister(parts[4])
			irFunc.Emit(ir.OpSub, destReg, src1, src2)
			
		case "mul":
			if len(parts) < 5 {
				return fmt.Errorf("mul requires two operands")
			}
			src1 := a.parseMIRRegister(parts[3])
			src2 := a.parseMIRRegister(parts[4])
			irFunc.Emit(ir.OpMul, destReg, src1, src2)
			
		case "cmp":
			if len(parts) < 5 {
				return fmt.Errorf("cmp requires two operands")
			}
			src1 := a.parseMIRRegister(parts[3])
			src2 := a.parseMIRRegister(parts[4])
			irFunc.Emit(ir.OpCmp, destReg, src1, src2)
			
		default:
			return fmt.Errorf("unsupported MIR operation: %s", op)
		}
		
	} else if parts[0] == "ret" {
		// Return instruction
		if len(parts) >= 2 {
			srcReg := a.parseMIRRegister(parts[1])
			irFunc.Emit(ir.OpReturn, srcReg, 0, 0)
		} else {
			irFunc.Emit(ir.OpReturn, 0, 0, 0)
		}
		
	} else if strings.HasSuffix(parts[0], ":") {
		// Label definition
		label := strings.TrimSuffix(parts[0], ":")
		inst := ir.Instruction{
			Op:    ir.OpLabel,
			Label: label,
		}
		irFunc.Instructions = append(irFunc.Instructions, inst)
		
	} else if parts[0] == "jmp" {
		// Unconditional jump
		if len(parts) < 2 {
			return fmt.Errorf("jmp requires a label")
		}
		inst := ir.Instruction{
			Op:    ir.OpJump,
			Label: parts[1],
		}
		irFunc.Instructions = append(irFunc.Instructions, inst)
		
	} else if parts[0] == "jz" || parts[0] == "jle" {
		// Conditional jumps
		if len(parts) < 2 {
			return fmt.Errorf("%s requires a label", parts[0])
		}
		var op ir.Opcode
		switch parts[0] {
		case "jz":
			op = ir.OpJumpIfZero
		case "jle":
			// For now, use conditional jump
			op = ir.OpJumpIf
		}
		inst := ir.Instruction{
			Op:    op,
			Label: parts[1],
		}
		irFunc.Instructions = append(irFunc.Instructions, inst)
		
	} else {
		return fmt.Errorf("unrecognized MIR instruction format: %s", line)
	}
	
	return nil
}

// parseMIRRegister converts MIR register notation (r1, r2, etc) to IR register
func (a *Analyzer) parseMIRRegister(s string) ir.Register {
	s = strings.TrimSpace(strings.TrimSuffix(s, ","))
	if strings.HasPrefix(s, "r") {
		if num, err := strconv.Atoi(s[1:]); err == nil {
			return ir.Register(num)
		}
	}
	// Default to r0 if parsing fails
	return 0
}

// analyzeMetaExecutionBlock processes @lang[[[]]] blocks
func (a *Analyzer) analyzeMetaExecutionBlock(block *ast.MetaExecutionBlock) error {
	switch block.Language {
	case "lua":
		// Execute Lua code
		return a.luaEvaluator.EvaluateLuaBlock(block.Code)
	case "minz":
		// Execute MinZ code through MIR interpreter
		return a.analyzeMinzBlockCode(block.Code)
	case "mir":
		// Generate MIR directly
		return a.analyzeMIRBlockCode(block.Code)
	default:
		return fmt.Errorf("unsupported meta execution language: %s", block.Language)
	}
}


// analyzeMinzBlockCode executes MinZ code at compile time
func (a *Analyzer) analyzeMinzBlockCode(code string) error {
	// TODO: Parse the MinZ code
	// TODO: Execute it through the MIR interpreter
	// TODO: Capture @emit() calls and generate code
	return nil
}

// analyzeMIRBlock processes @mir[[[]]] blocks
func (a *Analyzer) analyzeMIRBlock(block *ast.MIRBlock) error {
	return a.analyzeMIRBlockCode(block.Code)
}

// analyzeMIRBlockCode generates MIR directly from the block
func (a *Analyzer) analyzeMIRBlockCode(code string) error {
	// TODO: Parse MIR instructions
	// TODO: Generate IR directly
	return nil
}

// shouldUseInstructionPatching determines if a function call should use instruction patching
func (a *Analyzer) shouldUseInstructionPatching(funcSym *FuncSymbol, call *ast.CallExpr) bool {
	// For now, enable instruction patching for non-builtin functions with simple return types
	if funcSym.IsBuiltin {
		return false
	}
	
	// Check if return type is patchable (u8, u16)
	if funcSym.ReturnType == nil {
		return false
	}
	
	switch funcSym.ReturnType.String() {
	case "u8", "u16", "i8", "i16":
		return true
	default:
		return false
	}
}

// generateInstructionPatchingCall generates a function call with instruction patching
func (a *Analyzer) generateInstructionPatchingCall(funcSym *FuncSymbol, call *ast.CallExpr, argRegs []ir.Register, irFunc *ir.Function) (ir.Register, error) {
	funcName := funcSym.Name
	
	// 1. Mark target function as needing patch points
	if targetFunc := a.GetFunction(funcSym.Name); targetFunc != nil {
		targetFunc.NeedsPatchPoints = true
	}
	
	// 2. Generate patch point in target function (if not already done)
	patchPointLabel := funcName + "_return_patch"
	
	// 2. Analyze usage pattern to determine template
	templateName := a.analyzeUsagePattern(call)
	
	// 3. Generate patch template selection
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:              ir.OpPatchTemplate,
		PatchPointLabel: patchPointLabel,
		TemplateName:    templateName,
	})
	
	// 4. If using store template, set target address
	if templateName == "store_u8" || templateName == "store_u16" {
		// For now, use a generic target - this would be determined by usage context
		targetSymbol := "temp_result"
		irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
			Op:              ir.OpPatchTarget,
			PatchPointLabel: patchPointLabel,
			TargetAddress:   targetSymbol,
		})
	}
	
	// 5. Generate parameter patches
	for i, argReg := range argRegs {
		if i < len(funcSym.Params) {
			paramName := funcSym.Params[i].Name
			// Convert AST Type to IR Type
			irType, err := a.convertType(funcSym.Params[i].Type)
			if err != nil {
				irType = &ir.BasicType{Kind: ir.TypeU8} // Default fallback
			}
			
			irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
				Op:        ir.OpPatchParam,
				Symbol:    funcName,
				ParamName: paramName,
				Src1:      argReg,
				Type:      irType,
			})
		}
	}
	
	// 6. Generate the actual call
	resultReg := irFunc.AllocReg()
	irFunc.Instructions = append(irFunc.Instructions, ir.Instruction{
		Op:     ir.OpCall,
		Dest:   resultReg,
		Symbol: funcName,
		Args:   argRegs,
	})
	
	return resultReg, nil
}

// analyzeUsagePattern analyzes how the function call result is used
func (a *Analyzer) analyzeUsagePattern(call *ast.CallExpr) string {
	// For this initial implementation, default to store pattern
	// TODO: Implement proper usage pattern analysis by examining parent AST nodes
	
	// Future patterns:
	// - Immediate use: call is part of binary expression (add_numbers(10, 20) + 5)
	// - Assignment: call is assigned to variable (let x = add_numbers(10, 20))
	// - Return: call is returned directly (return add_numbers(10, 20))
	
	return "store_u8" // Default to store pattern
}

// GetFunction returns the IR function by name
func (a *Analyzer) GetFunction(name string) *ir.Function {
	// Look up in the current module's functions
	for _, fn := range a.module.Functions {
		if fn.Name == name {
			return fn
		}
	}
	return nil
}

// findSimilarIdentifiers finds identifiers similar to the given name
// using Levenshtein distance for typo detection
func (a *Analyzer) findSimilarIdentifiers(name string) []string {
	var suggestions []string
	maxDistance := 2 // Maximum edit distance for suggestions
	
	// Collect all visible identifiers
	candidates := make(map[string]bool)
	
	// Walk up the scope chain
	scope := a.currentScope
	for scope != nil {
		for ident := range scope.symbols {
			candidates[ident] = true
		}
		scope = scope.parent
	}
	
	// Add global functions
	for _, fn := range a.module.Functions {
		candidates[fn.Name] = true
	}
	
	// Add built-in functions
	builtins := []string{
		"print_u8", "print_u16", "print_i8", "print_i16",
		"print_bool", "print_char", "print",
		"memcpy", "memset", "strlen",
	}
	for _, builtin := range builtins {
		candidates[builtin] = true
	}
	
	// Find similar names
	for candidate := range candidates {
		if distance := levenshteinDistance(name, candidate); distance <= maxDistance && distance > 0 {
			suggestions = append(suggestions, candidate)
		}
	}
	
	// Sort by similarity (shorter distance first)
	if len(suggestions) > 1 {
		// Simple bubble sort for small lists
		for i := 0; i < len(suggestions)-1; i++ {
			for j := 0; j < len(suggestions)-i-1; j++ {
				if levenshteinDistance(name, suggestions[j]) > levenshteinDistance(name, suggestions[j+1]) {
					suggestions[j], suggestions[j+1] = suggestions[j+1], suggestions[j]
				}
			}
		}
	}
	
	// Return top 3 suggestions
	if len(suggestions) > 3 {
		suggestions = suggestions[:3]
	}
	
	return suggestions
}

// levenshteinDistance calculates the edit distance between two strings
func levenshteinDistance(s1, s2 string) int {
	if s1 == s2 {
		return 0
	}
	
	// Create distance matrix
	m, n := len(s1), len(s2)
	if m == 0 {
		return n
	}
	if n == 0 {
		return m
	}
	
	// Initialize matrix
	d := make([][]int, m+1)
	for i := range d {
		d[i] = make([]int, n+1)
		d[i][0] = i
	}
	for j := 0; j <= n; j++ {
		d[0][j] = j
	}
	
	// Calculate distances
	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			cost := 0
			if s1[i-1] != s2[j-1] {
				cost = 1
			}
			
			d[i][j] = min(
				d[i-1][j]+1,    // deletion
				d[i][j-1]+1,    // insertion
				d[i-1][j-1]+cost, // substitution
			)
		}
	}
	
	return d[m][n]
}

// min returns the minimum of three integers
func min(a, b, c int) int {
	if a < b {
		if a < c {
			return a
		}
		return c
	}
	if b < c {
		return b
	}
	return c
}

