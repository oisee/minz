package z80asm

import (
	"fmt"
	"strings"
)

// MinZAssembler provides MinZ-specific assembly functionality
type MinZAssembler struct {
	*Assembler
	baseAddress uint16
}

// NewMinZAssembler creates an assembler configured for MinZ
func NewMinZAssembler(baseAddress uint16) *MinZAssembler {
	asm := NewAssembler()
	asm.AllowUndocumented = true // MinZ needs undocumented opcodes
	
	return &MinZAssembler{
		Assembler:   asm,
		baseAddress: baseAddress,
	}
}

// AssembleInlineBlock assembles an asm{} block from MinZ
func (m *MinZAssembler) AssembleInlineBlock(asmCode string, currentPC uint16) ([]byte, error) {
	// Prepare the assembly source with proper origin
	source := fmt.Sprintf("ORG $%04X\n%s", currentPC, asmCode)
	
	// Assemble
	result, err := m.AssembleString(source)
	if err != nil {
		return nil, fmt.Errorf("inline assembly error: %w", err)
	}
	
	return result.Binary, nil
}

// AssembleFunction assembles a complete function with MinZ conventions
func (m *MinZAssembler) AssembleFunction(name string, body string) (*AssembledFunction, error) {
	// Build the complete assembly source
	var source strings.Builder
	
	source.WriteString(fmt.Sprintf("ORG $%04X\n", m.baseAddress))
	source.WriteString(fmt.Sprintf("%s:\n", name))
	source.WriteString(body)
	
	// Assemble
	result, err := m.AssembleString(source.String())
	if err != nil {
		return nil, err
	}
	
	return &AssembledFunction{
		Name:    name,
		Address: m.baseAddress,
		Binary:  result.Binary,
		Size:    uint16(len(result.Binary)),
		Symbols: result.Symbols,
	}, nil
}

// AssembledFunction represents an assembled MinZ function
type AssembledFunction struct {
	Name    string
	Address uint16
	Binary  []byte
	Size    uint16
	Symbols map[string]uint16
}

// Example of how the MinZ compiler would use this:
func ExampleMinZIntegration() {
	// Create assembler for MinZ code at $8000
	masm := NewMinZAssembler(0x8000)
	
	// Example 1: Inline assembly block
	inlineASM := `
		PUSH HL
		LD HL, $1234
		LD A, (HL)
		POP HL
	`
	
	binary, err := masm.AssembleInlineBlock(inlineASM, 0x8100)
	if err != nil {
		panic(err)
	}
	
	fmt.Printf("Inline assembly: %X\n", binary)
	
	// Example 2: Complete function with SMC support
	funcASM := `
		; Self-modifying parameter
	param1:
		LD A, 0     ; This 0 will be patched
		ADD A, B
		RET
	`
	
	fn, err := masm.AssembleFunction("add_with_smc", funcASM)
	if err != nil {
		panic(err)
	}
	
	fmt.Printf("Function at $%04X, size %d bytes\n", fn.Address, fn.Size)
	fmt.Printf("SMC param at: $%04X\n", fn.Symbols["param1"])
}

// AssembleSMCFunction helps generate self-modifying code patterns
func (m *MinZAssembler) AssembleSMCFunction(name string, params []SMCParam, body string) (*AssembledFunction, error) {
	var source strings.Builder
	
	source.WriteString(fmt.Sprintf("ORG $%04X\n", m.baseAddress))
	source.WriteString(fmt.Sprintf("%s:\n", name))
	
	// Generate SMC parameter labels and instructions
	for _, param := range params {
		source.WriteString(fmt.Sprintf("%s_%s:\n", name, param.Name))
		
		switch param.Type {
		case "u8":
			source.WriteString(fmt.Sprintf("    LD %s, 0  ; SMC parameter %s\n", param.TargetReg, param.Name))
		case "u16":
			source.WriteString(fmt.Sprintf("    LD %s, 0  ; SMC parameter %s\n", param.TargetReg, param.Name))
		}
	}
	
	source.WriteString(body)
	
	return m.AssembleFunction(name, source.String())
}

// SMCParam describes a self-modifying code parameter
type SMCParam struct {
	Name      string
	Type      string // "u8" or "u16"
	TargetReg string // Target register (A, HL, etc.)
}

// FixupSMCReferences fixes up SMC parameter references after assembly
func (m *MinZAssembler) FixupSMCReferences(binary []byte, symbols map[string]uint16, baseAddr uint16) {
	// This would patch the immediate values in the binary
	// based on the symbol table and SMC conventions
	
	// For each SMC parameter symbol:
	// 1. Find the instruction at that address
	// 2. Locate the immediate value offset (+1 for most instructions)
	// 3. Store that offset for runtime patching
}

// GenerateMinZHeader generates a header comment for MinZ assembly output
func GenerateMinZHeader() string {
	return `; MinZ inline assembly
; Generated by MinZ compiler with integrated Z80 assembler
; Supports full Z80 instruction set including undocumented opcodes
`
}