package codegen

import (
	"bytes"
	"fmt"
	"strings"
	
	"github.com/minz/minzc/pkg/ir"
)

// BackendToolkit provides common utilities and patterns for backend development
type BackendToolkit struct {
	// Instruction mappings
	OpToAsm map[ir.Opcode]string
	
	// Register mappings
	VirtualToPhysical map[ir.Register]string
	
	// Type size mappings
	TypeSizes map[string]int
	
	// Common patterns
	Patterns BackendPatterns
	
	// Helper functions
	Helpers BackendHelpers
}

// BackendPatterns contains common code generation patterns
type BackendPatterns struct {
	// Function prologue/epilogue patterns
	FunctionPrologue string
	FunctionEpilogue string
	
	// Call conventions
	ParamPassingStyle string // "stack", "registers", "zero-page"
	ReturnValueReg    string
	
	// Memory access patterns
	LoadPattern  string // Pattern with %reg% and %addr% placeholders
	StorePattern string
	
	// Arithmetic patterns
	AddPattern string
	SubPattern string
	MulPattern string // Empty if not supported natively
	DivPattern string // Empty if not supported natively
	
	// Control flow patterns
	ComparePattern    string
	BranchIfPattern   string
	BranchIfNotPattern string
}

// BackendHelpers provides helper methods for code generation
type BackendHelpers struct {
	// Generate label names
	LabelPrefix string
	labelCount  int
}

// NewBackendToolkit creates a toolkit with common defaults
func NewBackendToolkit() *BackendToolkit {
	return &BackendToolkit{
		OpToAsm:           make(map[ir.Opcode]string),
		VirtualToPhysical: make(map[ir.Register]string),
		TypeSizes: map[string]int{
			"u8":   1,
			"i8":   1,
			"u16":  2,
			"i16":  2,
			"u24":  3,
			"i24":  3,
			"u32":  4,
			"i32":  4,
			"bool": 1,
			"ptr":  2, // Default 16-bit pointers
		},
		Helpers: BackendHelpers{
			LabelPrefix: ".L",
		},
	}
}

// BaseGenerator provides common functionality for all backends
type BaseGenerator struct {
	Backend     Backend
	Module      *ir.Module
	CurrentFunc *ir.Function
	Output      *bytes.Buffer
	Toolkit     *BackendToolkit
	
	// Track current state
	CurrentRegs map[ir.Register]string
	UsedRegs    map[string]bool
}

// NewBaseGenerator creates a base generator
func NewBaseGenerator(backend Backend, module *ir.Module, toolkit *BackendToolkit) *BaseGenerator {
	return &BaseGenerator{
		Backend:     backend,
		Module:      module,
		Output:      &bytes.Buffer{},
		Toolkit:     toolkit,
		CurrentRegs: make(map[ir.Register]string),
		UsedRegs:    make(map[string]bool),
	}
}

// Generate generates assembly code using the toolkit patterns
func (g *BaseGenerator) Generate() (string, error) {
	// Generate header
	g.EmitHeader()
	
	// Generate globals
	if len(g.Module.Globals) > 0 {
		g.EmitComment("Global variables")
		for _, global := range g.Module.Globals {
			if err := g.GenerateGlobal(&global); err != nil {
				return "", err
			}
		}
		g.EmitLine("")
	}
	
	// Generate functions
	for _, fn := range g.Module.Functions {
		if err := g.GenerateFunction(fn); err != nil {
			return "", fmt.Errorf("generating function %s: %w", fn.Name, err)
		}
		g.EmitLine("")
	}
	
	// Generate runtime helpers
	g.GenerateHelpers()
	
	return g.Output.String(), nil
}

// EmitHeader emits the file header
func (g *BaseGenerator) EmitHeader() {
	g.EmitComment(fmt.Sprintf("MinZ %s generated code", g.Backend.Name()))
	g.EmitComment("Generated by MinZ compiler")
	g.EmitLine("")
}

// GenerateFunction generates code for a function
func (g *BaseGenerator) GenerateFunction(fn *ir.Function) error {
	g.CurrentFunc = fn
	
	g.EmitComment(fmt.Sprintf("Function: %s", fn.Name))
	g.EmitLabel(g.SanitizeName(fn.Name))
	
	// Emit prologue if defined
	if g.Toolkit.Patterns.FunctionPrologue != "" {
		g.EmitLine(g.Toolkit.Patterns.FunctionPrologue)
	}
	
	// Generate instructions
	for _, inst := range fn.Instructions {
		if err := g.GenerateInstruction(&inst); err != nil {
			return err
		}
	}
	
	// Emit epilogue if defined
	if g.Toolkit.Patterns.FunctionEpilogue != "" {
		g.EmitLine(g.Toolkit.Patterns.FunctionEpilogue)
	}
	
	return nil
}

// GenerateInstruction generates code for a single instruction
func (g *BaseGenerator) GenerateInstruction(inst *ir.Instruction) error {
	// Add debug comment if present
	if inst.Comment != "" {
		g.EmitComment(inst.Comment)
	}
	
	// Check if we have a direct mapping
	if asmOp, exists := g.Toolkit.OpToAsm[inst.Op]; exists {
		g.EmitLine(g.FormatInstruction(asmOp, inst))
		return nil
	}
	
	// Otherwise use pattern-based generation
	switch inst.Op {
	case ir.OpLoadConst:
		return g.GenerateLoadConst(inst)
	case ir.OpLoadVar:
		return g.GenerateLoadVar(inst)
	case ir.OpStoreVar:
		return g.GenerateStoreVar(inst)
	case ir.OpAdd:
		return g.GenerateArithmetic(inst, g.Toolkit.Patterns.AddPattern)
	case ir.OpSub:
		return g.GenerateArithmetic(inst, g.Toolkit.Patterns.SubPattern)
	case ir.OpCall:
		return g.GenerateCall(inst)
	case ir.OpReturn:
		return g.GenerateReturn(inst)
	case ir.OpLabel:
		g.EmitLabel(inst.Label)
		return nil
	case ir.OpJump:
		g.EmitLine(fmt.Sprintf("    jmp %s", inst.Label))
		return nil
	default:
		g.EmitComment(fmt.Sprintf("TODO: %s", inst.Op))
		return nil
	}
}

// Helper methods for common operations

func (g *BaseGenerator) GenerateLoadConst(inst *ir.Instruction) error {
	pattern := g.Toolkit.Patterns.LoadPattern
	if pattern == "" {
		return fmt.Errorf("no load pattern defined")
	}
	
	reg := g.GetPhysicalReg(inst.Dest)
	code := strings.ReplaceAll(pattern, "%reg%", reg)
	code = strings.ReplaceAll(code, "%value%", fmt.Sprintf("%d", inst.Imm))
	g.EmitLine(code)
	
	return nil
}

func (g *BaseGenerator) GenerateLoadVar(inst *ir.Instruction) error {
	pattern := g.Toolkit.Patterns.LoadPattern
	if pattern == "" {
		return fmt.Errorf("no load pattern defined")
	}
	
	reg := g.GetPhysicalReg(inst.Dest)
	code := strings.ReplaceAll(pattern, "%reg%", reg)
	code = strings.ReplaceAll(code, "%addr%", inst.Symbol)
	g.EmitLine(code)
	
	return nil
}

func (g *BaseGenerator) GenerateStoreVar(inst *ir.Instruction) error {
	pattern := g.Toolkit.Patterns.StorePattern
	if pattern == "" {
		return fmt.Errorf("no store pattern defined")
	}
	
	reg := g.GetPhysicalReg(inst.Src1)
	code := strings.ReplaceAll(pattern, "%reg%", reg)
	code = strings.ReplaceAll(code, "%addr%", inst.Symbol)
	g.EmitLine(code)
	
	return nil
}

func (g *BaseGenerator) GenerateArithmetic(inst *ir.Instruction, pattern string) error {
	if pattern == "" {
		return fmt.Errorf("arithmetic pattern not defined for %s", inst.Op)
	}
	
	dest := g.GetPhysicalReg(inst.Dest)
	src1 := g.GetPhysicalReg(inst.Src1)
	src2 := g.GetPhysicalReg(inst.Src2)
	
	code := strings.ReplaceAll(pattern, "%dest%", dest)
	code = strings.ReplaceAll(code, "%src1%", src1)
	code = strings.ReplaceAll(code, "%src2%", src2)
	g.EmitLine(code)
	
	return nil
}

func (g *BaseGenerator) GenerateCall(inst *ir.Instruction) error {
	// Handle parameter passing based on style
	switch g.Toolkit.Patterns.ParamPassingStyle {
	case "stack":
		// Push arguments in reverse order
		for i := len(inst.Args) - 1; i >= 0; i-- {
			reg := g.GetPhysicalReg(inst.Args[i])
			g.EmitLine(fmt.Sprintf("    push %s", reg))
		}
	case "registers":
		// Move arguments to parameter registers
		// Backend should define which registers
	case "zero-page":
		// Store arguments to zero-page locations
		// Backend should define the locations
	}
	
	// Make the call
	g.EmitLine(fmt.Sprintf("    call %s", g.SanitizeName(inst.Symbol)))
	
	// Clean up stack if needed
	if g.Toolkit.Patterns.ParamPassingStyle == "stack" && len(inst.Args) > 0 {
		stackCleanup := len(inst.Args) * g.Toolkit.TypeSizes["ptr"]
		g.EmitLine(fmt.Sprintf("    add sp, %d", stackCleanup))
	}
	
	// Handle return value
	if inst.Dest != 0 && g.Toolkit.Patterns.ReturnValueReg != "" {
		destReg := g.GetPhysicalReg(inst.Dest)
		if destReg != g.Toolkit.Patterns.ReturnValueReg {
			g.EmitLine(fmt.Sprintf("    mov %s, %s", destReg, g.Toolkit.Patterns.ReturnValueReg))
		}
	}
	
	return nil
}

func (g *BaseGenerator) GenerateReturn(inst *ir.Instruction) error {
	if inst.Src1 != 0 && g.Toolkit.Patterns.ReturnValueReg != "" {
		srcReg := g.GetPhysicalReg(inst.Src1)
		if srcReg != g.Toolkit.Patterns.ReturnValueReg {
			g.EmitLine(fmt.Sprintf("    mov %s, %s", g.Toolkit.Patterns.ReturnValueReg, srcReg))
		}
	}
	
	g.EmitLine("    ret")
	return nil
}

func (g *BaseGenerator) GenerateGlobal(global *ir.Global) error {
	size := g.GetTypeSize(global.Type)
	g.EmitLine(fmt.Sprintf("%s: .space %d", global.Name, size))
	return nil
}

func (g *BaseGenerator) GenerateHelpers() {
	// Override in specific backends
}

// Utility methods

func (g *BaseGenerator) GetPhysicalReg(virtual ir.Register) string {
	if physical, exists := g.Toolkit.VirtualToPhysical[virtual]; exists {
		return physical
	}
	// Fallback to memory location
	return fmt.Sprintf("temp_%d", virtual)
}

func (g *BaseGenerator) GetTypeSize(t ir.Type) int {
	if size, exists := g.Toolkit.TypeSizes[t.String()]; exists {
		return size
	}
	return t.Size()
}

func (g *BaseGenerator) EmitLine(line string) {
	fmt.Fprintln(g.Output, line)
}

func (g *BaseGenerator) EmitComment(comment string) {
	fmt.Fprintf(g.Output, "; %s\n", comment)
}

func (g *BaseGenerator) EmitLabel(label string) {
	fmt.Fprintf(g.Output, "%s:\n", label)
}

func (g *BaseGenerator) FormatInstruction(op string, inst *ir.Instruction) string {
	// Simple formatting - backends can override
	return fmt.Sprintf("    %s", op)
}

func (g *BaseGenerator) SanitizeName(name string) string {
	return strings.ReplaceAll(name, ".", "_")
}

func (g *BaseGenerator) GetLabel() string {
	g.Toolkit.Helpers.labelCount++
	return fmt.Sprintf("%s%d", g.Toolkit.Helpers.LabelPrefix, g.Toolkit.Helpers.labelCount)
}

// BackendBuilder provides a fluent interface for creating backends
type BackendBuilder struct {
	toolkit *BackendToolkit
}

// NewBackendBuilder creates a new backend builder
func NewBackendBuilder() *BackendBuilder {
	return &BackendBuilder{
		toolkit: NewBackendToolkit(),
	}
}

// WithInstruction adds an instruction mapping
func (b *BackendBuilder) WithInstruction(op ir.Opcode, asm string) *BackendBuilder {
	b.toolkit.OpToAsm[op] = asm
	return b
}

// WithRegisterMapping adds a virtual to physical register mapping
func (b *BackendBuilder) WithRegisterMapping(virtual ir.Register, physical string) *BackendBuilder {
	b.toolkit.VirtualToPhysical[virtual] = physical
	return b
}

// WithPattern sets a code generation pattern
func (b *BackendBuilder) WithPattern(name string, pattern string) *BackendBuilder {
	switch name {
	case "load":
		b.toolkit.Patterns.LoadPattern = pattern
	case "store":
		b.toolkit.Patterns.StorePattern = pattern
	case "add":
		b.toolkit.Patterns.AddPattern = pattern
	case "sub":
		b.toolkit.Patterns.SubPattern = pattern
	case "prologue":
		b.toolkit.Patterns.FunctionPrologue = pattern
	case "epilogue":
		b.toolkit.Patterns.FunctionEpilogue = pattern
	}
	return b
}

// WithCallConvention sets the calling convention
func (b *BackendBuilder) WithCallConvention(style string, returnReg string) *BackendBuilder {
	b.toolkit.Patterns.ParamPassingStyle = style
	b.toolkit.Patterns.ReturnValueReg = returnReg
	return b
}

// Build returns the configured toolkit
func (b *BackendBuilder) Build() *BackendToolkit {
	return b.toolkit
}