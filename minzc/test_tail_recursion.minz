// Test cases for tail recursion optimization

// ======= TAIL RECURSIVE FACTORIAL (with accumulator) =======
fun factorial_tail(n: u8, acc: u16) -> u16 {
    if n <= 1 {
        return acc;
    }
    return factorial_tail(n - 1, acc * n);  // TAIL CALL - should be optimized!
}

// Wrapper for cleaner interface
fun factorial(n: u8) -> u16 {
    return factorial_tail(n, 1);
}

// ======= TAIL RECURSIVE SUM =======
fun sum_tail(n: u8, acc: u16) -> u16 {
    if n == 0 {
        return acc;
    }
    return sum_tail(n - 1, acc + n);  // TAIL CALL - should be optimized!
}

// ======= TAIL RECURSIVE COUNTDOWN =======
fun countdown_tail(n: u8) -> u8 {
    if n == 0 {
        return 0;
    }
    return countdown_tail(n - 1);  // TAIL CALL - should be optimized!
}

// ======= NON-TAIL RECURSIVE (for comparison) =======
fun factorial_non_tail(n: u8) -> u16 {
    if n <= 1 {
        return 1;
    }
    return n * factorial_non_tail(n - 1);  // NOT tail call - multiplication after
}

fun fibonacci_non_tail(n: u8) -> u16 {
    if n <= 1 {
        return n;
    }
    return fibonacci_non_tail(n - 1) + fibonacci_non_tail(n - 2);  // NOT tail calls
}

// ======= TAIL RECURSIVE FIBONACCI (with two accumulators) =======
fun fib_tail_helper(n: u8, a: u16, b: u16) -> u16 {
    if n == 0 {
        return a;
    }
    if n == 1 {
        return b;
    }
    return fib_tail_helper(n - 1, b, a + b);  // TAIL CALL - should be optimized!
}

fun fibonacci_tail(n: u8) -> u16 {
    return fib_tail_helper(n, 0, 1);
}

// ======= TAIL RECURSIVE GCD (Greatest Common Divisor) =======
fun gcd_tail(a: u16, b: u16) -> u16 {
    if b == 0 {
        return a;
    }
    return gcd_tail(b, a % b);  // TAIL CALL - should be optimized!
}

// ======= TAIL RECURSIVE POWER =======
fun power_tail(base: u8, exp: u8, acc: u16) -> u16 {
    if exp == 0 {
        return acc;
    }
    return power_tail(base, exp - 1, acc * base);  // TAIL CALL - should be optimized!
}

fun power(base: u8, exp: u8) -> u16 {
    return power_tail(base, exp, 1);
}

// ======= COMPLEX TAIL RECURSION WITH CONDITIONALS =======
fun complex_tail(n: u8, flag: bool, acc: u16) -> u16 {
    if n == 0 {
        return acc;
    }
    
    if flag {
        return complex_tail(n - 1, false, acc + n);  // TAIL CALL 1
    } else {
        return complex_tail(n - 1, true, acc * 2);   // TAIL CALL 2
    }
}

// ======= MAIN TEST FUNCTION =======
fun main() -> void {
    // Test tail recursive functions
    let fact5 = factorial(5);              // Should use optimized tail recursion
    let sum10 = sum_tail(10, 0);           // Should be optimized
    let countdown = countdown_tail(5);      // Should be optimized
    let fib10 = fibonacci_tail(10);        // Should be optimized
    let gcd_result = gcd_tail(48, 18);     // Should be optimized
    let pow_result = power(2, 8);          // Should be optimized
    let complex_result = complex_tail(5, true, 1);  // Should be optimized
    
    // Test non-tail recursive (for comparison)
    let fact5_normal = factorial_non_tail(5);   // Cannot be optimized
    let fib5_normal = fibonacci_non_tail(5);    // Cannot be optimized
}