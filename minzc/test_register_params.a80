; MinZ generated code
; Generated: 2025-07-27 08:32:48


; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.test_register_params.add_bytes
...examples.test_register_params.add_bytes:
; Using absolute addressing for locals
    PUSH IX
    LD IX, SP
    ; Load parameters from registers
    LD C, A         ; Store to physical register C
    LD A, E       ; Get parameter b
    LD ($F004), A     ; Virtual register 2 to memory
    ; unknown op 12
    ; Load parameter a
    ; unknown op 12
    ; Load parameter b
    ; r5 = r3 + r4
    LD D, H
    LD E, L
    ADD HL, DE
    ; return r5
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.test_register_params.add_words
...examples.test_register_params.add_words:
; Using absolute addressing for locals
    PUSH IX
    LD IX, SP
    ; Load parameters from registers
    LD B, H
    LD C, L
    EX DE, HL     ; Get parameter y from DE
    LD ($F004), HL    ; Virtual register 2 to memory
    ; unknown op 12
    ; Load parameter x
    ; unknown op 12
    ; Load parameter y
    ; r5 = r3 + r4
    ; Register 3 already in HL
    LD D, H
    LD E, L
    LD H, D
    LD L, E
    ADD HL, DE
    EXX               ; Switch to shadow registers
    ; Store to shadow HL
    EXX               ; HL now in shadow HL
    ; return r5
    EXX               ; Switch to shadow registers
    ; Register 5 in shadow HL
    EXX               ; Keep shadow HL in HL
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.test_register_params.process
...examples.test_register_params.process:
; Using absolute addressing for locals
    PUSH IX
    LD IX, SP
    ; Load parameters from registers
    EXX               ; Switch to shadow registers
    LD E', A         ; Store to shadow E'
    EXX               ; Switch back to main registers
    EX DE, HL     ; Get parameter ptr from DE
    ; Register 2 already in HL
    POP HL        ; Get parameter count from stack
    LD ($F006), HL    ; Virtual register 3 to memory
    ; unknown op 12
    ; Load parameter value
    ; store , r5
    EXX               ; Switch to shadow registers
    LD ($F000), HL
    ; unknown op 12
    ; Load parameter ptr
    ; r7 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; r8 = r6 + r7
    EXX               ; Switch to shadow registers
    LD D, H
    LD E, L
    ; Register 7 already in HL
    ADD HL, DE
    ; store ptr, r8
    LD ($F000), HL
    ; return
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.test_register_params.many_params
...examples.test_register_params.many_params:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
...examples.test_register_params.many_params_param_a:
    LD HL, #0000   ; SMC parameter a (u8->u16)
...examples.test_register_params.many_params_param_b:
    LD HL, #0000   ; SMC parameter b (u8->u16)
    LD ($F00E), HL    ; Virtual register 7 to memory
    ; r8 = r6 + r7
    LD D, H
    LD E, L
    LD HL, ($F00E)    ; Virtual register 7 from memory
    ADD HL, DE
...examples.test_register_params.many_params_param_c:
    LD HL, #0000   ; SMC parameter c (u8->u16)
    LD ($F012), HL    ; Virtual register 9 to memory
    ; r10 = r8 + r9
    LD D, H
    LD E, L
    LD HL, ($F012)    ; Virtual register 9 from memory
    ADD HL, DE
...examples.test_register_params.many_params_param_d:
    LD HL, #0000   ; SMC parameter d (u8->u16)
    LD ($F016), HL    ; Virtual register 11 to memory
    ; r12 = r10 + r11
    LD D, H
    LD E, L
    LD HL, ($F016)    ; Virtual register 11 from memory
    ADD HL, DE
...examples.test_register_params.many_params_param_e:
    LD HL, #0000   ; SMC parameter e (u8->u16)
    ; Register 13 already in HL
    ; r14 = r12 + r13
    LD D, H
    LD E, L
    ; Register 13 already in HL
    ADD HL, DE
    ; return r14
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.test_register_params.recursive_sum
...examples.test_register_params.recursive_sum:
; Using stack-based locals (IX+offset)
    PUSH IX
    LD IX, SP
    ; Load parameters from registers
    LD ($F002), A     ; Virtual register 1 to memory
    ; unknown op 12
    ; Load parameter n
    ; r3 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; r4 = r2 == r3
    LD HL, ($F004)    ; Virtual register 2 from memory
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP Z, .L1
    LD HL, 0
    JP .L2
.L1:
    LD HL, 1
.L2:
    ; jump_if_not r4, else_1
    LD A, L
    OR A
    JP Z, else_1
    ; r5 = 0
    LD A, 0
    LD ($F00A), A     ; Virtual register 5 to memory
    ; return r5
    LD HL, ($F00A)    ; Virtual register 5 from memory
    LD SP, IX
    POP IX
    RET
    ; jump end_if_2
    JP end_if_2
    ; else_1:
else_1:
    ; end_if_2:
end_if_2:
    ; unknown op 12
    ; Load parameter n
    ; unknown op 12
    ; Load parameter n
    ; r8 = 1
    LD A, 1
    LD ($F010), A     ; Virtual register 8 to memory
    ; r9 = r7 - r8
    LD D, H
    LD E, L
    LD HL, ($F010)    ; Virtual register 8 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    ; r10 = call recursive_sum
    ; Call to recursive_sum (args: 1)
    ; Register-based parameter passing
    LD A, H
    ; Parameter n in A
    ; Found function, UsesTrueSMC=false
    CALL recursive_sum
    ; r11 = r6 + r10
    LD D, H
    LD E, L
    ADD HL, DE
    ; Register 11 already in HL
    ; return r11
    ; Register 11 already in HL
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.test_register_params.main
...examples.test_register_params.main:
; Using stack-based locals (IX+offset)
    PUSH IX
    LD IX, SP
    LD HL, -12
    ADD HL, SP
    LD SP, HL
    ; Load parameters from registers
    ; r2 = 10
    LD A, 10
    LD H, A         ; Store to physical register H
    ; r3 = 20
    LD A, 20
    LD L, A         ; Store to physical register L
    ; r4 = call add_bytes
    ; Call to add_bytes (args: 2)
    ; Register-based parameter passing
    LD A, H
    ; Parameter a in A
    LD A, L
    LD E, A       ; Parameter b in E
    ; Found function, UsesTrueSMC=false
    CALL add_bytes
    ; Register 4 already in HL
    ; store , r4
    ; Register 4 already in HL
    LD (IX-1), L
    LD (IX+0), H
    ; r6 = 1000
    LD HL, 1000
    LD ($F00C), HL    ; Virtual register 6 to memory
    ; r7 = 2000
    LD HL, 2000
    LD ($F00E), HL    ; Virtual register 7 to memory
    ; r8 = call add_words
    ; Call to add_words (args: 2)
    ; Register-based parameter passing
    LD HL, ($F00C)    ; Virtual register 6 from memory
    ; Parameter x in HL
    LD HL, ($F00E)    ; Virtual register 7 from memory
    EX DE, HL
    ; Parameter y in DE
    ; Found function, UsesTrueSMC=false
    CALL add_words
    ; store , r8
    LD (IX-3), L
    LD (IX-2), H
    ; r10 = 1
    LD A, 1
    LD ($F014), A     ; Virtual register 10 to memory
    ; r11 = 2
    LD A, 2
    LD H, A         ; Store to physical register H
    ; r12 = 3
    LD A, 3
    LD L, A         ; Store to physical register L
    ; r13 = 4
    LD A, 4
    LD ($F01A), A     ; Virtual register 13 to memory
    ; r14 = 5
    LD A, 5
    LD H, A         ; Store to physical register H
    ; r16 = 100
    LD A, 100
    LD L, A         ; Store to physical register L
    ; r17 = load data
    LD L, (IX-8)
    LD H, (IX-7)
    LD ($F022), HL    ; Virtual register 17 to memory
    ; r18 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; Load array element (u8)
    LD HL, ($F022)    ; Virtual register 17 from memory
    PUSH HL
    LD A, H
    LD E, A
    LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD L, A         ; Store to physical register L
    ; unknown op 58
    ; Address-of operation for register r19
    LD HL, $8026  ; Variable address (placeholder)
    LD ($F028), HL    ; Virtual register 20 to memory
    ; r21 = 5
    LD A, 5
    LD H, A         ; Store to physical register H
    ; r22 = call process
    ; Call to process (args: 3)
    ; Register-based parameter passing
    LD A, L
    ; Parameter value in A
    LD HL, ($F028)    ; Virtual register 20 from memory
    EX DE, HL
    ; Parameter ptr in DE
    PUSH HL       ; Parameter count on stack
    ; Found function, UsesTrueSMC=false
    CALL process
    ; store , r22
    LD (IX-9), L
    LD (IX-8), H
    ; r24 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r25 = 2
    LD A, 2
    LD L, A         ; Store to physical register L
    ; r26 = 3
    LD A, 3
    LD ($F034), A     ; Virtual register 26 to memory
    ; r27 = 4
    LD A, 4
    LD H, A         ; Store to physical register H
    ; r28 = 5
    LD A, 5
    LD L, A         ; Store to physical register L
    ; r29 = call many_params
    ; Call to many_params (args: 5)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 4
    PUSH HL       ; Argument 3
    LD HL, ($F034)    ; Virtual register 26 from memory
    PUSH HL       ; Argument 2
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL many_params
    LD ($F03A), HL    ; Virtual register 29 to memory
    ; store , r29
    LD HL, ($F03A)    ; Virtual register 29 from memory
    LD (IX-10), L
    LD (IX-9), H
    ; r31 = 10
    LD A, 10
    LD L, A         ; Store to physical register L
    ; r32 = call recursive_sum
    ; Call to recursive_sum (args: 1)
    ; Register-based parameter passing
    LD A, L
    ; Parameter n in A
    ; Found function, UsesTrueSMC=false
    CALL recursive_sum
    ; Register 32 already in HL
    ; store , r32
    ; Register 32 already in HL
    LD (IX-12), L
    LD (IX-11), H
    ; return
    LD SP, IX
    POP IX
    RET

    END main
