; MinZ generated code
; Generated: 2025-08-03 15:05:45


; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: ......examples.zero_cost_test.Circle.draw
......examples.zero_cost_test.Circle.draw:
; TRUE SMC function with immediate anchors
self$immOP:
    LD A, 0        ; self anchor (will be patched)
self$imm0 EQU self$immOP+1
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ......examples.zero_cost_test.Circle.get_size
......examples.zero_cost_test.Circle.get_size:
; TRUE SMC function with immediate anchors
self$immOP:
    LD B, 0        ; self anchor (will be patched)
self$imm0 EQU self$immOP+1
    LD A, (self$imm0)    ; Reuse from anchor
    LD C, A         ; Store to physical register C
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ......examples.zero_cost_test.Circle.scale
......examples.zero_cost_test.Circle.scale:
; TRUE SMC function with immediate anchors
self$immOP:
    LD D, 0        ; self anchor (will be patched)
self$imm0 EQU self$immOP+1
factor$immOP:
    LD E, 0        ; factor anchor (will be patched)
factor$imm0 EQU factor$immOP+1
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ......examples.zero_cost_test.Rectangle.draw
......examples.zero_cost_test.Rectangle.draw:
; TRUE SMC function with immediate anchors
self$immOP:
    LD HL, 0       ; self anchor (will be patched)
self$imm0 EQU self$immOP+1
    ; Register 2 already in HL
    LD HL, (self$imm0)   ; Reuse from anchor
    LD D, H
    LD E, L
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ......examples.zero_cost_test.Rectangle.get_size
......examples.zero_cost_test.Rectangle.get_size:
; TRUE SMC function with immediate anchors
self$immOP:
    LD HL, 0       ; self anchor (will be patched)
self$imm0 EQU self$immOP+1
    LD B, H
    LD C, L
    LD HL, (self$imm0)   ; Reuse from anchor
    PUSH HL           ; Save current HL
    EXX               ; Switch to shadow registers
    POP HL            ; Load into shadow HL
    EXX               ; Switch back to main registers
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ......examples.zero_cost_test.Rectangle.scale
......examples.zero_cost_test.Rectangle.scale:
; TRUE SMC function with immediate anchors
self$immOP:
    LD HL, 0       ; self anchor (will be patched)
self$imm0 EQU self$immOP+1
    LD HL, (self$imm0)   ; Reuse from anchor
factor$immOP:
    LD A, 0        ; factor anchor (will be patched)
factor$imm0 EQU factor$immOP+1
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ......examples.zero_cost_test.test_lambdas$double_0
......examples.zero_cost_test.test_lambdas$double_0:
; TRUE SMC function with immediate anchors
x$immOP:
    LD A, 0        ; x anchor (will be patched)
x$imm0 EQU x$immOP+1
    LD L, A         ; Store to HL (low byte)
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ......examples.zero_cost_test.test_lambdas$add_five_1
......examples.zero_cost_test.test_lambdas$add_five_1:
; TRUE SMC function with immediate anchors
x$immOP:
    LD A, 0        ; x anchor (will be patched)
x$imm0 EQU x$immOP+1
    LD H, A         ; Store to physical register H
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ......examples.zero_cost_test.test_lambdas$multiply_2
......examples.zero_cost_test.test_lambdas$multiply_2:
; TRUE SMC function with immediate anchors
a$immOP:
    LD A, 0        ; a anchor (will be patched)
a$imm0 EQU a$immOP+1
    LD L, A         ; Store to physical register L
b$immOP:
    LD A, 0        ; b anchor (will be patched)
b$imm0 EQU b$immOP+1
    LD L, A         ; Store to HL (low byte)
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ......examples.zero_cost_test.test_lambdas
......examples.zero_cost_test.test_lambdas:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    PUSH BC
    PUSH DE
    ; r3 = call double
    ; Call to double (args: 1)
    ; Stack-based parameter passing
    LD HL, ($F004)    ; Virtual register 2 from memory
    PUSH HL       ; Argument 0
    CALL double
    LD ($F006), HL    ; Virtual register 3 to memory
    ; r6 = call add_five
    ; Call to add_five (args: 1)
    ; Stack-based parameter passing
    LD HL, ($F00A)    ; Virtual register 5 from memory
    PUSH HL       ; Argument 0
    CALL add_five
    ; Register 6 already in HL
    ; r10 = call multiply
    ; Call to multiply (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F012)    ; Virtual register 9 from memory
    PUSH HL       ; Argument 1
    LD HL, ($F010)    ; Virtual register 8 from memory
    PUSH HL       ; Argument 0
    CALL multiply
    ; return
    POP DE
    POP BC
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ......examples.zero_cost_test.test_interfaces
......examples.zero_cost_test.test_interfaces:
; IsSMCDefault=false, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
