; MinZ Intermediate Representation (MIR)
; Module: main

Function ......examples.test_registers.add_numbers(a: u16, b: u16) -> u16
  @smc
  Instructions:
      0: UNKNOWN_OP_33 ; Load from anchor a$imm0
      1: UNKNOWN_OP_33 ; Load from anchor b$imm0
      2: r5 = r3 + r4
      3: return r5

Function ......examples.test_registers.complex_calc(x: u16, y: u16, z: u16) -> u16
  @smc
  Locals:
    r4 = a: u16
    r8 = b: u16
    r12 = c: u16
    r16 = d: u16
  Instructions:
      0: UNKNOWN_OP_33 ; Load from anchor x$imm0
      1: UNKNOWN_OP_33 ; Load from anchor y$imm0
      2: UNKNOWN_OP_33 ; Load from anchor y$imm0
      3: UNKNOWN_OP_33 ; Load from anchor z$imm0
      4: r20 = load c
      5: r21 = load d
      6: r22 = r20 + r21
      7: return r22

Function ......examples.test_registers.timer_interrupt() -> void
  @smc
  Locals:
    r1 = counter: u16
  Instructions:
      0: return

Function ......examples.test_registers.process_array(data: *u8, len: u16) -> u16
  @smc
  Locals:
    r3 = sum: u16
    r5 = i: u16
  Instructions:
      0: loop_1:
      1: r7 = load i
      2: UNKNOWN_OP_33 ; Load from anchor len$imm0
      3: r9 = r7 < r8
      4: jump_if_not r9, end_loop_2
      5: UNKNOWN_OP_33 ; Load from anchor data$imm0
      6: LOAD_INDEX ; Load array element (u8)
      7: jump loop_1
      8: end_loop_2:
      9: r18 = load sum
     10: return r18

Function ......examples.test_registers.main() -> void
  @smc
  Locals:
    r1 = x: u16
    r5 = y: u16
  Instructions:
      0: r4 = call add_numbers
      1: r9 = call complex_calc
      2: return

