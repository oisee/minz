// Test register allocation and lean prologue/epilogue

// Simple function that uses only a few registers
fun add_numbers(a: u16, b: u16) -> u16 {
    return a + b;
}

// Function with more register pressure
fun complex_calc(x: u16, y: u16, z: u16) -> u16 {
    let a = x + y;
    let b = y + z;
    let c = a * 2;
    let d = b * 3;
    return c + d;
}

// Interrupt handler should save all modified registers
@interrupt
fun timer_interrupt() -> void {
    let counter: u16 = 0;
    counter = counter + 1;
    // Write to port
    return;
}

// Function that could benefit from shadow registers
fun process_array(data: *u8, len: u16) -> u16 {
    let sum: u16 = 0;
    let i: u16 = 0;
    
    while i < len {
        sum = sum + data[i];
        i = i + 1;
    }
    
    return sum;
}

// Main entry point
fun main() -> void {
    let x = add_numbers(10, 20);
    let y = complex_calc(1, 2, 3);
    return;
}