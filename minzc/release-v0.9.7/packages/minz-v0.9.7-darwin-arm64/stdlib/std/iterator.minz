// MinZ Standard Library - Iterator Module
// Zero-cost iteration abstractions that compile to optimal assembly

import std.core.*;

// Core iterator trait
trait Iterator {
    type Item;
    
    fun next(mut self) -> Option<Self::Item>;
    
    // Adapter methods with default implementations
    fun map<B, F>(self, f: F) -> Map<Self, F> 
        where F: Fn(Self::Item) -> B {
        Map { iter: self, f: f }
    }
    
    fun filter<P>(self, predicate: P) -> Filter<Self, P>
        where P: Fn(&Self::Item) -> bool {
        Filter { iter: self, predicate: predicate }
    }
    
    fun take(self, n: u16) -> Take<Self> {
        Take { iter: self, remaining: n }
    }
    
    fun skip(self, n: u16) -> Skip<Self> {
        Skip { iter: self, remaining: n }
    }
    
    fun zip<U>(self, other: U) -> Zip<Self, U>
        where U: Iterator {
        Zip { a: self, b: other }
    }
    
    fun chain<U>(self, other: U) -> Chain<Self, U>
        where U: Iterator<Item = Self::Item> {
        Chain { first: self, second: other, first_done: false }
    }
    
    fun enumerate(self) -> Enumerate<Self> {
        Enumerate { iter: self, count: 0 }
    }
    
    // Terminal operations
    fun count(mut self) -> u16 {
        let mut count = 0;
        while self.next().is_some() {
            count += 1;
        }
        count
    }
    
    fun last(mut self) -> Option<Self::Item> {
        let mut last = None;
        while let Some(item) = self.next() {
            last = Some(item);
        }
        last
    }
    
    fun nth(mut self, n: u16) -> Option<Self::Item> {
        for _ in 0..n {
            self.next()?;
        }
        self.next()
    }
    
    fun find<P>(mut self, predicate: P) -> Option<Self::Item>
        where P: Fn(&Self::Item) -> bool {
        while let Some(item) = self.next() {
            if predicate(&item) {
                return Some(item);
            }
        }
        None
    }
    
    fun position<P>(mut self, predicate: P) -> Option<u16>
        where P: Fn(Self::Item) -> bool {
        let mut index = 0;
        while let Some(item) = self.next() {
            if predicate(item) {
                return Some(index);
            }
            index += 1;
        }
        None
    }
    
    fun all<P>(mut self, predicate: P) -> bool
        where P: Fn(Self::Item) -> bool {
        while let Some(item) = self.next() {
            if !predicate(item) {
                return false;
            }
        }
        true
    }
    
    fun any<P>(mut self, predicate: P) -> bool
        where P: Fn(Self::Item) -> bool {
        while let Some(item) = self.next() {
            if predicate(item) {
                return true;
            }
        }
        false
    }
    
    fun for_each<F>(mut self, f: F) -> void
        where F: FnMut(Self::Item) -> void {
        while let Some(item) = self.next() {
            f(item);
        }
    }
    
    // Collecting operations
    fun collect<C>(self) -> C
        where C: FromIterator<Self::Item> {
        C::from_iter(self)
    }
}

// Map adapter
struct Map<I, F> {
    iter: I,
    f: F
}

impl<I, F, B> Iterator for Map<I, F>
    where I: Iterator,
          F: Fn(I::Item) -> B {
    type Item = B;
    
    fun next(mut self) -> Option<B> {
        self.iter.next().map(|x| (self.f)(x))
    }
}

// Filter adapter
struct Filter<I, P> {
    iter: I,
    predicate: P
}

impl<I, P> Iterator for Filter<I, P>
    where I: Iterator,
          P: Fn(&I::Item) -> bool {
    type Item = I::Item;
    
    fun next(mut self) -> Option<I::Item> {
        while let Some(item) = self.iter.next() {
            if (self.predicate)(&item) {
                return Some(item);
            }
        }
        None
    }
}

// Take adapter
struct Take<I> {
    iter: I,
    remaining: u16
}

impl<I> Iterator for Take<I>
    where I: Iterator {
    type Item = I::Item;
    
    fun next(mut self) -> Option<I::Item> {
        if self.remaining == 0 {
            return None;
        }
        self.remaining -= 1;
        self.iter.next()
    }
}

// Skip adapter
struct Skip<I> {
    iter: I,
    remaining: u16
}

impl<I> Iterator for Skip<I>
    where I: Iterator {
    type Item = I::Item;
    
    fun next(mut self) -> Option<I::Item> {
        while self.remaining > 0 {
            self.iter.next()?;
            self.remaining -= 1;
        }
        self.iter.next()
    }
}

// Zip adapter
struct Zip<A, B> {
    a: A,
    b: B
}

impl<A, B> Iterator for Zip<A, B>
    where A: Iterator,
          B: Iterator {
    type Item = (A::Item, B::Item);
    
    fun next(mut self) -> Option<(A::Item, B::Item)> {
        match (self.a.next(), self.b.next()) {
            (Some(a), Some(b)) => Some((a, b)),
            _ => None
        }
    }
}

// Chain adapter
struct Chain<A, B> {
    first: A,
    second: B,
    first_done: bool
}

impl<A, B> Iterator for Chain<A, B>
    where A: Iterator,
          B: Iterator<Item = A::Item> {
    type Item = A::Item;
    
    fun next(mut self) -> Option<A::Item> {
        if !self.first_done {
            match self.first.next() {
                Some(item) => return Some(item),
                None => self.first_done = true
            }
        }
        self.second.next()
    }
}

// Enumerate adapter
struct Enumerate<I> {
    iter: I,
    count: u16
}

impl<I> Iterator for Enumerate<I>
    where I: Iterator {
    type Item = (u16, I::Item);
    
    fun next(mut self) -> Option<(u16, I::Item)> {
        let item = self.iter.next()?;
        let index = self.count;
        self.count += 1;
        Some((index, item))
    }
}

// Trait for types that can be created from an iterator
trait FromIterator<A> {
    fun from_iter<I>(iter: I) -> Self
        where I: Iterator<Item = A>;
}

// Range iterator
struct Range {
    start: u16,
    end: u16
}

impl Iterator for Range {
    type Item = u16;
    
    fun next(mut self) -> Option<u16> {
        if self.start < self.end {
            let val = self.start;
            self.start += 1;
            Some(val)
        } else {
            None
        }
    }
}

// Create a range iterator
fun range(start: u16, end: u16) -> Range {
    Range { start: start, end: end }
}

// Array iterator
struct ArrayIter<T, const N: u16> {
    array: *[T; N],
    index: u16
}

impl<T, const N: u16> Iterator for ArrayIter<T, N> {
    type Item = *T;
    
    fun next(mut self) -> Option<*T> {
        if self.index < N {
            let result = &(*self.array)[self.index];
            self.index += 1;
            Some(result)
        } else {
            None
        }
    }
}

// Create iterator from array
impl<T, const N: u16> [T; N] {
    fun iter(self) -> ArrayIter<T, N> {
        ArrayIter { array: &self, index: 0 }
    }
}

// Slice iterator (when we have slices)
struct SliceIter<T> {
    ptr: *T,
    end: *T
}

impl<T> Iterator for SliceIter<T> {
    type Item = *T;
    
    fun next(mut self) -> Option<*T> {
        if self.ptr < self.end {
            let result = self.ptr;
            self.ptr = self.ptr.offset(1);
            Some(result)
        } else {
            None
        }
    }
}

// Special optimized iterators for common patterns

// Repeat a value forever
struct Repeat<T> {
    value: T
}

impl<T: Clone> Iterator for Repeat<T> {
    type Item = T;
    
    fun next(mut self) -> Option<T> {
        Some(self.value.clone())
    }
}

fun repeat<T: Clone>(value: T) -> Repeat<T> {
    Repeat { value: value }
}

// Cycle through an iterator forever
struct Cycle<I> {
    orig: I,
    iter: I
}

impl<I: Clone> Iterator for Cycle<I>
    where I: Iterator {
    type Item = I::Item;
    
    fun next(mut self) -> Option<I::Item> {
        match self.iter.next() {
            Some(item) => Some(item),
            None => {
                self.iter = self.orig.clone();
                self.iter.next()
            }
        }
    }
}

// Windows iterator for sliding window operations
struct Windows<T, const N: u16> {
    slice: *[T],
    index: u16
}

impl<T, const N: u16> Iterator for Windows<T, N> {
    type Item = *[T; N];
    
    fun next(mut self) -> Option<*[T; N]> {
        if self.index + N <= self.slice.len() {
            let window = &self.slice[self.index..self.index + N];
            self.index += 1;
            Some(@unsafe_cast(*[T; N], window))
        } else {
            None
        }
    }
}

// Chunks iterator for batch processing  
struct Chunks<T, const N: u16> {
    slice: *[T],
    index: u16
}

impl<T, const N: u16> Iterator for Chunks<T, N> {
    type Item = *[T];
    
    fun next(mut self) -> Option<*[T]> {
        if self.index < self.slice.len() {
            let remaining = self.slice.len() - self.index;
            let chunk_size = if remaining < N { remaining } else { N };
            let chunk = &self.slice[self.index..self.index + chunk_size];
            self.index += chunk_size;
            Some(chunk)
        } else {
            None
        }
    }
}

// Optimization hints for the compiler
@compile_time_hint
fun optimize_iterator_chain<I: Iterator>(iter: I) -> I {
    // This function is replaced by the compiler with optimized code
    // It analyzes the iterator chain and generates optimal assembly
    iter
}