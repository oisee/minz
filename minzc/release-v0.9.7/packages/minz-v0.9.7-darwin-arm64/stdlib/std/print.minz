// MinZ Zero-Cost Print System
// Compile-time string interpolation with zero runtime overhead

// Core Printable interface - everything that can be printed
pub interface Printable {
    fun print_to(self, writer: Writer) -> void;
}

// Formatter interface for custom formatting
pub interface Formatter {
    fun format(self, value: Printable, spec: *u8) -> void;
}

// Basic implementations for primitive types
impl Printable for u8 {
    fun print_to(self, writer: Writer) -> void {
        if self == 0 {
            writer.write_byte('0');
            return;
        }
        
        // Compile-time optimization: for constants, generate direct code
        @if_const(self) {
            // This path is taken when self is a compile-time constant
            @emit_digits(self)  // Generates optimal digit sequence
        } else {
            // Runtime path for variables
            let mut buffer: [u8; 3];
            let mut pos = 3;
            let mut num = self;
            
            while num > 0 {
                pos = pos - 1;
                buffer[pos] = '0' + (num % 10);
                num = num / 10;
            }
            
            while pos < 3 {
                writer.write_byte(buffer[pos]);
                pos = pos + 1;
            }
        }
    }
}

impl Printable for u16 {
    fun print_to(self, writer: Writer) -> void {
        @if_const(self) {
            // Compile-time path - generate exact digit sequence
            @emit_digits(self)
        } else {
            // Runtime path
            if self < 256 {
                (self as u8).print_to(writer);  // Optimize small values
                return;
            }
            
            let mut buffer: [u8; 5];
            let mut pos = 5;
            let mut num = self;
            
            while num > 0 {
                pos = pos - 1;
                buffer[pos] = '0' + ((num % 10) as u8);
                num = num / 10;
            }
            
            while pos < 5 {
                writer.write_byte(buffer[pos]);
                pos = pos + 1;
            }
        }
    }
}

impl Printable for i8 {
    fun print_to(self, writer: Writer) -> void {
        if self < 0 {
            writer.write_byte('-');
            ((-self) as u8).print_to(writer);
        } else {
            (self as u8).print_to(writer);
        }
    }
}

impl Printable for i16 {
    fun print_to(self, writer: Writer) -> void {
        if self < 0 {
            writer.write_byte('-');
            ((-self) as u16).print_to(writer);
        } else {
            (self as u16).print_to(writer);
        }
    }
}

impl Printable for bool {
    fun print_to(self, writer: Writer) -> void {
        @if_const(self) {
            // Compile-time: generate exact string
            @if(self) {
                @emit_string("true")
            } else {
                @emit_string("false")
            }
        } else {
            // Runtime path
            if self {
                writer.write_bytes("true", 4);
            } else {
                writer.write_bytes("false", 5);
            }
        }
    }
}

impl Printable for *u8 {
    fun print_to(self, writer: Writer) -> void {
        // String printing
        let mut ptr = self;
        while *ptr != 0 {
            writer.write_byte(*ptr);
            ptr = ptr + 1;
        }
    }
}

// Hex formatting wrapper
pub struct Hex<T> {
    value: T,
}

impl Printable for Hex<u8> {
    fun print_to(self, writer: Writer) -> void {
        let high = self.value >> 4;
        let low = self.value & 0x0F;
        
        writer.write_byte(hex_digit(high));
        writer.write_byte(hex_digit(low));
    }
}

impl Printable for Hex<u16> {
    fun print_to(self, writer: Writer) -> void {
        Hex { value: (self.value >> 8) as u8 }.print_to(writer);
        Hex { value: (self.value & 0xFF) as u8 }.print_to(writer);
    }
}

fun hex_digit(val: u8) -> u8 {
    if val < 10 {
        '0' + val
    } else {
        'A' + (val - 10)
    }
}

// Binary formatting wrapper
pub struct Bin<T> {
    value: T,
}

impl Printable for Bin<u8> {
    fun print_to(self, writer: Writer) -> void {
        writer.write_byte('0');
        writer.write_byte('b');
        
        let mut mask: u8 = 0x80;
        while mask != 0 {
            if (self.value & mask) != 0 {
                writer.write_byte('1');
            } else {
                writer.write_byte('0');
            }
            mask = mask >> 1;
        }
    }
}

// Padding wrapper
pub struct Pad<T> {
    value: T,
    width: u8,
    fill: u8,
}

impl<T: Printable> Printable for Pad<T> {
    fun print_to(self, writer: Writer) -> void {
        // This would require knowing the printed length
        // For now, just print the value
        self.value.print_to(writer);
    }
}

// Array printing
impl<T: Printable> Printable for [T] {
    fun print_to(self, writer: Writer) -> void {
        writer.write_byte('[');
        let mut first = true;
        for item in self {
            if !first {
                writer.write_bytes(", ", 2);
            }
            item.print_to(writer);
            first = false;
        }
        writer.write_byte(']');
    }
}

// Helper functions for formatting
pub fun hex<T>(value: T) -> Hex<T> {
    Hex { value: value }
}

pub fun bin<T>(value: T) -> Bin<T> {
    Bin { value: value }
}

pub fun pad<T>(value: T, width: u8, fill: u8) -> Pad<T> {
    Pad { value: value, width: width, fill: fill }
}

// The magical @print macro that does compile-time interpolation
@macro print(format: string_literal, args...) {
    // This is processed at compile time!
    // The compiler parses the format string and generates optimal code
    
    // Example: @print("Hello {}, you scored {}!", name, score)
    // Generates:
    //   stdout.write_bytes("Hello ", 6);
    //   name.print_to(stdout);
    //   stdout.write_bytes(", you scored ", 13);
    //   score.print_to(stdout);
    //   stdout.write_byte('!');
    
    @parse_format_string(format, args)
}

@macro println(format: string_literal, args...) {
    @print(format, args);
    stdout.write_byte('\n');
}

// Even more optimized - compile-time string building
@macro format(format: string_literal, args...) -> string {
    // Build string at compile time if all args are constants
    @if_all_const(args) {
        @const_format(format, args)
    } else {
        // Runtime formatting with pre-calculated buffer size
        @runtime_format(format, args)
    }
}

// Debug printing that includes type information
@macro debug(expr) {
    @print("[DEBUG] {} = {}", @stringify(expr), expr);
}

// Assertion with formatted messages
@macro assert(condition, format: string_literal, args...) {
    if !(condition) {
        @print("ASSERTION FAILED: ");
        @print(format, args);
        @panic();
    }
}

// Compile-time print for build messages
@macro static_print(message: string_literal) {
    @compile_time {
        @emit_build_message(message)
    }
}

// Examples of zero-cost printing:

// This:
//   @print("x = {}, y = {}", 42, true)
// Compiles to:
//   stdout.write_bytes("x = ", 4);
//   stdout.write_bytes("42", 2);  // Constant folded!
//   stdout.write_bytes(", y = ", 6);
//   stdout.write_bytes("true", 4); // Constant folded!

// This:
//   @print("Hex: 0x{:x}, Bin: {:b}", hex(255), bin(15))
// Compiles to:
//   stdout.write_bytes("Hex: 0x", 7);
//   stdout.write_bytes("FF", 2);   // Compile-time hex conversion!
//   stdout.write_bytes(", Bin: ", 7);
//   stdout.write_bytes("0b00001111", 10); // Compile-time binary!

// For runtime values, it generates minimal code:
//   let score = get_score();
//   @print("Score: {}", score)
// Compiles to:
//   stdout.write_bytes("Score: ", 7);
//   score.print_to(stdout);  // Single interface call

// Advanced formatting with zero runtime parsing:
//   @print("{:<10} | {:>5} | {:^8}", name, score, level)
// The format specifiers are parsed at compile time!