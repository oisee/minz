; MinZ Intermediate Representation (MIR)
; Module: main

; Globals:
;   ...examples.zvdb.vectors: [16]...examples.zvdb.Vector256
;   ...examples.zvdb.count: u8
;   ...examples.zvdb.lut: [256]u8

Function ...examples.zvdb.init_lut() -> void
  @smc
  Locals:
    r5 = val: u8
    r7 = bits: u8
  Instructions:
      0: r1 = 0
      1: r2 = 256
      2: r3 = r1 ; Initialize loop variable i
      3: for_loop_1:
      4: r4 = r3 < r2 ; Check i < end
      5: jump_if_not r4, for_end_2
      6: r6 = load i
      7: store , r6
      8: r8 = 0
      9: store , r8
     10: r9 = 0
     11: r10 = 8
     12: r11 = r9 ; Initialize loop variable b
     13: for_loop_3:
     14: r12 = r11 < r10 ; Check b < end
     15: jump_if_not r12, for_end_4
     16: r13 = load val
     17: r14 = 1
     18: r15 = load b
     19: SHL
     20: r17 = r13 & r16
     21: r18 = 0
     22: r19 = r17 != r18
     23: jump_if_not r19, else_5
     24: r20 = load bits
     25: r21 = 1
     26: r22 = r20 + r21
     27: store bits, r22
     28: jump end_if_6
     29: else_5:
     30: end_if_6:
     31: r23 = 1
     32: r11 = r11 + r23 ; Increment b
     33: jump for_loop_3
     34: for_end_4:
     35: r24 = load bits
     36: r25 = load lut
     37: r26 = load i
     38: r27 = r25 + r26 ; Calculate array element address
     39: UNKNOWN_OP_67 ; Store to array[index] (u8)
     40: r28 = 1
     41: r3 = r3 + r28 ; Increment i
     42: jump for_loop_1
     43: for_end_2:
     44: return

Function ...examples.zvdb.popcount(val: u8) -> u8
  @smc
  Instructions:
      0: r2 = load lut
      1: LOAD_PARAM
      2: LOAD_INDEX ; Load array element (u8)
      3: return r4

Function ...examples.zvdb.hamming(v1: *...examples.zvdb.Vector256, v2: *...examples.zvdb.Vector256) -> u16
  @smc
  Locals:
    r3 = dist: u16
    r9 = xor_val: u8
    r19 = pc: u8
  Instructions:
      0: r4 = 0
      1: store , r4
      2: r5 = 0
      3: r6 = 32
      4: r7 = r5 ; Initialize loop variable i
      5: for_loop_7:
      6: r8 = r7 < r6 ; Check i < end
      7: jump_if_not r8, for_end_8
      8: LOAD_PARAM
      9: LOAD_FIELD ; Load field data (offset 0)
     10: r12 = load i
     11: LOAD_INDEX ; Load array element (u8)
     12: LOAD_PARAM
     13: LOAD_FIELD ; Load field data (offset 0)
     14: r16 = load i
     15: LOAD_INDEX ; Load array element (u8)
     16: r18 = r13 ^ r17
     17: store , r18
     18: r20 = load xor_val
     19: r21 = call popcount
     20: store , r21
     21: r22 = load dist
     22: r23 = load pc
     23: r24 = r22 + r23
     24: store dist, r24
     25: r25 = 1
     26: r7 = r7 + r25 ; Increment i
     27: jump for_loop_7
     28: for_end_8:
     29: r26 = load dist
     30: return r26

Function ...examples.zvdb.add_vector(vec: *...examples.zvdb.Vector256) -> u8
  @smc
  Locals:
    r6 = idx: u8
  Instructions:
      0: r2 = load count
      1: r3 = 16
      2: r4 = r2 >= r3
      3: jump_if_not r4, else_9
      4: r5 = 255
      5: return r5
      6: jump end_if_10
      7: else_9:
      8: end_if_10:
      9: r7 = load count
     10: store , r7
     11: r8 = 0
     12: r9 = 32
     13: r10 = r8 ; Initialize loop variable i
     14: for_loop_11:
     15: r11 = r10 < r9 ; Check i < end
     16: jump_if_not r11, for_end_12
     17: LOAD_PARAM
     18: LOAD_FIELD ; Load field data (offset 0)
     19: r14 = load i
     20: LOAD_INDEX ; Load array element (u8)
     21: r16 = load vectors
     22: r17 = load idx
     23: LOAD_INDEX ; Load array element (...examples.zvdb.Vector256)
     24: LOAD_FIELD ; Load field data (offset 0)
     25: r20 = load i
     26: r21 = r19 + r20 ; Calculate array element address
     27: UNKNOWN_OP_67 ; Store to array[index] (u8)
     28: r22 = 1
     29: r10 = r10 + r22 ; Increment i
     30: jump for_loop_11
     31: for_end_12:
     32: r23 = load count
     33: r24 = 1
     34: r25 = r23 + r24
     35: store count, r25
     36: r26 = load idx
     37: return r26

Function ...examples.zvdb.find_best(query: *...examples.zvdb.Vector256) -> ...examples.zvdb.SearchResult
  @smc
  Locals:
    r2 = result: ...examples.zvdb.SearchResult
    r14 = dist: u16
    r29 = doubled: u16
  Instructions:
      0: r3 = 255
      1: r4 = load result
      2: STORE_FIELD ; Store to field vector_id (offset 0)
      3: r5 = 256
      4: r6 = load result
      5: STORE_FIELD ; Store to field hamming (offset 1)
      6: r7 = 256
      7: NEG
      8: r9 = load result
      9: STORE_FIELD ; Store to field score (offset 3)
     10: r10 = 0
     11: r11 = load count
     12: r12 = r10 ; Initialize loop variable i
     13: for_loop_13:
     14: r13 = r12 < r11 ; Check i < end
     15: jump_if_not r13, for_end_14
     16: LOAD_PARAM
     17: r16 = load vectors
     18: r17 = load i
     19: LOAD_INDEX ; Load array element (...examples.zvdb.Vector256)
     20: UNKNOWN_OP_68
     21: r20 = call hamming
     22: store , r20
     23: r21 = load dist
     24: r22 = load result
     25: LOAD_FIELD ; Load field hamming (offset 1)
     26: r24 = r21 < r23
     27: jump_if_not r24, else_15
     28: r25 = load i
     29: r26 = load result
     30: STORE_FIELD ; Store to field vector_id (offset 0)
     31: r27 = load dist
     32: r28 = load result
     33: STORE_FIELD ; Store to field hamming (offset 1)
     34: r30 = load dist
     35: r31 = 1
     36: SHL
     37: store , r32
     38: r33 = 256
     39: r34 = load doubled
     40: r35 = r33 - r34
     41: r36 = load result
     42: STORE_FIELD ; Store to field score (offset 3)
     43: jump end_if_16
     44: else_15:
     45: end_if_16:
     46: r37 = 1
     47: r12 = r12 + r37 ; Increment i
     48: jump for_loop_13
     49: for_end_14:
     50: r38 = load result
     51: return r38

Function ...examples.zvdb.create_tests() -> void
  @smc
  Locals:
    r1 = vec: ...examples.zvdb.Vector256
  Instructions:
      0: r2 = 0
      1: r3 = 32
      2: r4 = r2 ; Initialize loop variable i
      3: for_loop_17:
      4: r5 = r4 < r3 ; Check i < end
      5: jump_if_not r5, for_end_18
      6: r6 = load i
      7: r7 = 1
      8: r8 = r6 & r7
      9: r9 = 0
     10: r10 = r8 == r9
     11: jump_if_not r10, else_19
     12: r11 = 85
     13: r12 = load vec
     14: LOAD_FIELD ; Load field data (offset 0)
     15: r14 = load i
     16: r15 = r13 + r14 ; Calculate array element address
     17: UNKNOWN_OP_67 ; Store to array[index] (u8)
     18: jump end_if_20
     19: else_19:
     20: r16 = 170
     21: r17 = load vec
     22: LOAD_FIELD ; Load field data (offset 0)
     23: r19 = load i
     24: r20 = r18 + r19 ; Calculate array element address
     25: UNKNOWN_OP_67 ; Store to array[index] (u8)
     26: end_if_20:
     27: r21 = 1
     28: r4 = r4 + r21 ; Increment i
     29: jump for_loop_17
     30: for_end_18:
     31: r22 = load vec
     32: UNKNOWN_OP_68
     33: r24 = call add_vector
     34: r25 = 0
     35: r26 = 32
     36: r27 = r25 ; Initialize loop variable i
     37: for_loop_21:
     38: r28 = r27 < r26 ; Check i < end
     39: jump_if_not r28, for_end_22
     40: r29 = 255
     41: r30 = load vec
     42: LOAD_FIELD ; Load field data (offset 0)
     43: r32 = load i
     44: r33 = r31 + r32 ; Calculate array element address
     45: UNKNOWN_OP_67 ; Store to array[index] (u8)
     46: r34 = 1
     47: r27 = r27 + r34 ; Increment i
     48: jump for_loop_21
     49: for_end_22:
     50: r35 = load vec
     51: UNKNOWN_OP_68
     52: r37 = call add_vector
     53: r38 = 0
     54: r39 = 32
     55: r40 = r38 ; Initialize loop variable i
     56: for_loop_23:
     57: r41 = r40 < r39 ; Check i < end
     58: jump_if_not r41, for_end_24
     59: r42 = 0
     60: r43 = load vec
     61: LOAD_FIELD ; Load field data (offset 0)
     62: r45 = load i
     63: r46 = r44 + r45 ; Calculate array element address
     64: UNKNOWN_OP_67 ; Store to array[index] (u8)
     65: r47 = 1
     66: r40 = r40 + r47 ; Increment i
     67: jump for_loop_23
     68: for_end_24:
     69: r48 = load vec
     70: UNKNOWN_OP_68
     71: r50 = call add_vector
     72: return

Function ...examples.zvdb.main() -> void
  @smc
  Locals:
    r9 = h01: u16
    r19 = h02: u16
    r33 = query: ...examples.zvdb.Vector256
    r54 = result: ...examples.zvdb.SearchResult
  Instructions:
      0: UNKNOWN_OP_88
      1: UNKNOWN_OP_86 ; Print "ZVDB-MinZ Production Ready
" (27 chars via loop)
      2: UNKNOWN_OP_88
      3: UNKNOWN_OP_86 ; Print "==========================

" (28 chars via loop)
      4: UNKNOWN_OP_88
      5: UNKNOWN_OP_86 ; Print "Initializing LUT...
" (20 chars via loop)
      6: r4 = call init_lut
      7: UNKNOWN_OP_88
      8: UNKNOWN_OP_86 ; Print "Creating test vectors...
" (25 chars via loop)
      9: r6 = call create_tests
     10: UNKNOWN_OP_88
     11: UNKNOWN_OP_86 ; Print "Database has " (13 chars via loop)
     12: UNKNOWN_OP_88
     13: UNKNOWN_OP_86 ; Print " vectors

" (10 chars via loop)
     14: r10 = load vectors
     15: r11 = 0
     16: LOAD_INDEX ; Load array element (...examples.zvdb.Vector256)
     17: UNKNOWN_OP_68
     18: r14 = load vectors
     19: r15 = 1
     20: LOAD_INDEX ; Load array element (...examples.zvdb.Vector256)
     21: UNKNOWN_OP_68
     22: r18 = call hamming
     23: store , r18
     24: r20 = load vectors
     25: r21 = 0
     26: LOAD_INDEX ; Load array element (...examples.zvdb.Vector256)
     27: UNKNOWN_OP_68
     28: r24 = load vectors
     29: r25 = 2
     30: LOAD_INDEX ; Load array element (...examples.zvdb.Vector256)
     31: UNKNOWN_OP_68
     32: r28 = call hamming
     33: store , r28
     34: UNKNOWN_OP_88
     35: UNKNOWN_OP_86 ; Print "Hamming distances:
" (19 chars via loop)
     36: UNKNOWN_OP_88
     37: UNKNOWN_OP_86 ; Print "  V0 vs V1: " (12 chars via loop)
     38: UNKNOWN_OP_87 ; Direct print " bits
" (6 chars)
     39: UNKNOWN_OP_88
     40: UNKNOWN_OP_86 ; Print "  V0 vs V2: " (12 chars via loop)
     41: UNKNOWN_OP_87 ; Direct print " bits
" (6 chars)
     42: UNKNOWN_OP_88
     43: UNKNOWN_OP_86 ; Print "
Searching...
" (14 chars via loop)
     44: r34 = 0
     45: r35 = 32
     46: r36 = r34 ; Initialize loop variable i
     47: for_loop_25:
     48: r37 = r36 < r35 ; Check i < end
     49: jump_if_not r37, for_end_26
     50: r38 = load i
     51: r39 = 1
     52: r40 = r38 & r39
     53: r41 = 0
     54: r42 = r40 == r41
     55: jump_if_not r42, else_27
     56: r43 = 84
     57: r44 = load query
     58: LOAD_FIELD ; Load field data (offset 0)
     59: r46 = load i
     60: r47 = r45 + r46 ; Calculate array element address
     61: UNKNOWN_OP_67 ; Store to array[index] (u8)
     62: jump end_if_28
     63: else_27:
     64: r48 = 171
     65: r49 = load query
     66: LOAD_FIELD ; Load field data (offset 0)
     67: r51 = load i
     68: r52 = r50 + r51 ; Calculate array element address
     69: UNKNOWN_OP_67 ; Store to array[index] (u8)
     70: end_if_28:
     71: r53 = 1
     72: r36 = r36 + r53 ; Increment i
     73: jump for_loop_25
     74: for_end_26:
     75: r55 = load query
     76: UNKNOWN_OP_68
     77: r57 = call find_best
     78: store , r57
     79: r58 = load result
     80: LOAD_FIELD ; Load field vector_id (offset 0)
     81: UNKNOWN_OP_81
     82: r60 = load result
     83: LOAD_FIELD ; Load field hamming (offset 1)
     84: UNKNOWN_OP_82
     85: r62 = load result
     86: LOAD_FIELD ; Load field score (offset 3)
     87: UNKNOWN_OP_82
     88: UNKNOWN_OP_88
     89: UNKNOWN_OP_86 ; Print "
â ZVDB-MinZ Complete!
" (28 chars via loop)
     90: return

