; MinZ Intermediate Representation (MIR)
; Module: main

; Globals:
;   ...examples.zvdb_test.tests_passed: u8
;   ...examples.zvdb_test.tests_failed: u8

Function ...examples.zvdb_test.assert_equal(actual: u16, expected: u16, test_name: *u8) -> void
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r6 = r4 == r5
      3: jump_if_not r6, else_1
      4: r7 = load tests_passed
      5: r8 = 1
      6: r9 = r7 + r8
      7: store tests_passed, r9
      8: UNKNOWN_OP_88
      9: UNKNOWN_OP_86 ; Print "Ã¢ÂÂ " (13 chars via loop)
     10: UNKNOWN_OP_87 ; Direct print ": PASS
" (7 chars)
     11: jump end_if_2
     12: else_1:
     13: r11 = load tests_failed
     14: r12 = 1
     15: r13 = r11 + r12
     16: store tests_failed, r13
     17: UNKNOWN_OP_88
     18: UNKNOWN_OP_86 ; Print "Ã¢ÂÂ " (13 chars via loop)
     19: UNKNOWN_OP_88
     20: UNKNOWN_OP_86 ; Print ": FAIL (got " (12 chars via loop)
     21: UNKNOWN_OP_88
     22: UNKNOWN_OP_86 ; Print ", expected " (11 chars via loop)
     23: UNKNOWN_OP_87 ; Direct print ")
" (2 chars)
     24: end_if_2:
     25: return

Function ...examples.zvdb_test.test_popcount() -> void
  Locals:
    r2 = pc0: u8
    r9 = pc1: u8
    r16 = pc3: u8
    r23 = pcF: u8
    r30 = pc55: u8
    r37 = pcAA: u8
    r44 = pcFF: u8
  Instructions:
      0: UNKNOWN_OP_88
      1: UNKNOWN_OP_86 ; Print "
=== Popcount Tests ===
" (24 chars via loop)
      2: r3 = 0
      3: r4 = call popcount_bits
      4: store , r4
      5: r5 = load pc0
      6: r6 = 0
      7: LOAD_LABEL ; Load string "popcount(0x00)"
      8: r8 = call assert_equal
      9: r10 = 1
     10: r11 = call popcount_bits
     11: store , r11
     12: r12 = load pc1
     13: r13 = 1
     14: LOAD_LABEL ; Load string "popcount(0x01)"
     15: r15 = call assert_equal
     16: r17 = 3
     17: r18 = call popcount_bits
     18: store , r18
     19: r19 = load pc3
     20: r20 = 2
     21: LOAD_LABEL ; Load string "popcount(0x03)"
     22: r22 = call assert_equal
     23: r24 = 15
     24: r25 = call popcount_bits
     25: store , r25
     26: r26 = load pcF
     27: r27 = 4
     28: LOAD_LABEL ; Load string "popcount(0x0F)"
     29: r29 = call assert_equal
     30: r31 = 85
     31: r32 = call popcount_bits
     32: store , r32
     33: r33 = load pc55
     34: r34 = 4
     35: LOAD_LABEL ; Load string "popcount(0x55)"
     36: r36 = call assert_equal
     37: r38 = 170
     38: r39 = call popcount_bits
     39: store , r39
     40: r40 = load pcAA
     41: r41 = 4
     42: LOAD_LABEL ; Load string "popcount(0xAA)"
     43: r43 = call assert_equal
     44: r45 = 255
     45: r46 = call popcount_bits
     46: store , r46
     47: r47 = load pcFF
     48: r48 = 8
     49: LOAD_LABEL ; Load string "popcount(0xFF)"
     50: r50 = call assert_equal
     51: return

Function ...examples.zvdb_test.popcount_bits(val: u8) -> u8
  @smc
  Locals:
    r2 = count: u8
    r4 = v: u8
  Instructions:
      0: r3 = 0
      1: store , r3
      2: LOAD_PARAM
      3: store , r5
      4: r6 = 0
      5: r7 = 8
      6: r8 = r6 ; Initialize loop variable i
      7: for_loop_3:
      8: r9 = r8 < r7 ; Check i < end
      9: jump_if_not r9, for_end_4
     10: r10 = load v
     11: r11 = 1
     12: r12 = r10 & r11
     13: r13 = 0
     14: r14 = r12 != r13
     15: jump_if_not r14, else_5
     16: r15 = load count
     17: r16 = 1
     18: r17 = r15 + r16
     19: store count, r17
     20: jump end_if_6
     21: else_5:
     22: end_if_6:
     23: r18 = load v
     24: r19 = 1
     25: SHR
     26: store v, r20
     27: r21 = 1
     28: r8 = r8 + r21 ; Increment i
     29: jump for_loop_3
     30: for_end_4:
     31: r22 = load count
     32: return r22

Function ...examples.zvdb_test.test_hamming() -> void
  @smc
  Locals:
    r2 = v1: ...examples.zvdb_test.Vector256
    r3 = v2: ...examples.zvdb_test.Vector256
    r19 = dist1: u16
    r44 = dist2: u16
    r69 = dist3: u16
    r99 = dist4: u16
  Instructions:
      0: UNKNOWN_OP_88
      1: UNKNOWN_OP_86 ; Print "
=== Hamming Distance Tests ===
" (32 chars via loop)
      2: r4 = 0
      3: r5 = 32
      4: r6 = r4 ; Initialize loop variable i
      5: for_loop_7:
      6: r7 = r6 < r5 ; Check i < end
      7: jump_if_not r7, for_end_8
      8: r8 = 85
      9: r9 = load v1
     10: LOAD_FIELD ; Load field data (offset 0)
     11: r11 = load i
     12: r12 = r10 + r11 ; Calculate array element address
     13: UNKNOWN_OP_67 ; Store to array[index] (u8)
     14: r13 = 85
     15: r14 = load v2
     16: LOAD_FIELD ; Load field data (offset 0)
     17: r16 = load i
     18: r17 = r15 + r16 ; Calculate array element address
     19: UNKNOWN_OP_67 ; Store to array[index] (u8)
     20: r18 = 1
     21: r6 = r6 + r18 ; Increment i
     22: jump for_loop_7
     23: for_end_8:
     24: r20 = load v1
     25: UNKNOWN_OP_68
     26: r22 = load v2
     27: UNKNOWN_OP_68
     28: r24 = call calc_hamming
     29: store , r24
     30: r25 = load dist1
     31: r26 = 0
     32: LOAD_LABEL ; Load string "Identical vectors"
     33: r28 = call assert_equal
     34: r29 = 0
     35: r30 = 32
     36: r31 = r29 ; Initialize loop variable i
     37: for_loop_9:
     38: r32 = r31 < r30 ; Check i < end
     39: jump_if_not r32, for_end_10
     40: r33 = 0
     41: r34 = load v1
     42: LOAD_FIELD ; Load field data (offset 0)
     43: r36 = load i
     44: r37 = r35 + r36 ; Calculate array element address
     45: UNKNOWN_OP_67 ; Store to array[index] (u8)
     46: r38 = 255
     47: r39 = load v2
     48: LOAD_FIELD ; Load field data (offset 0)
     49: r41 = load i
     50: r42 = r40 + r41 ; Calculate array element address
     51: UNKNOWN_OP_67 ; Store to array[index] (u8)
     52: r43 = 1
     53: r31 = r31 + r43 ; Increment i
     54: jump for_loop_9
     55: for_end_10:
     56: r45 = load v1
     57: UNKNOWN_OP_68
     58: r47 = load v2
     59: UNKNOWN_OP_68
     60: r49 = call calc_hamming
     61: store , r49
     62: r50 = load dist2
     63: r51 = 256
     64: LOAD_LABEL ; Load string "Opposite vectors"
     65: r53 = call assert_equal
     66: r54 = 0
     67: r55 = 32
     68: r56 = r54 ; Initialize loop variable i
     69: for_loop_11:
     70: r57 = r56 < r55 ; Check i < end
     71: jump_if_not r57, for_end_12
     72: r58 = 15
     73: r59 = load v1
     74: LOAD_FIELD ; Load field data (offset 0)
     75: r61 = load i
     76: r62 = r60 + r61 ; Calculate array element address
     77: UNKNOWN_OP_67 ; Store to array[index] (u8)
     78: r63 = 240
     79: r64 = load v2
     80: LOAD_FIELD ; Load field data (offset 0)
     81: r66 = load i
     82: r67 = r65 + r66 ; Calculate array element address
     83: UNKNOWN_OP_67 ; Store to array[index] (u8)
     84: r68 = 1
     85: r56 = r56 + r68 ; Increment i
     86: jump for_loop_11
     87: for_end_12:
     88: r70 = load v1
     89: UNKNOWN_OP_68
     90: r72 = load v2
     91: UNKNOWN_OP_68
     92: r74 = call calc_hamming
     93: store , r74
     94: r75 = load dist3
     95: r76 = 256
     96: LOAD_LABEL ; Load string "Half different"
     97: r78 = call assert_equal
     98: r79 = 0
     99: r80 = 32
    100: r81 = r79 ; Initialize loop variable i
    101: for_loop_13:
    102: r82 = r81 < r80 ; Check i < end
    103: jump_if_not r82, for_end_14
    104: r83 = 0
    105: r84 = load v1
    106: LOAD_FIELD ; Load field data (offset 0)
    107: r86 = load i
    108: r87 = r85 + r86 ; Calculate array element address
    109: UNKNOWN_OP_67 ; Store to array[index] (u8)
    110: r88 = 0
    111: r89 = load v2
    112: LOAD_FIELD ; Load field data (offset 0)
    113: r91 = load i
    114: r92 = r90 + r91 ; Calculate array element address
    115: UNKNOWN_OP_67 ; Store to array[index] (u8)
    116: r93 = 1
    117: r81 = r81 + r93 ; Increment i
    118: jump for_loop_13
    119: for_end_14:
    120: r94 = 1
    121: r95 = load v2
    122: LOAD_FIELD ; Load field data (offset 0)
    123: r97 = 0
    124: r98 = r96 + r97 ; Calculate array element address
    125: UNKNOWN_OP_67 ; Store to array[index] (u8)
    126: r100 = load v1
    127: UNKNOWN_OP_68
    128: r102 = load v2
    129: UNKNOWN_OP_68
    130: r104 = call calc_hamming
    131: store , r104
    132: r105 = load dist4
    133: r106 = 1
    134: LOAD_LABEL ; Load string "One bit different"
    135: r108 = call assert_equal
    136: return

Function ...examples.zvdb_test.calc_hamming(v1: *...examples.zvdb_test.Vector256, v2: *...examples.zvdb_test.Vector256) -> u16
  @smc
  Locals:
    r3 = distance: u16
    r9 = xor_val: u8
    r19 = bits: u8
  Instructions:
      0: r4 = 0
      1: store , r4
      2: r5 = 0
      3: r6 = 32
      4: r7 = r5 ; Initialize loop variable i
      5: for_loop_15:
      6: r8 = r7 < r6 ; Check i < end
      7: jump_if_not r8, for_end_16
      8: LOAD_PARAM
      9: LOAD_FIELD ; Load field data (offset 0)
     10: r12 = load i
     11: LOAD_INDEX ; Load array element (u8)
     12: LOAD_PARAM
     13: LOAD_FIELD ; Load field data (offset 0)
     14: r16 = load i
     15: LOAD_INDEX ; Load array element (u8)
     16: r18 = r13 ^ r17
     17: store , r18
     18: r20 = load xor_val
     19: r21 = call popcount_bits
     20: store , r21
     21: r22 = load distance
     22: r23 = load bits
     23: r24 = r22 + r23
     24: store distance, r24
     25: r25 = 1
     26: r7 = r7 + r25 ; Increment i
     27: jump for_loop_15
     28: for_end_16:
     29: r26 = load distance
     30: return r26

Function ...examples.zvdb_test.test_similarity() -> void
  Locals:
    r2 = v1: ...examples.zvdb_test.Vector256
    r3 = v2: ...examples.zvdb_test.Vector256
    r19 = sim1: i16
    r25 = sim1_u: u16
    r46 = sim2: i16
    r79 = sim3: i16
    r85 = sim3_u: u16
  Instructions:
      0: UNKNOWN_OP_88
      1: UNKNOWN_OP_86 ; Print "
=== Similarity Score Tests ===
" (32 chars via loop)
      2: r4 = 0
      3: r5 = 32
      4: r6 = r4 ; Initialize loop variable i
      5: for_loop_17:
      6: r7 = r6 < r5 ; Check i < end
      7: jump_if_not r7, for_end_18
      8: r8 = 170
      9: r9 = load v1
     10: LOAD_FIELD ; Load field data (offset 0)
     11: r11 = load i
     12: r12 = r10 + r11 ; Calculate array element address
     13: UNKNOWN_OP_67 ; Store to array[index] (u8)
     14: r13 = 170
     15: r14 = load v2
     16: LOAD_FIELD ; Load field data (offset 0)
     17: r16 = load i
     18: r17 = r15 + r16 ; Calculate array element address
     19: UNKNOWN_OP_67 ; Store to array[index] (u8)
     20: r18 = 1
     21: r6 = r6 + r18 ; Increment i
     22: jump for_loop_17
     23: for_end_18:
     24: r20 = load v1
     25: UNKNOWN_OP_68
     26: r22 = load v2
     27: UNKNOWN_OP_68
     28: r24 = call calc_similarity
     29: store , r24
     30: r26 = load sim1
     31: store , r26
     32: r27 = load sim1_u
     33: r28 = 256
     34: LOAD_LABEL ; Load string "Identical similarity"
     35: r30 = call assert_equal
     36: r31 = 0
     37: r32 = 32
     38: r33 = r31 ; Initialize loop variable i
     39: for_loop_19:
     40: r34 = r33 < r32 ; Check i < end
     41: jump_if_not r34, for_end_20
     42: r35 = 0
     43: r36 = load v1
     44: LOAD_FIELD ; Load field data (offset 0)
     45: r38 = load i
     46: r39 = r37 + r38 ; Calculate array element address
     47: UNKNOWN_OP_67 ; Store to array[index] (u8)
     48: r40 = 255
     49: r41 = load v2
     50: LOAD_FIELD ; Load field data (offset 0)
     51: r43 = load i
     52: r44 = r42 + r43 ; Calculate array element address
     53: UNKNOWN_OP_67 ; Store to array[index] (u8)
     54: r45 = 1
     55: r33 = r33 + r45 ; Increment i
     56: jump for_loop_19
     57: for_end_20:
     58: r47 = load v1
     59: UNKNOWN_OP_68
     60: r49 = load v2
     61: UNKNOWN_OP_68
     62: r51 = call calc_similarity
     63: store , r51
     64: r52 = load sim2
     65: r53 = 256
     66: NEG
     67: r55 = r52 == r54
     68: jump_if_not r55, else_21
     69: r56 = load tests_passed
     70: r57 = 1
     71: r58 = r56 + r57
     72: store tests_passed, r58
     73: UNKNOWN_OP_88
     74: UNKNOWN_OP_86 ; Print "â Opposite similarity: PASS
" (33 chars via loop)
     75: jump end_if_22
     76: else_21:
     77: r60 = load tests_failed
     78: r61 = 1
     79: r62 = r60 + r61
     80: store tests_failed, r62
     81: UNKNOWN_OP_88
     82: UNKNOWN_OP_86 ; Print "â Opposite similarity: FAIL
" (33 chars via loop)
     83: end_if_22:
     84: r64 = 0
     85: r65 = 32
     86: r66 = r64 ; Initialize loop variable i
     87: for_loop_23:
     88: r67 = r66 < r65 ; Check i < end
     89: jump_if_not r67, for_end_24
     90: r68 = 15
     91: r69 = load v1
     92: LOAD_FIELD ; Load field data (offset 0)
     93: r71 = load i
     94: r72 = r70 + r71 ; Calculate array element address
     95: UNKNOWN_OP_67 ; Store to array[index] (u8)
     96: r73 = 0
     97: r74 = load v2
     98: LOAD_FIELD ; Load field data (offset 0)
     99: r76 = load i
    100: r77 = r75 + r76 ; Calculate array element address
    101: UNKNOWN_OP_67 ; Store to array[index] (u8)
    102: r78 = 1
    103: r66 = r66 + r78 ; Increment i
    104: jump for_loop_23
    105: for_end_24:
    106: r80 = load v1
    107: UNKNOWN_OP_68
    108: r82 = load v2
    109: UNKNOWN_OP_68
    110: r84 = call calc_similarity
    111: store , r84
    112: r86 = load sim3
    113: store , r86
    114: r87 = load sim3_u
    115: r88 = 128
    116: LOAD_LABEL ; Load string "Half similar"
    117: r90 = call assert_equal
    118: return

Function ...examples.zvdb_test.calc_similarity(v1: *...examples.zvdb_test.Vector256, v2: *...examples.zvdb_test.Vector256) -> i16
  @smc
  Locals:
    r3 = hamming: u16
    r7 = doubled: u16
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r6 = call calc_hamming
      3: store , r6
      4: r8 = load hamming
      5: r9 = 1
      6: SHL
      7: store , r10
      8: r11 = 256
      9: r12 = load doubled
     10: r13 = r11 - r12
     11: return r13

Function ...examples.zvdb_test.test_search() -> void
  Locals:
    r2 = db: [4]...examples.zvdb_test.Vector256
    r51 = query1: ...examples.zvdb_test.Vector256
    r62 = best1: u8
    r71 = best1_u: u16
    r77 = query2: ...examples.zvdb_test.Vector256
    r88 = best2: u8
    r97 = best2_u: u16
  Instructions:
      0: UNKNOWN_OP_88
      1: UNKNOWN_OP_86 ; Print "
=== Vector Search Tests ===
" (29 chars via loop)
      2: r3 = 0
      3: r4 = 32
      4: r5 = r3 ; Initialize loop variable i
      5: for_loop_25:
      6: r6 = r5 < r4 ; Check i < end
      7: jump_if_not r6, for_end_26
      8: r7 = 0
      9: r8 = load db
     10: r9 = 0
     11: LOAD_INDEX ; Load array element (...examples.zvdb_test.Vector256)
     12: LOAD_FIELD ; Load field data (offset 0)
     13: r12 = load i
     14: r13 = r11 + r12 ; Calculate array element address
     15: UNKNOWN_OP_67 ; Store to array[index] (u8)
     16: r14 = 1
     17: r5 = r5 + r14 ; Increment i
     18: jump for_loop_25
     19: for_end_26:
     20: r15 = 0
     21: r16 = 32
     22: r17 = r15 ; Initialize loop variable i
     23: for_loop_27:
     24: r18 = r17 < r16 ; Check i < end
     25: jump_if_not r18, for_end_28
     26: r19 = 255
     27: r20 = load db
     28: r21 = 1
     29: LOAD_INDEX ; Load array element (...examples.zvdb_test.Vector256)
     30: LOAD_FIELD ; Load field data (offset 0)
     31: r24 = load i
     32: r25 = r23 + r24 ; Calculate array element address
     33: UNKNOWN_OP_67 ; Store to array[index] (u8)
     34: r26 = 1
     35: r17 = r17 + r26 ; Increment i
     36: jump for_loop_27
     37: for_end_28:
     38: r27 = 0
     39: r28 = 32
     40: r29 = r27 ; Initialize loop variable i
     41: for_loop_29:
     42: r30 = r29 < r28 ; Check i < end
     43: jump_if_not r30, for_end_30
     44: r31 = 85
     45: r32 = load db
     46: r33 = 2
     47: LOAD_INDEX ; Load array element (...examples.zvdb_test.Vector256)
     48: LOAD_FIELD ; Load field data (offset 0)
     49: r36 = load i
     50: r37 = r35 + r36 ; Calculate array element address
     51: UNKNOWN_OP_67 ; Store to array[index] (u8)
     52: r38 = 1
     53: r29 = r29 + r38 ; Increment i
     54: jump for_loop_29
     55: for_end_30:
     56: r39 = 0
     57: r40 = 32
     58: r41 = r39 ; Initialize loop variable i
     59: for_loop_31:
     60: r42 = r41 < r40 ; Check i < end
     61: jump_if_not r42, for_end_32
     62: r43 = 170
     63: r44 = load db
     64: r45 = 3
     65: LOAD_INDEX ; Load array element (...examples.zvdb_test.Vector256)
     66: LOAD_FIELD ; Load field data (offset 0)
     67: r48 = load i
     68: r49 = r47 + r48 ; Calculate array element address
     69: UNKNOWN_OP_67 ; Store to array[index] (u8)
     70: r50 = 1
     71: r41 = r41 + r50 ; Increment i
     72: jump for_loop_31
     73: for_end_32:
     74: r52 = 0
     75: r53 = 32
     76: r54 = r52 ; Initialize loop variable i
     77: for_loop_33:
     78: r55 = r54 < r53 ; Check i < end
     79: jump_if_not r55, for_end_34
     80: r56 = 0
     81: r57 = load query1
     82: LOAD_FIELD ; Load field data (offset 0)
     83: r59 = load i
     84: r60 = r58 + r59 ; Calculate array element address
     85: UNKNOWN_OP_67 ; Store to array[index] (u8)
     86: r61 = 1
     87: r54 = r54 + r61 ; Increment i
     88: jump for_loop_33
     89: for_end_34:
     90: r63 = load query1
     91: UNKNOWN_OP_68
     92: r65 = load db
     93: r66 = 0
     94: LOAD_INDEX ; Load array element (...examples.zvdb_test.Vector256)
     95: UNKNOWN_OP_68
     96: r69 = 4
     97: r70 = call find_nearest
     98: store , r70
     99: r72 = load best1
    100: store , r72
    101: r73 = load best1_u
    102: r74 = 0
    103: LOAD_LABEL ; Load string "Find exact match"
    104: r76 = call assert_equal
    105: r78 = 0
    106: r79 = 32
    107: r80 = r78 ; Initialize loop variable i
    108: for_loop_35:
    109: r81 = r80 < r79 ; Check i < end
    110: jump_if_not r81, for_end_36
    111: r82 = 84
    112: r83 = load query2
    113: LOAD_FIELD ; Load field data (offset 0)
    114: r85 = load i
    115: r86 = r84 + r85 ; Calculate array element address
    116: UNKNOWN_OP_67 ; Store to array[index] (u8)
    117: r87 = 1
    118: r80 = r80 + r87 ; Increment i
    119: jump for_loop_35
    120: for_end_36:
    121: r89 = load query2
    122: UNKNOWN_OP_68
    123: r91 = load db
    124: r92 = 0
    125: LOAD_INDEX ; Load array element (...examples.zvdb_test.Vector256)
    126: UNKNOWN_OP_68
    127: r95 = 4
    128: r96 = call find_nearest
    129: store , r96
    130: r98 = load best2
    131: store , r98
    132: r99 = load best2_u
    133: r100 = 2
    134: LOAD_LABEL ; Load string "Find nearest"
    135: r102 = call assert_equal
    136: return

Function ...examples.zvdb_test.find_nearest(query: *...examples.zvdb_test.Vector256, db: *...examples.zvdb_test.Vector256, count: u8) -> u8
  @smc
  Locals:
    r4 = best_id: u8
    r6 = best_dist: u16
    r12 = dist: u16
  Instructions:
      0: r5 = 255
      1: store , r5
      2: r7 = 65535
      3: store , r7
      4: r8 = 0
      5: LOAD_PARAM
      6: r10 = r8 ; Initialize loop variable i
      7: for_loop_37:
      8: r11 = r10 < r9 ; Check i < end
      9: jump_if_not r11, for_end_38
     10: LOAD_PARAM
     11: LOAD_PARAM
     12: r15 = load i
     13: LOAD_INDEX ; Load array element (u8)
     14: UNKNOWN_OP_68
     15: r18 = call calc_hamming
     16: store , r18
     17: r19 = load dist
     18: r20 = load best_dist
     19: r21 = r19 < r20
     20: jump_if_not r21, else_39
     21: r22 = load dist
     22: store best_dist, r22
     23: r23 = load i
     24: store best_id, r23
     25: jump end_if_40
     26: else_39:
     27: end_if_40:
     28: r24 = 1
     29: r10 = r10 + r24 ; Increment i
     30: jump for_loop_37
     31: for_end_38:
     32: r25 = load best_id
     33: return r25

Function ...examples.zvdb_test.main() -> void
  @smc
  Instructions:
      0: UNKNOWN_OP_88
      1: UNKNOWN_OP_86 ; Print "ZVDB E2E Test Suite
" (20 chars via loop)
      2: UNKNOWN_OP_88
      3: UNKNOWN_OP_86 ; Print "==================
" (19 chars via loop)
      4: r3 = call test_popcount
      5: r4 = call test_hamming
      6: r5 = call test_similarity
      7: r6 = call test_search
      8: UNKNOWN_OP_88
      9: UNKNOWN_OP_86 ; Print "
=== Test Summary ===
" (22 chars via loop)
     10: UNKNOWN_OP_87 ; Direct print "Passed: " (8 chars)
     11: UNKNOWN_OP_87 ; Direct print "
" (1 chars)
     12: UNKNOWN_OP_87 ; Direct print "Failed: " (8 chars)
     13: UNKNOWN_OP_87 ; Direct print "
" (1 chars)
     14: r8 = load tests_failed
     15: r9 = 0
     16: r10 = r8 == r9
     17: jump_if_not r10, else_41
     18: UNKNOWN_OP_88
     19: UNKNOWN_OP_86 ; Print "
â All tests passed!
" (26 chars via loop)
     20: jump end_if_42
     21: else_41:
     22: UNKNOWN_OP_88
     23: UNKNOWN_OP_86 ; Print "
â Some tests failed!
" (27 chars via loop)
     24: end_if_42:
     25: return

