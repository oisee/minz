// MinZ Standard Library - Core Module
// Foundation types and functions that everything else builds on

// Option type for nullable values
enum Option<T> {
    Some(T),
    None
}

impl<T> Option<T> {
    fun is_some(self) -> bool {
        match self {
            Some(_) => true,
            None => false
        }
    }
    
    fun is_none(self) -> bool {
        !self.is_some()
    }
    
    fun unwrap(self) -> T {
        match self {
            Some(val) => val,
            None => @panic("unwrap on None value")
        }
    }
    
    fun unwrap_or(self, default: T) -> T {
        match self {
            Some(val) => val,
            None => default
        }
    }
    
    fun map<U>(self, f: fn(T) -> U) -> Option<U> {
        match self {
            Some(val) => Some(f(val)),
            None => None
        }
    }
}

// Result type for error handling
enum Result<T, E> {
    Ok(T),
    Err(E)
}

impl<T, E> Result<T, E> {
    fun is_ok(self) -> bool {
        match self {
            Ok(_) => true,
            Err(_) => false
        }
    }
    
    fun is_err(self) -> bool {
        !self.is_ok()
    }
    
    fun unwrap(self) -> T {
        match self {
            Ok(val) => val,
            Err(_) => @panic("unwrap on Err value")
        }
    }
    
    fun unwrap_err(self) -> E {
        match self {
            Ok(_) => @panic("unwrap_err on Ok value"),
            Err(err) => err
        }
    }
    
    fun map<U>(self, f: fn(T) -> U) -> Result<U, E> {
        match self {
            Ok(val) => Ok(f(val)),
            Err(err) => Err(err)
        }
    }
    
    fun map_err<F>(self, f: fn(E) -> F) -> Result<T, F> {
        match self {
            Ok(val) => Ok(val),
            Err(err) => Err(f(err))
        }
    }
}

// Basic bounds checking
fun check_bounds(index: u16, len: u16) -> void {
    if index >= len {
        @panic("index out of bounds");
    }
}

// Memory utilities
namespace mem {
    // Copy memory from src to dest
    fun copy(dest: *u8, src: *u8, count: u16) -> void {
        // For small copies, unroll
        if count <= 8 {
            for i in 0..count {
                *dest.offset(i) = *src.offset(i);
            }
        } else {
            // Use block copy for larger amounts
            @asm("
                ld hl, {src}
                ld de, {dest}
                ld bc, {count}
                ldir
            ");
        }
    }
    
    // Set memory to value
    fun set(dest: *u8, value: u8, count: u16) -> void {
        if count == 0 { return; }
        
        // For very small counts, unroll
        if count <= 4 {
            for i in 0..count {
                *dest.offset(i) = value;
            }
        } else {
            // Set first byte then copy
            *dest = value;
            if count > 1 {
                @asm("
                    ld hl, {dest}
                    ld de, {dest}
                    inc de
                    ld bc, {count}
                    dec bc
                    ldir
                ");
            }
        }
    }
    
    // Compare memory regions
    fun compare(a: *u8, b: *u8, count: u16) -> i8 {
        for i in 0..count {
            let va = *a.offset(i);
            let vb = *b.offset(i);
            if va < vb { return -1; }
            if va > vb { return 1; }
        }
        return 0;
    }
    
    // Find byte in memory
    fun find(haystack: *u8, needle: u8, count: u16) -> Option<u16> {
        for i in 0..count {
            if *haystack.offset(i) == needle {
                return Some(i);
            }
        }
        return None;
    }
}

// Math utilities
namespace math {
    // Absolute value
    fun abs(x: i8) -> u8 {
        if x < 0 { -x as u8 } else { x as u8 }
    }
    
    fun abs16(x: i16) -> u16 {
        if x < 0 { -x as u16 } else { x as u16 }
    }
    
    // Min/max functions
    fun min(a: u8, b: u8) -> u8 {
        if a < b { a } else { b }
    }
    
    fun max(a: u8, b: u8) -> u8 {
        if a > b { a } else { b }
    }
    
    fun min16(a: u16, b: u16) -> u16 {
        if a < b { a } else { b }
    }
    
    fun max16(a: u16, b: u16) -> u16 {
        if a > b { a } else { b }
    }
    
    // Clamp value to range
    fun clamp(value: u8, min: u8, max: u8) -> u8 {
        if value < min { min }
        else if value > max { max }
        else { value }
    }
    
    // Integer square root (8-bit)
    fun sqrt(n: u8) -> u8 {
        if n == 0 { return 0; }
        
        let mut x = n;
        let mut y = (x + 1) / 2;
        
        while y < x {
            x = y;
            y = (x + n / x) / 2;
        }
        
        return x;
    }
}

// Bit manipulation utilities
namespace bits {
    // Count set bits (popcount)
    fun count_ones(x: u8) -> u8 {
        let mut count = 0;
        let mut val = x;
        while val != 0 {
            count += val & 1;
            val >>= 1;
        }
        return count;
    }
    
    // Find first set bit (returns 0-7, or 8 if no bit set)
    fun first_one(x: u8) -> u8 {
        if x == 0 { return 8; }
        
        let mut pos = 0;
        let mut val = x;
        while (val & 1) == 0 {
            val >>= 1;
            pos += 1;
        }
        return pos;
    }
    
    // Reverse bits
    fun reverse(x: u8) -> u8 {
        let mut result = 0;
        let mut val = x;
        for i in 0..8 {
            result = (result << 1) | (val & 1);
            val >>= 1;
        }
        return result;
    }
    
    // Rotate left
    fun rotate_left(x: u8, n: u8) -> u8 {
        let n = n & 7;  // Mod 8
        return (x << n) | (x >> (8 - n));
    }
    
    // Rotate right
    fun rotate_right(x: u8, n: u8) -> u8 {
        let n = n & 7;  // Mod 8
        return (x >> n) | (x << (8 - n));
    }
}

// Panic handler
@noreturn
fun panic(msg: *str) -> void {
    @print("PANIC: ");
    print_string(msg);
    @print("\n");
    @halt();
}

// Assertion
fun assert(condition: bool, msg: *str) -> void {
    if !condition {
        panic(msg);
    }
}

// Debug assertion (only in debug builds)
@if(DEBUG) {
    fun debug_assert(condition: bool, msg: *str) -> void {
        assert(condition, msg);
    }
} else {
    fun debug_assert(condition: bool, msg: *str) -> void {
        // No-op in release
    }
}