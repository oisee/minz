; MinZ generated code
; Generated: 2025-07-27 08:41:25


; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_abi_comprehensive.add_smc
test_abi_comprehensive.add_smc:
; Using absolute addressing for locals
    PUSH IX
    LD IX, SP
    ; Load parameters from registers
    LD C, A         ; Store to physical register C
    LD A, E       ; Get parameter b
    LD ($F004), A     ; Virtual register 2 to memory
    ; unknown op 12
    ; Load parameter a
    ; unknown op 12
    ; Load parameter b
    ; r5 = r3 + r4
    LD D, H
    LD E, L
    ADD HL, DE
    ; return r5
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_abi_comprehensive.calculate_smc
test_abi_comprehensive.calculate_smc:
; Using absolute addressing for locals
    PUSH IX
    LD IX, SP
    ; Load parameters from registers
    LD L, A         ; Store to physical register L
    LD A, E       ; Get parameter y
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    LD A, D       ; Get parameter z
    LD ($F006), A     ; Virtual register 3 to memory
    ; unknown op 12
    ; Load parameter x
    ; unknown op 12
    ; Load parameter y
    ; r6 = r4 * r5
    ; 8-bit multiplication
    LD A, E
    LD B, A       ; B = multiplicand
    LD A, H
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_0
.mul_loop_0:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_0
.mul_done_0:
    EXX               ; Switch to shadow registers
    ; unknown op 12
    ; Load parameter z
    ; r8 = r6 + r7
    EXX               ; Switch to shadow registers
    LD D, H
    LD E, L
    EXX               ; Switch to shadow registers
    ADD HL, DE
    EXX               ; Switch to shadow registers
    ; return r8
    EXX               ; Switch to shadow registers
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_abi_comprehensive.factorial_tsmc
test_abi_comprehensive.factorial_tsmc:
; Using stack-based locals (IX+offset)
    PUSH IX
    LD IX, SP
    ; Load parameters from registers
    LD ($F002), A     ; Virtual register 1 to memory
    ; unknown op 12
    ; Load parameter n
    ; r3 = 1
    LD A, 1
    LD ($F006), A     ; Virtual register 3 to memory
    ; r4 = r2 <= r3
    LD D, H
    LD E, L
    LD HL, ($F006)    ; Virtual register 3 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L2
    JP Z, .L2
    LD HL, 0
    JP .L3
.L2:
    LD HL, 1
.L3:
    ; jump_if_not r4, else_1
    LD A, E
    OR A
    JP Z, else_1
    ; r5 = 1
    LD A, 1
    LD E, A         ; Store to physical register E
    ; return r5
    LD SP, IX
    POP IX
    RET
    ; jump end_if_2
    JP end_if_2
    ; else_1:
else_1:
    ; end_if_2:
end_if_2:
    ; unknown op 12
    ; Load parameter n
    ; unknown op 12
    ; Load parameter n
    ; r8 = 1
    LD A, 1
    LD D, A         ; Store to physical register D
    ; r9 = r7 - r8
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    ; r10 = call factorial_tsmc
    ; Call to factorial_tsmc (args: 1)
    ; Register-based parameter passing
    LD A, D
    ; Parameter n in A
    ; Found function, UsesTrueSMC=false
    CALL factorial_tsmc
    ; r11 = r6 * r10
    ; 8-bit multiplication
    LD A, L
    LD B, A       ; B = multiplicand
    ; Register 10 already in A
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_3
.mul_loop_3:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_3
.mul_done_3:
    ; return r11
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_abi_comprehensive.fib_tsmc
test_abi_comprehensive.fib_tsmc:
; Using stack-based locals (IX+offset)
    PUSH IX
    LD IX, SP
    ; Load parameters from registers
    LD ($F002), A     ; Virtual register 1 to memory
    ; unknown op 12
    ; Load parameter n
    ; r3 = 1
    LD A, 1
    LD D, A         ; Store to physical register D
    ; r4 = r2 <= r3
    LD HL, ($F004)    ; Virtual register 2 from memory
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L5
    JP Z, .L5
    LD HL, 0
    JP .L6
.L5:
    LD HL, 1
.L6:
    ; jump_if_not r4, else_3
    ; Register 4 already in A
    OR A
    JP Z, else_3
    ; unknown op 12
    ; Load parameter n
    ; return r5
    LD HL, ($F00A)    ; Virtual register 5 from memory
    LD SP, IX
    POP IX
    RET
    ; jump end_if_4
    JP end_if_4
    ; else_3:
else_3:
    ; end_if_4:
end_if_4:
    ; unknown op 12
    ; Load parameter n
    ; r7 = 1
    LD A, 1
    LD ($F00E), A     ; Virtual register 7 to memory
    ; r8 = r6 - r7
    EXX               ; Switch to shadow registers
    LD D, H
    LD E, L
    LD HL, ($F00E)    ; Virtual register 7 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    EXX               ; Switch to shadow registers
    ; r9 = call fib_tsmc
    ; Call to fib_tsmc (args: 1)
    ; Register-based parameter passing
    EXX               ; Switch to shadow registers
    LD A, B'         ; From shadow B'
    EXX               ; Switch back to main registers
    ; Parameter n in A
    ; Found function, UsesTrueSMC=false
    CALL fib_tsmc
    EXX               ; Switch to shadow registers
    ; unknown op 12
    ; Load parameter n
    ; r11 = 2
    LD A, 2
    EXX               ; Switch to shadow registers
    LD C', A         ; Store to shadow C'
    EXX               ; Switch back to main registers
    ; r12 = r10 - r11
    EXX               ; Switch to shadow registers
    LD D, H
    LD E, L
    EXX               ; Switch to shadow registers
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    EXX               ; Switch to shadow registers
    ; r13 = call fib_tsmc
    ; Call to fib_tsmc (args: 1)
    ; Register-based parameter passing
    EXX               ; Switch to shadow registers
    LD A, C'         ; From shadow C'
    EXX               ; Switch back to main registers
    ; Parameter n in A
    ; Found function, UsesTrueSMC=false
    CALL fib_tsmc
    ; r14 = r9 + r13
    EXX               ; Switch to shadow registers
    LD D, H
    LD E, L
    ADD HL, DE
    ; return r14
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_abi_comprehensive.multiply_register
test_abi_comprehensive.multiply_register:
; Using absolute addressing for locals
    PUSH IX
    LD IX, SP
    ; Load parameters from registers
    LD D, A         ; Store to physical register D
    LD A, E       ; Get parameter b
    LD ($F004), A     ; Virtual register 2 to memory
    ; unknown op 12
    ; Load parameter a
    ; unknown op 12
    ; Load parameter b
    ; r5 = r3 * r4
    ; 8-bit multiplication
    EXX               ; Switch to shadow registers
    LD A, B'         ; From shadow B'
    EXX               ; Switch back to main registers
    LD B, A       ; B = multiplicand
    EXX               ; Switch to shadow registers
    LD A, B'         ; From shadow B'
    EXX               ; Switch back to main registers
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_6
.mul_loop_6:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_6
.mul_done_6:
    ; return r5
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_abi_comprehensive.sum3_register
test_abi_comprehensive.sum3_register:
; Using absolute addressing for locals
    PUSH IX
    LD IX, SP
    ; Load parameters from registers
    LD B, A         ; Store to physical register B
    LD A, E       ; Get parameter b
    LD E, A         ; Store to physical register E
    LD A, D       ; Get parameter c
    LD ($F006), A     ; Virtual register 3 to memory
    ; unknown op 12
    ; Load parameter a
    ; unknown op 12
    ; Load parameter b
    ; r6 = r4 + r5
    LD D, H
    LD E, L
    ADD HL, DE
    ; unknown op 12
    ; Load parameter c
    ; r8 = r6 + r7
    LD D, H
    LD E, L
    EXX               ; Switch to shadow registers
    ADD HL, DE
    EXX               ; Switch to shadow registers
    ; return r8
    EXX               ; Switch to shadow registers
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_abi_comprehensive.sum5_stack
test_abi_comprehensive.sum5_stack:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
test_abi_comprehensive.sum5_stack_param_a:
    LD HL, #0000   ; SMC parameter a (u8->u16)
test_abi_comprehensive.sum5_stack_param_b:
    LD HL, #0000   ; SMC parameter b (u8->u16)
    EXX               ; Switch to shadow registers
    ; r8 = r6 + r7
    LD D, H
    LD E, L
    EXX               ; Switch to shadow registers
    ADD HL, DE
    LD ($F010), HL    ; Virtual register 8 to memory
test_abi_comprehensive.sum5_stack_param_c:
    LD HL, #0000   ; SMC parameter c (u8->u16)
    LD ($F012), HL    ; Virtual register 9 to memory
    ; r10 = r8 + r9
    LD HL, ($F010)    ; Virtual register 8 from memory
    LD D, H
    LD E, L
    LD HL, ($F012)    ; Virtual register 9 from memory
    ADD HL, DE
    LD ($F014), HL    ; Virtual register 10 to memory
test_abi_comprehensive.sum5_stack_param_d:
    LD HL, #0000   ; SMC parameter d (u8->u16)
    ; r12 = r10 + r11
    LD HL, ($F014)    ; Virtual register 10 from memory
    LD D, H
    LD E, L
    ADD HL, DE
    EXX               ; Switch to shadow registers
test_abi_comprehensive.sum5_stack_param_e:
    LD HL, #0000   ; SMC parameter e (u8->u16)
    EXX               ; Switch to shadow registers
    ; r14 = r12 + r13
    EXX               ; Switch to shadow registers
    LD D, H
    LD E, L
    EXX               ; Switch to shadow registers
    ADD HL, DE
    EXX               ; Switch to shadow registers
    ; return r14
    EXX               ; Switch to shadow registers
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_abi_comprehensive.countdown_stack
test_abi_comprehensive.countdown_stack:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
test_abi_comprehensive.countdown_stack_param_n:
    LD HL, #0000   ; SMC parameter n (u8->u16)
    LD ($F00C), HL    ; Virtual register 6 to memory
test_abi_comprehensive.countdown_stack_param_min:
    LD HL, #0000   ; SMC parameter min (u8->u16)
    LD ($F00E), HL    ; Virtual register 7 to memory
    ; r8 = r6 <= r7
    LD HL, ($F00C)    ; Virtual register 6 from memory
    LD D, H
    LD E, L
    LD HL, ($F00E)    ; Virtual register 7 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L8
    JP Z, .L8
    LD HL, 0
    JP .L9
.L8:
    LD HL, 1
.L9:
    LD ($F010), HL    ; Virtual register 8 to memory
    ; jump_if_not r8, else_5
    LD A, ($F010)     ; Virtual register 8 from memory
    OR A
    JP Z, else_5
test_abi_comprehensive.countdown_stack_param_offset:
    LD HL, #0000   ; SMC parameter offset (u8->u16)
    ; return r9
    RET
    ; jump end_if_6
    JP end_if_6
    ; else_5:
else_5:
    ; end_if_6:
end_if_6:
test_abi_comprehensive.countdown_stack_param_mult:
    LD HL, #0000   ; SMC parameter mult (u8->u16)
    EXX               ; Switch to shadow registers
    LD A, (test_abi_comprehensive.countdown_stack_param_n)
    LD D, A         ; Store to physical register D
test_abi_comprehensive.countdown_stack_param_step:
    LD HL, #0000   ; SMC parameter step (u8->u16)
    ; r13 = r11 - r12
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    LD A, (test_abi_comprehensive.countdown_stack_param_step)
    LD H, A         ; Store to physical register H
    LD A, (test_abi_comprehensive.countdown_stack_param_min)
    LD B, A         ; Store to physical register B
    LD A, (test_abi_comprehensive.countdown_stack_param_mult)
    ; Register 16 already in A
    LD A, (test_abi_comprehensive.countdown_stack_param_offset)
    LD ($F022), A     ; Virtual register 17 to memory
    ; r18 = call countdown_stack
    ; Call to countdown_stack (args: 5)
    ; Stack-based parameter passing
    LD HL, ($F022)    ; Virtual register 17 from memory
    PUSH HL       ; Argument 4
    PUSH HL       ; Argument 3
    PUSH HL       ; Argument 2
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL countdown_stack
    ; r19 = r10 + r18
    EXX               ; Switch to shadow registers
    LD D, H
    LD E, L
    ADD HL, DE
    ; return r19
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_abi_comprehensive.complex_calculation
test_abi_comprehensive.complex_calculation:
; Using stack-based locals (IX+offset)
    PUSH IX
    LD IX, SP
    LD HL, -7
    ADD HL, SP
    LD SP, HL
    ; Parameter a from stack
    LD L, (IX+4)
    LD H, (IX+5)
    LD (IX-2), L
    LD (IX-1), H
    ; Parameter b from stack
    LD L, (IX+6)
    LD H, (IX+7)
    LD (IX-4), L
    LD (IX-3), H
    ; Parameter c from stack
    LD L, (IX+8)
    LD H, (IX+9)
    LD (IX-6), L
    LD (IX-5), H
    ; Parameter d from stack
    LD L, (IX+10)
    LD H, (IX+11)
    LD (IX-8), L
    LD (IX-7), H
    ; unknown op 12
    ; Load parameter a
    ; r7 = 2
    LD A, 2
    LD ($F00E), A     ; Virtual register 7 to memory
    ; r8 = r6 * r7
    ; 8-bit multiplication
    ; Register 6 already in A
    LD B, A       ; B = multiplicand
    LD A, ($F00E)     ; Virtual register 7 from memory
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_9
.mul_loop_9:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_9
.mul_done_9:
    EXX               ; Switch to shadow registers
    ; store , r8
    EXX               ; Switch to shadow registers
    LD (IX-1), L
    LD (IX+0), H
    ; unknown op 12
    ; Load parameter b
    ; r11 = 3
    LD A, 3
    LD ($F016), A     ; Virtual register 11 to memory
    ; r12 = r10 * r11
    ; 8-bit multiplication
    LD A, ($F014)     ; Virtual register 10 from memory
    LD B, A       ; B = multiplicand
    LD A, ($F016)     ; Virtual register 11 from memory
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_10
.mul_loop_10:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_10
.mul_done_10:
    ; store , r12
    LD (IX-2), L
    LD (IX-1), H
    ; unknown op 12
    ; Load parameter c
    ; r15 = 4
    LD A, 4
    EXX               ; Switch to shadow registers
    LD E', A         ; Store to shadow E'
    EXX               ; Switch back to main registers
    ; r16 = r14 * r15
    ; 8-bit multiplication
    LD A, ($F01C)     ; Virtual register 14 from memory
    LD B, A       ; B = multiplicand
    EXX               ; Switch to shadow registers
    LD A, E'         ; From shadow E'
    EXX               ; Switch back to main registers
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_11
.mul_loop_11:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_11
.mul_done_11:
    ; store , r16
    LD (IX-3), L
    LD (IX-2), H
    ; unknown op 12
    ; Load parameter d
    ; r19 = 5
    LD A, 5
    LD H, A         ; Store to physical register H
    ; r20 = r18 * r19
    ; 8-bit multiplication
    LD A, D
    LD B, A       ; B = multiplicand
    LD A, H
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_12
.mul_loop_12:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_12
.mul_done_12:
    LD ($F028), HL    ; Virtual register 20 to memory
    ; store , r20
    LD HL, ($F028)    ; Virtual register 20 from memory
    LD (IX-4), L
    LD (IX-3), H
    ; r22 = load temp1
    LD L, (IX-1)
    LD H, (IX+0)
    LD ($F02C), HL    ; Virtual register 22 to memory
    ; r23 = load temp2
    LD L, (IX-2)
    LD H, (IX-1)
    ; r24 = r22 + r23
    LD HL, ($F02C)    ; Virtual register 22 from memory
    LD D, H
    LD E, L
    ADD HL, DE
    LD ($F030), HL    ; Virtual register 24 to memory
    ; store , r24
    LD HL, ($F030)    ; Virtual register 24 from memory
    LD (IX-5), L
    LD (IX-4), H
    ; r26 = load temp3
    LD L, (IX-3)
    LD H, (IX-2)
    ; r27 = load temp4
    LD L, (IX-4)
    LD H, (IX-3)
    ; r28 = r26 + r27
    LD D, H
    LD E, L
    ADD HL, DE
    EXX               ; Switch to shadow registers
    ; store , r28
    EXX               ; Switch to shadow registers
    LD (IX-6), L
    LD (IX-5), H
    ; r30 = load sum1
    LD L, (IX-5)
    LD H, (IX-4)
    ; r31 = load sum2
    LD L, (IX-6)
    LD H, (IX-5)
    ; r32 = r30 * r31
    ; 8-bit multiplication
    ; Register 30 already in A
    LD B, A       ; B = multiplicand
    ; Register 31 already in A
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_13
.mul_loop_13:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_13
.mul_done_13:
    ; store , r32
    LD (IX-7), L
    LD (IX-6), H
    ; r33 = load final_result
    LD L, (IX-7)
    LD H, (IX-6)
    EXX               ; Switch to shadow registers
    ; return r33
    EXX               ; Switch to shadow registers
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_abi_comprehensive.test_mixed_calls
test_abi_comprehensive.test_mixed_calls:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = 5
    LD A, 5
    LD ($F004), A     ; Virtual register 2 to memory
    ; r3 = 3
    LD A, 3
    LD B, A         ; Store to physical register B
    ; r4 = call add_smc
    ; Call to add_smc (args: 2)
    ; Register-based parameter passing
    LD A, ($F004)     ; Virtual register 2 from memory
    ; Parameter a in A
    LD A, B
    LD E, A       ; Parameter b in E
    ; Found function, UsesTrueSMC=false
    CALL add_smc
    LD ($F008), HL    ; Virtual register 4 to memory
    ; store , r4
    LD HL, ($F008)    ; Virtual register 4 from memory
    LD ($F002), HL
    ; r6 = 4
    LD A, 4
    LD ($F00C), A     ; Virtual register 6 to memory
    ; r7 = call factorial_tsmc
    ; Call to factorial_tsmc (args: 1)
    ; Register-based parameter passing
    LD A, ($F00C)     ; Virtual register 6 from memory
    ; Parameter n in A
    ; Found function, UsesTrueSMC=false
    CALL factorial_tsmc
    ; store , r7
    LD ($F00A), HL
    ; r9 = 6
    LD A, 6
    LD D, A         ; Store to physical register D
    ; r10 = 7
    LD A, 7
    LD ($F014), A     ; Virtual register 10 to memory
    ; r11 = call multiply_register
    ; Call to multiply_register (args: 2)
    ; Register-based parameter passing
    LD A, D
    ; Parameter a in A
    LD A, ($F014)     ; Virtual register 10 from memory
    LD E, A       ; Parameter b in E
    ; Found function, UsesTrueSMC=false
    CALL multiply_register
    ; store , r11
    LD ($F010), HL
    ; r13 = 1
    LD A, 1
    LD ($F01A), A     ; Virtual register 13 to memory
    ; r14 = 2
    LD A, 2
    LD ($F01C), A     ; Virtual register 14 to memory
    ; r15 = 3
    LD A, 3
    LD ($F01E), A     ; Virtual register 15 to memory
    ; r16 = 4
    LD A, 4
    EXX               ; Switch to shadow registers
    LD B', A         ; Store to shadow B'
    EXX               ; Switch back to main registers
    ; r17 = 5
    LD A, 5
    LD E, A         ; Store to physical register E
    ; r18 = call sum5_stack
    ; Call to sum5_stack (args: 5)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 4
    EXX               ; Switch to shadow registers
    PUSH HL       ; Argument 3
    LD HL, ($F01E)    ; Virtual register 15 from memory
    PUSH HL       ; Argument 2
    LD HL, ($F01C)    ; Virtual register 14 from memory
    PUSH HL       ; Argument 1
    LD HL, ($F01A)    ; Virtual register 13 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL sum5_stack
    ; store , r18
    LD ($F018), HL
    ; r19 = load smc_result
    LD HL, ($F002)
    LD ($F026), HL    ; Virtual register 19 to memory
    ; r20 = load tsmc_result
    LD HL, ($F00A)
    EXX               ; Switch to shadow registers
    ; r21 = r19 + r20
    LD HL, ($F026)    ; Virtual register 19 from memory
    LD D, H
    LD E, L
    EXX               ; Switch to shadow registers
    ADD HL, DE
    EXX               ; Switch to shadow registers
    ; r22 = load register_result
    LD HL, ($F010)
    ; r23 = r21 + r22
    EXX               ; Switch to shadow registers
    LD D, H
    LD E, L
    ADD HL, DE
    ; r24 = load stack_result
    LD HL, ($F018)
    ; r25 = r23 + r24
    LD D, H
    LD E, L
    ADD HL, DE
    ; return r25
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_abi_comprehensive.boundary_3params
test_abi_comprehensive.boundary_3params:
; Using absolute addressing for locals
    PUSH IX
    LD IX, SP
    ; Load parameters from registers
    ; Register 1 already in A
    LD A, E       ; Get parameter b
    ; Register 2 already in A
    LD A, D       ; Get parameter c
    LD ($F006), A     ; Virtual register 3 to memory
    ; unknown op 12
    ; Load parameter a
    ; unknown op 12
    ; Load parameter b
    ; r6 = r4 + r5
    LD D, H
    LD E, L
    ADD HL, DE
    ; unknown op 12
    ; Load parameter c
    ; r8 = r6 + r7
    LD D, H
    LD E, L
    ADD HL, DE
    ; return r8
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_abi_comprehensive.boundary_4params
test_abi_comprehensive.boundary_4params:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
test_abi_comprehensive.boundary_4params_param_a:
    LD HL, #0000   ; SMC parameter a (u8->u16)
    LD ($F00A), HL    ; Virtual register 5 to memory
test_abi_comprehensive.boundary_4params_param_b:
    LD HL, #0000   ; SMC parameter b (u8->u16)
    ; r7 = r5 + r6
    LD HL, ($F00A)    ; Virtual register 5 from memory
    LD D, H
    LD E, L
    ADD HL, DE
test_abi_comprehensive.boundary_4params_param_c:
    LD HL, #0000   ; SMC parameter c (u8->u16)
    LD ($F010), HL    ; Virtual register 8 to memory
    ; r9 = r7 + r8
    LD D, H
    LD E, L
    LD HL, ($F010)    ; Virtual register 8 from memory
    ADD HL, DE
test_abi_comprehensive.boundary_4params_param_d:
    LD HL, #0000   ; SMC parameter d (u8->u16)
    ; r11 = r9 + r10
    LD D, H
    LD E, L
    ADD HL, DE
    ; return r11
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_abi_comprehensive.recursive_3params
test_abi_comprehensive.recursive_3params:
; Using stack-based locals (IX+offset)
    PUSH IX
    LD IX, SP
    ; Load parameters from registers
    EXX               ; Switch to shadow registers
    LD E', A         ; Store to shadow E'
    EXX               ; Switch back to main registers
    LD A, E       ; Get parameter mult
    LD D, A         ; Store to physical register D
    LD A, D       ; Get parameter base
    LD ($F006), A     ; Virtual register 3 to memory
    ; unknown op 12
    ; Load parameter n
    ; r5 = 0
    LD A, 0
    EXX               ; Switch to shadow registers
    LD B', A         ; Store to shadow B'
    EXX               ; Switch back to main registers
    ; r6 = r4 == r5
    LD D, H
    LD E, L
    EXX               ; Switch to shadow registers
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP Z, .L15
    LD HL, 0
    JP .L16
.L15:
    LD HL, 1
.L16:
    EXX               ; Switch to shadow registers
    ; jump_if_not r6, else_7
    EXX               ; Switch to shadow registers
    LD A, B'         ; From shadow B'
    EXX               ; Switch back to main registers
    OR A
    JP Z, else_7
    ; unknown op 12
    ; Load parameter base
    ; return r7
    LD SP, IX
    POP IX
    RET
    ; jump end_if_8
    JP end_if_8
    ; else_7:
else_7:
    ; end_if_8:
end_if_8:
    ; unknown op 12
    ; Load parameter mult
    ; unknown op 12
    ; Load parameter n
    ; r10 = 1
    LD A, 1
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    ; r11 = r9 - r10
    EXX               ; Switch to shadow registers
    LD D, H
    LD E, L
    EXX               ; Switch to shadow registers
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    LD ($F016), HL    ; Virtual register 11 to memory
    ; unknown op 12
    ; Load parameter mult
    ; unknown op 12
    ; Load parameter base
    ; r14 = call recursive_3params
    ; Call to recursive_3params (args: 3)
    ; Register-based parameter passing
    LD A, ($F016)     ; Virtual register 11 from memory
    ; Parameter n in A
    LD A, E
    LD E, A       ; Parameter mult in E
    LD A, D
    LD D, A       ; Parameter base in D
    ; Found function, UsesTrueSMC=false
    CALL recursive_3params
    ; r15 = r8 + r14
    EXX               ; Switch to shadow registers
    LD D, H
    LD E, L
    ADD HL, DE
    ; return r15
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_abi_comprehensive.main
test_abi_comprehensive.main:
; Using stack-based locals (IX+offset)
    PUSH IX
    LD IX, SP
    LD HL, -23
    ADD HL, SP
    LD SP, HL
    ; Load parameters from registers
    ; r2 = 10
    LD A, 10
    LD ($F004), A     ; Virtual register 2 to memory
    ; r3 = 20
    LD A, 20
    LD ($F006), A     ; Virtual register 3 to memory
    ; r4 = call add_smc
    ; Call to add_smc (args: 2)
    ; Register-based parameter passing
    LD A, ($F004)     ; Virtual register 2 from memory
    ; Parameter a in A
    LD A, ($F006)     ; Virtual register 3 from memory
    LD E, A       ; Parameter b in E
    ; Found function, UsesTrueSMC=false
    CALL add_smc
    LD ($F008), HL    ; Virtual register 4 to memory
    ; store , r4
    LD HL, ($F008)    ; Virtual register 4 from memory
    LD (IX-1), L
    LD (IX+0), H
    ; r6 = 3
    LD A, 3
    LD ($F00C), A     ; Virtual register 6 to memory
    ; r7 = 4
    LD A, 4
    LD ($F00E), A     ; Virtual register 7 to memory
    ; r8 = 5
    LD A, 5
    ; Register 8 already in A
    ; r9 = call calculate_smc
    ; Call to calculate_smc (args: 3)
    ; Register-based parameter passing
    LD A, ($F00C)     ; Virtual register 6 from memory
    ; Parameter x in A
    LD A, ($F00E)     ; Virtual register 7 from memory
    LD E, A       ; Parameter y in E
    ; Register 8 already in A
    LD D, A       ; Parameter z in D
    ; Found function, UsesTrueSMC=false
    CALL calculate_smc
    LD ($F012), HL    ; Virtual register 9 to memory
    ; store , r9
    LD HL, ($F012)    ; Virtual register 9 from memory
    LD (IX-3), L
    LD (IX-2), H
    ; r11 = 5
    LD A, 5
    LD ($F016), A     ; Virtual register 11 to memory
    ; r12 = call factorial_tsmc
    ; Call to factorial_tsmc (args: 1)
    ; Register-based parameter passing
    LD A, ($F016)     ; Virtual register 11 from memory
    ; Parameter n in A
    ; Found function, UsesTrueSMC=false
    CALL factorial_tsmc
    LD ($F018), HL    ; Virtual register 12 to memory
    ; store , r12
    LD HL, ($F018)    ; Virtual register 12 from memory
    LD (IX-5), L
    LD (IX-4), H
    ; r14 = 6
    LD A, 6
    ; Register 14 already in A
    ; r15 = call fib_tsmc
    ; Call to fib_tsmc (args: 1)
    ; Register-based parameter passing
    ; Register 14 already in A
    ; Parameter n in A
    ; Found function, UsesTrueSMC=false
    CALL fib_tsmc
    LD ($F01E), HL    ; Virtual register 15 to memory
    ; store , r15
    LD HL, ($F01E)    ; Virtual register 15 from memory
    LD (IX-7), L
    LD (IX-6), H
    ; r17 = 8
    LD A, 8
    LD ($F022), A     ; Virtual register 17 to memory
    ; r18 = 9
    LD A, 9
    EXX               ; Switch to shadow registers
    LD C', A         ; Store to shadow C'
    EXX               ; Switch back to main registers
    ; r19 = call multiply_register
    ; Call to multiply_register (args: 2)
    ; Register-based parameter passing
    LD A, ($F022)     ; Virtual register 17 from memory
    ; Parameter a in A
    EXX               ; Switch to shadow registers
    LD A, C'         ; From shadow C'
    EXX               ; Switch back to main registers
    LD E, A       ; Parameter b in E
    ; Found function, UsesTrueSMC=false
    CALL multiply_register
    LD ($F026), HL    ; Virtual register 19 to memory
    ; store , r19
    LD HL, ($F026)    ; Virtual register 19 from memory
    LD (IX-9), L
    LD (IX-8), H
    ; r21 = 1
    LD A, 1
    LD ($F02A), A     ; Virtual register 21 to memory
    ; r22 = 2
    LD A, 2
    ; Register 22 already in A
    ; r23 = 3
    LD A, 3
    LD ($F02E), A     ; Virtual register 23 to memory
    ; r24 = call sum3_register
    ; Call to sum3_register (args: 3)
    ; Register-based parameter passing
    LD A, ($F02A)     ; Virtual register 21 from memory
    ; Parameter a in A
    ; Register 22 already in A
    LD E, A       ; Parameter b in E
    LD A, ($F02E)     ; Virtual register 23 from memory
    LD D, A       ; Parameter c in D
    ; Found function, UsesTrueSMC=false
    CALL sum3_register
    EXX               ; Switch to shadow registers
    ; store , r24
    EXX               ; Switch to shadow registers
    LD (IX-11), L
    LD (IX-10), H
    ; r26 = 1
    LD A, 1
    LD D, A         ; Store to physical register D
    ; r27 = 2
    LD A, 2
    LD ($F036), A     ; Virtual register 27 to memory
    ; r28 = 3
    LD A, 3
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    ; r29 = 4
    LD A, 4
    LD ($F03A), A     ; Virtual register 29 to memory
    ; r30 = 5
    LD A, 5
    LD E, A         ; Store to physical register E
    ; r31 = call sum5_stack
    ; Call to sum5_stack (args: 5)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 4
    LD HL, ($F03A)    ; Virtual register 29 from memory
    PUSH HL       ; Argument 3
    EXX               ; Switch to shadow registers
    PUSH HL       ; Argument 2
    LD HL, ($F036)    ; Virtual register 27 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL sum5_stack
    ; store , r31
    LD (IX-13), L
    LD (IX-12), H
    ; r33 = 5
    LD A, 5
    LD ($F042), A     ; Virtual register 33 to memory
    ; r34 = 1
    LD A, 1
    EXX               ; Switch to shadow registers
    LD B', A         ; Store to shadow B'
    EXX               ; Switch back to main registers
    ; r35 = 0
    LD A, 0
    LD ($F046), A     ; Virtual register 35 to memory
    ; r36 = 2
    LD A, 2
    LD B, A         ; Store to physical register B
    ; r37 = 10
    LD A, 10
    LD B, A         ; Store to physical register B
    ; r38 = call countdown_stack
    ; Call to countdown_stack (args: 5)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 4
    PUSH HL       ; Argument 3
    LD HL, ($F046)    ; Virtual register 35 from memory
    PUSH HL       ; Argument 2
    EXX               ; Switch to shadow registers
    PUSH HL       ; Argument 1
    LD HL, ($F042)    ; Virtual register 33 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL countdown_stack
    ; store , r38
    LD (IX-15), L
    LD (IX-14), H
    ; r40 = 1
    LD A, 1
    ; Register 40 already in A
    ; r41 = 2
    LD A, 2
    LD ($F052), A     ; Virtual register 41 to memory
    ; r42 = 3
    LD A, 3
    ; Register 42 already in A
    ; r43 = 4
    LD A, 4
    LD ($F056), A     ; Virtual register 43 to memory
    ; r44 = call complex_calculation
    ; Call to complex_calculation (args: 4)
    ; Stack-based parameter passing
    LD HL, ($F056)    ; Virtual register 43 from memory
    PUSH HL       ; Argument 3
    PUSH HL       ; Argument 2
    LD HL, ($F052)    ; Virtual register 41 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL complex_calculation
    ; store , r44
    LD (IX-17), L
    LD (IX-16), H
    ; r46 = call test_mixed_calls
    ; Call to test_mixed_calls (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL test_mixed_calls
    EXX               ; Switch to shadow registers
    ; store , r46
    EXX               ; Switch to shadow registers
    LD (IX-19), L
    LD (IX-18), H
    ; r48 = 1
    LD A, 1
    LD D, A         ; Store to physical register D
    ; r49 = 2
    LD A, 2
    LD ($F062), A     ; Virtual register 49 to memory
    ; r50 = 3
    LD A, 3
    ; Register 50 already in A
    ; r51 = call boundary_3params
    ; Call to boundary_3params (args: 3)
    ; Register-based parameter passing
    LD A, D
    ; Parameter a in A
    LD A, ($F062)     ; Virtual register 49 from memory
    LD E, A       ; Parameter b in E
    ; Register 50 already in A
    LD D, A       ; Parameter c in D
    ; Found function, UsesTrueSMC=false
    CALL boundary_3params
    LD ($F066), HL    ; Virtual register 51 to memory
    ; store , r51
    LD HL, ($F066)    ; Virtual register 51 from memory
    LD (IX-20), L
    LD (IX-19), H
    ; r53 = 1
    LD A, 1
    EXX               ; Switch to shadow registers
    LD B', A         ; Store to shadow B'
    EXX               ; Switch back to main registers
    ; r54 = 2
    LD A, 2
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    ; r55 = 3
    LD A, 3
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    ; r56 = 4
    LD A, 4
    ; Register 56 already in A
    ; r57 = call boundary_4params
    ; Call to boundary_4params (args: 4)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 3
    EXX               ; Switch to shadow registers
    PUSH HL       ; Argument 2
    EXX               ; Switch to shadow registers
    PUSH HL       ; Argument 1
    EXX               ; Switch to shadow registers
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL boundary_4params
    LD ($F072), HL    ; Virtual register 57 to memory
    ; store , r57
    LD HL, ($F072)    ; Virtual register 57 from memory
    LD (IX-21), L
    LD (IX-20), H
    ; r59 = 3
    LD A, 3
    EXX               ; Switch to shadow registers
    LD C', A         ; Store to shadow C'
    EXX               ; Switch back to main registers
    ; r60 = 5
    LD A, 5
    ; Register 60 already in A
    ; r61 = 10
    LD A, 10
    ; Register 61 already in A
    ; r62 = call recursive_3params
    ; Call to recursive_3params (args: 3)
    ; Register-based parameter passing
    EXX               ; Switch to shadow registers
    LD A, C'         ; From shadow C'
    EXX               ; Switch back to main registers
    ; Parameter n in A
    ; Register 60 already in A
    LD E, A       ; Parameter mult in E
    ; Register 61 already in A
    LD D, A       ; Parameter base in D
    ; Found function, UsesTrueSMC=false
    CALL recursive_3params
    ; store , r62
    LD (IX-23), L
    LD (IX-22), H
    ; return
    LD SP, IX
    POP IX
    RET

    END main
