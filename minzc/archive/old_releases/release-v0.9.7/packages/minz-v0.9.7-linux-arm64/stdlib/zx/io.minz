// ZX Spectrum I/O Implementation
// Implements the standard I/O interfaces for ZX Spectrum hardware

import std.io;

// ZX Spectrum ROM routines
const ROM_CLS: u16 = 0x0DAF;      // Clear screen
const ROM_PRINT: u16 = 0x0010;    // Print character in A
const ROM_KEY_SCAN: u16 = 0x028E; // Keyboard scanning
const ROM_KEY_TEST: u16 = 0x031E; // Test specific key
const ROM_BEEP: u16 = 0x03B5;     // Sound generation

// ZX Spectrum system variables
const LAST_K: u16 = 0x5C08;       // Last key pressed
const ATTR_P: u16 = 0x5C8D;       // Permanent colors
const ATTR_T: u16 = 0x5C8F;       // Temporary colors
const BORDCR: u16 = 0x5C48;       // Border color

// Channel addresses
const CHAN_K: u16 = 0x5C4B;       // Keyboard channel
const CHAN_S: u16 = 0x5C4F;       // Screen channel

// ZX Spectrum implementation of Reader
struct ZXStdin {
    // No state needed for keyboard input
}

impl Reader for ZXStdin {
    fun read_byte(self) -> u8 {
        // Wait for key press using ROM routine
        @asm {
            ; Wait for key press
        wait_key:
            RST 0x18          ; ROM call
            DB 0x15           ; Wait for key
            ; Key is now in A register
        }
    }
    
    fun read_bytes(self, buffer: *u8, len: u16) -> u16 {
        let mut count: u16 = 0;
        while count < len {
            buffer[count] = self.read_byte();
            count = count + 1;
        }
        count
    }
    
    fun available(self) -> bool {
        // Check if key is available without blocking
        let last_key: u8;
        @asm {
            LD HL, (LAST_K)
            LD A, (HL)
            LD (last_key), A
        }
        last_key != 0xFF
    }
}

// ZX Spectrum implementation of Writer
struct ZXStdout {
    // No state needed for screen output
}

impl Writer for ZXStdout {
    fun write_byte(self, byte: u8) -> void {
        // Use ROM print routine
        @asm {
            LD A, (byte)
            RST 0x10          ; ROM print character
        }
    }
    
    fun write_bytes(self, buffer: *u8, len: u16) -> u16 {
        let mut count: u16 = 0;
        while count < len {
            self.write_byte(buffer[count]);
            count = count + 1;
        }
        count
    }
    
    fun flush(self) -> void {
        // No buffering on ZX Spectrum
    }
}

// Global instances
pub let stdin = ZXStdin {};
pub let stdout = ZXStdout {};
pub let stderr = ZXStdout {};  // Same as stdout on ZX

// ZX Spectrum specific functions
pub fun cls() -> void {
    @asm {
        CALL ROM_CLS
    }
}

pub fun set_ink(color: u8) -> void {
    let attr = color & 0x07;  // Ink is bits 0-2
    @asm {
        LD HL, ATTR_T
        LD A, (HL)
        AND 0xF8          ; Clear ink bits
        OR (attr)         ; Set new ink
        LD (HL), A
    }
}

pub fun set_paper(color: u8) -> void {
    let attr = (color & 0x07) << 3;  // Paper is bits 3-5
    @asm {
        LD HL, ATTR_T
        LD A, (HL)
        AND 0xC7          ; Clear paper bits
        OR (attr)         ; Set new paper
        LD (HL), A
    }
}

pub fun set_border(color: u8) -> void {
    @asm {
        LD A, (color)
        AND 0x07          ; Only lower 3 bits
        OUT (254), A      ; Set border color
        ; Also update system variable
        LD (BORDCR), A
    }
}

pub fun set_flash(enable: bool) -> void {
    let bit = if enable { 0x80 } else { 0x00 };
    @asm {
        LD HL, ATTR_T
        LD A, (HL)
        AND 0x7F          ; Clear flash bit
        OR (bit)          ; Set new flash state
        LD (HL), A
    }
}

pub fun set_bright(enable: bool) -> void {
    let bit = if enable { 0x40 } else { 0x00 };
    @asm {
        LD HL, ATTR_T
        LD A, (HL)
        AND 0xBF          ; Clear bright bit
        OR (bit)          ; Set new bright state
        LD (HL), A
    }
}

pub fun at(x: u8, y: u8) -> void {
    // Position cursor at x,y
    @asm {
        LD A, 22          ; AT control code
        RST 0x10
        LD A, (y)         ; Y position
        RST 0x10
        LD A, (x)         ; X position
        RST 0x10
    }
}

pub fun beep(duration: u16, pitch: u16) -> void {
    // Generate sound using ROM routine
    @asm {
        LD HL, (duration)
        PUSH HL
        LD HL, (pitch)
        POP DE
        CALL ROM_BEEP
    }
}

// Key codes for common keys
pub const KEY_ENTER: u8 = 13;
pub const KEY_SPACE: u8 = 32;
pub const KEY_CAPS_SHIFT: u8 = 14;
pub const KEY_SYMBOL_SHIFT: u8 = 15;
pub const KEY_DELETE: u8 = 12;

// Check if specific key is pressed
pub fun key_pressed(key: u8) -> bool {
    let result: bool = false;
    @asm {
        LD A, (key)
        CALL ROM_KEY_TEST
        JR NC, not_pressed
        LD A, 1
        JR done
    not_pressed:
        XOR A
    done:
        LD (result), A
    }
    result
}

// Wait for any key
pub fun wait_key() -> u8 {
    stdin.read_byte()
}

// Get key without waiting (returns 0 if no key)
pub fun get_key() -> u8 {
    if stdin.available() {
        stdin.read_byte()
    } else {
        0
    }
}