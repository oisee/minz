// MinZ Standard Library - Core Module (With Function Overloading)
// Clean, intuitive API without generics

// ============================================
// Print Functions - One name, multiple types
// ============================================

fun print(value: u8) -> void {
    print_u8(value);  // Calls existing implementation
}

fun print(value: u16) -> void {
    print_u16(value);
}

fun print(value: i8) -> void {
    print_i8(value);
}

fun print(value: i16) -> void {
    print_i16(value);
}

fun print(s: *str) -> void {
    print_string(s);
}

fun print(c: bool) -> void {
    if c {
        print("true");
    } else {
        print("false");
    }
}

// Print with newline
fun println(value: u8) -> void {
    print(value);
    print("\n");
}

fun println(value: u16) -> void {
    print(value);
    print("\n");
}

fun println(s: *str) -> void {
    print(s);
    print("\n");
}

// ============================================
// Math Functions - Natural overloading
// ============================================

// Min functions
fun min(a: u8, b: u8) -> u8 {
    if a < b { return a; }
    return b;
}

fun min(a: u16, b: u16) -> u16 {
    if a < b { return a; }
    return b;
}

fun min(a: i8, b: i8) -> i8 {
    if a < b { return a; }
    return b;
}

fun min(a: i16, b: i16) -> i16 {
    if a < b { return a; }
    return b;
}

// Max functions
fun max(a: u8, b: u8) -> u8 {
    if a > b { return a; }
    return b;
}

fun max(a: u16, b: u16) -> u16 {
    if a > b { return a; }
    return b;
}

fun max(a: i8, b: i8) -> i8 {
    if a > b { return a; }
    return b;
}

fun max(a: i16, b: i16) -> i16 {
    if a > b { return a; }
    return b;
}

// Absolute value
fun abs(x: i8) -> u8 {
    if x < 0 { return (-x) as u8; }
    return x as u8;
}

fun abs(x: i16) -> u16 {
    if x < 0 { return (-x) as u16; }
    return x as u16;
}

// Clamp to range
fun clamp(value: u8, min: u8, max: u8) -> u8 {
    if value < min { return min; }
    if value > max { return max; }
    return value;
}

fun clamp(value: u16, min: u16, max: u16) -> u16 {
    if value < min { return min; }
    if value > max { return max; }
    return value;
}

fun clamp(value: i8, min: i8, max: i8) -> i8 {
    if value < min { return min; }
    if value > max { return max; }
    return value;
}

// ============================================
// Memory Operations - Type-safe copying
// ============================================

fun copy(dest: *u8, src: *u8, count: u16) -> void {
    @asm("
        ld hl, {src}
        ld de, {dest}
        ld bc, {count}
        ldir
    ");
}

fun copy(dest: *u16, src: *u16, count: u16) -> void {
    // Copy 16-bit values
    for i in 0..count {
        *(dest + i) = *(src + i);
    }
}

fun fill(dest: *u8, value: u8, count: u16) -> void {
    if count == 0 { return; }
    *dest = value;
    if count > 1 {
        copy(dest + 1, dest, count - 1);
    }
}

fun fill(dest: *u16, value: u16, count: u16) -> void {
    for i in 0..count {
        *(dest + i) = value;
    }
}

// ============================================
// Comparison Functions
// ============================================

fun compare(a: *u8, b: *u8, count: u16) -> i8 {
    for i in 0..count {
        let va = *(a + i);
        let vb = *(b + i);
        if va < vb { return -1; }
        if va > vb { return 1; }
    }
    return 0;
}

fun compare(a: u8, b: u8) -> i8 {
    if a < b { return -1; }
    if a > b { return 1; }
    return 0;
}

fun compare(a: u16, b: u16) -> i8 {
    if a < b { return -1; }
    if a > b { return 1; }
    return 0;
}

// ============================================
// Swap Functions
// ============================================

fun swap(a: *u8, b: *u8) -> void {
    let temp = *a;
    *a = *b;
    *b = temp;
}

fun swap(a: *u16, b: *u16) -> void {
    let temp = *a;
    *a = *b;
    *b = temp;
}

fun swap(a: *i8, b: *i8) -> void {
    let temp = *a;
    *a = *b;
    *b = temp;
}

// ============================================
// Array Operations
// ============================================

fun find(arr: *u8, len: u16, value: u8) -> u16 {
    for i in 0..len {
        if *(arr + i) == value {
            return i;
        }
    }
    return 0xFFFF;  // Not found
}

fun find(arr: *u16, len: u16, value: u16) -> u16 {
    for i in 0..len {
        if *(arr + i) == value {
            return i;
        }
    }
    return 0xFFFF;  // Not found
}

fun contains(arr: *u8, len: u16, value: u8) -> bool {
    return find(arr, len, value) != 0xFFFF;
}

fun contains(arr: *u16, len: u16, value: u16) -> bool {
    return find(arr, len, value) != 0xFFFF;
}

fun count(arr: *u8, len: u16, value: u8) -> u16 {
    let mut count: u16 = 0;
    for i in 0..len {
        if *(arr + i) == value {
            count = count + 1;
        }
    }
    return count;
}

fun count(arr: *u16, len: u16, value: u16) -> u16 {
    let mut count: u16 = 0;
    for i in 0..len {
        if *(arr + i) == value {
            count = count + 1;
        }
    }
    return count;
}

// ============================================
// Bit Operations
// ============================================

fun popcount(x: u8) -> u8 {
    let mut count: u8 = 0;
    let mut val = x;
    while val != 0 {
        count = count + (val & 1);
        val = val >> 1;
    }
    return count;
}

fun popcount(x: u16) -> u8 {
    return popcount((x & 0xFF) as u8) + popcount((x >> 8) as u8);
}

fun leading_zeros(x: u8) -> u8 {
    if x == 0 { return 8; }
    let mut count: u8 = 0;
    let mut mask: u8 = 0x80;
    while (x & mask) == 0 {
        count = count + 1;
        mask = mask >> 1;
    }
    return count;
}

fun leading_zeros(x: u16) -> u8 {
    let high = (x >> 8) as u8;
    if high != 0 {
        return leading_zeros(high);
    }
    return 8 + leading_zeros((x & 0xFF) as u8);
}

// ============================================
// String Operations (length-prefixed)
// ============================================

fun len(s: *str) -> u8 {
    return *s;  // First byte is length
}

fun compare(a: *str, b: *str) -> i8 {
    let len_a = len(a);
    let len_b = len(b);
    let min_len = min(len_a, len_b);
    
    let result = compare(a + 1, b + 1, min_len as u16);
    if result != 0 {
        return result;
    }
    
    // If prefixes equal, shorter string is less
    return compare(len_a, len_b);
}

fun copy(dest: *str, src: *str) -> void {
    let length = len(src);
    *dest = length;  // Copy length byte
    copy(dest + 1, src + 1, length as u16);
}

// ============================================
// Assert with different message types
// ============================================

fun assert(condition: bool) -> void {
    if !condition {
        print("ASSERTION FAILED\n");
        @halt();
    }
}

fun assert(condition: bool, msg: *str) -> void {
    if !condition {
        print("ASSERTION FAILED: ");
        print(msg);
        print("\n");
        @halt();
    }
}

fun assert(condition: bool, code: u8) -> void {
    if !condition {
        print("ASSERTION FAILED: Error code ");
        print(code);
        print("\n");
        @halt();
    }
}

// ============================================
// Debug helpers (only in debug builds)
// ============================================

@if(DEBUG) {
    fun debug_print(msg: *str) -> void {
        print("[DEBUG] ");
        println(msg);
    }
    
    fun debug_print(label: *str, value: u8) -> void {
        print("[DEBUG] ");
        print(label);
        print(": ");
        println(value);
    }
    
    fun debug_print(label: *str, value: u16) -> void {
        print("[DEBUG] ");
        print(label);
        print(": ");
        println(value);
    }
} else {
    // Empty functions in release
    fun debug_print(msg: *str) -> void {}
    fun debug_print(label: *str, value: u8) -> void {}
    fun debug_print(label: *str, value: u16) -> void {}
}