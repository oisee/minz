// MinZ Standard Error Handling
// Zero-cost error handling using Z80 carry flag

// Base error codes (0-15 reserved for core)
enum CoreError {
    None = 0,           // Success - never returned as error
    Generic = 1,        // Unknown error  
    OutOfMemory = 2,
    InvalidParam = 3,
    NotImplemented = 4,
    BufferOverflow = 5,
    DivideByZero = 6,
    StackOverflow = 7,
    Timeout = 8,
}

// Error handling macros
@macro ok(value) {
    // Clear carry flag and return value
    @asm {
        OR A            ; Clear carry flag
    }
    return value;
}

@macro err(code: u8) {
    // Set carry flag and return error code
    @asm {
        LD A, code
        SCF             ; Set carry flag
        RET
    }
}

@macro error(code) {
    // Syntactic sugar for @err
    @err(code)
}

// Check if a result contains an error
@inline fun is_error() -> bool {
    @asm {
        ; Check carry flag from last operation
        LD A, 0
        RET NC          ; Return 0 if no error
        INC A           ; Return 1 if error
    }
}

// Get last error code (only valid if is_error() returns true)
@inline fun get_error_code() -> u8 {
    @asm {
        ; A register already contains error code after error return
        RET
    }
}

// Propagate error with custom code transformation
@macro map_error(new_code: u8) {
    @asm {
        RET NC          ; No error, continue
        LD A, new_code  ; Replace error code
        SCF
        RET
    }
}

// Try to execute and handle specific errors
@macro try_catch(expr, handler) {
    let result = expr;
    @asm {
        JR NC, .end_try
        ; Error occurred, A contains code
    }
    handler
    @asm {
    .end_try:
    }
    result
}

// Ensure cleanup runs even on error
@macro defer(cleanup) {
    ; Note: This needs compiler support for proper implementation
    ; For now, manual cleanup after each ? is required
}

// Common error patterns
@inline fun unwrap<T>(value: T?) -> T {
    @asm {
        RET NC          ; Success - value in registers
        ; Error - panic or halt
        RST 0           ; System reset on unwrap error
    }
}

@inline fun unwrap_or<T>(value: T?, default: T) -> T {
    @asm {
        RET NC          ; Success - use value
        ; Error - use default
    }
    return default;
}

@inline fun expect<T>(value: T?, message: *u8) -> T {
    @asm {
        RET NC          ; Success
        ; Error - print message and halt
        PUSH HL
        LD HL, message
        CALL print_string
        RST 0           ; Reset
    }
}

// Result type for more complex error handling
struct Result<T, E> {
    is_ok: bool,
    value: T,       // Only valid if is_ok
    error: E,       // Only valid if !is_ok
}

// Convert error-returning function to Result
@inline fun to_result<T, E: u8>(value: T?) -> Result<T, E> {
    @asm {
        JR C, .is_error
        ; Success path
        LD (result.is_ok), 1
        ; value already in place
        RET
    .is_error:
        LD (result.is_ok), 0
        LD (result.error), A
        RET
    }
}

// Chain operations that might fail
@macro and_then(value, next_op) {
    @asm {
        RET C           ; Propagate error
    }
    next_op(value)
}

// Example error range allocation for modules
@const ERROR_RANGE_CORE = 0      // 0-15
@const ERROR_RANGE_FILE = 16     // 16-31  
@const ERROR_RANGE_NETWORK = 32  // 32-47
@const ERROR_RANGE_GRAPHICS = 48 // 48-63
@const ERROR_RANGE_SOUND = 64    // 64-79
@const ERROR_RANGE_INPUT = 80    // 80-95
@const ERROR_RANGE_USER = 96     // 96-127
// 128-255 reserved for application-specific errors

// Helper to check error range
@inline fun error_module(code: u8) -> u8 {
    return code >> 4;  // Upper 4 bits = module
}

@inline fun error_local(code: u8) -> u8 {
    return code & 0x0F; // Lower 4 bits = local code
}