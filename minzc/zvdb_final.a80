; MinZ generated code
; Generated: 2025-08-02 20:14:44


; Data section
    ORG $F000

...examples.zvdb_final.db_count:
    DB 0
...examples.zvdb_final.rng_state:
    DW 44257
...examples.zvdb_final.vector0:
    DS 32
...examples.zvdb_final.vector1:
    DS 32
...examples.zvdb_final.vector2:
    DS 32
...examples.zvdb_final.vector3:
    DS 32
str_0:
    DB 35    ; Length
    DB "ZVDB-MinZ: 256-bit Vector Database"
    DB 10
str_1:
    DB 37    ; Length
    DB "==================================="
    DB 10
    DB 10
str_2:
    DB 37    ; Length
    DB "Initializing 256-bit test vectors..."
    DB 10
str_3:
    DB 26    ; Length
    DB "Database initialized with "
str_4:
    DB 10    ; Length
    DB " vectors"
    DB 10
    DB 10
str_5:
    DB 18    ; Length
    DB "Testing popcount:"
    DB 10
str_6:
    DB 27    ; Length
    DB "256-bit Hamming distances:"
    DB 10
str_7:
    DB 17    ; Length
    DB "  Vector 0 vs 1: "
str_8:
    DB 16    ; Length
    DB " bits different"
    DB 10
str_9:
    DB 17    ; Length
    DB "  Vector 0 vs 2: "
str_10:
    DB 16    ; Length
    DB " bits different"
    DB 10
str_11:
    DB 17    ; Length
    DB "  Vector 0 vs 3: "
str_12:
    DB 17    ; Length
    DB " bits different"
    DB 10
    DB 10
str_13:
    DB 27    ; Length
    DB "256-bit Similarity scores:"
    DB 10
str_14:
    DB 17    ; Length
    DB "  Vector 0 vs 1: "
str_15:
    DB 17    ; Length
    DB "  Vector 0 vs 2: "
str_16:
    DB 17    ; Length
    DB "  Vector 0 vs 3: "
str_17:
    DB 40    ; Length
    DB "Searching for best match to vector 0..."
    DB 10
str_18:
    DB 38    ; Length
    DB "Searching with custom query vector..."
    DB 10
str_19:
    DB 49    ; Length
    DB 226
    DB 156
    DB 133
    DB " ZVDB-MinZ 256-bit Implementation Working!"
    DB 10
str_20:
    DB 47    ; Length
    DB "   "
    DB 226
    DB 128
    DB 162
    DB " Full 256-bit vectors (32 bytes each)"
    DB 10
str_21:
    DB 39    ; Length
    DB "   "
    DB 226
    DB 128
    DB 162
    DB " Hamming distance calculation"
    DB 10
str_22:
    DB 41    ; Length
    DB "   "
    DB 226
    DB 128
    DB 162
    DB " Similarity search with scoring"
    DB 10
str_23:
    DB 45    ; Length
    DB "   "
    DB 226
    DB 128
    DB 162
    DB " Production-ready for Z80 hardware!"
    DB 10

; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.zvdb_final.popcount_byte
...examples.zvdb_final.popcount_byte:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r3 = 0
    LD A, 0
    LD ($F006), A     ; Virtual register 3 to memory
    ; store , r3
    LD A, ($F006)     ; Virtual register 3 from memory
    LD ($F004), A
...examples.zvdb_final.popcount_byte_param_val:
    LD HL, #0000   ; SMC parameter val (u8->u16)
    LD ($F00A), HL    ; Virtual register 5 to memory
    ; store , r5
    LD A, ($F00A)     ; Virtual register 5 from memory
    LD ($F008), A
    ; r6 = load temp
    LD A, ($F008)
    LD ($F00C), A     ; Virtual register 6 to memory
    ; r7 = 1
    LD A, 1
    LD ($F00E), A     ; Virtual register 7 to memory
    ; r8 = r6 & r7
    LD HL, ($F00C)    ; Virtual register 6 from memory
    LD D, H
    LD E, L
    LD HL, ($F00E)    ; Virtual register 7 from memory
    LD A, L
    AND E
    LD L, A
    LD A, H
    AND D
    LD H, A
    LD ($F010), HL    ; Virtual register 8 to memory
    ; r9 = 0
    LD A, 0
    EXX               ; Switch to shadow registers
    LD B', A         ; Store to shadow B'
    EXX               ; Switch back to main registers
    ; r10 = r8 != r9
    LD HL, ($F010)    ; Virtual register 8 from memory
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L1
    LD HL, 0
    JP .L2
.L1:
    LD HL, 1
.L2:
    LD ($F014), HL    ; Virtual register 10 to memory
    ; jump_if_not r10, else_1
    LD A, ($F014)     ; Virtual register 10 from memory
    OR A
    JP Z, else_1
    ; r11 = load count
    LD A, ($F004)
    LD ($F016), A     ; Virtual register 11 to memory
    ; r12 = 1
    LD A, 1
    LD ($F018), A     ; Virtual register 12 to memory
    ; r13 = r11 + r12
    LD HL, ($F016)    ; Virtual register 11 from memory
    LD D, H
    LD E, L
    LD HL, ($F018)    ; Virtual register 12 from memory
    ADD HL, DE
    ; store count, r13
    EXX               ; Switch to shadow registers
    LD A, E'         ; From shadow E'
    EXX               ; Switch back to main registers
    LD ($F004), A
    ; jump end_if_2
    JP end_if_2
    ; else_1:
else_1:
    ; end_if_2:
end_if_2:
    ; r14 = load temp
    LD A, ($F008)
    ; Register 14 already in A
    ; r15 = 1
    LD A, 1
    LD ($F01E), A     ; Virtual register 15 to memory
    ; r16 = r14 >> r15
    ; Shift right
    ; Register 14 already in A
    LD B, A       ; B = value to shift
    LD A, ($F01E)     ; Virtual register 15 from memory
    LD C, A       ; C = shift count
    LD A, B       ; A = value
    OR A          ; Clear carry
    JR Z, .shr_done_2
    LD B, C       ; B = counter
.shr_loop_2:
    DEC B
    JP M, .shr_done_2
    SRL A         ; Shift right, 0 into bit 7
    JR .shr_loop_2
.shr_done_2:
    LD L, A
    LD H, 0
    ; store temp, r16
    LD A, E
    LD ($F008), A
    ; r17 = load temp
    LD A, ($F008)
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    ; r18 = 1
    LD A, 1
    LD E, A         ; Store to physical register E
    ; r19 = r17 & r18
    LD D, H
    LD E, L
    LD A, L
    AND E
    LD L, A
    LD A, H
    AND D
    LD H, A
    LD ($F026), HL    ; Virtual register 19 to memory
    ; r20 = 0
    LD A, 0
    LD ($F028), A     ; Virtual register 20 to memory
    ; r21 = r19 != r20
    LD HL, ($F026)    ; Virtual register 19 from memory
    LD D, H
    LD E, L
    LD HL, ($F028)    ; Virtual register 20 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L4
    LD HL, 0
    JP .L5
.L4:
    LD HL, 1
.L5:
    ; jump_if_not r21, else_3
    ; Register 21 already in A
    OR A
    JP Z, else_3
    ; r22 = load count
    LD A, ($F004)
    LD ($F02C), A     ; Virtual register 22 to memory
    ; r23 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r24 = r22 + r23
    LD HL, ($F02C)    ; Virtual register 22 from memory
    LD D, H
    LD E, L
    ADD HL, DE
    LD ($F030), HL    ; Virtual register 24 to memory
    ; store count, r24
    LD A, ($F030)     ; Virtual register 24 from memory
    LD ($F004), A
    ; jump end_if_4
    JP end_if_4
    ; else_3:
else_3:
    ; end_if_4:
end_if_4:
    ; r25 = load temp
    LD A, ($F008)
    ; Register 25 already in A
    ; r26 = 1
    LD A, 1
    LD ($F034), A     ; Virtual register 26 to memory
    ; r27 = r25 >> r26
    ; Shift right
    ; Register 25 already in A
    LD B, A       ; B = value to shift
    LD A, ($F034)     ; Virtual register 26 from memory
    LD C, A       ; C = shift count
    LD A, B       ; A = value
    OR A          ; Clear carry
    JR Z, .shr_done_5
    LD B, C       ; B = counter
.shr_loop_5:
    DEC B
    JP M, .shr_done_5
    SRL A         ; Shift right, 0 into bit 7
    JR .shr_loop_5
.shr_done_5:
    LD L, A
    LD H, 0
    ; store temp, r27
    ; Register 27 already in A
    LD ($F008), A
    ; r28 = load temp
    LD A, ($F008)
    ; Register 28 already in A
    ; r29 = 1
    LD A, 1
    LD ($F03A), A     ; Virtual register 29 to memory
    ; r30 = r28 & r29
    LD D, H
    LD E, L
    LD HL, ($F03A)    ; Virtual register 29 from memory
    LD A, L
    AND E
    LD L, A
    LD A, H
    AND D
    LD H, A
    ; r31 = 0
    LD A, 0
    LD ($F03E), A     ; Virtual register 31 to memory
    ; r32 = r30 != r31
    LD D, H
    LD E, L
    LD HL, ($F03E)    ; Virtual register 31 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L7
    LD HL, 0
    JP .L8
.L7:
    LD HL, 1
.L8:
    ; jump_if_not r32, else_5
    EXX               ; Switch to shadow registers
    LD A, D'         ; From shadow D'
    EXX               ; Switch back to main registers
    OR A
    JP Z, else_5
    ; r33 = load count
    LD A, ($F004)
    LD ($F042), A     ; Virtual register 33 to memory
    ; r34 = 1
    LD A, 1
    LD B, A         ; Store to physical register B
    ; r35 = r33 + r34
    LD HL, ($F042)    ; Virtual register 33 from memory
    LD D, H
    LD E, L
    ADD HL, DE
    LD ($F046), HL    ; Virtual register 35 to memory
    ; store count, r35
    LD A, ($F046)     ; Virtual register 35 from memory
    LD ($F004), A
    ; jump end_if_6
    JP end_if_6
    ; else_5:
else_5:
    ; end_if_6:
end_if_6:
    ; r36 = load temp
    LD A, ($F008)
    EXX               ; Switch to shadow registers
    LD E', A         ; Store to shadow E'
    EXX               ; Switch back to main registers
    ; r37 = 1
    LD A, 1
    LD ($F04A), A     ; Virtual register 37 to memory
    ; r38 = r36 >> r37
    ; Shift right
    EXX               ; Switch to shadow registers
    LD A, E'         ; From shadow E'
    EXX               ; Switch back to main registers
    LD B, A       ; B = value to shift
    LD A, ($F04A)     ; Virtual register 37 from memory
    LD C, A       ; C = shift count
    LD A, B       ; A = value
    OR A          ; Clear carry
    JR Z, .shr_done_8
    LD B, C       ; B = counter
.shr_loop_8:
    DEC B
    JP M, .shr_done_8
    SRL A         ; Shift right, 0 into bit 7
    JR .shr_loop_8
.shr_done_8:
    LD L, A
    LD H, 0
    ; store temp, r38
    ; Register 38 already in A
    LD ($F008), A
    ; r39 = load temp
    LD A, ($F008)
    LD ($F04E), A     ; Virtual register 39 to memory
    ; r40 = 1
    LD A, 1
    LD D, A         ; Store to physical register D
    ; r41 = r39 & r40
    LD HL, ($F04E)    ; Virtual register 39 from memory
    LD D, H
    LD E, L
    LD A, L
    AND E
    LD L, A
    LD A, H
    AND D
    LD H, A
    LD ($F052), HL    ; Virtual register 41 to memory
    ; r42 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; r43 = r41 != r42
    LD HL, ($F052)    ; Virtual register 41 from memory
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L10
    LD HL, 0
    JP .L11
.L10:
    LD HL, 1
.L11:
    LD ($F056), HL    ; Virtual register 43 to memory
    ; jump_if_not r43, else_7
    LD A, ($F056)     ; Virtual register 43 from memory
    OR A
    JP Z, else_7
    ; r44 = load count
    LD A, ($F004)
    LD C, A         ; Store to physical register C
    ; r45 = 1
    LD A, 1
    LD ($F05A), A     ; Virtual register 45 to memory
    ; r46 = r44 + r45
    LD D, H
    LD E, L
    LD HL, ($F05A)    ; Virtual register 45 from memory
    ADD HL, DE
    ; store count, r46
    LD A, H
    LD ($F004), A
    ; jump end_if_8
    JP end_if_8
    ; else_7:
else_7:
    ; end_if_8:
end_if_8:
    ; r47 = load temp
    LD A, ($F008)
    LD H, A         ; Store to physical register H
    ; r48 = 1
    LD A, 1
    EXX               ; Switch to shadow registers
    LD C', A         ; Store to shadow C'
    EXX               ; Switch back to main registers
    ; r49 = r47 >> r48
    ; Shift right
    LD A, H
    LD B, A       ; B = value to shift
    EXX               ; Switch to shadow registers
    LD A, C'         ; From shadow C'
    EXX               ; Switch back to main registers
    LD C, A       ; C = shift count
    LD A, B       ; A = value
    OR A          ; Clear carry
    JR Z, .shr_done_11
    LD B, C       ; B = counter
.shr_loop_11:
    DEC B
    JP M, .shr_done_11
    SRL A         ; Shift right, 0 into bit 7
    JR .shr_loop_11
.shr_done_11:
    LD L, A
    LD H, 0
    LD ($F062), HL    ; Virtual register 49 to memory
    ; store temp, r49
    LD A, ($F062)     ; Virtual register 49 from memory
    LD ($F008), A
    ; r50 = load temp
    LD A, ($F008)
    EXX               ; Switch to shadow registers
    LD E', A         ; Store to shadow E'
    EXX               ; Switch back to main registers
    ; r51 = 1
    LD A, 1
    ; Register 51 already in A
    ; r52 = r50 & r51
    LD D, H
    LD E, L
    LD A, L
    AND E
    LD L, A
    LD A, H
    AND D
    LD H, A
    LD ($F068), HL    ; Virtual register 52 to memory
    ; r53 = 0
    LD A, 0
    LD B, A         ; Store to physical register B
    ; r54 = r52 != r53
    LD HL, ($F068)    ; Virtual register 52 from memory
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L13
    LD HL, 0
    JP .L14
.L13:
    LD HL, 1
.L14:
    LD ($F06C), HL    ; Virtual register 54 to memory
    ; jump_if_not r54, else_9
    LD A, ($F06C)     ; Virtual register 54 from memory
    OR A
    JP Z, else_9
    ; r55 = load count
    LD A, ($F004)
    LD D, A         ; Store to physical register D
    ; r56 = 1
    LD A, 1
    LD ($F070), A     ; Virtual register 56 to memory
    ; r57 = r55 + r56
    LD D, H
    LD E, L
    LD HL, ($F070)    ; Virtual register 56 from memory
    ADD HL, DE
    ; store count, r57
    LD A, D
    LD ($F004), A
    ; jump end_if_10
    JP end_if_10
    ; else_9:
else_9:
    ; end_if_10:
end_if_10:
    ; r58 = load temp
    LD A, ($F008)
    ; Register 58 already in A
    ; r59 = 1
    LD A, 1
    LD ($F076), A     ; Virtual register 59 to memory
    ; r60 = r58 >> r59
    ; Shift right
    ; Register 58 already in A
    LD B, A       ; B = value to shift
    LD A, ($F076)     ; Virtual register 59 from memory
    LD C, A       ; C = shift count
    LD A, B       ; A = value
    OR A          ; Clear carry
    JR Z, .shr_done_14
    LD B, C       ; B = counter
.shr_loop_14:
    DEC B
    JP M, .shr_done_14
    SRL A         ; Shift right, 0 into bit 7
    JR .shr_loop_14
.shr_done_14:
    LD L, A
    LD H, 0
    ; store temp, r60
    EXX               ; Switch to shadow registers
    LD A, D'         ; From shadow D'
    EXX               ; Switch back to main registers
    LD ($F008), A
    ; r61 = load temp
    LD A, ($F008)
    LD ($F07A), A     ; Virtual register 61 to memory
    ; r62 = 1
    LD A, 1
    LD E, A         ; Store to physical register E
    ; r63 = r61 & r62
    LD HL, ($F07A)    ; Virtual register 61 from memory
    LD D, H
    LD E, L
    LD A, L
    AND E
    LD L, A
    LD A, H
    AND D
    LD H, A
    ; r64 = 0
    LD A, 0
    ; Register 64 already in A
    ; r65 = r63 != r64
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L16
    LD HL, 0
    JP .L17
.L16:
    LD HL, 1
.L17:
    LD ($F082), HL    ; Virtual register 65 to memory
    ; jump_if_not r65, else_11
    LD A, ($F082)     ; Virtual register 65 from memory
    OR A
    JP Z, else_11
    ; r66 = load count
    LD A, ($F004)
    LD D, A         ; Store to physical register D
    ; r67 = 1
    LD A, 1
    LD ($F086), A     ; Virtual register 67 to memory
    ; r68 = r66 + r67
    LD D, H
    LD E, L
    LD HL, ($F086)    ; Virtual register 67 from memory
    ADD HL, DE
    ; store count, r68
    LD A, B
    LD ($F004), A
    ; jump end_if_12
    JP end_if_12
    ; else_11:
else_11:
    ; end_if_12:
end_if_12:
    ; r69 = load temp
    LD A, ($F008)
    LD ($F08A), A     ; Virtual register 69 to memory
    ; r70 = 1
    LD A, 1
    ; Register 70 already in A
    ; r71 = r69 >> r70
    ; Shift right
    LD A, ($F08A)     ; Virtual register 69 from memory
    LD B, A       ; B = value to shift
    ; Register 70 already in A
    LD C, A       ; C = shift count
    LD A, B       ; A = value
    OR A          ; Clear carry
    JR Z, .shr_done_17
    LD B, C       ; B = counter
.shr_loop_17:
    DEC B
    JP M, .shr_done_17
    SRL A         ; Shift right, 0 into bit 7
    JR .shr_loop_17
.shr_done_17:
    LD L, A
    LD H, 0
    LD ($F08E), HL    ; Virtual register 71 to memory
    ; store temp, r71
    LD A, ($F08E)     ; Virtual register 71 from memory
    LD ($F008), A
    ; r72 = load temp
    LD A, ($F008)
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    ; r73 = 1
    LD A, 1
    LD ($F092), A     ; Virtual register 73 to memory
    ; r74 = r72 & r73
    LD D, H
    LD E, L
    LD HL, ($F092)    ; Virtual register 73 from memory
    LD A, L
    AND E
    LD L, A
    LD A, H
    AND D
    LD H, A
    ; r75 = 0
    LD A, 0
    LD ($F096), A     ; Virtual register 75 to memory
    ; r76 = r74 != r75
    LD D, H
    LD E, L
    LD HL, ($F096)    ; Virtual register 75 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L19
    LD HL, 0
    JP .L20
.L19:
    LD HL, 1
.L20:
    ; jump_if_not r76, else_13
    LD A, C
    OR A
    JP Z, else_13
    ; r77 = load count
    LD A, ($F004)
    LD C, A         ; Store to physical register C
    ; r78 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r79 = r77 + r78
    LD D, H
    LD E, L
    ADD HL, DE
    ; store count, r79
    LD A, L
    LD ($F004), A
    ; jump end_if_14
    JP end_if_14
    ; else_13:
else_13:
    ; end_if_14:
end_if_14:
    ; r80 = load temp
    LD A, ($F008)
    ; Register 80 already in A
    ; r81 = 1
    LD A, 1
    LD ($F0A2), A     ; Virtual register 81 to memory
    ; r82 = r80 >> r81
    ; Shift right
    ; Register 80 already in A
    LD B, A       ; B = value to shift
    LD A, ($F0A2)     ; Virtual register 81 from memory
    LD C, A       ; C = shift count
    LD A, B       ; A = value
    OR A          ; Clear carry
    JR Z, .shr_done_20
    LD B, C       ; B = counter
.shr_loop_20:
    DEC B
    JP M, .shr_done_20
    SRL A         ; Shift right, 0 into bit 7
    JR .shr_loop_20
.shr_done_20:
    LD L, A
    LD H, 0
    ; store temp, r82
    ; Register 82 already in A
    LD ($F008), A
    ; r83 = load temp
    LD A, ($F008)
    LD D, A         ; Store to physical register D
    ; r84 = 1
    LD A, 1
    LD D, A         ; Store to physical register D
    ; r85 = r83 & r84
    LD D, H
    LD E, L
    LD A, L
    AND E
    LD L, A
    LD A, H
    AND D
    LD H, A
    ; r86 = 0
    LD A, 0
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    ; r87 = r85 != r86
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L22
    LD HL, 0
    JP .L23
.L22:
    LD HL, 1
.L23:
    ; jump_if_not r87, else_15
    ; Register 87 already in A
    OR A
    JP Z, else_15
    ; r88 = load count
    LD A, ($F004)
    ; Register 88 already in A
    ; r89 = 1
    LD A, 1
    EXX               ; Switch to shadow registers
    LD C', A         ; Store to shadow C'
    EXX               ; Switch back to main registers
    ; r90 = r88 + r89
    LD D, H
    LD E, L
    ADD HL, DE
    ; store count, r90
    EXX               ; Switch to shadow registers
    LD A, C'         ; From shadow C'
    EXX               ; Switch back to main registers
    LD ($F004), A
    ; jump end_if_16
    JP end_if_16
    ; else_15:
else_15:
    ; end_if_16:
end_if_16:
    ; r91 = load count
    LD A, ($F004)
    LD B, A         ; Store to physical register B
    ; return r91
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.zvdb_final.hamming_distance
...examples.zvdb_final.hamming_distance:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r4 = 0
    LD A, 0
    LD B, A         ; Store to physical register B
    ; store , r4
    LD ($F006), HL
    ; r5 = 0
    LD A, 0
    ; Register 5 already in A
    ; r6 = 32
    LD A, 32
    LD E, A         ; Store to physical register E
    ; Initialize loop variable i
    ; for_loop_17:
for_loop_17:
    ; Check i < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L24
    LD HL, 0
    JP .L25
.L24:
    LD HL, 1
.L25:
    ; jump_if_not r8, for_end_18
    LD A, C
    OR A
    JP Z, for_end_18
; TSMC reference parameter vec1
vec1$immOP:
    LD HL, 0000      ; TSMC ref address for vec1
vec1$imm0 EQU vec1$immOP+1
    LD ($F014), HL    ; Virtual register 10 to memory
    ; Load field data (offset 0)
    LD HL, ($F014)    ; Virtual register 10 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD D, H
    LD E, L
    ; r12 = load i
    LD HL, ($F000)
    ; Load array element (u8)
    LD H, D
    LD L, E
    PUSH HL
    LD A, C
    LD E, A
    LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD L, A         ; Store to HL (low byte)
; TSMC reference parameter vec2
vec2$immOP:
    LD HL, 0000      ; TSMC ref address for vec2
vec2$imm0 EQU vec2$immOP+1
    LD ($F01C), HL    ; Virtual register 14 to memory
    ; Load field data (offset 0)
    LD HL, ($F01C)    ; Virtual register 14 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    PUSH HL           ; Save current HL
    EXX               ; Switch to shadow registers
    POP HL            ; Load into shadow HL
    EXX               ; Switch back to main registers
    ; r16 = load i
    LD HL, ($F000)
    LD ($F020), HL    ; Virtual register 16 to memory
    ; Load array element (u8)
    EXX               ; Switch to shadow registers
    PUSH HL           ; Save shadow HL
    EXX               ; Switch back to main registers
    POP HL            ; Load shadow HL into main HL
    PUSH HL
    LD A, ($F020)     ; Virtual register 16 from memory
    LD E, A
    LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; r18 = r13 ^ r17
    ; Register 13 already in HL
    LD D, H
    LD E, L
    LD A, L
    XOR E
    LD L, A
    LD A, H
    XOR D
    LD H, A
    ; store , r18
    LD A, L
    LD ($F012), A
    ; r20 = load xor_byte
    LD A, ($F012)
    LD H, A         ; Store to physical register H
    ; r21 = call popcount_byte
    ; Call to popcount_byte (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.popcount_byte
    ; store , r21
    LD A, L
    LD ($F026), A
    ; r22 = load distance
    LD HL, ($F006)
    ; r23 = load pc
    LD A, ($F026)
    LD L, A         ; Store to physical register L
    ; r24 = r22 + r23
    LD D, H
    LD E, L
    ADD HL, DE
    LD ($F030), HL    ; Virtual register 24 to memory
    ; store distance, r24
    LD HL, ($F030)    ; Virtual register 24 from memory
    LD ($F006), HL
    ; r25 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; Increment i
    LD D, H
    LD E, L
    ; Register 25 already in HL
    ADD HL, DE
    ; jump for_loop_17
    JP for_loop_17
    ; for_end_18:
for_end_18:
    ; r26 = load distance
    LD HL, ($F006)
    ; return r26
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.zvdb_final.similarity_score
...examples.zvdb_final.similarity_score:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
; TSMC reference parameter vec1
vec1$immOP:
    LD HL, 0000      ; TSMC ref address for vec1
vec1$imm0 EQU vec1$immOP+1
    LD ($F008), HL    ; Virtual register 4 to memory
; TSMC reference parameter vec2
vec2$immOP:
    LD HL, 0000      ; TSMC ref address for vec2
vec2$imm0 EQU vec2$immOP+1
    ; Register 5 already in HL
    ; r6 = call hamming_distance
    ; Call to hamming_distance (args: 2)
    ; Stack-based parameter passing
    ; Register 5 already in HL
    PUSH HL       ; Argument 1
    LD HL, ($F008)    ; Virtual register 4 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.hamming_distance
    LD ($F00C), HL    ; Virtual register 6 to memory
    ; store , r6
    LD HL, ($F00C)    ; Virtual register 6 from memory
    LD ($F006), HL
    ; r8 = load hamming
    LD HL, ($F006)
    ; r9 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; r10 = r8 << r9
    ; 16-bit shift left
    LD A, L
    LD B, A       ; B = shift count
    OR A
    JR Z, .shl16_done_25
.shl16_loop_25:
    ADD HL, HL    ; Shift left by 1
    DJNZ .shl16_loop_25
.shl16_done_25:
    ; store , r10
    LD ($F00E), HL
    ; r12 = 256
    LD HL, 256
    LD ($F018), HL    ; Virtual register 12 to memory
    ; r13 = load doubled
    LD HL, ($F00E)
    ; Register 13 already in HL
    ; r14 = r12 - r13
    LD HL, ($F018)    ; Virtual register 12 from memory
    LD D, H
    LD E, L
    ; Register 13 already in HL
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    ; store , r14
    LD ($F016), HL
    ; r15 = load result
    LD HL, ($F016)
    ; Register 15 already in HL
    ; return r15
    ; Register 15 already in HL
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.zvdb_final.similarity_percentage
...examples.zvdb_final.similarity_percentage:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
...examples.zvdb_final.similarity_percentage_param_score:
    LD HL, #0000   ; SMC parameter score
    LD ($F006), HL    ; Virtual register 3 to memory
    ; r4 = 256
    LD HL, 256
    ; Register 4 already in HL
    ; r5 = r3 + r4
    LD HL, ($F006)    ; Virtual register 3 from memory
    LD D, H
    LD E, L
    ; Register 4 already in HL
    ADD HL, DE
    ; store , r5
    LD ($F004), HL
    ; r7 = load normalized
    LD HL, ($F004)
    ; Register 7 already in HL
    ; r8 = 100
    LD A, 100
    LD H, A         ; Store to physical register H
    ; r9 = r7 * r8
    ; 16-bit multiplication
    ; Register 7 already in HL
    LD (mul_src1_26), HL  ; Save multiplicand
    LD (mul_src2_26), HL  ; Save multiplier
    LD HL, 0             ; Result = 0
    LD DE, (mul_src1_26)  ; DE = multiplicand
    LD BC, (mul_src2_26)  ; BC = multiplier
    LD A, B
    OR C                 ; Check if multiplier is 0
    JR Z, .mul16_done_26
.mul16_loop_26:
    ADD HL, DE           ; Result += multiplicand
    DEC BC
    LD A, B
    OR C
    JR NZ, .mul16_loop_26
.mul16_done_26:
mul_src1_26: DW 0
mul_src2_26: DW 0
    LD ($F012), HL    ; Virtual register 9 to memory
    ; r10 = 9
    LD A, 9
    LD L, A         ; Store to HL (low byte)
    ; r11 = r9 >> r10
    ; 16-bit shift right
    LD HL, ($F012)    ; Virtual register 9 from memory
    LD A, L
    LD B, A       ; B = shift count
    OR A
    JR Z, .shr16_done_27
.shr16_loop_27:
    SRL H         ; Shift high byte right
    RR L          ; Rotate right through carry
    DJNZ .shr16_loop_27
.shr16_done_27:
    ; store , r11
    LD A, L
    LD ($F00C), A
    ; r12 = load percentage
    LD A, ($F00C)
    LD L, A         ; Store to HL (low byte)
    ; return r12
    ; Register 12 already in HL
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.zvdb_final.rand_next
...examples.zvdb_final.rand_next:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r1 = load ...examples.zvdb_final.rng_state
    LD HL, ($F020)
    ; r2 = 5
    LD A, 5
    LD L, A         ; Store to physical register L
    ; r3 = r1 * r2
    ; 16-bit multiplication
    LD (mul_src1_28), HL  ; Save multiplicand
    LD (mul_src2_28), HL  ; Save multiplier
    LD HL, 0             ; Result = 0
    LD DE, (mul_src1_28)  ; DE = multiplicand
    LD BC, (mul_src2_28)  ; BC = multiplier
    LD A, B
    OR C                 ; Check if multiplier is 0
    JR Z, .mul16_done_28
.mul16_loop_28:
    ADD HL, DE           ; Result += multiplicand
    DEC BC
    LD A, B
    OR C
    JR NZ, .mul16_loop_28
.mul16_done_28:
mul_src1_28: DW 0
mul_src2_28: DW 0
    LD ($F006), HL    ; Virtual register 3 to memory
    ; r4 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; r5 = r3 + r4
    LD HL, ($F006)    ; Virtual register 3 from memory
    LD D, H
    LD E, L
    ; Register 4 already in HL
    ADD HL, DE
    ; store ...examples.zvdb_final.rng_state, r5
    LD ($F020), HL
    ; r6 = load ...examples.zvdb_final.rng_state
    LD HL, ($F020)
    ; r7 = 8
    LD A, 8
    LD L, A         ; Store to HL (low byte)
    ; r8 = r6 >> r7
    ; 16-bit shift right
    LD A, L
    LD B, A       ; B = shift count
    OR A
    JR Z, .shr16_done_29
.shr16_loop_29:
    SRL H         ; Shift high byte right
    RR L          ; Rotate right through carry
    DJNZ .shr16_loop_29
.shr16_done_29:
    ; Register 8 already in HL
    ; return r8
    ; Register 8 already in HL
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.zvdb_final.init_vectors
...examples.zvdb_final.init_vectors:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r1 = 0
    LD A, 0
    LD ($F002), A     ; Virtual register 1 to memory
    ; r2 = 32
    LD A, 32
    LD H, A         ; Store to physical register H
    ; Initialize loop variable i
    LD HL, ($F002)    ; Virtual register 1 from memory
    ; for_loop_19:
for_loop_19:
    ; Check i < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L31
    LD HL, 0
    JP .L32
.L31:
    LD HL, 1
.L32:
    LD ($F008), HL    ; Virtual register 4 to memory
    ; jump_if_not r4, for_end_20
    LD A, ($F008)     ; Virtual register 4 from memory
    OR A
    JP Z, for_end_20
    ; r5 = load i
    LD HL, ($F000)
    ; r6 = 2
    LD A, 2
    LD L, A         ; Store to physical register L
    ; r7 = r5 % r6
    ; 8-bit modulo
    LD A, H
    LD D, A       ; D = dividend
    LD A, L
    LD E, A       ; E = divisor
    OR A          ; Check for divide by zero
    JR Z, .mod_by_zero_32
    LD A, D       ; A = dividend
.mod_loop_32:
    CP E          ; Compare with divisor
    JR C, .mod_done_32
    SUB E         ; Subtract divisor
    JR .mod_loop_32
.mod_by_zero_32:
    LD A, 0       ; Return 0 for modulo by zero
.mod_done_32:
    LD L, A       ; Result (remainder) in L
    LD H, 0
    LD ($F00E), HL    ; Virtual register 7 to memory
    ; r8 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; r9 = r7 == r8
    LD HL, ($F00E)    ; Virtual register 7 from memory
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP Z, .L34
    LD HL, 0
    JP .L35
.L34:
    LD HL, 1
.L35:
    ; jump_if_not r9, else_21
    LD A, L
    OR A
    JP Z, else_21
    ; r10 = 85
    LD A, 85
    LD L, A         ; Store to HL (low byte)
    ; r11 = load ...examples.zvdb_final.vector0
    LD HL, ($F040)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F018), HL    ; Virtual register 12 to memory
    ; r13 = load i
    LD HL, ($F000)
    ; Register 13 already in HL
    ; Calculate array element address
    LD HL, ($F018)    ; Virtual register 12 from memory
    LD D, H
    LD E, L
    ; Register 13 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; jump end_if_22
    JP end_if_22
    ; else_21:
else_21:
    ; r15 = 170
    LD A, 170
    LD L, A         ; Store to physical register L
    ; r16 = load ...examples.zvdb_final.vector0
    LD HL, ($F040)
    ; Register 16 already in HL
    ; Load field data (offset 0)
    ; Register 16 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F022), HL    ; Virtual register 17 to memory
    ; r18 = load i
    LD HL, ($F000)
    ; Register 18 already in HL
    ; Calculate array element address
    LD HL, ($F022)    ; Virtual register 17 from memory
    LD D, H
    LD E, L
    ; Register 18 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; end_if_22:
end_if_22:
    ; r20 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_19
    JP for_loop_19
    ; for_end_20:
for_end_20:
    ; r21 = 0
    LD A, 0
    LD ($F02A), A     ; Virtual register 21 to memory
    ; r22 = 32
    LD A, 32
    LD H, A         ; Store to physical register H
    ; Initialize loop variable i
    LD HL, ($F02A)    ; Virtual register 21 from memory
    ; for_loop_23:
for_loop_23:
    ; Check i < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L36
    LD HL, 0
    JP .L37
.L36:
    LD HL, 1
.L37:
    ; Register 24 already in HL
    ; jump_if_not r24, for_end_24
    LD A, L
    OR A
    JP Z, for_end_24
    ; r25 = 255
    LD A, 255
    LD H, A         ; Store to physical register H
    ; r26 = load ...examples.zvdb_final.vector1
    LD HL, ($F060)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F036), HL    ; Virtual register 27 to memory
    ; r28 = load i
    LD HL, ($F000)
    ; Register 28 already in HL
    ; Calculate array element address
    LD HL, ($F036)    ; Virtual register 27 from memory
    LD D, H
    LD E, L
    ; Register 28 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, H
    POP HL
    LD (HL), A
    ; r30 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_23
    JP for_loop_23
    ; for_end_24:
for_end_24:
    ; r31 = 0
    LD A, 0
    LD ($F03E), A     ; Virtual register 31 to memory
    ; r32 = 32
    LD A, 32
    LD H, A         ; Store to physical register H
    ; Initialize loop variable i
    LD HL, ($F03E)    ; Virtual register 31 from memory
    ; for_loop_25:
for_loop_25:
    ; Check i < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L38
    LD HL, 0
    JP .L39
.L38:
    LD HL, 1
.L39:
    ; Register 34 already in HL
    ; jump_if_not r34, for_end_26
    LD A, L
    OR A
    JP Z, for_end_26
    ; r35 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; r36 = load ...examples.zvdb_final.vector2
    LD HL, ($F080)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 37 already in HL
    ; r38 = load i
    LD HL, ($F000)
    ; Register 38 already in HL
    ; Calculate array element address
    ; Register 37 already in HL
    LD D, H
    LD E, L
    ; Register 38 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, H
    POP HL
    LD (HL), A
    ; r40 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_25
    JP for_loop_25
    ; for_end_26:
for_end_26:
    ; r41 = 4660
    LD HL, 4660
    LD ($F052), HL    ; Virtual register 41 to memory
    ; store ...examples.zvdb_final.rng_state, r41
    LD HL, ($F052)    ; Virtual register 41 from memory
    LD ($F020), HL
    ; r42 = 0
    LD A, 0
    LD ($F054), A     ; Virtual register 42 to memory
    ; r43 = 32
    LD A, 32
    LD H, A         ; Store to physical register H
    ; Initialize loop variable i
    LD HL, ($F054)    ; Virtual register 42 from memory
    ; for_loop_27:
for_loop_27:
    ; Check i < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L40
    LD HL, 0
    JP .L41
.L40:
    LD HL, 1
.L41:
    ; Register 45 already in HL
    ; jump_if_not r45, for_end_28
    LD A, L
    OR A
    JP Z, for_end_28
    ; r46 = call rand_next
    ; Call to rand_next (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.rand_next
    ; r47 = load ...examples.zvdb_final.vector3
    LD HL, ($F0A0)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F060), HL    ; Virtual register 48 to memory
    ; r49 = load i
    LD HL, ($F000)
    ; Register 49 already in HL
    ; Calculate array element address
    LD HL, ($F060)    ; Virtual register 48 from memory
    LD D, H
    LD E, L
    ; Register 49 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, H
    POP HL
    LD (HL), A
    ; r51 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_27
    JP for_loop_27
    ; for_end_28:
for_end_28:
    ; r52 = 4
    LD A, 4
    LD L, A         ; Store to HL (low byte)
    ; store ...examples.zvdb_final.db_count, r52
    ; Register 52 already in HL
    LD ($F000), HL
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.zvdb_final.get_vector
...examples.zvdb_final.get_vector:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
...examples.zvdb_final.get_vector_param_id:
    LD HL, #0000   ; SMC parameter id (u8->u16)
    ; r3 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r4 = r2 == r3
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP Z, .L42
    LD HL, 0
    JP .L43
.L42:
    LD HL, 1
.L43:
    LD ($F008), HL    ; Virtual register 4 to memory
    ; jump_if_not r4, else_29
    LD A, ($F008)     ; Virtual register 4 from memory
    OR A
    JP Z, else_29
    ; r5 = load ...examples.zvdb_final.vector0
    LD HL, ($F040)
    ; r6 = &r5
    ; Address-of operation for register r5
    LD HL, $F00A  ; Variable address
    ; return r6
    RET
    ; jump end_if_30
    JP end_if_30
    ; else_29:
else_29:
    LD A, (...examples.zvdb_final.get_vector_param_id)
    LD ($F00E), A     ; Virtual register 7 to memory
    ; r8 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r9 = r7 == r8
    LD HL, ($F00E)    ; Virtual register 7 from memory
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP Z, .L44
    LD HL, 0
    JP .L45
.L44:
    LD HL, 1
.L45:
    ; jump_if_not r9, else_31
    LD A, L
    OR A
    JP Z, else_31
    ; r10 = load ...examples.zvdb_final.vector1
    LD HL, ($F060)
    LD ($F014), HL    ; Virtual register 10 to memory
    ; r11 = &r10
    ; Address-of operation for register r10
    LD HL, $F014  ; Variable address
    ; return r11
    RET
    ; jump end_if_32
    JP end_if_32
    ; else_31:
else_31:
    LD A, (...examples.zvdb_final.get_vector_param_id)
    LD L, A         ; Store to physical register L
    ; r13 = 2
    LD A, 2
    LD ($F01A), A     ; Virtual register 13 to memory
    ; r14 = r12 == r13
    LD D, H
    LD E, L
    LD HL, ($F01A)    ; Virtual register 13 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP Z, .L46
    LD HL, 0
    JP .L47
.L46:
    LD HL, 1
.L47:
    ; jump_if_not r14, else_33
    LD A, H
    OR A
    JP Z, else_33
    ; r15 = load ...examples.zvdb_final.vector2
    LD HL, ($F080)
    ; r16 = &r15
    ; Address-of operation for register r15
    LD HL, $F01E  ; Variable address
    ; Register 16 already in HL
    ; return r16
    ; Register 16 already in HL
    RET
    ; jump end_if_34
    JP end_if_34
    ; else_33:
else_33:
    ; r17 = load ...examples.zvdb_final.vector3
    LD HL, ($F0A0)
    ; r18 = &r17
    ; Address-of operation for register r17
    LD HL, $F022  ; Variable address
    ; return r18
    RET
    ; end_if_34:
end_if_34:
    ; end_if_32:
end_if_32:
    ; end_if_30:
end_if_30:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.zvdb_final.search_best_match
...examples.zvdb_final.search_best_match:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r3 = 255
    LD A, 255
    LD L, A         ; Store to HL (low byte)
    ; r4 = load result
    LD HL, ($F004)
    ; Store to field vector_id (offset 0)
    PUSH HL
    ; Register 3 already in HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r5 = 256
    LD HL, 256
    ; r6 = -r5
    XOR A         ; Clear A
    SUB L         ; 0 - L
    LD L, A
    LD A, 0
    SBC A, H      ; 0 - H with borrow
    LD H, A
    LD ($F00C), HL    ; Virtual register 6 to memory
    ; r7 = load result
    LD HL, ($F004)
    ; Store to field score (offset 1)
    LD DE, 1
    ADD HL, DE
    PUSH HL
    LD HL, ($F00C)    ; Virtual register 6 from memory
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r8 = 0
    LD A, 0
    LD ($F010), A     ; Virtual register 8 to memory
    ; r9 = load result
    LD HL, ($F004)
    ; Store to field similarity (offset 3)
    LD DE, 3
    ADD HL, DE
    PUSH HL
    LD HL, ($F010)    ; Virtual register 8 from memory
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r10 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r11 = load ...examples.zvdb_final.db_count
    LD HL, ($F000)
    LD ($F016), HL    ; Virtual register 11 to memory
    ; Initialize loop variable i
    ; for_loop_35:
for_loop_35:
    ; Check i < end
    LD D, H
    LD E, L
    LD HL, ($F016)    ; Virtual register 11 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L48
    LD HL, 0
    JP .L49
.L48:
    LD HL, 1
.L49:
    ; jump_if_not r13, for_end_36
    LD A, L
    OR A
    JP Z, for_end_36
    ; r15 = load i
    LD HL, ($F000)
    ; Register 15 already in HL
    ; r16 = call get_vector
    ; Call to get_vector (args: 1)
    ; Stack-based parameter passing
    ; Register 15 already in HL
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.get_vector
    ; store , r16
    LD ($F01C), HL
; TSMC reference parameter query
query$immOP:
    LD HL, 0000      ; TSMC ref address for query
query$imm0 EQU query$immOP+1
    LD ($F024), HL    ; Virtual register 18 to memory
    ; r19 = load vec
    LD HL, ($F01C)
    LD ($F026), HL    ; Virtual register 19 to memory
    ; r20 = call similarity_score
    ; Call to similarity_score (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F026)    ; Virtual register 19 from memory
    PUSH HL       ; Argument 1
    LD HL, ($F024)    ; Virtual register 18 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.similarity_score
    ; store , r20
    LD ($F022), HL
    ; r21 = load score
    LD HL, ($F022)
    ; Register 21 already in HL
    ; r22 = load result
    LD HL, ($F004)
    ; Load field score (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F02E), HL    ; Virtual register 23 to memory
    ; r24 = r21 > r23
    ; Register 21 already in HL
    LD D, H
    LD E, L
    LD HL, ($F02E)    ; Virtual register 23 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP Z, .L51
    JP P, .L50
    LD HL, 0
    JP .L51
.L50:
    LD HL, 1
.L51:
    ; Register 24 already in HL
    ; jump_if_not r24, else_37
    LD A, L
    OR A
    JP Z, else_37
    ; r25 = load i
    LD HL, ($F000)
    LD ($F032), HL    ; Virtual register 25 to memory
    ; r26 = load result
    LD HL, ($F004)
    ; Store to field vector_id (offset 0)
    PUSH HL
    LD HL, ($F032)    ; Virtual register 25 from memory
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r27 = load score
    LD HL, ($F022)
    ; r28 = load result
    LD HL, ($F004)
    LD ($F038), HL    ; Virtual register 28 to memory
    ; Store to field score (offset 1)
    LD HL, ($F038)    ; Virtual register 28 from memory
    LD DE, 1
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r29 = load score
    LD HL, ($F022)
    ; r30 = call similarity_percentage
    ; Call to similarity_percentage (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.similarity_percentage
    ; r31 = load result
    LD HL, ($F004)
    ; Register 31 already in HL
    ; Store to field similarity (offset 3)
    ; Register 31 already in HL
    LD DE, 3
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; jump end_if_38
    JP end_if_38
    ; else_37:
else_37:
    ; end_if_38:
end_if_38:
    ; r32 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_35
    JP for_loop_35
    ; for_end_36:
for_end_36:
    ; r33 = load result
    LD HL, ($F004)
    ; return r33
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.zvdb_final.main
...examples.zvdb_final.main:
; Using stack-based locals (IX+offset)
    PUSH IX
    LD IX, SP
    LD HL, -52
    ADD HL, SP
    LD SP, HL
    ; Load parameters from registers
    ; r1 = string(str_0)
    LD HL, str_0
    LD ($F002), HL    ; Virtual register 1 to memory
    ; Print "ZVDB-MinZ: 256-bit Vector Database
" (35 chars via loop)
    LD HL, ($F002)    ; Virtual register 1 from memory
    CALL print_string
    ; r2 = string(str_1)
    LD HL, str_1
    ; Print "===================================

" (37 chars via loop)
    CALL print_string
    ; r3 = string(str_2)
    LD HL, str_2
    ; Print "Initializing 256-bit test vectors...
" (37 chars via loop)
    CALL print_string
    ; r4 = call init_vectors
    ; Call to init_vectors (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.init_vectors
    LD ($F008), HL    ; Virtual register 4 to memory
    ; r5 = string(str_3)
    LD HL, str_3
    ; Print "Database initialized with " (26 chars via loop)
    CALL print_string
    ; r6 = string(str_4)
    LD HL, str_4
    ; Print " vectors

" (10 chars via loop)
    CALL print_string
    ; r7 = string(str_5)
    LD HL, str_5
    LD ($F00E), HL    ; Virtual register 7 to memory
    ; Print "Testing popcount:
" (18 chars via loop)
    LD HL, ($F00E)    ; Virtual register 7 from memory
    CALL print_string
    ; r8 = 255
    LD A, 255
    LD H, A         ; Store to physical register H
    ; r9 = call popcount_byte
    ; Call to popcount_byte (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.popcount_byte
    ; print_u8(r9)
    LD A, L
    CALL print_u8_decimal
    ; r10 = 85
    LD A, 85
    LD ($F014), A     ; Virtual register 10 to memory
    ; r11 = call popcount_byte
    ; Call to popcount_byte (args: 1)
    ; Stack-based parameter passing
    LD HL, ($F014)    ; Virtual register 10 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.popcount_byte
    ; print_u8(r11)
    LD A, H
    CALL print_u8_decimal
    ; r12 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r13 = call popcount_byte
    ; Call to popcount_byte (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.popcount_byte
    LD ($F01A), HL    ; Virtual register 13 to memory
    ; print_u8(r13)
    LD A, ($F01A)     ; Virtual register 13 from memory
    CALL print_u8_decimal
    ; r14 = string(str_6)
    LD HL, str_6
    ; Print "256-bit Hamming distances:
" (27 chars via loop)
    CALL print_string
    ; r16 = load ...examples.zvdb_final.vector0
    LD HL, ($F040)
    ; r17 = &r16
    ; Address-of operation for register r16
    LD HL, $F020  ; Variable address
    LD ($F022), HL    ; Virtual register 17 to memory
    ; r18 = load ...examples.zvdb_final.vector1
    LD HL, ($F060)
    ; r19 = &r18
    ; Address-of operation for register r18
    LD HL, $F024  ; Variable address
    ; r20 = call hamming_distance
    ; Call to hamming_distance (args: 2)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 1
    LD HL, ($F022)    ; Virtual register 17 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.hamming_distance
    LD ($F028), HL    ; Virtual register 20 to memory
    ; store , r20
    LD HL, ($F028)    ; Virtual register 20 from memory
    LD (IX-2), L
    LD (IX-1), H
    ; r22 = load ...examples.zvdb_final.vector0
    LD HL, ($F040)
    ; r23 = &r22
    ; Address-of operation for register r22
    LD HL, $F02C  ; Variable address
    LD ($F02E), HL    ; Virtual register 23 to memory
    ; r24 = load ...examples.zvdb_final.vector2
    LD HL, ($F080)
    ; r25 = &r24
    ; Address-of operation for register r24
    LD HL, $F030  ; Variable address
    ; r26 = call hamming_distance
    ; Call to hamming_distance (args: 2)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 1
    LD HL, ($F02E)    ; Virtual register 23 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.hamming_distance
    LD ($F034), HL    ; Virtual register 26 to memory
    ; store , r26
    LD HL, ($F034)    ; Virtual register 26 from memory
    LD (IX-4), L
    LD (IX-3), H
    ; r28 = load ...examples.zvdb_final.vector0
    LD HL, ($F040)
    ; r29 = &r28
    ; Address-of operation for register r28
    LD HL, $F038  ; Variable address
    LD ($F03A), HL    ; Virtual register 29 to memory
    ; r30 = load ...examples.zvdb_final.vector3
    LD HL, ($F0A0)
    ; r31 = &r30
    ; Address-of operation for register r30
    LD HL, $F03C  ; Variable address
    ; r32 = call hamming_distance
    ; Call to hamming_distance (args: 2)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 1
    LD HL, ($F03A)    ; Virtual register 29 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.hamming_distance
    LD ($F040), HL    ; Virtual register 32 to memory
    ; store , r32
    LD HL, ($F040)    ; Virtual register 32 from memory
    LD (IX-6), L
    LD (IX-5), H
    ; r33 = string(str_7)
    LD HL, str_7
    ; Print "  Vector 0 vs 1: " (17 chars via loop)
    CALL print_string
    ; r34 = string(str_8)
    LD HL, str_8
    LD ($F044), HL    ; Virtual register 34 to memory
    ; Print " bits different
" (16 chars via loop)
    LD HL, ($F044)    ; Virtual register 34 from memory
    CALL print_string
    ; r35 = string(str_9)
    LD HL, str_9
    ; Print "  Vector 0 vs 2: " (17 chars via loop)
    CALL print_string
    ; r36 = string(str_10)
    LD HL, str_10
    ; Print " bits different
" (16 chars via loop)
    CALL print_string
    ; r37 = string(str_11)
    LD HL, str_11
    LD ($F04A), HL    ; Virtual register 37 to memory
    ; Print "  Vector 0 vs 3: " (17 chars via loop)
    LD HL, ($F04A)    ; Virtual register 37 from memory
    CALL print_string
    ; r38 = string(str_12)
    LD HL, str_12
    ; Print " bits different

" (17 chars via loop)
    CALL print_string
    ; r39 = string(str_13)
    LD HL, str_13
    ; Print "256-bit Similarity scores:
" (27 chars via loop)
    CALL print_string
    ; r41 = load ...examples.zvdb_final.vector0
    LD HL, ($F040)
    LD ($F052), HL    ; Virtual register 41 to memory
    ; r42 = &r41
    ; Address-of operation for register r41
    LD HL, $F052  ; Variable address
    ; r43 = load ...examples.zvdb_final.vector1
    LD HL, ($F060)
    ; r44 = &r43
    ; Address-of operation for register r43
    LD HL, $F056  ; Variable address
    LD ($F058), HL    ; Virtual register 44 to memory
    ; r45 = call similarity_score
    ; Call to similarity_score (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F058)    ; Virtual register 44 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.similarity_score
    ; store , r45
    LD (IX-8), L
    LD (IX-7), H
    ; r47 = load ...examples.zvdb_final.vector0
    LD HL, ($F040)
    LD ($F05E), HL    ; Virtual register 47 to memory
    ; r48 = &r47
    ; Address-of operation for register r47
    LD HL, $F05E  ; Variable address
    ; r49 = load ...examples.zvdb_final.vector2
    LD HL, ($F080)
    ; r50 = &r49
    ; Address-of operation for register r49
    LD HL, $F062  ; Variable address
    LD ($F064), HL    ; Virtual register 50 to memory
    ; r51 = call similarity_score
    ; Call to similarity_score (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F064)    ; Virtual register 50 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.similarity_score
    ; store , r51
    LD (IX-10), L
    LD (IX-9), H
    ; r53 = load ...examples.zvdb_final.vector0
    LD HL, ($F040)
    LD ($F06A), HL    ; Virtual register 53 to memory
    ; r54 = &r53
    ; Address-of operation for register r53
    LD HL, $F06A  ; Variable address
    ; r55 = load ...examples.zvdb_final.vector3
    LD HL, ($F0A0)
    ; r56 = &r55
    ; Address-of operation for register r55
    LD HL, $F06E  ; Variable address
    LD ($F070), HL    ; Virtual register 56 to memory
    ; r57 = call similarity_score
    ; Call to similarity_score (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F070)    ; Virtual register 56 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.similarity_score
    ; store , r57
    LD (IX-12), L
    LD (IX-11), H
    ; r58 = string(str_14)
    LD HL, str_14
    LD ($F074), HL    ; Virtual register 58 to memory
    ; Print "  Vector 0 vs 1: " (17 chars via loop)
    LD HL, ($F074)    ; Virtual register 58 from memory
    CALL print_string
    ; Direct print "
" (1 chars)
    ; Direct print "
" (1 chars)
    LD A, 10
    RST 16             ; Print character
    ; r59 = string(str_15)
    LD HL, str_15
    ; Print "  Vector 0 vs 2: " (17 chars via loop)
    CALL print_string
    ; Direct print "
" (1 chars)
    ; Direct print "
" (1 chars)
    LD A, 10
    RST 16             ; Print character
    ; r60 = string(str_16)
    LD HL, str_16
    ; Print "  Vector 0 vs 3: " (17 chars via loop)
    CALL print_string
    ; Direct print "

" (2 chars)
    ; Direct print "

" (2 chars)
    LD A, 10
    RST 16             ; Print character
    LD A, 10
    RST 16             ; Print character
    ; r61 = string(str_17)
    LD HL, str_17
    LD ($F07A), HL    ; Virtual register 61 to memory
    ; Print "Searching for best match to vector 0...
" (40 chars via loop)
    LD HL, ($F07A)    ; Virtual register 61 from memory
    CALL print_string
    ; r63 = load ...examples.zvdb_final.vector0
    LD HL, ($F040)
    ; r64 = &r63
    ; Address-of operation for register r63
    LD HL, $F07E  ; Variable address
    ; r65 = call search_best_match
    ; Call to search_best_match (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.search_best_match
    LD ($F082), HL    ; Virtual register 65 to memory
    ; store , r65
    LD HL, ($F082)    ; Virtual register 65 from memory
    LD (IX-16), L
    LD (IX-15), H
    ; r66 = load result
    LD L, (IX-16)
    LD H, (IX-15)
    ; Load field vector_id (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 67 already in HL
    ; print_u8(r67)
    LD A, L
    CALL print_u8_decimal
    ; r68 = load result
    LD L, (IX-16)
    LD H, (IX-15)
    ; Load field score (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F08A), HL    ; Virtual register 69 to memory
    ; print_u16(r69)
    LD HL, ($F08A)    ; Virtual register 69 from memory
    CALL print_u16_decimal
    ; r70 = load result
    LD L, (IX-16)
    LD H, (IX-15)
    LD ($F08C), HL    ; Virtual register 70 to memory
    ; Load field similarity (offset 3)
    LD HL, ($F08C)    ; Virtual register 70 from memory
    LD DE, 3
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; print_u8(r71)
    LD A, H
    CALL print_u8_decimal
    ; r73 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r74 = 32
    LD A, 32
    LD ($F094), A     ; Virtual register 74 to memory
    ; Initialize loop variable i
    ; for_loop_39:
for_loop_39:
    ; Check i < end
    LD D, H
    LD E, L
    LD HL, ($F094)    ; Virtual register 74 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L52
    LD HL, 0
    JP .L53
.L52:
    LD HL, 1
.L53:
    ; jump_if_not r76, for_end_40
    LD A, L
    OR A
    JP Z, for_end_40
    ; r77 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    LD ($F09A), HL    ; Virtual register 77 to memory
    ; r78 = 2
    LD A, 2
    LD H, A         ; Store to physical register H
    ; r79 = r77 % r78
    ; 8-bit modulo
    LD A, ($F09A)     ; Virtual register 77 from memory
    LD D, A       ; D = dividend
    LD A, H
    LD E, A       ; E = divisor
    OR A          ; Check for divide by zero
    JR Z, .mod_by_zero_53
    LD A, D       ; A = dividend
.mod_loop_53:
    CP E          ; Compare with divisor
    JR C, .mod_done_53
    SUB E         ; Subtract divisor
    JR .mod_loop_53
.mod_by_zero_53:
    LD A, 0       ; Return 0 for modulo by zero
.mod_done_53:
    LD L, A       ; Result (remainder) in L
    LD H, 0
    ; r80 = 0
    LD A, 0
    LD ($F0A0), A     ; Virtual register 80 to memory
    ; r81 = r79 == r80
    LD D, H
    LD E, L
    LD HL, ($F0A0)    ; Virtual register 80 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP Z, .L55
    LD HL, 0
    JP .L56
.L55:
    LD HL, 1
.L56:
    ; jump_if_not r81, else_41
    LD A, H
    OR A
    JP Z, else_41
    ; r82 = 80
    LD A, 80
    LD L, A         ; Store to physical register L
    ; r83 = load query
    LD L, (IX-48)
    LD H, (IX-47)
    ; Register 83 already in HL
    ; Load field data (offset 0)
    ; Register 83 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F0A8), HL    ; Virtual register 84 to memory
    ; r85 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    ; Register 85 already in HL
    ; Calculate array element address
    LD HL, ($F0A8)    ; Virtual register 84 from memory
    LD D, H
    LD E, L
    ; Register 85 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; jump end_if_42
    JP end_if_42
    ; else_41:
else_41:
    ; r87 = 160
    LD A, 160
    LD L, A         ; Store to physical register L
    ; r88 = load query
    LD L, (IX-48)
    LD H, (IX-47)
    ; Register 88 already in HL
    ; Load field data (offset 0)
    ; Register 88 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F0B2), HL    ; Virtual register 89 to memory
    ; r90 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    ; Register 90 already in HL
    ; Calculate array element address
    LD HL, ($F0B2)    ; Virtual register 89 from memory
    LD D, H
    LD E, L
    ; Register 90 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; end_if_42:
end_if_42:
    ; r92 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_39
    JP for_loop_39
    ; for_end_40:
for_end_40:
    ; r93 = string(str_18)
    LD HL, str_18
    LD ($F0BA), HL    ; Virtual register 93 to memory
    ; Print "Searching with custom query vector...
" (38 chars via loop)
    LD HL, ($F0BA)    ; Virtual register 93 from memory
    CALL print_string
    ; r95 = load query
    LD L, (IX-48)
    LD H, (IX-47)
    ; r96 = &r95
    ; Address-of operation for register r95
    LD HL, $F0BE  ; Variable address
    ; r97 = call search_best_match
    ; Call to search_best_match (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL ...examples.zvdb_final.search_best_match
    LD ($F0C2), HL    ; Virtual register 97 to memory
    ; store , r97
    LD HL, ($F0C2)    ; Virtual register 97 from memory
    LD (IX-52), L
    LD (IX-51), H
    ; r98 = load result2
    LD L, (IX-52)
    LD H, (IX-51)
    ; Load field vector_id (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 99 already in HL
    ; print_u8(r99)
    LD A, L
    CALL print_u8_decimal
    ; r100 = load result2
    LD L, (IX-52)
    LD H, (IX-51)
    ; Load field score (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F0CA), HL    ; Virtual register 101 to memory
    ; print_u16(r101)
    LD HL, ($F0CA)    ; Virtual register 101 from memory
    CALL print_u16_decimal
    ; r102 = load result2
    LD L, (IX-52)
    LD H, (IX-51)
    LD ($F0CC), HL    ; Virtual register 102 to memory
    ; Load field similarity (offset 3)
    LD HL, ($F0CC)    ; Virtual register 102 from memory
    LD DE, 3
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; print_u8(r103)
    LD A, H
    CALL print_u8_decimal
    ; r104 = string(str_19)
    LD HL, str_19
    ; Print "â ZVDB-MinZ 256-bit Implementation Working!
" (49 chars via loop)
    CALL print_string
    ; r105 = string(str_20)
    LD HL, str_20
    LD ($F0D2), HL    ; Virtual register 105 to memory
    ; Print "   â¢ Full 256-bit vectors (32 bytes each)
" (47 chars via loop)
    LD HL, ($F0D2)    ; Virtual register 105 from memory
    CALL print_string
    ; r106 = string(str_21)
    LD HL, str_21
    ; Print "   â¢ Hamming distance calculation
" (39 chars via loop)
    CALL print_string
    ; r107 = string(str_22)
    LD HL, str_22
    ; Print "   â¢ Similarity search with scoring
" (41 chars via loop)
    CALL print_string
    ; r108 = string(str_23)
    LD HL, str_23
    ; Register 108 already in HL
    ; Print "   â¢ Production-ready for Z80 hardware!
" (45 chars via loop)
    ; Register 108 already in HL
    CALL print_string
    ; return
    LD SP, IX
    POP IX
    RET

; Runtime print helper functions
print_string:
    LD B, (HL)         ; B = length from first byte
    INC HL             ; HL -> string data
    LD A, B            ; Check if length is zero
    OR A
    RET Z              ; Return if empty string
print_loop:
    LD A, (HL)         ; Load character
    RST 16             ; Print character
    INC HL             ; Next character
    DJNZ print_loop    ; Decrement B and loop
    RET

print_u8_decimal:
    LD H, 0            ; HL = A (zero extend)
    LD L, A
    CALL print_u16_decimal
    RET

print_u16_decimal:
    LD BC, -10000
    LD DE, -1000
    CALL print_digit
    LD BC, -1000
    LD DE, -100
    CALL print_digit
    LD BC, -100
    LD DE, -10
    CALL print_digit
    LD BC, -10
    LD DE, -1
    CALL print_digit
    LD A, L
    ADD A, '0'         ; Convert to ASCII
    RST 16             ; Print last digit
    RET

print_digit:
    LD A, '0'-1
print_digit_loop:
    INC A
    ADD HL, BC         ; Subtract power of 10
    JR C, print_digit_loop
    ADD HL, DE         ; Add back one power of 10
    RST 16             ; Print digit
    RET

print_i8_decimal:
    BIT 7, A           ; Check sign bit
    JR Z, print_u8_decimal
    PUSH AF
    LD A, '-'          ; Print minus sign
    RST 16
    POP AF
    NEG                ; Make positive
    JR print_u8_decimal

print_i16_decimal:
    BIT 7, H           ; Check sign bit
    JR Z, print_u16_decimal
    PUSH HL
    LD A, '-'          ; Print minus sign
    RST 16
    POP HL
    LD A, H            ; Negate HL
    CPL
    LD H, A
    LD A, L
    CPL
    LD L, A
    INC HL
    JR print_u16_decimal

print_bool:
    OR A               ; Test if A is zero
    JR NZ, print_true
    LD HL, bool_false_str
    JR print_string
print_true:
    LD HL, bool_true_str
    JR print_string

bool_true_str:
    DB 4, "true"      ; Length + data
bool_false_str:
    DB 5, "false"     ; Length + data


    END main
