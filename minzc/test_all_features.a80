; MinZ generated code
; Generated: 2025-07-26 22:22:21


; Data section
    ORG $F000

g_version:
    DB 3
g_magic:
    DW 51966
g_enabled:
    DB 1
g_computed:
    DB 30
g_shifted:
    DW 1024
g_masked:
    DB 60

; Code section
    ORG $8000


; Function: test_all_features.test_locals
test_all_features.test_locals:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = 10
    LD A, 10
    LD ($F004), A
    ; store , r2
    LD HL, ($F004)
    LD ($F002), HL
    ; r4 = 20
    LD A, 20
    LD ($F008), A
    ; store , r4
    LD HL, ($F008)
    LD ($F006), HL
    ; r6 = 30
    LD A, 30
    LD ($F00C), A
    ; store , r6
    LD HL, ($F00C)
    LD ($F00A), HL
    ; r8 = load a
    LD HL, ($F002)
    LD ($F010), HL
    ; r9 = load b
    LD HL, ($F006)
    LD ($F012), HL
    ; r10 = r8 + r9
    LD HL, ($F010)
    LD D, H
    LD E, L
    LD HL, ($F012)
    ADD HL, DE
    LD ($F014), HL
    ; r11 = load c
    LD HL, ($F00A)
    LD ($F016), HL
    ; r12 = r10 + r11
    LD HL, ($F014)
    LD D, H
    LD E, L
    LD HL, ($F016)
    ADD HL, DE
    LD ($F018), HL
    ; store , r12
    LD HL, ($F018)
    LD ($F00E), HL
    ; r14 = load a
    LD HL, ($F002)
    LD ($F01C), HL
    ; store , r14
    LD HL, ($F01C)
    LD ($F01A), HL
    ; r16 = load b
    LD HL, ($F006)
    LD ($F020), HL
    ; store , r16
    LD HL, ($F020)
    LD ($F01E), HL
    ; r18 = load c
    LD HL, ($F00A)
    LD ($F024), HL
    ; store , r18
    LD HL, ($F024)
    LD ($F022), HL
    ; r19 = load sum
    LD HL, ($F00E)
    LD ($F026), HL
    ; r20 = load d
    LD HL, ($F01A)
    LD ($F028), HL
    ; r21 = r19 + r20
    LD HL, ($F026)
    LD D, H
    LD E, L
    LD HL, ($F028)
    ADD HL, DE
    LD ($F02A), HL
    ; r22 = load e
    LD HL, ($F01E)
    LD ($F02C), HL
    ; r23 = r21 + r22
    LD HL, ($F02A)
    LD D, H
    LD E, L
    LD HL, ($F02C)
    ADD HL, DE
    LD ($F02E), HL
    ; r24 = load f
    LD HL, ($F022)
    LD ($F030), HL
    ; r25 = r23 + r24
    LD HL, ($F02E)
    LD D, H
    LD E, L
    LD HL, ($F030)
    ADD HL, DE
    LD ($F032), HL
    ; return r25
    LD HL, ($F032)
    RET

; Function: test_all_features.test_16bit_ops
test_all_features.test_16bit_ops:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = 1000
    LD HL, 1000
    LD ($F004), HL
    ; store , r2
    LD HL, ($F004)
    LD ($F002), HL
    ; r4 = 234
    LD A, 234
    LD ($F008), A
    ; store , r4
    LD HL, ($F008)
    LD ($F006), HL
    ; r6 = load x
    LD HL, ($F002)
    LD ($F00C), HL
    ; r7 = load y
    LD HL, ($F006)
    LD ($F00E), HL
    ; r8 = r6 * r7
    ; 16-bit multiplication
    LD HL, ($F00C)
    LD (mul_src1_0), HL  ; Save multiplicand
    LD HL, ($F00E)
    LD (mul_src2_0), HL  ; Save multiplier
    LD HL, 0             ; Result = 0
    LD DE, (mul_src1_0)  ; DE = multiplicand
    LD BC, (mul_src2_0)  ; BC = multiplier
    LD A, B
    OR C                 ; Check if multiplier is 0
    JR Z, .mul16_done_0
.mul16_loop_0:
    ADD HL, DE           ; Result += multiplicand
    DEC BC
    LD A, B
    OR C
    JR NZ, .mul16_loop_0
.mul16_done_0:
mul_src1_0: DW 0
mul_src2_0: DW 0
    LD ($F010), HL
    ; store , r8
    LD HL, ($F010)
    LD ($F00A), HL
    ; r10 = load x
    LD HL, ($F002)
    LD ($F014), HL
    ; r11 = 2
    LD A, 2
    LD ($F016), A
    ; unknown op 45
    ; 16-bit shift left
    LD HL, ($F014)
    LD A, ($F016)
    LD B, A       ; B = shift count
    OR A
    JR Z, .shl16_done_1
.shl16_loop_1:
    ADD HL, HL    ; Shift left by 1
    DJNZ .shl16_loop_1
.shl16_done_1:
    LD ($F018), HL
    ; store , r12
    LD HL, ($F018)
    LD ($F012), HL
    ; r14 = load x
    LD HL, ($F002)
    LD ($F01C), HL
    ; r15 = 2
    LD A, 2
    LD ($F01E), A
    ; unknown op 46
    ; 16-bit shift right
    LD HL, ($F01C)
    LD A, ($F01E)
    LD B, A       ; B = shift count
    OR A
    JR Z, .shr16_done_2
.shr16_loop_2:
    SRL H         ; Shift high byte right
    RR L          ; Rotate right through carry
    DJNZ .shr16_loop_2
.shr16_done_2:
    LD ($F020), HL
    ; store , r16
    LD HL, ($F020)
    LD ($F01A), HL
    ; r17 = load product
    LD HL, ($F00A)
    LD ($F022), HL
    ; r18 = 65535
    LD HL, 65535
    LD ($F024), HL
    ; unknown op 41
    LD HL, ($F022)
    LD D, H
    LD E, L
    LD HL, ($F024)
    LD A, L
    AND E
    LD L, A
    LD A, H
    AND D
    LD H, A
    LD ($F026), HL
    ; store g_magic, r19
    LD HL, ($F026)
    LD ($F020), HL
    ; return
    RET

; Function: test_all_features.test_type_aware_ops
test_all_features.test_type_aware_ops:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = 5
    LD A, 5
    LD ($F004), A
    ; store , r2
    LD HL, ($F004)
    LD ($F002), HL
    ; r4 = 10
    LD A, 10
    LD ($F008), A
    ; store , r4
    LD HL, ($F008)
    LD ($F006), HL
    ; r6 = load small_a
    LD HL, ($F002)
    LD ($F00C), HL
    ; r7 = load small_b
    LD HL, ($F006)
    LD ($F00E), HL
    ; r8 = r6 * r7
    ; 8-bit multiplication
    LD A, ($F00C)
    LD B, A       ; B = multiplicand
    LD A, ($F00E)
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_3
.mul_loop_3:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_3
.mul_done_3:
    LD ($F010), HL
    ; store , r8
    LD HL, ($F010)
    LD ($F00A), HL
    ; r10 = 500
    LD HL, 500
    LD ($F014), HL
    ; store , r10
    LD HL, ($F014)
    LD ($F012), HL
    ; r12 = 100
    LD A, 100
    LD ($F018), A
    ; store , r12
    LD HL, ($F018)
    LD ($F016), HL
    ; r14 = load large_a
    LD HL, ($F012)
    LD ($F01C), HL
    ; r15 = load large_b
    LD HL, ($F016)
    LD ($F01E), HL
    ; r16 = r14 * r15
    ; 16-bit multiplication
    LD HL, ($F01C)
    LD (mul_src1_4), HL  ; Save multiplicand
    LD HL, ($F01E)
    LD (mul_src2_4), HL  ; Save multiplier
    LD HL, 0             ; Result = 0
    LD DE, (mul_src1_4)  ; DE = multiplicand
    LD BC, (mul_src2_4)  ; BC = multiplier
    LD A, B
    OR C                 ; Check if multiplier is 0
    JR Z, .mul16_done_4
.mul16_loop_4:
    ADD HL, DE           ; Result += multiplicand
    DEC BC
    LD A, B
    OR C
    JR NZ, .mul16_loop_4
.mul16_done_4:
mul_src1_4: DW 0
mul_src2_4: DW 0
    LD ($F020), HL
    ; store , r16
    LD HL, ($F020)
    LD ($F01A), HL
    ; r18 = load large_a
    LD HL, ($F012)
    LD ($F024), HL
    ; r19 = load small_a
    LD HL, ($F002)
    LD ($F026), HL
    ; r20 = r18 + r19
    LD HL, ($F024)
    LD D, H
    LD E, L
    LD HL, ($F026)
    ADD HL, DE
    LD ($F028), HL
    ; store , r20
    LD HL, ($F028)
    LD ($F022), HL
    ; r21 = load mixed
    LD HL, ($F022)
    LD ($F02A), HL
    ; return r21
    LD HL, ($F02A)
    RET

; Function: test_all_features.test_complex_expr
test_all_features.test_complex_expr:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = 1000
    LD HL, 1000
    LD ($F004), HL
    ; store , r2
    LD HL, ($F004)
    LD ($F002), HL
    ; r4 = 50
    LD A, 50
    LD ($F008), A
    ; store , r4
    LD HL, ($F008)
    LD ($F006), HL
    ; r6 = load base
    LD HL, ($F002)
    LD ($F00C), HL
    ; r7 = 1
    LD A, 1
    LD ($F00E), A
    ; unknown op 45
    ; 16-bit shift left
    LD HL, ($F00C)
    LD A, ($F00E)
    LD B, A       ; B = shift count
    OR A
    JR Z, .shl16_done_5
.shl16_loop_5:
    ADD HL, HL    ; Shift left by 1
    DJNZ .shl16_loop_5
.shl16_done_5:
    LD ($F010), HL
    ; r9 = load offset
    LD HL, ($F006)
    LD ($F012), HL
    ; r10 = 2
    LD A, 2
    LD ($F014), A
    ; r11 = r9 * r10
    ; 8-bit multiplication
    LD A, ($F012)
    LD B, A       ; B = multiplicand
    LD A, ($F014)
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_6
.mul_loop_6:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_6
.mul_done_6:
    LD ($F016), HL
    ; r12 = r8 + r11
    LD HL, ($F010)
    LD D, H
    LD E, L
    LD HL, ($F016)
    ADD HL, DE
    LD ($F018), HL
    ; r13 = 100
    LD A, 100
    LD ($F01A), A
    ; r14 = r12 - r13
    LD HL, ($F018)
    LD D, H
    LD E, L
    LD HL, ($F01A)
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    LD ($F01C), HL
    ; store , r14
    LD HL, ($F01C)
    LD ($F00A), HL
    ; r15 = load result
    LD HL, ($F00A)
    LD ($F01E), HL
    ; r16 = 2000
    LD HL, 2000
    LD ($F020), HL
    ; r17 = r15 == r16
    LD HL, ($F01E)
    LD D, H
    LD E, L
    LD HL, ($F020)
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP Z, .L8
    LD HL, 0
    JP .L9
.L8:
    LD HL, 1
.L9:
    LD ($F022), HL
    ; return r17
    LD HL, ($F022)
    RET

; Function: test_all_features.main
test_all_features.main:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r1 = load g_version
    LD HL, ($F000)
    LD ($F002), HL
    ; r2 = 3
    LD A, 3
    LD ($F004), A
    ; r3 = r1 != r2
    LD HL, ($F002)
    LD D, H
    LD E, L
    LD HL, ($F004)
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L10
    LD HL, 0
    JP .L11
.L10:
    LD HL, 1
.L11:
    LD ($F006), HL
    ; jump_if_not r3, else_1
    LD A, ($F006)
    OR A
    JP Z, else_1
    ; return
    RET
    ; jump end_if_2
    JP end_if_2
    ; else_1:
else_1:
    ; end_if_2:
end_if_2:
    ; r4 = load g_computed
    LD HL, ($F060)
    LD ($F008), HL
    ; r5 = 30
    LD A, 30
    LD ($F00A), A
    ; r6 = r4 != r5
    LD HL, ($F008)
    LD D, H
    LD E, L
    LD HL, ($F00A)
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L12
    LD HL, 0
    JP .L13
.L12:
    LD HL, 1
.L13:
    LD ($F00C), HL
    ; jump_if_not r6, else_3
    LD A, ($F00C)
    OR A
    JP Z, else_3
    ; return
    RET
    ; jump end_if_4
    JP end_if_4
    ; else_3:
else_3:
    ; end_if_4:
end_if_4:
    ; r7 = load g_shifted
    LD HL, ($F080)
    LD ($F00E), HL
    ; r8 = 1024
    LD HL, 1024
    LD ($F010), HL
    ; r9 = r7 != r8
    LD HL, ($F00E)
    LD D, H
    LD E, L
    LD HL, ($F010)
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L14
    LD HL, 0
    JP .L15
.L14:
    LD HL, 1
.L15:
    LD ($F012), HL
    ; jump_if_not r9, else_5
    LD A, ($F012)
    OR A
    JP Z, else_5
    ; return
    RET
    ; jump end_if_6
    JP end_if_6
    ; else_5:
else_5:
    ; end_if_6:
end_if_6:
    ; r10 = load g_masked
    LD HL, ($F0A0)
    LD ($F014), HL
    ; r11 = 60
    LD A, 60
    LD ($F016), A
    ; r12 = r10 != r11
    LD HL, ($F014)
    LD D, H
    LD E, L
    LD HL, ($F016)
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L16
    LD HL, 0
    JP .L17
.L16:
    LD HL, 1
.L17:
    LD ($F018), HL
    ; jump_if_not r12, else_7
    LD A, ($F018)
    OR A
    JP Z, else_7
    ; return
    RET
    ; jump end_if_8
    JP end_if_8
    ; else_7:
else_7:
    ; end_if_8:
end_if_8:
    ; r14 = call test_locals
    ; Call to test_locals (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL test_locals
    LD ($F01C), HL
    ; store , r14
    LD HL, ($F01C)
    LD ($F01A), HL
    ; r15 = load local_result
    LD HL, ($F01A)
    LD ($F01E), HL
    ; r16 = 120
    LD A, 120
    LD ($F020), A
    ; r17 = r15 != r16
    LD HL, ($F01E)
    LD D, H
    LD E, L
    LD HL, ($F020)
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L18
    LD HL, 0
    JP .L19
.L18:
    LD HL, 1
.L19:
    LD ($F022), HL
    ; jump_if_not r17, else_9
    LD A, ($F022)
    OR A
    JP Z, else_9
    ; return
    RET
    ; jump end_if_10
    JP end_if_10
    ; else_9:
else_9:
    ; end_if_10:
end_if_10:
    ; r18 = call test_16bit_ops
    ; Call to test_16bit_ops (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL test_16bit_ops
    LD ($F024), HL
    ; r20 = call test_type_aware_ops
    ; Call to test_type_aware_ops (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL test_type_aware_ops
    LD ($F028), HL
    ; store , r20
    LD HL, ($F028)
    LD ($F026), HL
    ; r21 = load type_result
    LD HL, ($F026)
    LD ($F02A), HL
    ; r22 = 505
    LD HL, 505
    LD ($F02C), HL
    ; r23 = r21 != r22
    LD HL, ($F02A)
    LD D, H
    LD E, L
    LD HL, ($F02C)
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L20
    LD HL, 0
    JP .L21
.L20:
    LD HL, 1
.L21:
    LD ($F02E), HL
    ; jump_if_not r23, else_11
    LD A, ($F02E)
    OR A
    JP Z, else_11
    ; return
    RET
    ; jump end_if_12
    JP end_if_12
    ; else_11:
else_11:
    ; end_if_12:
end_if_12:
    ; r25 = call test_complex_expr
    ; Call to test_complex_expr (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL test_complex_expr
    LD ($F032), HL
    ; store , r25
    LD HL, ($F032)
    LD ($F030), HL
    ; r26 = load complex_result
    LD HL, ($F030)
    LD ($F034), HL
    ; unknown op 44
    LD HL, ($F034)
    LD A, L
    CPL
    LD L, A
    LD A, H
    CPL
    LD H, A
    LD ($F036), HL
    ; jump_if_not r27, else_13
    LD A, ($F036)
    OR A
    JP Z, else_13
    ; return
    RET
    ; jump end_if_14
    JP end_if_14
    ; else_13:
else_13:
    ; end_if_14:
end_if_14:
    ; r28 = 1
    LD A, 1
    LD ($F038), A
    ; store g_enabled, r28
    LD HL, ($F038)
    LD ($F040), HL
    ; return
    RET

    END main
