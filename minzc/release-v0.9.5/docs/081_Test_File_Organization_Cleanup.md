# Article 081: MinZ Test File Organization and Cleanup Strategy

**Author:** Claude Code Assistant  
**Date:** August 1, 2025  
**Version:** MinZ v0.7.0+  
**Status:** REPOSITORY CLEANUP ğŸ§¹

## Current Chaos Analysis

### Scattered Test Files Problem
Test files are currently scattered across multiple directories:

1. **Root Directory** (`/Users/alice/dev/minz-ts/`): 
   - âŒ `test_abi.a80`, `fibonacci.a80`, `simple_add.mir`
   - âŒ 50+ test files that should not be here!

2. **Examples Directory** (`examples/`):
   - âœ… Source files: `fibonacci.minz`, `test_abi.minz` 
   - âœ… Output directory: `examples/output/*.a80`, `examples/output/*.mir`

3. **MinZC Directory** (`minzc/`):
   - âŒ Mixed: some legitimate, some temporary test files

## Proper File Organization

### âœ… Correct Structure
```
minz-ts/
â”œâ”€â”€ examples/                    # MinZ source examples
â”‚   â”œâ”€â”€ fibonacci.minz          # Source files
â”‚   â”œâ”€â”€ test_abi.minz
â”‚   â”œâ”€â”€ simple_add.minz
â”‚   â””â”€â”€ output/                 # Compiler output
â”‚       â”œâ”€â”€ fibonacci.a80       # Assembly output
â”‚       â”œâ”€â”€ fibonacci.mir       # IR output
â”‚       â””â”€â”€ test_abi.a80
â”œâ”€â”€ minzc/                      # Compiler directory
â”‚   â”œâ”€â”€ tests/                  # Compiler unit tests
â”‚   â”‚   â”œâ”€â”€ benchmarks/         # Performance tests
â”‚   â”‚   â””â”€â”€ corpus/            # Test corpus
â”‚   â”œâ”€â”€ pkg/                    # Compiler packages
â”‚   â””â”€â”€ examples/              # Compiler-specific examples
â””â”€â”€ test/                       # Tree-sitter grammar tests
    â””â”€â”€ corpus/                 # Grammar test cases
```

### âŒ Current Wrong Structure
```
minz-ts/
â”œâ”€â”€ test_abi.a80              # âŒ Should be in examples/output/
â”œâ”€â”€ fibonacci.mir             # âŒ Should be in examples/output/
â”œâ”€â”€ simple_add.a80            # âŒ Should be in examples/output/
â”œâ”€â”€ (50+ scattered files)     # âŒ All in wrong place!
```

## Cleanup Strategy

### Phase 1: Identify File Categories
1. **MinZ Examples**: `.minz` source files â†’ `examples/`
2. **Compiler Output**: `.a80`, `.mir` files â†’ `examples/output/`
3. **Temporary Files**: Debug files, test artifacts â†’ DELETE
4. **Backup Files**: Archive materials â†’ `archive/`

### Phase 2: Safe Cleanup Process
```bash
# 1. Create proper output directory structure
mkdir -p examples/output
mkdir -p minzc/tests/integration
mkdir -p archive/temp_files

# 2. Move scattered output files to proper location
find . -maxdepth 1 -name "*.a80" -exec mv {} examples/output/ \;
find . -maxdepth 1 -name "*.mir" -exec mv {} examples/output/ \;

# 3. Move source files to examples (if not already there)
find . -maxdepth 1 -name "*.minz" -exec mv {} examples/ \;

# 4. Archive temporary/debug files
find . -maxdepth 1 -name "test_debug*.a80" -exec mv {} archive/temp_files/ \;
find . -maxdepth 1 -name "test_debug*.mir" -exec mv {} archive/temp_files/ \;
```

### Phase 3: Recompile All Examples
```bash
# Recompile all examples to ensure proper output location
cd minzc
for file in ../examples/*.minz; do
    basename=$(basename "$file" .minz)
    echo "Compiling $basename..."
    ./minzc "$file" -o "../examples/output/$basename.a80"
done
```

## Implementation Plan

### Step 1: Backup Current State
```bash
# Create safety backup
tar -czf minz_backup_$(date +%Y%m%d).tar.gz .
```

### Step 2: Clean Root Directory
Move all scattered test files to appropriate locations.

### Step 3: Establish Compilation Script
Create script to recompile all examples and place output correctly.

### Step 4: Update .gitignore
```gitignore
# Temporary files
*.tmp
test_debug*
test_final.*

# Compiler outputs (except examples/output/)
/*.a80
/*.mir
/minzc/*.a80
/minzc/*.mir

# Keep examples output
!examples/output/*.a80
!examples/output/*.mir
```

### Step 5: Documentation Update
Update README to explain proper file organization.

## Expected Benefits

### Cleaner Repository
- Clear separation of source vs output
- Easier to find relevant files
- Professional project structure

### Better Development Workflow
- Predictable file locations
- Easier CI/CD integration
- Simpler build scripts

### Maintainability
- Clear ownership of files
- Easier to clean up artifacts
- Better Git history

## File Location Rules

### Source Files (`.minz`)
- **Location**: `examples/`
- **Purpose**: Demonstrate MinZ language features
- **Naming**: Descriptive names like `fibonacci.minz`, `smc_demo.minz`

### Compiler Output (`.a80`, `.mir`)
- **Location**: `examples/output/`
- **Purpose**: Generated by compiler for testing/verification
- **Naming**: Match source file name: `fibonacci.minz` â†’ `fibonacci.a80`

### Test Files
- **Grammar Tests**: `test/corpus/`
- **Compiler Tests**: `minzc/tests/`
- **Integration Tests**: `minzc/tests/integration/`

### Temporary Files
- **Location**: Should not be committed
- **Purpose**: Debug, development artifacts
- **Cleanup**: Automated cleanup scripts

## Implementation Commands

### Immediate Cleanup
```bash
#!/bin/bash
# cleanup_test_files.sh

echo "Starting MinZ test file cleanup..."

# Create directories
mkdir -p examples/output
mkdir -p archive/scattered_files

# Move scattered .a80 files
echo "Moving .a80 files..."
find . -maxdepth 1 -name "*.a80" -not -path "./examples/*" -exec mv {} examples/output/ \;

# Move scattered .mir files  
echo "Moving .mir files..."
find . -maxdepth 1 -name "*.mir" -not -path "./examples/*" -exec mv {} examples/output/ \;

# Archive debug files
echo "Archiving debug files..."
find . -maxdepth 1 -name "test_debug*" -exec mv {} archive/scattered_files/ \;
find . -maxdepth 1 -name "test_final*" -exec mv {} archive/scattered_files/ \;

echo "Cleanup complete!"
```

### Recompilation Script
```bash
#!/bin/bash
# recompile_examples.sh

echo "Recompiling all MinZ examples..."

cd minzc
for file in ../examples/*.minz; do
    if [ -f "$file" ]; then
        basename=$(basename "$file" .minz)
        echo "Compiling $basename..."
        ./minzc "$file" -o "../examples/output/$basename.a80"
        if [ $? -eq 0 ]; then
            echo "âœ… $basename compiled successfully"
        else
            echo "âŒ $basename compilation failed"
        fi
    fi
done

echo "Recompilation complete!"
```

## Conclusion

This cleanup will transform the MinZ repository from a chaotic collection of scattered files into a professionally organized codebase with clear file ownership and predictable locations.

The proper organization enables:
- **Better CI/CD**: Predictable file locations for automated testing
- **Easier Development**: Developers know exactly where to find files
- **Professional Appearance**: Clean, organized repository structure
- **Maintainability**: Clear rules for where files belong

---

*A clean repository is like a well-organized workshop - you can find what you need quickly and focus on building great things instead of searching through clutter.*