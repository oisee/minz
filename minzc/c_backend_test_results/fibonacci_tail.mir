; MinZ Intermediate Representation (MIR)
; Module: main

Function fibonacci_tail.fib_tail$u8$u16$u16(n: u8, a: u16, b: u16) -> u16
  @smc
  @recursive
  Instructions:
      0: LOAD_PARAM
      1: r5 = 0
      2: r6 = r4 == r5
      3: jump_if_not r6, else_1
      4: LOAD_PARAM
      5: return r7
      6: jump end_if_2
      7: else_1:
      8: end_if_2:
      9: LOAD_PARAM
     10: r9 = 1
     11: r10 = r8 == r9
     12: jump_if_not r10, else_3
     13: LOAD_PARAM
     14: return r11
     15: jump end_if_4
     16: else_3:
     17: end_if_4:
     18: LOAD_PARAM
     19: r13 = 1
     20: r14 = r12 - r13
     21: LOAD_PARAM
     22: LOAD_PARAM
     23: LOAD_PARAM
     24: r18 = r16 + r17
     25: LOAD_PARAM
     26: r20 = 1
     27: r21 = r19 - r20
     28: LOAD_PARAM
     29: LOAD_PARAM
     30: LOAD_PARAM
     31: r25 = r23 + r24
     32: r26 = call fibonacci_tail.fib_tail$u8$u16$u16
     33: return r26

Function fibonacci_tail.fibonacci$u8(n: u8) -> u16
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r3 = 0
      2: r4 = 1
      3: LOAD_PARAM
      4: r6 = 0
      5: r7 = 1
      6: r8 = call fibonacci_tail.fib_tail$u8$u16$u16
      7: return r8

Function fibonacci_tail.main() -> void
  @smc
  Locals:
    r1 = result: u16
  Instructions:
      0: r2 = 10
      1: r3 = 10
      2: r4 = call fibonacci_tail.fibonacci$u8
      3: store , r4
      4: return

