// Test complete error handling system with CY flag

// Define error types
enum Error {
    DivideByZero,
    InvalidInput,
    OutOfRange,
    ParseError,
}

// Function that can fail - ends with ? and uses @error
fun safe_divide?(a: u8, b: u8) -> u8 {
    if b == 0 {
        @error(Error.DivideByZero);  // Sets CY flag and returns error
    }
    return a / b;  // CY flag remains clear for success
}

// Another error-prone function  
fun parse_digit?(ch: u8) -> u8 {
    if ch < 48 || ch > 57 {  // ASCII '0' to '9'
        @error(Error.ParseError);
    }
    return ch - 48;  // Convert ASCII to digit
}

// Function that validates range
fun check_range?(value: u8, min: u8, max: u8) -> u8 {
    if value < min || value > max {
        @error(Error.OutOfRange);
    }
    return value;
}

fun main() -> void {
    // 1. Basic nil coalescing with error functions
    let result1 = safe_divide?(10, 2) ?? 99;   // Should be 5 (no error)
    let result2 = safe_divide?(10, 0) ?? 99;   // Should be 99 (DivideByZero error)
    
    // 2. Chaining error-prone functions
    let ascii_5 = 53;  // ASCII '5'
    let digit = parse_digit?(ascii_5) ?? 0;    // Should be 5
    let invalid = parse_digit?(65) ?? 0;       // Should be 0 (ASCII 'A' is invalid)
    
    // 3. Complex chaining with multiple fallbacks
    let complex = check_range?(150, 0, 100) ?? safe_divide?(20, 4) ?? 42;
    // First fails (150 > 100), second succeeds (5), result should be 5
    
    // 4. Combining with other conditional expressions
    let smart = (safe_divide?(a, b) ?? 1) if a > 0 else 0;
    
    // 5. Nested error handling
    let nested = safe_divide?(parse_digit?(ascii_5) ?? 1, 2) ?? 99;
    // parse_digit?(53) -> 5, safe_divide?(5, 2) -> 2, result should be 2
    
    @print("Basic results: {} {}", result1, result2);
    @print("Digit parsing: {} {}", digit, invalid);
    @print("Complex chain: {}", complex);
    @print("Nested: {}", nested);
}