// Working MNIST Editor - Simplified for Current MinZ Compiler
// Focus on SMC work areas and modern syntax

// Constants
const GRID_SIZE: u8 = 16;
const CANVAS_BYTES: u8 = 32;

// Editor state with SMC-optimized work area
type Editor = struct {
    cursor_x: u8,
    cursor_y: u8,
    canvas: [32]u8    // Work area - SMC will optimize access
};

// Initialize editor
fun editor_new() -> Editor {
    let mut editor: Editor;
    
    editor.cursor_x = 8;
    editor.cursor_y = 8;
    
    // Clear canvas - SMC optimizes array access
    let mut i: u8 = 0;
    while i < CANVAS_BYTES {
        editor.canvas[i] = 0;
        i = i + 1;
    }
    
    return editor;
}

// Toggle pixel in work area using SMC
fun toggle_pixel(editor: *Editor) -> void {
    let x: u8 = editor.cursor_x;
    let y: u8 = editor.cursor_y;
    
    // Calculate position in work area
    let byte_idx: u8 = (y * 2) + (x / 8);
    let bit_pos: u8 = x & 7;
    let bit_mask: u8 = 128 >> bit_pos;
    
    // SMC will patch this to efficient direct memory XOR
    let current: u8 = editor.canvas[byte_idx];
    editor.canvas[byte_idx] = current ^ bit_mask;
}

// Clear work area using SMC optimization  
fun clear_canvas(editor: *Editor) -> void {
    // Modern approach would be:
    // loop at editor.canvas -> !byte {
    //     byte = 0;
    // }
    
    // For now, traditional but SMC-optimized
    let mut i: u8 = 0;
    while i < CANVAS_BYTES {
        editor.canvas[i] = 0;  // SMC patches this to direct store
        i = i + 1;
    }
}

// Check if pixel is set in work area
fun is_pixel_set(editor: *Editor, x: u8, y: u8) -> bool {
    let byte_idx: u8 = (y * 2) + (x / 8);
    let bit_pos: u8 = x & 7;
    let bit_mask: u8 = 128 >> bit_pos;
    
    // SMC optimizes this work area access
    let canvas_byte: u8 = editor.canvas[byte_idx];
    return (canvas_byte & bit_mask) != 0;
}

// Simple keyboard simulation (for compilation)
fun read_key() -> u8 {
    return 255; // No keys pressed
}

// Move cursor up
fun move_up(editor: *Editor) -> void {
    if editor.cursor_y > 0 {
        editor.cursor_y = editor.cursor_y - 1;
    }
}

// Move cursor down
fun move_down(editor: *Editor) -> void {
    if editor.cursor_y < 15 {
        editor.cursor_y = editor.cursor_y + 1;
    }
}

// Move cursor left
fun move_left(editor: *Editor) -> void {
    if editor.cursor_x > 0 {
        editor.cursor_x = editor.cursor_x - 1;
    }
}

// Move cursor right
fun move_right(editor: *Editor) -> void {
    if editor.cursor_x < 15 {
        editor.cursor_x = editor.cursor_x + 1;
    }
}

// Handle input (simplified)
fun handle_input(editor: *Editor) -> bool {
    let key: u8 = read_key();
    let mut input_handled: bool = false;
    
    // Simulate key presses for testing
    // In real version, would check actual keyboard ports
    
    // For compilation test, just toggle pixel occasionally
    if (key & 1) == 0 {
        toggle_pixel(editor);
        input_handled = true;
    }
    
    return input_handled;
}

// Render canvas to screen (simplified)
fun render_canvas(editor: *Editor) -> void {
    // Scan through work area and "render" pixels
    let mut y: u8 = 0;
    while y < GRID_SIZE {
        let mut x: u8 = 0;
        while x < GRID_SIZE {
            // SMC-optimized work area access
            let pixel_on: bool = is_pixel_set(editor, x, y);
            
            // In real version, would set ZX Spectrum screen pixel
            // For now, just access the work area to show SMC optimization
            
            x = x + 1;
        }
        y = y + 1;
    }
}

// Simple delay
fun delay() -> void {
    let mut count: u16 = 0;
    while count < 500 {
        count = count + 1;
    }
}

// Print canvas state (for testing)
fun print_canvas_stats(editor: *Editor) -> void {
    let mut set_pixels: u16 = 0;
    
    // Count set pixels using work area
    let mut i: u8 = 0;
    while i < CANVAS_BYTES {
        let byte_val: u8 = editor.canvas[i];  // SMC optimized
        
        // Count bits set in this byte
        let mut bit_count: u8 = 0;
        let mut temp: u8 = byte_val;
        while temp != 0 {
            if (temp & 1) != 0 {
                bit_count = bit_count + 1;
            }
            temp = temp >> 1;
        }
        
        set_pixels = set_pixels + bit_count;
        i = i + 1;
    }
    
    // Stats calculated - in real version would display
}

// Main program demonstrating SMC work areas
fun main() -> void {
    // Initialize editor with SMC work area
    let mut editor: Editor = editor_new();
    
    // Simulation loop
    let mut frame: u16 = 0;
    while frame < 100 {  // Limited for testing
        
        // Render canvas - SMC optimizes work area access
        render_canvas(&editor);
        
        // Handle input - modifies work area via SMC
        if handle_input(&editor) {
            delay();
        }
        
        // Simulate some drawing activity
        if (frame & 7) == 0 {
            toggle_pixel(&editor);
            move_right(&editor);
        }
        
        if (frame & 15) == 0 {
            move_down(&editor);
        }
        
        // Calculate stats using work area
        print_canvas_stats(&editor);
        
        delay();
        frame = frame + 1;
    }
    
    // Final canvas clear using SMC
    clear_canvas(&editor);
}