; MinZ generated code
; Generated: 2025-08-16 20:13:17


; Data section
    ORG $F000

games_snake_SCREEN_WIDTH:
    DB 32
games_snake_SCREEN_HEIGHT:
    DB 24
games_snake_MAX_SNAKE_LENGTH:
    DB 100
games_snake_SCREEN_MEM:
    DW 16384
games_snake_ATTR_MEM:
    DW 22528
games_snake_BORDER_REG:
    DW 254

; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.clear_screen
games_snake_clear_screen:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = load games.snake.SCREEN_MEM
    LD HL, ($F060)
    ; store addr, r2
    LD ($F002), HL
    ; r4 = load games.snake.SCREEN_MEM
    LD HL, ($F060)
    ; r5 = 6144
    LD HL, 6144
    LD D, H
    LD E, L
    ; r6 = r4 + r5
    LD D, H
    LD E, L
    LD H, D
    LD L, E
    ADD HL, DE
    LD B, H
    LD C, L
    ; store end, r6
    LD H, B
    LD L, C
    LD ($F006), HL
    ; loop_1:
games_snake_clear_screen_loop_1:
    ; r7 = load addr
    LD HL, ($F002)
    ; r8 = load end
    LD HL, ($F006)
    ; r9 = r7 < r8
    EXX               ; Switch to shadow registers
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, games_snake_clear_screen_lt_true_0
    LD HL, 0       ; False
    JP games_snake_clear_screen_lt_done_0
games_snake_clear_screen_lt_true_0:
    LD HL, 1       ; True
games_snake_clear_screen_lt_done_0:
    ; jump_if_not r9, end_loop_2
    EXX               ; Switch to shadow registers
    LD A, D         ; From shadow D' (now active)
    EXX               ; Switch back to main registers
    OR A
    JP Z, games_snake_clear_screen_end_loop_2
    ; Inline assembly from @asm block
    LD HL, (addr)
    LD (HL), 0
    ; r10 = load addr
    LD HL, ($F002)
    ; r11 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; r12 = r10 + r11
    LD D, H
    LD E, L
    ; Register 11 already in HL
    ADD HL, DE
    ; store addr, r12
    LD ($F002), HL
    ; jump loop_1
    JP games_snake_clear_screen_loop_1
    ; end_loop_2:
games_snake_clear_screen_end_loop_2:
    ; r13 = load games.snake.ATTR_MEM
    LD HL, ($F080)
    ; store addr, r13
    LD ($F002), HL
    ; r14 = load games.snake.ATTR_MEM
    LD HL, ($F080)
    ; Register 14 already in HL
    ; r15 = 768
    LD HL, 768
    LD ($F01E), HL    ; Virtual register 15 to memory
    ; r16 = r14 + r15
    ; Register 14 already in HL
    LD D, H
    LD E, L
    LD HL, ($F01E)    ; Virtual register 15 from memory
    ADD HL, DE
    ; Register 16 already in HL
    ; store end, r16
    ; Register 16 already in HL
    LD ($F006), HL
    ; loop_3:
games_snake_clear_screen_loop_3:
    ; r17 = load addr
    LD HL, ($F002)
    ; Register 17 already in HL
    ; r18 = load end
    LD HL, ($F006)
    ; r19 = r17 < r18
    ; Register 17 already in HL
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, games_snake_clear_screen_lt_true_1
    LD HL, 0       ; False
    JP games_snake_clear_screen_lt_done_1
games_snake_clear_screen_lt_true_1:
    LD HL, 1       ; True
games_snake_clear_screen_lt_done_1:
    LD ($F026), HL    ; Virtual register 19 to memory
    ; jump_if_not r19, end_loop_4
    LD A, ($F026)     ; Virtual register 19 from memory
    OR A
    JP Z, games_snake_clear_screen_end_loop_4
    ; Inline assembly from @asm block
    LD HL, (addr)
    LD (HL), 7
    ; r20 = load addr
    LD HL, ($F002)
    ; Register 20 already in HL
    ; r21 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r22 = r20 + r21
    ; Register 20 already in HL
    LD D, H
    LD E, L
    ADD HL, DE
    ; store addr, r22
    LD ($F002), HL
    ; jump loop_3
    JP games_snake_clear_screen_loop_3
    ; end_loop_4:
games_snake_clear_screen_end_loop_4:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.plot_pixel$u8$u8$u8
games_snake_plot_pixel_u8_u8_u8:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; Inline assembly from @asm block
    LD A, (color)
    CP 0
    JR Z, clear_pixel
    ; Set pixel logic here
clear_pixel:
    ; Clear pixel logic here
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.set_border$u8
games_snake_set_border_u8:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; Inline assembly from @asm block
    LD A, (color)
    OUT (BORDER_REG), A
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.read_keyboard
games_snake_read_keyboard:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; Inline assembly from @asm block
    LD BC, 0xFBFE    // Port for Q,W,E,R,T row
    IN A, (C)
    CPL              // Invert bits (0 = pressed)
    AND 0x1F         // Mask to 5 bits
    ; r2 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; store keys_qwert, r2
    LD A, L
    LD ($F002), A
    ; Inline assembly from @asm block
    LD (keys_qwert), A
    ; Inline assembly from @asm block
    LD BC, 0xFDFE    // Port for A,S,D,F,G row
    IN A, (C)
    AND 0x1F
    ; r4 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; store keys_asdfg, r4
    LD A, H
    LD ($F006), A
    ; Inline assembly from @asm block
    LD (keys_asdfg), A

    ; *** SMART PATCHABLE RETURN SEQUENCE ***
    ; Default: Store to memory (most common complex case)
    ; For immediate use: Patch first NOP to RET for early return
games_snake_read_keyboard_return_patch_op:
NOP_PATCH_POINT: NOP or RET (C9) for early return
games_snake_read_keyboard_store_addr_op:
games.snake.read_keyboard_store_addr equ games.snake.read_keyboard_store_addr.op + 1
LD_0000_A_DEFAULT: Store result (address gets patched)
    RET                     ; Return after store
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.delay$u16
games_snake_delay_u16:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r3 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; store count, r3
    ; Register 3 already in HL
    LD ($F004), HL
    ; loop_5:
games_snake_delay_u16_loop_5:
    ; r4 = load count
    LD HL, ($F004)
    ; Register 4 already in HL
games_snake_delay_u16_param_frames_op:
games_snake_delay_u16_param_frames equ games_snake_delay_u16_param_frames_op + 1
    LD HL, #0000   ; SMC parameter frames
    LD ($F00A), HL    ; Virtual register 5 to memory
    ; r6 = r4 < r5
    ; Register 4 already in HL
    LD HL, ($F00A)    ; Virtual register 5 from memory
    EX DE, HL
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, games_snake_delay_u16_lt_true_2
    LD HL, 0       ; False
    JP games_snake_delay_u16_lt_done_2
games_snake_delay_u16_lt_true_2:
    LD HL, 1       ; True
games_snake_delay_u16_lt_done_2:
    ; Register 6 already in HL
    ; jump_if_not r6, end_loop_6
    LD A, L
    OR A
    JP Z, games_snake_delay_u16_end_loop_6
    ; Inline assembly from @asm block
    ; r7 = load count
    LD HL, ($F004)
    ; Register 7 already in HL
    ; r8 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r9 = r7 + r8
    ; Register 7 already in HL
    LD D, H
    LD E, L
    ADD HL, DE
    ; store count, r9
    LD ($F004), HL
    ; jump loop_5
    JP games_snake_delay_u16_loop_5
    ; end_loop_6:
games_snake_delay_u16_end_loop_6:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.init_snake
games_snake_init_snake:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r3 = load snake
    LD HL, ($F002)
    LD ($F006), HL    ; Virtual register 3 to memory
    ; Store to field length (offset 200)
    LD HL, ($F006)    ; Virtual register 3 from memory
    LD DE, 200
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r4 = 3
    LD A, 3
    LD L, A         ; Store to physical register L
    ; r5 = load snake
    LD HL, ($F002)
    LD ($F00A), HL    ; Virtual register 5 to memory
    ; Store to field direction (offset 201)
    LD HL, ($F00A)    ; Virtual register 5 from memory
    LD DE, 201
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r6 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r7 = load snake
    LD HL, ($F002)
    ; Store to field alive (offset 202)
    LD DE, 202
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r9 = 16
    LD A, 16
    LD ($F012), A     ; Virtual register 9 to memory
    ; r10 = load head
    LD HL, ($F010)
    ; Store to field x (offset 0)
    PUSH HL
    LD HL, ($F012)    ; Virtual register 9 from memory
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r11 = 12
    LD A, 12
    LD L, A         ; Store to physical register L
    ; r12 = load head
    LD HL, ($F010)
    ; Register 12 already in HL
    ; Store to field y (offset 1)
    ; Register 12 already in HL
    LD DE, 1
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r13 = load head
    LD HL, ($F010)
    ; r14 = load snake
    LD HL, ($F002)
    ; Load field body (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 15 already in HL
    ; r16 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Calculate array element address
    ; Register 15 already in HL
    LD D, H
    LD E, L
    ; Register 16 already in HL
    ADD HL, DE
    LD ($F022), HL    ; Virtual register 17 to memory
    ; Store to array[index] (games.snake.Point)
    LD HL, ($F022)    ; Virtual register 17 from memory
    PUSH HL
    EX DE, HL
    POP HL
    LD (HL), E
    INC HL
    LD (HL), D
    ; r18 = load snake
    LD HL, ($F002)
    ; Register 18 already in HL
    ; return r18
    ; Register 18 already in HL
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.init_game
games_snake_init_game:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = call games.snake.init_snake
    ; Call to games.snake.init_snake (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL games.snake.init_snake
    ; r3 = load game
    LD HL, ($F002)
    ; Store to field snake (offset 0)
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r5 = 10
    LD A, 10
    LD ($F00A), A     ; Virtual register 5 to memory
    ; r6 = load food
    LD HL, ($F008)
    ; Store to field x (offset 0)
    PUSH HL
    LD HL, ($F00A)    ; Virtual register 5 from memory
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r7 = 10
    LD A, 10
    LD L, A         ; Store to physical register L
    ; r8 = load food
    LD HL, ($F008)
    LD ($F010), HL    ; Virtual register 8 to memory
    ; Store to field y (offset 1)
    LD HL, ($F010)    ; Virtual register 8 from memory
    LD DE, 1
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r9 = load food
    LD HL, ($F008)
    ; r10 = load game
    LD HL, ($F002)
    ; Store to field food (offset 203)
    LD DE, 203
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r11 = 0
    LD A, 0
    LD ($F016), A     ; Virtual register 11 to memory
    ; r12 = load game
    LD HL, ($F002)
    ; Store to field score (offset 205)
    LD DE, 205
    ADD HL, DE
    PUSH HL
    LD HL, ($F016)    ; Virtual register 11 from memory
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r13 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r14 = load game
    LD HL, ($F002)
    ; Register 14 already in HL
    ; Store to field game_over (offset 207)
    ; Register 14 already in HL
    LD DE, 207
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r15 = load game
    LD HL, ($F002)
    ; return r15
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.move_snake$p_Snake
games_snake_move_snake_p_Snake:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
; TSMC reference parameter snake
snake_immOP:
    LD HL, 0000      ; TSMC ref address for snake
snake_imm0 EQU snake_immOP+1
    ; Load field length (offset 200)
    LD DE, 200
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r5 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r6 = r4 - r5
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A          ; Clear carry
    SBC HL, DE    ; HL = Src1 - Src2
    LD ($F00C), HL    ; Virtual register 6 to memory
    ; store i, r6
    LD A, ($F00C)     ; Virtual register 6 from memory
    LD ($F004), A
    ; loop_7:
games_snake_move_snake_p_Snake_loop_7:
    ; r7 = load i
    LD A, ($F004)
    LD L, A         ; Store to HL (low byte)
    ; r8 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; r9 = r7 > r8
    ; Register 7 already in HL
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP P, games_snake_move_snake_p_Snake_gt_check_zero_3
    LD HL, 0       ; False (negative)
    JP games_snake_move_snake_p_Snake_gt_done_3
games_snake_move_snake_p_Snake_gt_check_zero_3:
    LD A, H
    OR L           ; Check if result is zero
    JP Z, games_snake_move_snake_p_Snake_gt_false_3
    LD HL, 1       ; True (positive and non_zero)
    JP games_snake_move_snake_p_Snake_gt_done_3
games_snake_move_snake_p_Snake_gt_false_3:
    LD HL, 0       ; False (zero)
games_snake_move_snake_p_Snake_gt_done_3:
    ; jump_if_not r9, end_loop_8
    LD A, L
    OR A
    JP Z, games_snake_move_snake_p_Snake_end_loop_8
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F014), HL    ; Virtual register 10 to memory
    ; Load field body (offset 0)
    LD HL, ($F014)    ; Virtual register 10 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 11 already in HL
    ; r12 = load i
    LD A, ($F004)
    LD L, A         ; Store to HL (low byte)
    ; r13 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r14 = r12 - r13
    ; Register 12 already in HL
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A          ; Clear carry
    SBC HL, DE    ; HL = Src1 - Src2
    ; Load array element (games.snake.Point)
    ; Register 11 already in HL
    PUSH HL
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F01E), A     ; Virtual register 15 to memory
    LD HL, (snake_imm0) ; Reload TSMC ref address
    ; Register 16 already in HL
    ; Load field body (offset 0)
    ; Register 16 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 17 already in HL
    ; r18 = load i
    LD A, ($F004)
    LD L, A         ; Store to HL (low byte)
    ; Calculate array element address
    ; Register 17 already in HL
    LD D, H
    LD E, L
    ; Register 18 already in HL
    ADD HL, DE
    LD ($F026), HL    ; Virtual register 19 to memory
    ; Store to array[index] (games.snake.Point)
    LD HL, ($F026)    ; Virtual register 19 from memory
    PUSH HL
    LD HL, ($F01E)    ; Virtual register 15 from memory
    EX DE, HL
    POP HL
    LD (HL), E
    INC HL
    LD (HL), D
    ; r20 = load i
    LD A, ($F004)
    LD H, A         ; Store to physical register H
    ; r21 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r22 = r20 - r21
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A          ; Clear carry
    SBC HL, DE    ; HL = Src1 - Src2
    ; Register 22 already in HL
    ; store i, r22
    LD A, L
    LD ($F004), A
    ; jump loop_7
    JP games_snake_move_snake_p_Snake_loop_7
    ; end_loop_8:
games_snake_move_snake_p_Snake_end_loop_8:
    LD HL, (snake_imm0) ; Reload TSMC ref address
    ; Load field direction (offset 201)
    LD DE, 201
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r25 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r26 = r24 == r25
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_move_snake_p_Snake_eq_true_4
    LD HL, 0       ; False
    JP games_snake_move_snake_p_Snake_eq_done_4
games_snake_move_snake_p_Snake_eq_true_4:
    LD HL, 1       ; True
games_snake_move_snake_p_Snake_eq_done_4:
    ; Register 26 already in HL
    ; jump_if_not r26, else_9
    LD A, L
    OR A
    JP Z, games_snake_move_snake_p_Snake_else_9
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F036), HL    ; Virtual register 27 to memory
    ; Load field body (offset 0)
    LD HL, ($F036)    ; Virtual register 27 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 28 already in HL
    ; r29 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Load array element (games.snake.Point)
    ; Register 28 already in HL
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; Load field y (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r32 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r33 = r31 - r32
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A          ; Clear carry
    SBC HL, DE    ; HL = Src1 - Src2
    ; Register 33 already in HL
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F044), HL    ; Virtual register 34 to memory
    ; Load field body (offset 0)
    LD HL, ($F044)    ; Virtual register 34 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 35 already in HL
    ; r36 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Load array element (games.snake.Point)
    ; Register 35 already in HL
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F04A), A     ; Virtual register 37 to memory
    ; Store to field y (offset 1)
    LD HL, ($F04A)    ; Virtual register 37 from memory
    LD DE, 1
    ADD HL, DE
    PUSH HL
    ; Register 33 already in HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; jump end_if_10
    JP games_snake_move_snake_p_Snake_end_if_10
    ; else_9:
games_snake_move_snake_p_Snake_else_9:
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F04C), HL    ; Virtual register 38 to memory
    ; Load field direction (offset 201)
    LD HL, ($F04C)    ; Virtual register 38 from memory
    LD DE, 201
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r40 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r41 = r39 == r40
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_move_snake_p_Snake_eq_true_5
    LD HL, 0       ; False
    JP games_snake_move_snake_p_Snake_eq_done_5
games_snake_move_snake_p_Snake_eq_true_5:
    LD HL, 1       ; True
games_snake_move_snake_p_Snake_eq_done_5:
    ; Register 41 already in HL
    ; jump_if_not r41, else_11
    LD A, L
    OR A
    JP Z, games_snake_move_snake_p_Snake_else_11
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F054), HL    ; Virtual register 42 to memory
    ; Load field body (offset 0)
    LD HL, ($F054)    ; Virtual register 42 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 43 already in HL
    ; r44 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Load array element (games.snake.Point)
    ; Register 43 already in HL
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; Load field y (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r47 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r48 = r46 + r47
    LD D, H
    LD E, L
    ADD HL, DE
    ; Register 48 already in HL
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F062), HL    ; Virtual register 49 to memory
    ; Load field body (offset 0)
    LD HL, ($F062)    ; Virtual register 49 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 50 already in HL
    ; r51 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Load array element (games.snake.Point)
    ; Register 50 already in HL
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F068), A     ; Virtual register 52 to memory
    ; Store to field y (offset 1)
    LD HL, ($F068)    ; Virtual register 52 from memory
    LD DE, 1
    ADD HL, DE
    PUSH HL
    ; Register 48 already in HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; jump end_if_12
    JP games_snake_move_snake_p_Snake_end_if_12
    ; else_11:
games_snake_move_snake_p_Snake_else_11:
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F06A), HL    ; Virtual register 53 to memory
    ; Load field direction (offset 201)
    LD HL, ($F06A)    ; Virtual register 53 from memory
    LD DE, 201
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r55 = 2
    LD A, 2
    LD L, A         ; Store to physical register L
    ; r56 = r54 == r55
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_move_snake_p_Snake_eq_true_6
    LD HL, 0       ; False
    JP games_snake_move_snake_p_Snake_eq_done_6
games_snake_move_snake_p_Snake_eq_true_6:
    LD HL, 1       ; True
games_snake_move_snake_p_Snake_eq_done_6:
    ; Register 56 already in HL
    ; jump_if_not r56, else_13
    LD A, L
    OR A
    JP Z, games_snake_move_snake_p_Snake_else_13
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F072), HL    ; Virtual register 57 to memory
    ; Load field body (offset 0)
    LD HL, ($F072)    ; Virtual register 57 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 58 already in HL
    ; r59 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Load array element (games.snake.Point)
    ; Register 58 already in HL
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; Load field x (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r62 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r63 = r61 - r62
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A          ; Clear carry
    SBC HL, DE    ; HL = Src1 - Src2
    ; Register 63 already in HL
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F080), HL    ; Virtual register 64 to memory
    ; Load field body (offset 0)
    LD HL, ($F080)    ; Virtual register 64 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 65 already in HL
    ; r66 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Load array element (games.snake.Point)
    ; Register 65 already in HL
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F086), A     ; Virtual register 67 to memory
    ; Store to field x (offset 0)
    LD HL, ($F086)    ; Virtual register 67 from memory
    PUSH HL
    ; Register 63 already in HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; jump end_if_14
    JP games_snake_move_snake_p_Snake_end_if_14
    ; else_13:
games_snake_move_snake_p_Snake_else_13:
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F088), HL    ; Virtual register 68 to memory
    ; Load field direction (offset 201)
    LD HL, ($F088)    ; Virtual register 68 from memory
    LD DE, 201
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r70 = 3
    LD A, 3
    LD L, A         ; Store to physical register L
    ; r71 = r69 == r70
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_move_snake_p_Snake_eq_true_7
    LD HL, 0       ; False
    JP games_snake_move_snake_p_Snake_eq_done_7
games_snake_move_snake_p_Snake_eq_true_7:
    LD HL, 1       ; True
games_snake_move_snake_p_Snake_eq_done_7:
    ; Register 71 already in HL
    ; jump_if_not r71, else_15
    LD A, L
    OR A
    JP Z, games_snake_move_snake_p_Snake_else_15
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F090), HL    ; Virtual register 72 to memory
    ; Load field body (offset 0)
    LD HL, ($F090)    ; Virtual register 72 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 73 already in HL
    ; r74 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Load array element (games.snake.Point)
    ; Register 73 already in HL
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; Load field x (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r77 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r78 = r76 + r77
    LD D, H
    LD E, L
    ADD HL, DE
    ; Register 78 already in HL
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F09E), HL    ; Virtual register 79 to memory
    ; Load field body (offset 0)
    LD HL, ($F09E)    ; Virtual register 79 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 80 already in HL
    ; r81 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Load array element (games.snake.Point)
    ; Register 80 already in HL
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD L, A         ; Store to HL (low byte)
    ; Store to field x (offset 0)
    ; Register 82 already in HL
    PUSH HL
    ; Register 78 already in HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; jump end_if_16
    JP games_snake_move_snake_p_Snake_end_if_16
    ; else_15:
games_snake_move_snake_p_Snake_else_15:
    ; end_if_16:
games_snake_move_snake_p_Snake_end_if_16:
    ; end_if_14:
games_snake_move_snake_p_Snake_end_if_14:
    ; end_if_12:
games_snake_move_snake_p_Snake_end_if_12:
    ; end_if_10:
games_snake_move_snake_p_Snake_end_if_10:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.check_collision$p_Snake
games_snake_check_collision_p_Snake:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
; TSMC reference parameter snake
snake_immOP:
    LD HL, 0000      ; TSMC ref address for snake
snake_imm0 EQU snake_immOP+1
    ; Register 3 already in HL
    ; Load field body (offset 0)
    ; Register 3 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 4 already in HL
    ; r5 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Load array element (games.snake.Point)
    ; Register 4 already in HL
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F00C), A     ; Virtual register 6 to memory
    ; store head, r6
    LD HL, ($F00C)    ; Virtual register 6 from memory
    LD ($F004), HL
    ; r7 = load head
    LD HL, ($F004)
    ; Load field x (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r9 = load games.snake.SCREEN_WIDTH
    LD HL, ($F000)
    LD ($F012), HL    ; Virtual register 9 to memory
    ; r10 = r8 >= r9
    LD HL, ($F012)    ; Virtual register 9 from memory
    EX DE, HL
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP P, games_snake_check_collision_p_Snake_ge_true_8
    JP Z, games_snake_check_collision_p_Snake_ge_true_8
    LD HL, 0       ; False
    JP games_snake_check_collision_p_Snake_ge_done_8
games_snake_check_collision_p_Snake_ge_true_8:
    LD HL, 1       ; True
games_snake_check_collision_p_Snake_ge_done_8:
    ; r11 = load head
    LD HL, ($F004)
    ; Load field y (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F018), HL    ; Virtual register 12 to memory
    ; r13 = load games.snake.SCREEN_HEIGHT
    LD HL, ($F020)
    ; r14 = r12 >= r13
    LD HL, ($F018)    ; Virtual register 12 from memory
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP P, games_snake_check_collision_p_Snake_ge_true_9
    JP Z, games_snake_check_collision_p_Snake_ge_true_9
    LD HL, 0       ; False
    JP games_snake_check_collision_p_Snake_ge_done_9
games_snake_check_collision_p_Snake_ge_true_9:
    LD HL, 1       ; True
games_snake_check_collision_p_Snake_ge_done_9:
    ; unknown op 61
    LD A, H
    OR A           ; Test if zero
    JR NZ, lor_true_10      ; Skip if first operand is true
    LD A, L
    OR A           ; Test if zero
    JR NZ, lor_true_10      ; Skip if second operand is true
    XOR A          ; Result is false
    JR lor_end_11
lor_true_10:
    LD A, 1        ; Result is true (1)
lor_end_11:
    LD ($F01E), A     ; Virtual register 15 to memory
    ; jump_if_not r15, else_17
    LD A, ($F01E)     ; Virtual register 15 from memory
    OR A
    JP Z, games_snake_check_collision_p_Snake_else_17
    ; r16 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; return r16
    RET
    ; jump end_if_18
    JP games_snake_check_collision_p_Snake_end_if_18
    ; else_17:
games_snake_check_collision_p_Snake_else_17:
    ; end_if_18:
games_snake_check_collision_p_Snake_end_if_18:
    ; r18 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; store i, r18
    LD A, L
    LD ($F022), A
    ; loop_19:
games_snake_check_collision_p_Snake_loop_19:
    ; r19 = load i
    LD A, ($F022)
    LD H, A         ; Store to physical register H
    LD HL, (snake_imm0) ; Reload TSMC ref address
    ; Load field length (offset 200)
    LD DE, 200
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F02A), HL    ; Virtual register 21 to memory
    ; r22 = r19 < r21
    LD HL, ($F02A)    ; Virtual register 21 from memory
    EX DE, HL
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, games_snake_check_collision_p_Snake_lt_true_12
    LD HL, 0       ; False
    JP games_snake_check_collision_p_Snake_lt_done_12
games_snake_check_collision_p_Snake_lt_true_12:
    LD HL, 1       ; True
games_snake_check_collision_p_Snake_lt_done_12:
    ; jump_if_not r22, end_loop_20
    LD A, L
    OR A
    JP Z, games_snake_check_collision_p_Snake_end_loop_20
    ; r23 = load head
    LD HL, ($F004)
    ; Register 23 already in HL
    ; Load field x (offset 0)
    ; Register 23 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F032), HL    ; Virtual register 25 to memory
    ; Load field body (offset 0)
    LD HL, ($F032)    ; Virtual register 25 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 26 already in HL
    ; r27 = load i
    LD A, ($F022)
    LD L, A         ; Store to HL (low byte)
    ; Load array element (games.snake.Point)
    ; Register 26 already in HL
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; Load field x (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F03A), HL    ; Virtual register 29 to memory
    ; r30 = r24 == r29
    LD HL, ($F03A)    ; Virtual register 29 from memory
    EX DE, HL
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_check_collision_p_Snake_eq_true_13
    LD HL, 0       ; False
    JP games_snake_check_collision_p_Snake_eq_done_13
games_snake_check_collision_p_Snake_eq_true_13:
    LD HL, 1       ; True
games_snake_check_collision_p_Snake_eq_done_13:
    ; r31 = load head
    LD HL, ($F004)
    ; Register 31 already in HL
    ; Load field y (offset 1)
    ; Register 31 already in HL
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F042), HL    ; Virtual register 33 to memory
    ; Load field body (offset 0)
    LD HL, ($F042)    ; Virtual register 33 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 34 already in HL
    ; r35 = load i
    LD A, ($F022)
    LD L, A         ; Store to HL (low byte)
    ; Load array element (games.snake.Point)
    ; Register 34 already in HL
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; Load field y (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F04A), HL    ; Virtual register 37 to memory
    ; r38 = r32 == r37
    LD HL, ($F04A)    ; Virtual register 37 from memory
    EX DE, HL
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_check_collision_p_Snake_eq_true_14
    LD HL, 0       ; False
    JP games_snake_check_collision_p_Snake_eq_done_14
games_snake_check_collision_p_Snake_eq_true_14:
    LD HL, 1       ; True
games_snake_check_collision_p_Snake_eq_done_14:
    ; unknown op 60
    LD A, L
    OR A           ; Test if zero
    JR Z, land_false_15       ; Skip if first operand is false
    LD A, L
    OR A           ; Test if zero
    JR Z, land_false_15       ; Skip if second operand is false
    LD A, 1        ; Result is true
    JR land_end_16
land_false_15:
    XOR A          ; Result is false (0)
land_end_16:
    LD ($F04E), A     ; Virtual register 39 to memory
    ; jump_if_not r39, else_21
    LD A, ($F04E)     ; Virtual register 39 from memory
    OR A
    JP Z, games_snake_check_collision_p_Snake_else_21
    ; r40 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; return r40
    RET
    ; jump end_if_22
    JP games_snake_check_collision_p_Snake_end_if_22
    ; else_21:
games_snake_check_collision_p_Snake_else_21:
    ; end_if_22:
games_snake_check_collision_p_Snake_end_if_22:
    ; r41 = load i
    LD A, ($F022)
    LD L, A         ; Store to physical register L
    ; r42 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; r43 = r41 + r42
    LD D, H
    LD E, L
    ; Register 42 already in HL
    ADD HL, DE
    ; store i, r43
    LD A, H
    LD ($F022), A
    ; jump loop_19
    JP games_snake_check_collision_p_Snake_loop_19
    ; end_loop_20:
games_snake_check_collision_p_Snake_end_loop_20:
    ; r44 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    LD A, L

    ; *** SMART PATCHABLE RETURN SEQUENCE ***
    ; Default: Store to memory (most common complex case)
    ; For immediate use: Patch first NOP to RET for early return
games_snake_check_collision_p_Snake_return_patch_op:
NOP_PATCH_POINT: NOP or RET (C9) for early return
games_snake_check_collision_p_Snake_store_addr_op:
games_snake_check_collision_p_Snake_store_addr equ games_snake_check_collision_p_Snake_store_addr_op + 1
LD_0000_A_DEFAULT: Store result (address gets patched)
    RET                     ; Return after store
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.check_food_collision$p_Snake$p_Point
games_snake_check_food_collision_p_Snake_p_Point:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
; TSMC reference parameter snake
snake_immOP:
    LD HL, 0000      ; TSMC ref address for snake
snake_imm0 EQU snake_immOP+1
    LD ($F008), HL    ; Virtual register 4 to memory
    ; Load field body (offset 0)
    LD HL, ($F008)    ; Virtual register 4 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 5 already in HL
    ; r6 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Load array element (games.snake.Point)
    ; Register 5 already in HL
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F00E), A     ; Virtual register 7 to memory
    ; store head, r7
    LD HL, ($F00E)    ; Virtual register 7 from memory
    LD ($F006), HL
    ; r8 = load head
    LD HL, ($F006)
    ; Register 8 already in HL
    ; Load field x (offset 0)
    ; Register 8 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
; TSMC reference parameter food
food_immOP:
    LD HL, 0000      ; TSMC ref address for food
food_imm0 EQU food_immOP+1
    ; Load field x (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r12 = r9 == r11
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_check_food_collision_p_Snake_p_Point_eq_true_17
    LD HL, 0       ; False
    JP games_snake_check_food_collision_p_Snake_p_Point_eq_done_17
games_snake_check_food_collision_p_Snake_p_Point_eq_true_17:
    LD HL, 1       ; True
games_snake_check_food_collision_p_Snake_p_Point_eq_done_17:
    ; Register 12 already in HL
    ; r13 = load head
    LD HL, ($F006)
    ; Load field y (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD HL, (food_imm0) ; Reload TSMC ref address
    ; Load field y (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r17 = r14 == r16
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_check_food_collision_p_Snake_p_Point_eq_true_18
    LD HL, 0       ; False
    JP games_snake_check_food_collision_p_Snake_p_Point_eq_done_18
games_snake_check_food_collision_p_Snake_p_Point_eq_true_18:
    LD HL, 1       ; True
games_snake_check_food_collision_p_Snake_p_Point_eq_done_18:
    LD ($F022), HL    ; Virtual register 17 to memory
    ; unknown op 60
    LD A, L
    OR A           ; Test if zero
    JR Z, land_false_19       ; Skip if first operand is false
    LD A, ($F022)     ; Virtual register 17 from memory
    OR A           ; Test if zero
    JR Z, land_false_19       ; Skip if second operand is false
    LD A, 1        ; Result is true
    JR land_end_20
land_false_19:
    XOR A          ; Result is false (0)
land_end_20:
    LD H, A         ; Store to physical register H
    ; jump_if_not r18, else_23
    LD A, H
    OR A
    JP Z, games_snake_check_food_collision_p_Snake_p_Point_else_23
    ; r19 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; return r19
    RET
    ; jump end_if_24
    JP games_snake_check_food_collision_p_Snake_p_Point_end_if_24
    ; else_23:
games_snake_check_food_collision_p_Snake_p_Point_else_23:
    ; end_if_24:
games_snake_check_food_collision_p_Snake_p_Point_end_if_24:
    ; r20 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    LD A, L

    ; *** SMART PATCHABLE RETURN SEQUENCE ***
    ; Default: Store to memory (most common complex case)
    ; For immediate use: Patch first NOP to RET for early return
games_snake_check_food_collision_p_Snake_p_Point_return_patch_op:
NOP_PATCH_POINT: NOP or RET (C9) for early return
games_snake_check_food_collision_p_Snake_p_Point_store_addr_op:
games_snake_check_food_collision_p_Snake_p_Point_store_addr equ games_snake_check_food_collision_p_Snake_p_Point_store_addr_op + 1
LD_0000_A_DEFAULT: Store result (address gets patched)
    RET                     ; Return after store
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.grow_snake$p_Snake
games_snake_grow_snake_p_Snake:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
; TSMC reference parameter snake
snake_immOP:
    LD HL, 0000      ; TSMC ref address for snake
snake_imm0 EQU snake_immOP+1
    ; Load field length (offset 200)
    LD DE, 200
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r4 = load games.snake.MAX_SNAKE_LENGTH
    LD HL, ($F040)
    ; r5 = r3 < r4
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, games_snake_grow_snake_p_Snake_lt_true_21
    LD HL, 0       ; False
    JP games_snake_grow_snake_p_Snake_lt_done_21
games_snake_grow_snake_p_Snake_lt_true_21:
    LD HL, 1       ; True
games_snake_grow_snake_p_Snake_lt_done_21:
    ; Register 5 already in HL
    ; jump_if_not r5, else_25
    LD A, L
    OR A
    JP Z, games_snake_grow_snake_p_Snake_else_25
    LD HL, (snake_imm0) ; Reload TSMC ref address
    ; Load field length (offset 200)
    LD DE, 200
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r8 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r9 = r7 + r8
    LD D, H
    LD E, L
    ADD HL, DE
    ; Register 9 already in HL
    LD HL, (snake_imm0) ; Reload TSMC ref address
    ; Register 10 already in HL
    ; Store to field length (offset 200)
    ; Register 10 already in HL
    LD DE, 200
    ADD HL, DE
    PUSH HL
    ; Register 9 already in HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; jump end_if_26
    JP games_snake_grow_snake_p_Snake_end_if_26
    ; else_25:
games_snake_grow_snake_p_Snake_else_25:
    ; end_if_26:
games_snake_grow_snake_p_Snake_end_if_26:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.generate_food$p_Snake
games_snake_generate_food_p_Snake:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r3 = 15
    LD A, 15
    LD ($F006), A     ; Virtual register 3 to memory
    ; r4 = load food
    LD HL, ($F004)
    ; Store to field x (offset 0)
    PUSH HL
    LD HL, ($F006)    ; Virtual register 3 from memory
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r5 = 8
    LD A, 8
    LD L, A         ; Store to physical register L
    ; r6 = load food
    LD HL, ($F004)
    ; Register 6 already in HL
    ; Store to field y (offset 1)
    ; Register 6 already in HL
    LD DE, 1
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r7 = load food
    LD HL, ($F004)
    ; return r7
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.handle_input$p_Snake
games_snake_handle_input_p_Snake:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; unknown op 39
    ; Smart patch 'store_u8' for games.snake.read_keyboard_return_patch
    LD A, #00               ; NOP opcode
    LD (games.snake.read_keyboard_return_patch.op), A
    ; unknown op 40
    ; Patch storage address: temp_result
    LD HL, temp_result
    LD (games.snake.read_keyboard_store_addr), HL
    ; r3 = call games.snake.read_keyboard
    ; Call to games.snake.read_keyboard (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL games.snake.read_keyboard
    ; store key, r3
    LD A, L
    LD ($F004), A
    ; r4 = load key
    LD A, ($F004)
    LD H, A         ; Store to physical register H
    ; r5 = 87
    LD A, 87
    LD L, A         ; Store to physical register L
    ; r6 = r4 == r5
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_handle_input_p_Snake_eq_true_22
    LD HL, 0       ; False
    JP games_snake_handle_input_p_Snake_eq_done_22
games_snake_handle_input_p_Snake_eq_true_22:
    LD HL, 1       ; True
games_snake_handle_input_p_Snake_eq_done_22:
    ; Register 6 already in HL
    ; jump_if_not r6, else_27
    LD A, L
    OR A
    JP Z, games_snake_handle_input_p_Snake_else_27
; TSMC reference parameter snake
snake_immOP:
    LD HL, 0000      ; TSMC ref address for snake
snake_imm0 EQU snake_immOP+1
    ; Load field direction (offset 201)
    LD DE, 201
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r9 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r10 = r8 != r9
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP NZ, games_snake_handle_input_p_Snake_ne_true_23
    LD HL, 0       ; False
    JP games_snake_handle_input_p_Snake_ne_done_23
games_snake_handle_input_p_Snake_ne_true_23:
    LD HL, 1       ; True
games_snake_handle_input_p_Snake_ne_done_23:
    ; Register 10 already in HL
    ; jump_if_not r10, else_29
    LD A, L
    OR A
    JP Z, games_snake_handle_input_p_Snake_else_29
    ; r11 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F018), HL    ; Virtual register 12 to memory
    ; Store to field direction (offset 201)
    LD HL, ($F018)    ; Virtual register 12 from memory
    LD DE, 201
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; jump end_if_30
    JP games_snake_handle_input_p_Snake_end_if_30
    ; else_29:
games_snake_handle_input_p_Snake_else_29:
    ; end_if_30:
games_snake_handle_input_p_Snake_end_if_30:
    ; jump end_if_28
    JP games_snake_handle_input_p_Snake_end_if_28
    ; else_27:
games_snake_handle_input_p_Snake_else_27:
    ; r13 = load key
    LD A, ($F004)
    LD L, A         ; Store to HL (low byte)
    ; r14 = 83
    LD A, 83
    LD H, A         ; Store to physical register H
    ; r15 = r13 == r14
    ; Register 13 already in HL
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_handle_input_p_Snake_eq_true_24
    LD HL, 0       ; False
    JP games_snake_handle_input_p_Snake_eq_done_24
games_snake_handle_input_p_Snake_eq_true_24:
    LD HL, 1       ; True
games_snake_handle_input_p_Snake_eq_done_24:
    ; jump_if_not r15, else_31
    LD A, L
    OR A
    JP Z, games_snake_handle_input_p_Snake_else_31
    LD HL, (snake_imm0) ; Reload TSMC ref address
    ; Load field direction (offset 201)
    LD DE, 201
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r18 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r19 = r17 != r18
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP NZ, games_snake_handle_input_p_Snake_ne_true_25
    LD HL, 0       ; False
    JP games_snake_handle_input_p_Snake_ne_done_25
games_snake_handle_input_p_Snake_ne_true_25:
    LD HL, 1       ; True
games_snake_handle_input_p_Snake_ne_done_25:
    ; Register 19 already in HL
    ; jump_if_not r19, else_33
    LD A, L
    OR A
    JP Z, games_snake_handle_input_p_Snake_else_33
    ; r20 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F02A), HL    ; Virtual register 21 to memory
    ; Store to field direction (offset 201)
    LD HL, ($F02A)    ; Virtual register 21 from memory
    LD DE, 201
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; jump end_if_34
    JP games_snake_handle_input_p_Snake_end_if_34
    ; else_33:
games_snake_handle_input_p_Snake_else_33:
    ; end_if_34:
games_snake_handle_input_p_Snake_end_if_34:
    ; jump end_if_32
    JP games_snake_handle_input_p_Snake_end_if_32
    ; else_31:
games_snake_handle_input_p_Snake_else_31:
    ; r22 = load key
    LD A, ($F004)
    LD L, A         ; Store to HL (low byte)
    ; r23 = 65
    LD A, 65
    LD H, A         ; Store to physical register H
    ; r24 = r22 == r23
    ; Register 22 already in HL
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_handle_input_p_Snake_eq_true_26
    LD HL, 0       ; False
    JP games_snake_handle_input_p_Snake_eq_done_26
games_snake_handle_input_p_Snake_eq_true_26:
    LD HL, 1       ; True
games_snake_handle_input_p_Snake_eq_done_26:
    ; jump_if_not r24, else_35
    LD A, L
    OR A
    JP Z, games_snake_handle_input_p_Snake_else_35
    LD HL, (snake_imm0) ; Reload TSMC ref address
    ; Load field direction (offset 201)
    LD DE, 201
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r27 = 3
    LD A, 3
    LD L, A         ; Store to physical register L
    ; r28 = r26 != r27
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP NZ, games_snake_handle_input_p_Snake_ne_true_27
    LD HL, 0       ; False
    JP games_snake_handle_input_p_Snake_ne_done_27
games_snake_handle_input_p_Snake_ne_true_27:
    LD HL, 1       ; True
games_snake_handle_input_p_Snake_ne_done_27:
    ; Register 28 already in HL
    ; jump_if_not r28, else_37
    LD A, L
    OR A
    JP Z, games_snake_handle_input_p_Snake_else_37
    ; r29 = 2
    LD A, 2
    LD L, A         ; Store to physical register L
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F03C), HL    ; Virtual register 30 to memory
    ; Store to field direction (offset 201)
    LD HL, ($F03C)    ; Virtual register 30 from memory
    LD DE, 201
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; jump end_if_38
    JP games_snake_handle_input_p_Snake_end_if_38
    ; else_37:
games_snake_handle_input_p_Snake_else_37:
    ; end_if_38:
games_snake_handle_input_p_Snake_end_if_38:
    ; jump end_if_36
    JP games_snake_handle_input_p_Snake_end_if_36
    ; else_35:
games_snake_handle_input_p_Snake_else_35:
    ; r31 = load key
    LD A, ($F004)
    LD L, A         ; Store to HL (low byte)
    ; r32 = 68
    LD A, 68
    LD H, A         ; Store to physical register H
    ; r33 = r31 == r32
    ; Register 31 already in HL
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_handle_input_p_Snake_eq_true_28
    LD HL, 0       ; False
    JP games_snake_handle_input_p_Snake_eq_done_28
games_snake_handle_input_p_Snake_eq_true_28:
    LD HL, 1       ; True
games_snake_handle_input_p_Snake_eq_done_28:
    ; jump_if_not r33, else_39
    LD A, L
    OR A
    JP Z, games_snake_handle_input_p_Snake_else_39
    LD HL, (snake_imm0) ; Reload TSMC ref address
    ; Load field direction (offset 201)
    LD DE, 201
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r36 = 2
    LD A, 2
    LD L, A         ; Store to physical register L
    ; r37 = r35 != r36
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP NZ, games_snake_handle_input_p_Snake_ne_true_29
    LD HL, 0       ; False
    JP games_snake_handle_input_p_Snake_ne_done_29
games_snake_handle_input_p_Snake_ne_true_29:
    LD HL, 1       ; True
games_snake_handle_input_p_Snake_ne_done_29:
    ; Register 37 already in HL
    ; jump_if_not r37, else_41
    LD A, L
    OR A
    JP Z, games_snake_handle_input_p_Snake_else_41
    ; r38 = 3
    LD A, 3
    LD L, A         ; Store to physical register L
    LD HL, (snake_imm0) ; Reload TSMC ref address
    LD ($F04E), HL    ; Virtual register 39 to memory
    ; Store to field direction (offset 201)
    LD HL, ($F04E)    ; Virtual register 39 from memory
    LD DE, 201
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; jump end_if_42
    JP games_snake_handle_input_p_Snake_end_if_42
    ; else_41:
games_snake_handle_input_p_Snake_else_41:
    ; end_if_42:
games_snake_handle_input_p_Snake_end_if_42:
    ; jump end_if_40
    JP games_snake_handle_input_p_Snake_end_if_40
    ; else_39:
games_snake_handle_input_p_Snake_else_39:
    ; r40 = load key
    LD A, ($F004)
    LD ($F050), A     ; Virtual register 40 to memory
    ; r41 = 81
    LD A, 81
    LD H, A         ; Store to physical register H
    ; r42 = r40 == r41
    LD HL, ($F050)    ; Virtual register 40 from memory
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_handle_input_p_Snake_eq_true_30
    LD HL, 0       ; False
    JP games_snake_handle_input_p_Snake_eq_done_30
games_snake_handle_input_p_Snake_eq_true_30:
    LD HL, 1       ; True
games_snake_handle_input_p_Snake_eq_done_30:
    ; jump_if_not r42, else_43
    LD A, L
    OR A
    JP Z, games_snake_handle_input_p_Snake_else_43
    ; r43 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    LD HL, (snake_imm0) ; Reload TSMC ref address
    ; Register 44 already in HL
    ; Store to field alive (offset 202)
    ; Register 44 already in HL
    LD DE, 202
    ADD HL, DE
    PUSH HL
    ; Register 43 already in HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; jump end_if_44
    JP games_snake_handle_input_p_Snake_end_if_44
    ; else_43:
games_snake_handle_input_p_Snake_else_43:
    ; end_if_44:
games_snake_handle_input_p_Snake_end_if_44:
    ; end_if_40:
games_snake_handle_input_p_Snake_end_if_40:
    ; end_if_36:
games_snake_handle_input_p_Snake_end_if_36:
    ; end_if_32:
games_snake_handle_input_p_Snake_end_if_32:
    ; end_if_28:
games_snake_handle_input_p_Snake_end_if_28:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.render_game$p_GameState
games_snake_render_game_p_GameState:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = call games.snake.clear_screen
    ; Call to games.snake.clear_screen (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL games.snake.clear_screen
    LD ($F004), HL    ; Virtual register 2 to memory
    ; r3 = 4
    LD A, 4
    LD H, A         ; Store to physical register H
    ; r4 = 4
    LD A, 4
    LD L, A         ; Store to physical register L
    ; r5 = call games.snake.set_border$u8
    ; Call to games.snake.set_border$u8 (args: 1)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_set_border_u8
    LD ($F00A), HL    ; Virtual register 5 to memory
    ; r7 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; store i, r7
    LD A, H
    LD ($F00C), A
    ; loop_45:
games_snake_render_game_p_GameState_loop_45:
    ; r8 = load i
    LD A, ($F00C)
    LD L, A         ; Store to HL (low byte)
; TSMC reference parameter game
game_immOP:
    LD HL, 0000      ; TSMC ref address for game
game_imm0 EQU game_immOP+1
    LD ($F012), HL    ; Virtual register 9 to memory
    ; Load field snake (offset 0)
    LD HL, ($F012)    ; Virtual register 9 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 10 already in HL
    ; Load field length (offset 200)
    ; Register 10 already in HL
    LD DE, 200
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 11 already in HL
    ; r12 = r8 < r11
    ; Register 8 already in HL
    LD D, H
    LD E, L
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, games_snake_render_game_p_GameState_lt_true_31
    LD HL, 0       ; False
    JP games_snake_render_game_p_GameState_lt_done_31
games_snake_render_game_p_GameState_lt_true_31:
    LD HL, 1       ; True
games_snake_render_game_p_GameState_lt_done_31:
    ; jump_if_not r12, end_loop_46
    LD A, H
    OR A
    JP Z, games_snake_render_game_p_GameState_end_loop_46
    LD HL, (game_imm0) ; Reload TSMC ref address
    LD ($F01C), HL    ; Virtual register 14 to memory
    ; Load field snake (offset 0)
    LD HL, ($F01C)    ; Virtual register 14 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 15 already in HL
    ; Load field body (offset 0)
    ; Register 15 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 16 already in HL
    ; r17 = load i
    LD A, ($F00C)
    LD H, A         ; Store to physical register H
    ; Load array element (games.snake.Point)
    ; Register 16 already in HL
    PUSH HL
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F024), A     ; Virtual register 18 to memory
    ; store segment, r18
    LD HL, ($F024)    ; Virtual register 18 from memory
    LD ($F01A), HL
    ; r19 = load segment
    LD HL, ($F01A)
    LD ($F026), HL    ; Virtual register 19 to memory
    ; Load field x (offset 0)
    LD HL, ($F026)    ; Virtual register 19 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r21 = load segment
    LD HL, ($F01A)
    ; Load field y (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F02C), HL    ; Virtual register 22 to memory
    ; r23 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r24 = load segment
    LD HL, ($F01A)
    ; Load field x (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F032), HL    ; Virtual register 25 to memory
    ; r26 = load segment
    LD HL, ($F01A)
    ; Load field y (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r28 = 1
    LD A, 1
    LD ($F038), A     ; Virtual register 28 to memory
    ; r29 = call games.snake.plot_pixel$u8$u8$u8
    ; Call to games.snake.plot_pixel$u8$u8$u8 (args: 3)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_plot_pixel_u8_u8_u8
    ; r30 = load i
    LD A, ($F00C)
    LD L, A         ; Store to physical register L
    ; r31 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; r32 = r30 + r31
    LD D, H
    LD E, L
    ; Register 31 already in HL
    ADD HL, DE
    ; store i, r32
    LD A, H
    LD ($F00C), A
    ; jump loop_45
    JP games_snake_render_game_p_GameState_loop_45
    ; end_loop_46:
games_snake_render_game_p_GameState_end_loop_46:
    LD HL, (game_imm0) ; Reload TSMC ref address
    LD ($F042), HL    ; Virtual register 33 to memory
    ; Load field food (offset 203)
    LD HL, ($F042)    ; Virtual register 33 from memory
    LD DE, 203
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 34 already in HL
    ; Load field x (offset 0)
    ; Register 34 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 35 already in HL
    LD HL, (game_imm0) ; Reload TSMC ref address
    LD ($F048), HL    ; Virtual register 36 to memory
    ; Load field food (offset 203)
    LD HL, ($F048)    ; Virtual register 36 from memory
    LD DE, 203
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 37 already in HL
    ; Load field y (offset 1)
    ; Register 37 already in HL
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 38 already in HL
    ; r39 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    LD HL, (game_imm0) ; Reload TSMC ref address
    LD ($F050), HL    ; Virtual register 40 to memory
    ; Load field food (offset 203)
    LD HL, ($F050)    ; Virtual register 40 from memory
    LD DE, 203
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 41 already in HL
    ; Load field x (offset 0)
    ; Register 41 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 42 already in HL
    LD HL, (game_imm0) ; Reload TSMC ref address
    LD ($F056), HL    ; Virtual register 43 to memory
    ; Load field food (offset 203)
    LD HL, ($F056)    ; Virtual register 43 from memory
    LD DE, 203
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 44 already in HL
    ; Load field y (offset 1)
    ; Register 44 already in HL
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 45 already in HL
    ; r46 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r47 = call games.snake.plot_pixel$u8$u8$u8
    ; Call to games.snake.plot_pixel$u8$u8$u8 (args: 3)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_plot_pixel_u8_u8_u8
    LD HL, (game_imm0) ; Reload TSMC ref address
    ; Register 48 already in HL
    ; Load field score (offset 205)
    ; Register 48 already in HL
    LD DE, 205
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 49 already in HL
    ; Call runtime print_u16_decimal
    ; Call to print_u16_decimal (args: 1)
    ; Stack-based parameter passing
    ; Register 49 already in HL
    PUSH HL       ; Argument 0
    CALL print_u16_decimal
    LD ($F000), HL    ; Virtual register 0 to memory
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.game_loop
games_snake_game_loop:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = call games.snake.init_game
    ; Call to games.snake.init_game (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL games.snake.init_game
    ; Register 2 already in HL
    ; store game, r2
    ; Register 2 already in HL
    LD ($F002), HL
    ; r3 = load game
    LD HL, ($F002)
    LD ($F006), HL    ; Virtual register 3 to memory
    ; r4 = &r3
    ; Address-of operation for register r3
    LD HL, $F006  ; Variable address
    ; r5 = load game
    LD HL, ($F002)
    ; r6 = &r5
    ; Address-of operation for register r5
    LD HL, $F00A  ; Variable address
    LD ($F00C), HL    ; Virtual register 6 to memory
    ; r7 = call games.snake.render_game$p_GameState
    ; Call to games.snake.render_game$p_GameState (args: 1)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_render_game_p_GameState
    ; loop_47:
games_snake_game_loop_loop_47:
    ; r8 = load game
    LD HL, ($F002)
    ; Load field game_over (offset 207)
    LD DE, 207
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F012), HL    ; Virtual register 9 to memory
    ; r10 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; r11 = r9 == r10
    LD HL, ($F012)    ; Virtual register 9 from memory
    LD E, H        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_game_loop_eq_true_32
    LD HL, 0       ; False
    JP games_snake_game_loop_eq_done_32
games_snake_game_loop_eq_true_32:
    LD HL, 1       ; True
games_snake_game_loop_eq_done_32:
    ; r12 = load game
    LD HL, ($F002)
    ; Register 12 already in HL
    ; Load field snake (offset 0)
    ; Register 12 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Load field alive (offset 202)
    LD DE, 202
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r15 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r16 = r14 == r15
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_game_loop_eq_true_33
    LD HL, 0       ; False
    JP games_snake_game_loop_eq_done_33
games_snake_game_loop_eq_true_33:
    LD HL, 1       ; True
games_snake_game_loop_eq_done_33:
    LD ($F020), HL    ; Virtual register 16 to memory
    ; unknown op 60
    LD A, L
    OR A           ; Test if zero
    JR Z, land_false_34       ; Skip if first operand is false
    LD A, ($F020)     ; Virtual register 16 from memory
    OR A           ; Test if zero
    JR Z, land_false_34       ; Skip if second operand is false
    LD A, 1        ; Result is true
    JR land_end_35
land_false_34:
    XOR A          ; Result is false (0)
land_end_35:
    LD L, A         ; Store to physical register L
    ; jump_if_not r17, end_loop_48
    LD A, L
    OR A
    JP Z, games_snake_game_loop_end_loop_48
    ; r18 = load game
    LD HL, ($F002)
    ; Register 18 already in HL
    ; Load field snake (offset 0)
    ; Register 18 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r20 = &r19
    ; Address-of operation for register r19
    LD HL, $F026  ; Variable address
    ; Register 20 already in HL
    ; r21 = load game
    LD HL, ($F002)
    ; Load field snake (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r23 = &r22
    ; Address-of operation for register r22
    LD HL, $F02C  ; Variable address
    LD ($F02E), HL    ; Virtual register 23 to memory
    ; r24 = call games.snake.handle_input$p_Snake
    ; Call to games.snake.handle_input$p_Snake (args: 1)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_handle_input_p_Snake
    ; r25 = load game
    LD HL, ($F002)
    ; Register 25 already in HL
    ; Load field snake (offset 0)
    ; Register 25 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Load field alive (offset 202)
    LD DE, 202
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r28 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r29 = r27 == r28
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_game_loop_eq_true_36
    LD HL, 0       ; False
    JP games_snake_game_loop_eq_done_36
games_snake_game_loop_eq_true_36:
    LD HL, 1       ; True
games_snake_game_loop_eq_done_36:
    ; Register 29 already in HL
    ; jump_if_not r29, else_49
    LD A, L
    OR A
    JP Z, games_snake_game_loop_else_49
    ; jump end_if_50
    JP games_snake_game_loop_end_if_50
    ; else_49:
games_snake_game_loop_else_49:
    ; end_if_50:
games_snake_game_loop_end_if_50:
    ; r30 = load game
    LD HL, ($F002)
    ; Load field snake (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r32 = &r31
    ; Address-of operation for register r31
    LD HL, $F03E  ; Variable address
    ; Register 32 already in HL
    ; r33 = load game
    LD HL, ($F002)
    ; Load field snake (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r35 = &r34
    ; Address-of operation for register r34
    LD HL, $F044  ; Variable address
    LD ($F046), HL    ; Virtual register 35 to memory
    ; r36 = call games.snake.move_snake$p_Snake
    ; Call to games.snake.move_snake$p_Snake (args: 1)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_move_snake_p_Snake
    ; r37 = load game
    LD HL, ($F002)
    ; Register 37 already in HL
    ; Load field snake (offset 0)
    ; Register 37 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r39 = &r38
    ; Address-of operation for register r38
    LD HL, $F04C  ; Variable address
    ; Register 39 already in HL
    ; r40 = load game
    LD HL, ($F002)
    ; Load field snake (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r42 = &r41
    ; Address-of operation for register r41
    LD HL, $F052  ; Variable address
    LD ($F054), HL    ; Virtual register 42 to memory
    ; unknown op 39
    ; Smart patch 'store_u8' for games.snake.check_collision$p_Snake_return_patch
    LD A, #00               ; NOP opcode
    LD (games_snake_check_collision_p_Snake_return_patch_op), A
    ; unknown op 40
    ; Patch storage address: temp_result
    LD HL, temp_result
    LD (games_snake_check_collision_p_Snake_store_addr), HL
    ; unknown op 41
    ; Patch parameter snake = 0
    LD HL, 0              ; Parameter value
    LD (games_snake_check_collision_p_Snake_param_snake+1), HL  ; Patch parameter immediate
    ; r43 = call games.snake.check_collision$p_Snake
    ; Call to games.snake.check_collision$p_Snake (args: 1)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_check_collision_p_Snake
    ; r44 = 1
    LD A, 1
    LD ($F058), A     ; Virtual register 44 to memory
    ; r45 = r43 == r44
    LD HL, ($F058)    ; Virtual register 44 from memory
    EX DE, HL
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_game_loop_eq_true_37
    LD HL, 0       ; False
    JP games_snake_game_loop_eq_done_37
games_snake_game_loop_eq_true_37:
    LD HL, 1       ; True
games_snake_game_loop_eq_done_37:
    ; jump_if_not r45, else_51
    LD A, H
    OR A
    JP Z, games_snake_game_loop_else_51
    ; r46 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r47 = load game
    LD HL, ($F002)
    ; Register 47 already in HL
    ; Store to field game_over (offset 207)
    ; Register 47 already in HL
    LD DE, 207
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; jump end_if_52
    JP games_snake_game_loop_end_if_52
    ; else_51:
games_snake_game_loop_else_51:
    ; end_if_52:
games_snake_game_loop_end_if_52:
    ; r48 = load game
    LD HL, ($F002)
    ; Load field snake (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r50 = &r49
    ; Address-of operation for register r49
    LD HL, $F062  ; Variable address
    ; Register 50 already in HL
    ; r51 = load game
    LD HL, ($F002)
    ; Load field food (offset 203)
    LD DE, 203
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r53 = &r52
    ; Address-of operation for register r52
    LD HL, $F068  ; Variable address
    ; Register 53 already in HL
    ; r54 = load game
    LD HL, ($F002)
    ; Load field snake (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r56 = &r55
    ; Address-of operation for register r55
    LD HL, $F06E  ; Variable address
    ; Register 56 already in HL
    ; r57 = load game
    LD HL, ($F002)
    ; Load field food (offset 203)
    LD DE, 203
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r59 = &r58
    ; Address-of operation for register r58
    LD HL, $F074  ; Variable address
    LD ($F076), HL    ; Virtual register 59 to memory
    ; unknown op 39
    ; Smart patch 'store_u8' for games.snake.check_food_collision$p_Snake$p_Point_return_patch
    LD A, #00               ; NOP opcode
    LD (games_snake_check_food_collision_p_Snake_p_Point_return_patch_op), A
    ; unknown op 40
    ; Patch storage address: temp_result
    LD HL, temp_result
    LD (games_snake_check_food_collision_p_Snake_p_Point_store_addr), HL
    ; unknown op 41
    ; Patch parameter snake = 0
    LD HL, 0              ; Parameter value
    LD (games_snake_check_food_collision_p_Snake_p_Point_param_snake+1), HL  ; Patch parameter immediate
    ; unknown op 41
    ; Patch parameter food = 0
    LD HL, 0              ; Parameter value
    LD (games_snake_check_food_collision_p_Snake_p_Point_param_food+1), HL  ; Patch parameter immediate
    ; r60 = call games.snake.check_food_collision$p_Snake$p_Point
    ; Call to games.snake.check_food_collision$p_Snake$p_Point (args: 2)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_check_food_collision_p_Snake_p_Point
    ; r61 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; r62 = r60 == r61
    LD D, H
    LD E, L
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP Z, games_snake_game_loop_eq_true_38
    LD HL, 0       ; False
    JP games_snake_game_loop_eq_done_38
games_snake_game_loop_eq_true_38:
    LD HL, 1       ; True
games_snake_game_loop_eq_done_38:
    ; jump_if_not r62, else_53
    LD A, H
    OR A
    JP Z, games_snake_game_loop_else_53
    ; r63 = load game
    LD HL, ($F002)
    ; Load field snake (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r65 = &r64
    ; Address-of operation for register r64
    LD HL, $F080  ; Variable address
    ; Register 65 already in HL
    ; r66 = load game
    LD HL, ($F002)
    ; Load field snake (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r68 = &r67
    ; Address-of operation for register r67
    LD HL, $F086  ; Variable address
    LD ($F088), HL    ; Virtual register 68 to memory
    ; r69 = call games.snake.grow_snake$p_Snake
    ; Call to games.snake.grow_snake$p_Snake (args: 1)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_grow_snake_p_Snake
    ; r70 = load game
    LD HL, ($F002)
    ; Register 70 already in HL
    ; Load field snake (offset 0)
    ; Register 70 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r72 = &r71
    ; Address-of operation for register r71
    LD HL, $F08E  ; Variable address
    ; Register 72 already in HL
    ; r73 = load game
    LD HL, ($F002)
    ; Load field snake (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r75 = &r74
    ; Address-of operation for register r74
    LD HL, $F094  ; Variable address
    LD ($F096), HL    ; Virtual register 75 to memory
    ; r76 = call games.snake.generate_food$p_Snake
    ; Call to games.snake.generate_food$p_Snake (args: 1)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_generate_food_p_Snake
    ; r77 = load game
    LD HL, ($F002)
    ; Register 77 already in HL
    ; Store to field food (offset 203)
    ; Register 77 already in HL
    LD DE, 203
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r78 = load game
    LD HL, ($F002)
    ; Load field score (offset 205)
    LD DE, 205
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 79 already in HL
    ; r80 = 10
    LD A, 10
    LD L, A         ; Store to HL (low byte)
    ; r81 = r79 + r80
    ; Register 79 already in HL
    LD D, H
    LD E, L
    ; Register 80 already in HL
    ADD HL, DE
    LD ($F0A2), HL    ; Virtual register 81 to memory
    ; r82 = load game
    LD HL, ($F002)
    ; Store to field score (offset 205)
    LD DE, 205
    ADD HL, DE
    PUSH HL
    LD HL, ($F0A2)    ; Virtual register 81 from memory
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; jump end_if_54
    JP games_snake_game_loop_end_if_54
    ; else_53:
games_snake_game_loop_else_53:
    ; end_if_54:
games_snake_game_loop_end_if_54:
    ; r83 = load game
    LD HL, ($F002)
    LD ($F0A6), HL    ; Virtual register 83 to memory
    ; r84 = &r83
    ; Address-of operation for register r83
    LD HL, $F0A6  ; Variable address
    ; r85 = load game
    LD HL, ($F002)
    ; r86 = &r85
    ; Address-of operation for register r85
    LD HL, $F0AA  ; Variable address
    LD ($F0AC), HL    ; Virtual register 86 to memory
    ; r87 = call games.snake.render_game$p_GameState
    ; Call to games.snake.render_game$p_GameState (args: 1)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_render_game_p_GameState
    ; r88 = 5
    LD A, 5
    LD L, A         ; Store to physical register L
    ; r89 = 5
    LD A, 5
    LD ($F0B2), A     ; Virtual register 89 to memory
    ; r90 = call games.snake.delay$u16
    ; Call to games.snake.delay$u16 (args: 1)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_delay_u16
    ; jump loop_47
    JP games_snake_game_loop_loop_47
    ; end_loop_48:
games_snake_game_loop_end_loop_48:
    ; r91 = 2
    LD A, 2
    LD L, A         ; Store to physical register L
    ; r92 = 2
    LD A, 2
    LD ($F0B8), A     ; Virtual register 92 to memory
    ; r93 = call games.snake.set_border$u8
    ; Call to games.snake.set_border$u8 (args: 1)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_set_border_u8
    ; r94 = 25
    LD A, 25
    LD L, A         ; Store to physical register L
    ; r95 = 25
    LD A, 25
    LD ($F0BE), A     ; Virtual register 95 to memory
    ; r96 = call games.snake.delay$u16
    ; Call to games.snake.delay$u16 (args: 1)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_delay_u16
    ; r97 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r98 = 0
    LD A, 0
    LD ($F0C4), A     ; Virtual register 98 to memory
    ; r99 = call games.snake.set_border$u8
    ; Call to games.snake.set_border$u8 (args: 1)
    ; Found function, UsesTrueSMC=false
    CALL games_snake_set_border_u8
    ; r100 = call games.snake.clear_screen
    ; Call to games.snake.clear_screen (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL games.snake.clear_screen
    ; r101 = load game
    LD HL, ($F002)
    ; Register 101 already in HL
    ; Load field score (offset 205)
    ; Register 101 already in HL
    LD DE, 205
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 102 already in HL
    ; Call runtime print_u16_decimal
    ; Call to print_u16_decimal (args: 1)
    ; Stack-based parameter passing
    ; Register 102 already in HL
    PUSH HL       ; Argument 0
    CALL print_u16_decimal
    LD ($F000), HL    ; Virtual register 0 to memory
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: games.snake.main
games_snake_main:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r1 = call games.snake.game_loop
    ; Call to games.snake.game_loop (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL games.snake.game_loop
    ; Register 1 already in HL
    ; return
    RET

; Runtime print helper functions
print_u8_decimal:
    LD H, 0            ; HL = A (zero extend)
    LD L, A
    CALL print_u16_decimal
    RET

print_u16_decimal:
    LD BC, -10000
    LD DE, -1000
    CALL print_digit
    LD BC, -1000
    LD DE, -100
    CALL print_digit
    LD BC, -100
    LD DE, -10
    CALL print_digit
    LD BC, -10
    LD DE, -1
    CALL print_digit
    LD A, L
    ADD A, '0'         ; Convert to ASCII
    RST 16             ; Print last digit
    RET

print_digit:
    LD A, '0'-1
print_digit_loop:
    INC A
    ADD HL, BC         ; Subtract power of 10
    JR C, print_digit_loop
    ADD HL, DE         ; Add back one power of 10
    RST 16             ; Print digit
    RET


; Standard library routines

    END main
