; MinZ generated code
; Generated: 2025-08-10 20:45:50


; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_mul_patterns.test_multiplications
test_mul_patterns_test_multiplications:
; Using stack-based locals (IX+offset)
    PUSH IX
    LD IX, SP
    LD HL, -21
    ADD HL, SP
    LD SP, HL
    ; Load parameters from registers
    ; r2 = 5
    LD A, 5
    LD ($F004), A     ; Virtual register 2 to memory
    ; store x, r2
    LD A, ($F004)     ; Virtual register 2 from memory
    LD (IX_1), A
    ; r4 = load x
    LD A, (IX_1)
    LD ($F008), A     ; Virtual register 4 to memory
    ; r5 = 2
    LD A, 2
    LD D, A         ; Store to physical register D
    ; r6 = r4 * r5
    ; 8-bit multiplication
    LD A, ($F008)     ; Virtual register 4 from memory
    LD B, A       ; B = multiplicand
    LD A, D
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, test_mul_patterns_test_multiplications_mul_done_0
test_mul_patterns_test_multiplications_mul_loop_0:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, test_mul_patterns_test_multiplications_mul_loop_0
test_mul_patterns_test_multiplications_mul_done_0:
    ; store m2, r6
    LD (IX_3), L
    LD (IX_2), H
    ; r8 = load x
    LD A, (IX_1)
    LD L, A         ; Store to physical register L
    ; r9 = 4
    LD A, 4
    EXX               ; Switch to shadow registers
    LD B', A         ; Store to shadow B'
    EXX               ; Switch back to main registers
    ; r10 = r8 * r9
    ; 8-bit multiplication
    LD A, L
    LD B, A       ; B = multiplicand
    EXX               ; Switch to shadow registers
    LD A, B'         ; From shadow B'
    EXX               ; Switch back to main registers
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, test_mul_patterns_test_multiplications_mul_done_1
test_mul_patterns_test_multiplications_mul_loop_1:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, test_mul_patterns_test_multiplications_mul_loop_1
test_mul_patterns_test_multiplications_mul_done_1:
    ; store m4, r10
    LD (IX_5), L
    LD (IX_4), H
    ; r12 = load x
    LD A, (IX_1)
    LD ($F018), A     ; Virtual register 12 to memory
    ; r13 = 8
    LD A, 8
    LD C, A         ; Store to physical register C
    ; r14 = r12 * r13
    ; 8-bit multiplication
    LD A, ($F018)     ; Virtual register 12 from memory
    LD B, A       ; B = multiplicand
    LD A, C
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, test_mul_patterns_test_multiplications_mul_done_2
test_mul_patterns_test_multiplications_mul_loop_2:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, test_mul_patterns_test_multiplications_mul_loop_2
test_mul_patterns_test_multiplications_mul_done_2:
    LD ($F01C), HL    ; Virtual register 14 to memory
    ; store m8, r14
    LD HL, ($F01C)    ; Virtual register 14 from memory
    LD (IX_7), L
    LD (IX_6), H
    ; r16 = load x
    LD A, (IX_1)
    LD ($F020), A     ; Virtual register 16 to memory
    ; r17 = 16
    LD A, 16
    LD B, A         ; Store to physical register B
    ; r18 = r16 * r17
    ; 8-bit multiplication
    LD A, ($F020)     ; Virtual register 16 from memory
    LD B, A       ; B = multiplicand
    LD A, B
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, test_mul_patterns_test_multiplications_mul_done_3
test_mul_patterns_test_multiplications_mul_loop_3:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, test_mul_patterns_test_multiplications_mul_loop_3
test_mul_patterns_test_multiplications_mul_done_3:
    LD ($F024), HL    ; Virtual register 18 to memory
    ; store m16, r18
    LD HL, ($F024)    ; Virtual register 18 from memory
    LD (IX_9), L
    LD (IX_8), H
    ; r20 = load x
    LD A, (IX_1)
    LD ($F028), A     ; Virtual register 20 to memory
    ; r21 = 3
    LD A, 3
    LD C, A         ; Store to physical register C
    ; r22 = r20 * r21
    ; 8-bit multiplication
    LD A, ($F028)     ; Virtual register 20 from memory
    LD B, A       ; B = multiplicand
    LD A, C
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, test_mul_patterns_test_multiplications_mul_done_4
test_mul_patterns_test_multiplications_mul_loop_4:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, test_mul_patterns_test_multiplications_mul_loop_4
test_mul_patterns_test_multiplications_mul_done_4:
    LD ($F02C), HL    ; Virtual register 22 to memory
    ; store m3, r22
    LD HL, ($F02C)    ; Virtual register 22 from memory
    LD (IX_11), L
    LD (IX_10), H
    ; r24 = load x
    LD A, (IX_1)
    LD ($F030), A     ; Virtual register 24 to memory
    ; r25 = 5
    LD A, 5
    LD C, A         ; Store to physical register C
    ; r26 = r24 * r25
    ; 8-bit multiplication
    LD A, ($F030)     ; Virtual register 24 from memory
    LD B, A       ; B = multiplicand
    LD A, C
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, test_mul_patterns_test_multiplications_mul_done_5
test_mul_patterns_test_multiplications_mul_loop_5:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, test_mul_patterns_test_multiplications_mul_loop_5
test_mul_patterns_test_multiplications_mul_done_5:
    LD ($F034), HL    ; Virtual register 26 to memory
    ; store m5, r26
    LD HL, ($F034)    ; Virtual register 26 from memory
    LD (IX_13), L
    LD (IX_12), H
    ; r28 = load x
    LD A, (IX_1)
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    ; r29 = 10
    LD A, 10
    ; Register 29 already in A
    ; r30 = r28 * r29
    ; 8-bit multiplication
    EXX               ; Switch to shadow registers
    LD A, D'         ; From shadow D'
    EXX               ; Switch back to main registers
    LD B, A       ; B = multiplicand
    ; Register 29 already in A
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, test_mul_patterns_test_multiplications_mul_done_6
test_mul_patterns_test_multiplications_mul_loop_6:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, test_mul_patterns_test_multiplications_mul_loop_6
test_mul_patterns_test_multiplications_mul_done_6:
    LD ($F03C), HL    ; Virtual register 30 to memory
    ; store m10, r30
    LD HL, ($F03C)    ; Virtual register 30 from memory
    LD (IX_15), L
    LD (IX_14), H
    ; r32 = load x
    LD A, (IX_1)
    EXX               ; Switch to shadow registers
    LD E', A         ; Store to shadow E'
    EXX               ; Switch back to main registers
    ; r33 = 7
    LD A, 7
    LD B, A         ; Store to physical register B
    ; r34 = r32 * r33
    ; 8-bit multiplication
    EXX               ; Switch to shadow registers
    LD A, E'         ; From shadow E'
    EXX               ; Switch back to main registers
    LD B, A       ; B = multiplicand
    LD A, B
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, test_mul_patterns_test_multiplications_mul_done_7
test_mul_patterns_test_multiplications_mul_loop_7:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, test_mul_patterns_test_multiplications_mul_loop_7
test_mul_patterns_test_multiplications_mul_done_7:
    LD ($F044), HL    ; Virtual register 34 to memory
    ; store m7, r34
    LD HL, ($F044)    ; Virtual register 34 from memory
    LD (IX_17), L
    LD (IX_16), H
    ; r36 = load x
    LD A, (IX_1)
    LD C, A         ; Store to physical register C
    ; r37 = 9
    LD A, 9
    LD B, A         ; Store to physical register B
    ; r38 = r36 * r37
    ; 8-bit multiplication
    LD A, C
    LD B, A       ; B = multiplicand
    LD A, B
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, test_mul_patterns_test_multiplications_mul_done_8
test_mul_patterns_test_multiplications_mul_loop_8:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, test_mul_patterns_test_multiplications_mul_loop_8
test_mul_patterns_test_multiplications_mul_done_8:
    ; store m9, r38
    LD (IX_19), L
    LD (IX_18), H
    ; r40 = load x
    LD A, (IX_1)
    LD H, A         ; Store to physical register H
    ; r41 = 15
    LD A, 15
    LD H, A         ; Store to physical register H
    ; r42 = r40 * r41
    ; 8-bit multiplication
    LD A, H
    LD B, A       ; B = multiplicand
    LD A, H
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, test_mul_patterns_test_multiplications_mul_done_9
test_mul_patterns_test_multiplications_mul_loop_9:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, test_mul_patterns_test_multiplications_mul_loop_9
test_mul_patterns_test_multiplications_mul_done_9:
    ; store m15, r42
    LD (IX_21), L
    LD (IX_20), H
    ; return
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: test_mul_patterns.main
test_mul_patterns_main:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r1 = call test_mul_patterns.test_multiplications
    ; Call to test_mul_patterns.test_multiplications (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL test_mul_patterns.test_multiplications
    ; return
    RET

    END main
