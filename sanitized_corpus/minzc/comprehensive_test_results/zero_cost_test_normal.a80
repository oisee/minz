; MinZ generated code
; Generated: 2025-08-02 13:03:29


; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.draw
.Users_alice_dev_minz_ts_examples_zero_cost_test_Circle_draw:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
.Users_alice_dev_minz_ts_examples_zero_cost_test_Circle_draw_param_self:
    LD HL, #0000   ; SMC parameter self (u8->u16)
    ; Load field radius (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r4 = 6
    LD A, 6
    LD C, A         ; Store to physical register C
    ; r5 = r3 * r4
    ; 8-bit multiplication
    LD A, B
    LD B, A       ; B = multiplicand
    LD A, C
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_0
.mul_loop_0:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_0
.mul_done_0:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.get_size
.Users_alice_dev_minz_ts_examples_zero_cost_test_Circle_get_size:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
.Users_alice_dev_minz_ts_examples_zero_cost_test_Circle_get_size_param_self:
    LD HL, #0000   ; SMC parameter self (u8->u16)
    ; Load field radius (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD A, (.Users_alice_dev_minz_ts_examples_zero_cost_test_Circle_get_size_param_self)
    LD L, A         ; Store to physical register L
    ; Load field radius (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; r6 = r3 * r5
    ; 8-bit multiplication
    LD A, H
    LD B, A       ; B = multiplicand
    EXX               ; Switch to shadow registers
    LD A, B'         ; From shadow B'
    EXX               ; Switch back to main registers
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_1
.mul_loop_1:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_1
.mul_done_1:
    ; r7 = 3
    LD A, 3
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    ; r8 = r6 * r7
    ; 8-bit multiplication
    EXX               ; Switch to shadow registers
    LD A, C'         ; From shadow C'
    EXX               ; Switch back to main registers
    LD B, A       ; B = multiplicand
    EXX               ; Switch to shadow registers
    LD A, D'         ; From shadow D'
    EXX               ; Switch back to main registers
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_2
.mul_loop_2:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_2
.mul_done_2:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.scale
.Users_alice_dev_minz_ts_examples_zero_cost_test_Circle_scale:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
.Users_alice_dev_minz_ts_examples_zero_cost_test_Circle_scale_param_self:
    LD HL, #0000   ; SMC parameter self (u8->u16)
    ; Load field radius (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
.Users_alice_dev_minz_ts_examples_zero_cost_test_Circle_scale_param_factor:
    LD DE, #0000   ; SMC parameter factor (u8->u16)
    EX DE, HL      ; Move to HL for storage
    ; r6 = r4 * r5
    ; 8-bit multiplication
    LD A, C
    LD B, A       ; B = multiplicand
    LD A, C
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_3
.mul_loop_3:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_3
.mul_done_3:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.draw
.Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_draw:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
.Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_draw_param_self:
    LD HL, #0000   ; SMC parameter self
    ; Load field width (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 3 already in HL
    LD HL, (.Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_draw_param_self)
    ; Load field height (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F00A), HL    ; Virtual register 5 to memory
    ; r6 = r3 + r5
    ; Register 3 already in HL
    LD D, H
    LD E, L
    LD HL, ($F00A)    ; Virtual register 5 from memory
    ADD HL, DE
    ; r7 = 2
    LD A, 2
    LD L, A         ; Store to HL (low byte)
    ; r8 = r6 * r7
    ; 8-bit multiplication
    LD A, L
    LD B, A       ; B = multiplicand
    LD A, L
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_4
.mul_loop_4:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_4
.mul_done_4:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.get_size
.Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_get_size:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
.Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_get_size_param_self:
    LD HL, #0000   ; SMC parameter self
    ; Load field width (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 3 already in HL
    LD HL, (.Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_get_size_param_self)
    ; Load field height (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 5 already in HL
    ; r6 = r3 * r5
    ; 8-bit multiplication
    LD A, L
    LD B, A       ; B = multiplicand
    LD A, L
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_5
.mul_loop_5:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_5
.mul_done_5:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.scale
.Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_scale:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
.Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_scale_param_self:
    LD HL, #0000   ; SMC parameter self
    ; Load field width (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 4 already in HL
    LD HL, (.Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_scale_param_self)
    ; Load field height (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F00C), HL    ; Virtual register 6 to memory
    ; r7 = r4 + r6
    ; Register 4 already in HL
    LD D, H
    LD E, L
    LD HL, ($F00C)    ; Virtual register 6 from memory
    ADD HL, DE
.Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_scale_param_factor:
    LD DE, #0000   ; SMC parameter factor (u8->u16)
    EX DE, HL      ; Move to HL for storage
    ; Register 8 already in HL
    ; r9 = r7 * r8
    ; 8-bit multiplication
    LD A, L
    LD B, A       ; B = multiplicand
    LD A, L
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_6
.mul_loop_6:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_6
.mul_done_6:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas$double_0
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_lambdas_double_0:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_lambdas_double_0_param_x:
    LD HL, #0000   ; SMC parameter x (u8->u16)
    ; Register 1 already in HL
    ; r2 = 2
    LD A, 2
    LD H, A         ; Store to physical register H
    ; r3 = r1 * r2
    ; 8-bit multiplication
    LD A, L
    LD B, A       ; B = multiplicand
    LD A, H
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_7
.mul_loop_7:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_7
.mul_done_7:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas$add_five_1
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_lambdas_add_five_1:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_lambdas_add_five_1_param_x:
    LD HL, #0000   ; SMC parameter x (u8->u16)
    ; Register 1 already in HL
    ; r2 = 5
    LD A, 5
    LD H, A         ; Store to physical register H
    ; r3 = r1 + r2
    ; Register 1 already in HL
    LD D, H
    LD E, L
    ADD HL, DE
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas$multiply_2
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_lambdas_multiply_2:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_lambdas_multiply_2_param_a:
    LD HL, #0000   ; SMC parameter a (u8->u16)
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_lambdas_multiply_2_param_b:
    LD DE, #0000   ; SMC parameter b (u8->u16)
    EX DE, HL      ; Move to HL for storage
    ; r4 = r2 * r3
    ; 8-bit multiplication
    LD A, H
    LD B, A       ; B = multiplicand
    LD A, H
    LD C, A       ; C = multiplier
    LD HL, 0      ; HL = result
    LD A, C
    OR A          ; Check if multiplier is 0
    JR Z, .mul_done_8
.mul_loop_8:
    LD D, 0
    LD E, B
    ADD HL, DE    ; Add multiplicand to result
    DEC C
    JR NZ, .mul_loop_8
.mul_done_8:
    ; Register 4 already in HL
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_lambdas:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = 7
    LD A, 7
    LD L, A         ; Store to physical register L
    ; r3 = call double
    ; Call to double (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    CALL double
    LD ($F006), HL    ; Virtual register 3 to memory
    ; store , r3
    LD HL, ($F006)    ; Virtual register 3 from memory
    LD ($F002), HL
    ; r5 = load result1
    LD HL, ($F002)
    ; r6 = call add_five
    ; Call to add_five (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    CALL add_five
    LD ($F00C), HL    ; Virtual register 6 to memory
    ; store , r6
    LD HL, ($F00C)    ; Virtual register 6 from memory
    LD ($F008), HL
    ; r8 = load result2
    LD HL, ($F008)
    ; r9 = 2
    LD A, 2
    LD ($F012), A     ; Virtual register 9 to memory
    ; r10 = call multiply
    ; Call to multiply (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F012)    ; Virtual register 9 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    CALL multiply
    ; store , r10
    LD ($F00E), HL
    ; r11 = load result3
    LD HL, ($F00E)
    ; Register 11 already in HL
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_interfaces
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_interfaces:
; Using stack-based locals (IX+offset)
    PUSH IX
    LD IX, SP
    LD HL, -16
    ADD HL, SP
    LD SP, HL
    ; Load parameters from registers
    ; Allocate struct Circle
    LD HL, -1
    ADD HL, SP
    LD SP, HL
    EX DE, HL
    LD HL, SP
    ; r3 = 3
    LD A, 3
    LD L, A         ; Store to physical register L
    ; Store to Circle.radius
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; store , r2
    LD (IX_2), L
    LD (IX_1), H
    ; Allocate struct Rectangle
    LD HL, -2
    ADD HL, SP
    LD SP, HL
    EX DE, HL
    LD HL, SP
    ; r6 = 4
    LD A, 4
    LD ($F00C), A     ; Virtual register 6 to memory
    ; Store to Rectangle.width
    PUSH HL
    LD HL, ($F00C)    ; Virtual register 6 from memory
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r7 = 5
    LD A, 5
    LD L, A         ; Store to physical register L
    ; Store to Rectangle.height
    LD DE, 1
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; store , r5
    LD (IX_4), L
    LD (IX_3), H
    ; r9 = load circle
    LD L, (IX_2)
    LD H, (IX_1)
    ; r10 = call .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.draw
    ; Call to .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.draw (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL .Users_alice_dev_minz_ts_examples_zero_cost_test_Circle_draw
    ; store , r10
    LD (IX_6), L
    LD (IX_5), H
    ; r12 = load circle
    LD L, (IX_2)
    LD H, (IX_1)
    ; r13 = call .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.get_size
    ; Call to .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.get_size (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL .Users_alice_dev_minz_ts_examples_zero_cost_test_Circle_get_size
    ; store , r13
    LD (IX_8), L
    LD (IX_7), H
    ; r15 = load circle
    LD L, (IX_2)
    LD H, (IX_1)
    ; r16 = 2
    LD A, 2
    LD L, A         ; Store to physical register L
    ; r17 = call .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.scale
    ; Call to .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.scale (args: 2)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL .Users_alice_dev_minz_ts_examples_zero_cost_test_Circle_scale
    LD ($F022), HL    ; Virtual register 17 to memory
    ; store , r17
    LD HL, ($F022)    ; Virtual register 17 from memory
    LD (IX_10), L
    LD (IX_9), H
    ; r19 = load rect
    LD L, (IX_4)
    LD H, (IX_3)
    ; r20 = call .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.draw
    ; Call to .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.draw (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL .Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_draw
    LD ($F028), HL    ; Virtual register 20 to memory
    ; store , r20
    LD HL, ($F028)    ; Virtual register 20 from memory
    LD (IX_12), L
    LD (IX_11), H
    ; r22 = load rect
    LD L, (IX_4)
    LD H, (IX_3)
    ; r23 = call .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.get_size
    ; Call to .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.get_size (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL .Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_get_size
    LD ($F02E), HL    ; Virtual register 23 to memory
    ; store , r23
    LD HL, ($F02E)    ; Virtual register 23 from memory
    LD (IX_14), L
    LD (IX_13), H
    ; r25 = load rect
    LD L, (IX_4)
    LD H, (IX_3)
    ; r26 = 3
    LD A, 3
    LD ($F034), A     ; Virtual register 26 to memory
    ; r27 = call .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.scale
    ; Call to .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.scale (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F034)    ; Virtual register 26 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL .Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_scale
    ; store , r27
    LD (IX_16), L
    LD (IX_15), H
    ; r28 = load c_draw
    LD L, (IX_6)
    LD H, (IX_5)
    ; Register 28 already in HL
    ; r29 = load c_size
    LD L, (IX_8)
    LD H, (IX_7)
    ; r30 = r28 + r29
    ; Register 28 already in HL
    LD D, H
    LD E, L
    ADD HL, DE
    LD D, H
    LD E, L
    ; r31 = load c_size
    LD L, (IX_8)
    LD H, (IX_7)
    ; Register 31 already in HL
    ; r32 = r30 + r31
    LD H, D
    LD L, E
    LD D, H
    LD E, L
    ; Register 31 already in HL
    ADD HL, DE
    LD B, H
    LD C, L
    ; r33 = load r_draw
    LD L, (IX_12)
    LD H, (IX_11)
    ; Register 33 already in HL
    ; r34 = r32 + r33
    LD H, B
    LD L, C
    LD D, H
    LD E, L
    ; Register 33 already in HL
    ADD HL, DE
    PUSH HL           ; Save current HL
    EXX               ; Switch to shadow registers
    POP HL            ; Load into shadow HL
    EXX               ; Switch back to main registers
    ; r35 = load r_size
    LD L, (IX_14)
    LD H, (IX_13)
    ; Register 35 already in HL
    ; r36 = r34 + r35
    EXX               ; Switch to shadow registers
    PUSH HL           ; Save shadow HL
    EXX               ; Switch back to main registers
    POP HL            ; Load shadow HL into main HL
    LD D, H
    LD E, L
    ; Register 35 already in HL
    ADD HL, DE
    ; Register 36 already in HL
    ; r37 = load r_scale
    LD L, (IX_16)
    LD H, (IX_15)
    ; Register 37 already in HL
    ; r38 = r36 + r37
    ; Register 36 already in HL
    LD D, H
    LD E, L
    ; Register 37 already in HL
    ADD HL, DE
    LD ($F04C), HL    ; Virtual register 38 to memory
    ; return
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.traditional_function
.Users_alice_dev_minz_ts_examples_zero_cost_test_traditional_function:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
.Users_alice_dev_minz_ts_examples_zero_cost_test_traditional_function_param_x:
    LD HL, #0000   ; SMC parameter x (u8->u16)
.Users_alice_dev_minz_ts_examples_zero_cost_test_traditional_function_param_y:
    LD DE, #0000   ; SMC parameter y (u8->u16)
    EX DE, HL      ; Move to HL for storage
    ; r5 = r3 + r4
    LD D, H
    LD E, L
    ADD HL, DE
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_performance_equivalence$lambda_add_3
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_performance_equivalence_lambda_add_3:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_performance_equivalence_lambda_add_3_param_x:
    LD HL, #0000   ; SMC parameter x (u8->u16)
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_performance_equivalence_lambda_add_3_param_y:
    LD DE, #0000   ; SMC parameter y (u8->u16)
    EX DE, HL      ; Move to HL for storage
    ; Register 3 already in HL
    ; r4 = r2 + r3
    LD D, H
    LD E, L
    ; Register 3 already in HL
    ADD HL, DE
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_performance_equivalence
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_performance_equivalence:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = 20
    LD A, 20
    LD ($F004), A     ; Virtual register 2 to memory
    ; r3 = 22
    LD A, 22
    LD H, A         ; Store to physical register H
    ; r4 = call lambda_add
    ; Call to lambda_add (args: 2)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 1
    LD HL, ($F004)    ; Virtual register 2 from memory
    PUSH HL       ; Argument 0
    CALL lambda_add
    ; store , r4
    LD ($F002), HL
    ; r6 = 20
    LD A, 20
    LD H, A         ; Store to physical register H
    ; r7 = 22
    LD A, 22
    LD L, A         ; Store to physical register L
    ; r8 = call traditional_function
    ; Call to traditional_function (args: 2)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL .Users_alice_dev_minz_ts_examples_zero_cost_test_traditional_function
    LD ($F010), HL    ; Virtual register 8 to memory
    ; store , r8
    LD HL, ($F010)    ; Virtual register 8 from memory
    LD ($F00A), HL
    ; r9 = load lambda_result
    LD HL, ($F002)
    ; r10 = load traditional_result
    LD HL, ($F00A)
    ; Register 10 already in HL
    ; r11 = r9 + r10
    LD D, H
    LD E, L
    ; Register 10 already in HL
    ADD HL, DE
    ; Register 11 already in HL
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.main
.Users_alice_dev_minz_ts_examples_zero_cost_test_main:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = call test_lambdas
    ; Call to test_lambdas (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL .Users_alice_dev_minz_ts_examples_zero_cost_test_test_lambdas
    LD ($F004), HL    ; Virtual register 2 to memory
    ; store , r2
    LD HL, ($F004)    ; Virtual register 2 from memory
    LD ($F002), HL
    ; r4 = call test_interfaces
    ; Call to test_interfaces (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL .Users_alice_dev_minz_ts_examples_zero_cost_test_test_interfaces
    ; store , r4
    LD ($F006), HL
    ; r6 = call test_performance_equivalence
    ; Call to test_performance_equivalence (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL .Users_alice_dev_minz_ts_examples_zero_cost_test_test_performance_equivalence
    ; store , r6
    LD ($F00A), HL
    ; r7 = load lambda_test
    LD HL, ($F002)
    ; Register 7 already in HL
    ; r8 = load interface_test
    LD HL, ($F006)
    ; r9 = r7 + r8
    ; Register 7 already in HL
    LD D, H
    LD E, L
    ADD HL, DE
    ; Register 9 already in HL
    ; r10 = load performance_test
    LD HL, ($F00A)
    ; Register 10 already in HL
    ; r11 = r9 + r10
    ; Register 9 already in HL
    LD D, H
    LD E, L
    ; Register 10 already in HL
    ADD HL, DE
    LD ($F016), HL    ; Virtual register 11 to memory
    ; return
    RET

; Runtime print helper functions
print_string:
    LD B, (HL)         ; B = length from first byte
    INC HL             ; HL -> string data
    LD A, B            ; Check if length is zero
    OR A
    RET Z              ; Return if empty string
print_loop:
    LD A, (HL)         ; Load character
    RST 16             ; Print character
    INC HL             ; Next character
    DJNZ print_loop    ; Decrement B and loop
    RET

print_u8_decimal:
    LD H, 0            ; HL = A (zero extend)
    LD L, A
    CALL print_u16_decimal
    RET

print_u16_decimal:
    LD BC, -10000
    LD DE, -1000
    CALL print_digit
    LD BC, -1000
    LD DE, -100
    CALL print_digit
    LD BC, -100
    LD DE, -10
    CALL print_digit
    LD BC, -10
    LD DE, -1
    CALL print_digit
    LD A, L
    ADD A, '0'         ; Convert to ASCII
    RST 16             ; Print last digit
    RET

print_digit:
    LD A, '0'-1
print_digit_loop:
    INC A
    ADD HL, BC         ; Subtract power of 10
    JR C, print_digit_loop
    ADD HL, DE         ; Add back one power of 10
    RST 16             ; Print digit
    RET

print_i8_decimal:
    BIT 7, A           ; Check sign bit
    JR Z, print_u8_decimal
    PUSH AF
    LD A, '-'          ; Print minus sign
    RST 16
    POP AF
    NEG                ; Make positive
    JR print_u8_decimal

print_i16_decimal:
    BIT 7, H           ; Check sign bit
    JR Z, print_u16_decimal
    PUSH HL
    LD A, '-'          ; Print minus sign
    RST 16
    POP HL
    LD A, H            ; Negate HL
    CPL
    LD H, A
    LD A, L
    CPL
    LD L, A
    INC HL
    JR print_u16_decimal

print_bool:
    OR A               ; Test if A is zero
    JR NZ, print_true
    LD HL, bool_false_str
    JR print_string
print_true:
    LD HL, bool_true_str
    JR print_string

bool_true_str:
    DB 4, "true"      ; Length + data
bool_false_str:
    DB 5, "false"     ; Length + data


    END main
