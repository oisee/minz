; MinZ generated code
; Generated: 2025-08-02 13:03:29


; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.draw
.Users_alice_dev_minz_ts_examples_zero_cost_test_Circle_draw:
; TRUE SMC function with immediate anchors
self_immOP:
    LD A, 0        ; self anchor (will be patched)
self_imm0 EQU self_immOP+1
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.get_size
.Users_alice_dev_minz_ts_examples_zero_cost_test_Circle_get_size:
; TRUE SMC function with immediate anchors
self_immOP:
    LD B, 0        ; self anchor (will be patched)
self_imm0 EQU self_immOP+1
    LD A, (self_imm0)    ; Reuse from anchor
    LD C, A         ; Store to physical register C
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Circle.scale
.Users_alice_dev_minz_ts_examples_zero_cost_test_Circle_scale:
; TRUE SMC function with immediate anchors
self_immOP:
    LD D, 0        ; self anchor (will be patched)
self_imm0 EQU self_immOP+1
factor_immOP:
    LD E, 0        ; factor anchor (will be patched)
factor_imm0 EQU factor_immOP+1
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.draw
.Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_draw:
; TRUE SMC function with immediate anchors
self_immOP:
    LD HL, 0       ; self anchor (will be patched)
self_imm0 EQU self_immOP+1
    ; Register 2 already in HL
    LD HL, (self_imm0)   ; Reuse from anchor
    LD D, H
    LD E, L
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.get_size
.Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_get_size:
; TRUE SMC function with immediate anchors
self_immOP:
    LD HL, 0       ; self anchor (will be patched)
self_imm0 EQU self_immOP+1
    LD B, H
    LD C, L
    LD HL, (self_imm0)   ; Reuse from anchor
    PUSH HL           ; Save current HL
    EXX               ; Switch to shadow registers
    POP HL            ; Load into shadow HL
    EXX               ; Switch back to main registers
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.Rectangle.scale
.Users_alice_dev_minz_ts_examples_zero_cost_test_Rectangle_scale:
; TRUE SMC function with immediate anchors
self_immOP:
    LD HL, 0       ; self anchor (will be patched)
self_imm0 EQU self_immOP+1
    LD HL, (self_imm0)   ; Reuse from anchor
factor_immOP:
    LD A, 0        ; factor anchor (will be patched)
factor_imm0 EQU factor_immOP+1
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas$double_0
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_lambdas_double_0:
; TRUE SMC function with immediate anchors
x_immOP:
    LD A, 0        ; x anchor (will be patched)
x_imm0 EQU x_immOP+1
    LD L, A         ; Store to HL (low byte)
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas$add_five_1
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_lambdas_add_five_1:
; TRUE SMC function with immediate anchors
x_immOP:
    LD A, 0        ; x anchor (will be patched)
x_imm0 EQU x_immOP+1
    LD H, A         ; Store to physical register H
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas$multiply_2
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_lambdas_multiply_2:
; TRUE SMC function with immediate anchors
a_immOP:
    LD A, 0        ; a anchor (will be patched)
a_imm0 EQU a_immOP+1
    LD L, A         ; Store to physical register L
b_immOP:
    LD A, 0        ; b anchor (will be patched)
b_imm0 EQU b_immOP+1
    LD L, A         ; Store to HL (low byte)
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_lambdas
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_lambdas:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    PUSH BC
    PUSH DE
    ; r3 = call double
    ; Call to double (args: 1)
    ; Stack-based parameter passing
    LD HL, ($F004)    ; Virtual register 2 from memory
    PUSH HL       ; Argument 0
    CALL double
    LD ($F006), HL    ; Virtual register 3 to memory
    ; r6 = call add_five
    ; Call to add_five (args: 1)
    ; Stack-based parameter passing
    LD HL, ($F00A)    ; Virtual register 5 from memory
    PUSH HL       ; Argument 0
    CALL add_five
    ; Register 6 already in HL
    ; r10 = call multiply
    ; Call to multiply (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F012)    ; Virtual register 9 from memory
    PUSH HL       ; Argument 1
    LD HL, ($F010)    ; Virtual register 8 from memory
    PUSH HL       ; Argument 0
    CALL multiply
    ; return
    POP DE
    POP BC
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: .Users.alice.dev.minz-ts.examples.zero_cost_test.test_interfaces
.Users_alice_dev_minz_ts_examples_zero_cost_test_test_interfaces:
; IsSMCDefault=false, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
