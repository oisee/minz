// Test different calling conventions for the same function
// This demonstrates how MinZ can generate optimal code for different scenarios

// Simple addition function - compiler will choose optimal ABI
fun add_auto(a: u8, b: u8) -> u8 {
    return a + b;
}

// Force register-based calling convention
@abi("register")
fun add_register(a: u8, b: u8) -> u8 {
    return a + b;
}

// Force stack-based calling convention
@abi("stack")
fun add_stack(a: u8, b: u8) -> u8 {
    return a + b;
}

// Force SMC (self-modifying code) convention
@abi("smc")
fun add_smc(a: u8, b: u8) -> u8 {
    return a + b;
}

// Force virtual register (memory) convention
@abi("virtual")
fun add_virtual(a: u8, b: u8) -> u8 {
    return a + b;
}

// Complex function with many parameters - tests hybrid approach
fun complex_calc(a: u8, b: u8, c: u16, d: u16, e: u8, f: u8) -> u16 {
    let sum1 = a + b + e + f;
    let sum2 = c + d;
    return sum1 + sum2;
}

// Recursive function - must use stack-based ABI
fun factorial(n: u8) -> u16 {
    if n <= 1 {
        return 1;
    }
    return n * factorial(n - 1);
}

// Interrupt handler - should use shadow registers
@interrupt
fun timer_interrupt() -> void {
    // This should automatically use shadow registers
    // to avoid saving/restoring main registers
    let counter: u8 = 0;
    counter = counter + 1;
}

// Memory copy function - optimal register usage pattern
fun memcpy(dst: *u8, src: *u8, count: u16) -> void {
    // Should use HL=src, DE=dst, BC=count
    // Maps perfectly to LDIR instruction
    while count > 0 {
        *dst = *src;
        dst = dst + 1;
        src = src + 1;
        count = count - 1;
    }
}

// Test various calling patterns
fun main() -> void {
    // Test simple additions with different ABIs
    let r1 = add_auto(10, 20);      // Compiler chooses
    let r2 = add_register(10, 20);  // A=10, E=20
    let r3 = add_stack(10, 20);     // Push 20, Push 10, Call
    let r4 = add_smc(10, 20);       // Patch function directly
    let r5 = add_virtual(10, 20);   // Memory at $F000, $F002
    
    // Test complex function (hybrid ABI likely)
    let r6 = complex_calc(1, 2, 300, 400, 5, 6);
    
    // Test recursive function (must use stack)
    let r7 = factorial(5);
    
    // Test optimal register pattern
    let src: [10]u8 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let dst: [10]u8;
    memcpy(&dst[0], &src[0], 10);
}