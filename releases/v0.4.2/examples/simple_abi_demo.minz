// Simple @abi Demonstration - All Calling Conventions
// Shows seamless assembly integration with zero overhead

// =============================================================================
// CALLING CONVENTIONS DEMO
// =============================================================================

@abi("smc")
fun smc_add(x: u8, y: u8) -> u8 {
    return x + y;
}

@abi("register") 
fun register_multiply(a: u8, b: u8) -> u8 {
    return a * b;
}

@abi("stack")
fun stack_process(data: u16, offset: u8) -> u16 {
    return data + offset;
}

// =============================================================================  
// SEAMLESS ASSEMBLY INTEGRATION - ZERO OVERHEAD!
// =============================================================================

// Use existing ZX Spectrum ROM routines without modification
@abi("register: A=char")
@extern
fun rom_print_char(c: u8) -> void;

// Use existing assembly math library
@abi("register: HL=value")
@extern  
fun asm_double(value: u16) -> u16;

// Use existing graphics routines
@abi("register: D=x, E=y, A=color")
@extern
fun asm_plot_pixel(x: u8, y: u8, color: u8) -> void;

// Use existing hardware drivers
@abi("register: A=reg, C=value")
@extern
fun ay_sound_write(reg: u8, value: u8) -> void;

@abi("register: BC=port, A=data")
@extern
fun port_out(port: u16, data: u8) -> void;

// =============================================================================
// HIGH-LEVEL FUNCTIONS USING ASSEMBLY - BEST OF BOTH WORLDS  
// =============================================================================

fun graphics_demo() {
    // Use existing optimized assembly pixel routines
    asm_plot_pixel(10, 10, 1);  // White pixel at 10,10
    asm_plot_pixel(10, 11, 1);  // White pixel at 10,11  
    asm_plot_pixel(10, 12, 1);  // White pixel at 10,12
    
    // Draw a pattern using assembly functions
    asm_plot_pixel(20, 20, 1);
    asm_plot_pixel(21, 21, 1);
    asm_plot_pixel(22, 22, 1);
}

fun sound_demo() {
    // Play 440Hz note using existing AY chip driver
    ay_sound_write(0, 0x00);    // Channel A frequency low byte
    ay_sound_write(1, 0x02);    // Channel A frequency high byte (440Hz)
    ay_sound_write(8, 15);      // Channel A volume maximum
    ay_sound_write(7, 0x3E);    // Enable channel A tone
}

fun hardware_demo() {
    // Set ZX Spectrum border color using existing port routine
    port_out(0xFE, 2);          // Red border
    
    // Print message using ROM routine
    rom_print_char(72);         // 'H'  
    rom_print_char(101);        // 'e'
    rom_print_char(108);        // 'l'
    rom_print_char(108);        // 'l' 
    rom_print_char(111);        // 'o'
}

// =============================================================================
// MAIN DEMONSTRATION
// =============================================================================

fun main() {
    // Test different calling conventions
    let smc_result = smc_add(15, 25);           // Uses self-modifying code
    let reg_result = register_multiply(6, 7);    // Uses register passing
    let stack_result = stack_process(1000, 42); // Uses stack passing
    
    // Demonstrate seamless assembly integration
    graphics_demo();    // Uses existing assembly graphics routines
    sound_demo();       // Uses existing assembly sound routines  
    hardware_demo();    // Uses existing assembly I/O routines
    
    // Mixed high-level and assembly computation
    let doubled = asm_double(500);  // Call assembly math function
    rom_print_char(doubled as u8);  // Print result via ROM
    
    // The revolutionary breakthrough: ALL assembly functions are called
    // with ZERO OVERHEAD! The compiler automatically maps MinZ parameters
    // to the exact Z80 registers specified in the @abi annotations.
    //
    // This means you can use ANY existing Z80 assembly code library,
    // ROM routine, or hardware driver WITHOUT MODIFICATION!
}