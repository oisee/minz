; MinZ Intermediate Representation (MIR)
; Module: main

; Globals:
;   canvas: [32]u8
;   cursor_x: u8
;   cursor_y: u8
;   flash_counter: u8

Function mnist_complete.init_editor() -> void
  @smc
  Locals:
    r4 = i: u8
  Instructions:
      0: r1 = 8
      1: store cursor_x, r1
      2: r2 = 8
      3: store cursor_y, r2
      4: r3 = 0
      5: store flash_counter, r3
      6: r5 = 0
      7: store , r5
      8: loop_1:
      9: r6 = load i
     10: r7 = 32
     11: r8 = r6 < r7
     12: jump_if_not r8, end_loop_2
     13: r9 = 0
     14: r10 = load canvas
     15: r11 = load i
     16: r12 = r10 + r11 ; Calculate array element address
     17: 57 ; Store to array[index] (u8)
     18: r13 = load i
     19: r14 = 1
     20: r15 = r13 + r14
     21: store i, r15
     22: jump loop_1
     23: end_loop_2:
     24: return

Function mnist_complete.set_pixel(x: u8, y: u8) -> void
  @smc
  Locals:
    r3 = byte_idx: u8
    r11 = bit_idx: u8
    r15 = mask: u8
  Instructions:
      0: 12
      1: r5 = 2
      2: r6 = r4 * r5
      3: 12
      4: r8 = 8
      5: 36
      6: r10 = r6 + r9
      7: store , r10
      8: 12
      9: r13 = 7
     10: r14 = r12 & r13
     11: store , r14
     12: r16 = 128
     13: r17 = load bit_idx
     14: 46
     15: store , r18
     16: r19 = load canvas
     17: r20 = load byte_idx
     18: 15 ; Load array element (u8)
     19: r22 = load mask
     20: r23 = r21 | r22
     21: r24 = load canvas
     22: r25 = load byte_idx
     23: r26 = r24 + r25 ; Calculate array element address
     24: 57 ; Store to array[index] (u8)
     25: return

Function mnist_complete.clear_pixel(x: u8, y: u8) -> void
  @smc
  Locals:
    r3 = byte_idx: u8
    r11 = bit_idx: u8
    r15 = mask: u8
  Instructions:
      0: 12
      1: r5 = 2
      2: r6 = r4 * r5
      3: 12
      4: r8 = 8
      5: 36
      6: r10 = r6 + r9
      7: store , r10
      8: 12
      9: r13 = 7
     10: r14 = r12 & r13
     11: store , r14
     12: r16 = 128
     13: r17 = load bit_idx
     14: 46
     15: store , r18
     16: r19 = load canvas
     17: r20 = load byte_idx
     18: 15 ; Load array element (u8)
     19: r22 = load mask
     20: r23 = r21 & r22
     21: r24 = 0
     22: r25 = r23 != r24
     23: jump_if_not r25, else_3
     24: r26 = load canvas
     25: r27 = load byte_idx
     26: 15 ; Load array element (u8)
     27: r29 = load mask
     28: r30 = r28 ^ r29
     29: r31 = load canvas
     30: r32 = load byte_idx
     31: r33 = r31 + r32 ; Calculate array element address
     32: 57 ; Store to array[index] (u8)
     33: jump end_if_4
     34: else_3:
     35: end_if_4:
     36: return

Function mnist_complete.toggle_pixel() -> void
  @smc
  Locals:
    r1 = x: u8
    r3 = y: u8
    r5 = byte_idx: u8
    r13 = bit_idx: u8
    r17 = mask: u8
  Instructions:
      0: r2 = load cursor_x
      1: store , r2
      2: r4 = load cursor_y
      3: store , r4
      4: r6 = load y
      5: r7 = 2
      6: r8 = r6 * r7
      7: r9 = load x
      8: r10 = 8
      9: 36
     10: r12 = r8 + r11
     11: store , r12
     12: r14 = load x
     13: r15 = 7
     14: r16 = r14 & r15
     15: store , r16
     16: r18 = 128
     17: r19 = load bit_idx
     18: 46
     19: store , r20
     20: r21 = load canvas
     21: r22 = load byte_idx
     22: 15 ; Load array element (u8)
     23: r24 = load mask
     24: r25 = r23 ^ r24
     25: r26 = load canvas
     26: r27 = load byte_idx
     27: r28 = r26 + r27 ; Calculate array element address
     28: 57 ; Store to array[index] (u8)
     29: return

Function mnist_complete.is_pixel_set(x: u8, y: u8) -> bool
  @smc
  Locals:
    r3 = byte_idx: u8
    r11 = bit_idx: u8
    r15 = mask: u8
  Instructions:
      0: 12
      1: r5 = 2
      2: r6 = r4 * r5
      3: 12
      4: r8 = 8
      5: 36
      6: r10 = r6 + r9
      7: store , r10
      8: 12
      9: r13 = 7
     10: r14 = r12 & r13
     11: store , r14
     12: r16 = 128
     13: r17 = load bit_idx
     14: 46
     15: store , r18
     16: r19 = load canvas
     17: r20 = load byte_idx
     18: 15 ; Load array element (u8)
     19: r22 = load mask
     20: r23 = r21 & r22
     21: r24 = 0
     22: r25 = r23 != r24
     23: return r25

Function mnist_complete.move_cursor_up() -> void
  @smc
  Instructions:
      0: r1 = load cursor_y
      1: r2 = 0
      2: r3 = r1 > r2
      3: jump_if_not r3, else_5
      4: r4 = load cursor_y
      5: r5 = 1
      6: r6 = r4 - r5
      7: store cursor_y, r6
      8: jump end_if_6
      9: else_5:
     10: end_if_6:
     11: return

Function mnist_complete.move_cursor_down() -> void
  @smc
  Instructions:
      0: r1 = load cursor_y
      1: r2 = 15
      2: r3 = r1 < r2
      3: jump_if_not r3, else_7
      4: r4 = load cursor_y
      5: r5 = 1
      6: r6 = r4 + r5
      7: store cursor_y, r6
      8: jump end_if_8
      9: else_7:
     10: end_if_8:
     11: return

Function mnist_complete.move_cursor_left() -> void
  @smc
  Instructions:
      0: r1 = load cursor_x
      1: r2 = 0
      2: r3 = r1 > r2
      3: jump_if_not r3, else_9
      4: r4 = load cursor_x
      5: r5 = 1
      6: r6 = r4 - r5
      7: store cursor_x, r6
      8: jump end_if_10
      9: else_9:
     10: end_if_10:
     11: return

Function mnist_complete.move_cursor_right() -> void
  @smc
  Instructions:
      0: r1 = load cursor_x
      1: r2 = 15
      2: r3 = r1 < r2
      3: jump_if_not r3, else_11
      4: r4 = load cursor_x
      5: r5 = 1
      6: r6 = r4 + r5
      7: store cursor_x, r6
      8: jump end_if_12
      9: else_11:
     10: end_if_12:
     11: return

Function mnist_complete.clear_canvas() -> void
  @smc
  Locals:
    r1 = i: u8
  Instructions:
      0: r2 = 0
      1: store , r2
      2: r3 = 32
      3: r4 = r3 ; Initialize loop counter
      4: 5 ; Skip if count is zero
      5: do_times_13:
      6: r5 = 0
      7: r6 = load canvas
      8: r7 = load i
      9: r8 = r6 + r7 ; Calculate array element address
     10: 57 ; Store to array[index] (u8)
     11: r9 = load i
     12: r10 = 1
     13: r11 = r9 + r10
     14: store i, r11
     15: 40 ; Decrement counter
     16: 6 ; Loop if counter not zero (DJNZ pattern)
     17: do_end_14:
     18: return

Function mnist_complete.calc_screen_addr(x: u8, y: u8) -> u16
  @smc
  Locals:
    r3 = screen_base: u16
    r5 = y_low: u8
    r9 = y_mid: u8
    r15 = y_high: u8
    r19 = addr: u16
  Instructions:
      0: r4 = 16384
      1: store , r4
      2: 12
      3: r7 = 7
      4: r8 = r6 & r7
      5: store , r8
      6: 12
      7: r11 = 3
      8: 46
      9: r13 = 7
     10: r14 = r12 & r13
     11: store , r14
     12: 12
     13: r17 = 6
     14: 46
     15: store , r18
     16: r20 = load screen_base
     17: store , r20
     18: r21 = load addr
     19: r22 = load y_high
     20: r23 = 2048
     21: r24 = r22 * r23
     22: r25 = r21 + r24
     23: store addr, r25
     24: r26 = load addr
     25: r27 = load y_mid
     26: r28 = 32
     27: r29 = r27 * r28
     28: r30 = r26 + r29
     29: store addr, r30
     30: r31 = load addr
     31: r32 = load y_low
     32: r33 = 256
     33: r34 = r32 * r33
     34: r35 = r31 + r34
     35: store addr, r35
     36: r36 = load addr
     37: 12
     38: r38 = 8
     39: 36
     40: r40 = r36 + r39
     41: store addr, r40
     42: r41 = load addr
     43: return r41

Function mnist_complete.render_to_screen() -> void
  @smc
  Locals:
    r1 = grid_x: u8
    r3 = grid_y: u8
    r5 = y: u8
    r10 = x: u8
    r15 = pixel_on: bool
    r19 = screen_x: u8
    r23 = screen_y: u8
    r27 = screen_addr: u16
    r31 = pixel_mask: u8
  Instructions:
      0: r2 = 64
      1: store , r2
      2: r4 = 48
      3: store , r4
      4: r6 = 0
      5: store , r6
      6: loop_15:
      7: r7 = load y
      8: r8 = 16
      9: r9 = r7 < r8
     10: jump_if_not r9, end_loop_16
     11: r11 = 0
     12: store , r11
     13: loop_17:
     14: r12 = load x
     15: r13 = 16
     16: r14 = r12 < r13
     17: jump_if_not r14, end_loop_18
     18: r16 = load x
     19: r17 = load y
     20: r18 = call is_pixel_set
     21: store , r18
     22: r20 = load grid_x
     23: r21 = load x
     24: r22 = r20 + r21
     25: store , r22
     26: r24 = load grid_y
     27: r25 = load y
     28: r26 = r24 + r25
     29: store , r26
     30: r28 = load screen_x
     31: r29 = load screen_y
     32: r30 = call calc_screen_addr
     33: store , r30
     34: r32 = 128
     35: r33 = load screen_x
     36: r34 = 7
     37: r35 = r33 & r34
     38: 46
     39: store , r36
     40: r37 = load x
     41: r38 = 1
     42: r39 = r37 + r38
     43: store x, r39
     44: jump loop_17
     45: end_loop_18:
     46: r40 = load y
     47: r41 = 1
     48: r42 = r40 + r41
     49: store y, r42
     50: jump loop_15
     51: end_loop_16:
     52: return

Function mnist_complete.render_cursor() -> void
  @smc
  Locals:
    r1 = flash: bool
    r11 = grid_x: u8
    r13 = grid_y: u8
    r15 = cursor_screen_x: u8
    r19 = cursor_screen_y: u8
    r23 = cursor_addr: u16
    r27 = cursor_mask: u8
  Instructions:
      0: r2 = load flash_counter
      1: r3 = 16
      2: r4 = r2 & r3
      3: r5 = 0
      4: r6 = r4 != r5
      5: store , r6
      6: r7 = load flash_counter
      7: r8 = 1
      8: r9 = r7 + r8
      9: store flash_counter, r9
     10: r10 = load flash
     11: jump_if_not r10, else_19
     12: r12 = 64
     13: store , r12
     14: r14 = 48
     15: store , r14
     16: r16 = load grid_x
     17: r17 = load cursor_x
     18: r18 = r16 + r17
     19: store , r18
     20: r20 = load grid_y
     21: r21 = load cursor_y
     22: r22 = r20 + r21
     23: store , r22
     24: r24 = load cursor_screen_x
     25: r25 = load cursor_screen_y
     26: r26 = call calc_screen_addr
     27: store , r26
     28: r28 = 128
     29: r29 = load cursor_screen_x
     30: r30 = 7
     31: r31 = r29 & r30
     32: 46
     33: store , r32
     34: jump end_if_20
     35: else_19:
     36: end_if_20:
     37: return

Function mnist_complete.simulate_input() -> u8
  @smc
  Locals:
    r1 = sim_input: u8
  Instructions:
      0: r2 = load flash_counter
      1: r3 = 15
      2: r4 = r2 & r3
      3: store , r4
      4: r5 = load sim_input
      5: r6 = 4
      6: r7 = r5 < r6
      7: jump_if_not r7, else_21
      8: r8 = 1
      9: return r8
     10: jump end_if_22
     11: else_21:
     12: r9 = load sim_input
     13: r10 = 8
     14: r11 = r9 < r10
     15: jump_if_not r11, else_23
     16: r12 = 2
     17: return r12
     18: jump end_if_24
     19: else_23:
     20: r13 = load sim_input
     21: r14 = 12
     22: r15 = r13 < r14
     23: jump_if_not r15, else_25
     24: r16 = 3
     25: return r16
     26: jump end_if_26
     27: else_25:
     28: r17 = 0
     29: return r17
     30: end_if_26:
     31: end_if_24:
     32: end_if_22:
     33: return

Function mnist_complete.handle_input() -> bool
  @smc
  Locals:
    r1 = input: u8
    r3 = handled: bool
    r8 = direction: u8
  Instructions:
      0: r2 = call simulate_input
      1: store , r2
      2: r4 = 0
      3: store , r4
      4: r5 = load input
      5: r6 = 1
      6: r7 = r5 == r6
      7: jump_if_not r7, else_27
      8: r9 = load flash_counter
      9: r10 = 3
     10: r11 = r9 & r10
     11: store , r11
     12: r12 = load direction
     13: r13 = 0
     14: r14 = r12 == r13
     15: jump_if_not r14, else_29
     16: r15 = call move_cursor_up
     17: jump end_if_30
     18: else_29:
     19: r16 = load direction
     20: r17 = 1
     21: r18 = r16 == r17
     22: jump_if_not r18, else_31
     23: r19 = call move_cursor_down
     24: jump end_if_32
     25: else_31:
     26: r20 = load direction
     27: r21 = 2
     28: r22 = r20 == r21
     29: jump_if_not r22, else_33
     30: r23 = call move_cursor_left
     31: jump end_if_34
     32: else_33:
     33: r24 = call move_cursor_right
     34: end_if_34:
     35: end_if_32:
     36: end_if_30:
     37: r25 = 1
     38: store handled, r25
     39: jump end_if_28
     40: else_27:
     41: r26 = load input
     42: r27 = 2
     43: r28 = r26 == r27
     44: jump_if_not r28, else_35
     45: r29 = call toggle_pixel
     46: r30 = 1
     47: store handled, r30
     48: jump end_if_36
     49: else_35:
     50: r31 = load input
     51: r32 = 3
     52: r33 = r31 == r32
     53: jump_if_not r33, else_37
     54: r34 = call clear_canvas
     55: r35 = 1
     56: store handled, r35
     57: jump end_if_38
     58: else_37:
     59: end_if_38:
     60: end_if_36:
     61: end_if_28:
     62: r36 = load handled
     63: return r36

Function mnist_complete.count_set_pixels() -> u16
  @smc
  Locals:
    r1 = count: u16
    r3 = i: u8
    r8 = byte_val: u8
    r12 = bit_pos: u8
    r17 = test_mask: u8
  Instructions:
      0: r2 = 0
      1: store , r2
      2: r4 = 0
      3: store , r4
      4: loop_39:
      5: r5 = load i
      6: r6 = 32
      7: r7 = r5 < r6
      8: jump_if_not r7, end_loop_40
      9: r9 = load canvas
     10: r10 = load i
     11: 15 ; Load array element (u8)
     12: store , r11
     13: r13 = 0
     14: store , r13
     15: loop_41:
     16: r14 = load bit_pos
     17: r15 = 8
     18: r16 = r14 < r15
     19: jump_if_not r16, end_loop_42
     20: r18 = 1
     21: r19 = load bit_pos
     22: 45
     23: store , r20
     24: r21 = load byte_val
     25: r22 = load test_mask
     26: r23 = r21 & r22
     27: r24 = 0
     28: r25 = r23 != r24
     29: jump_if_not r25, else_43
     30: r26 = load count
     31: r27 = 1
     32: r28 = r26 + r27
     33: store count, r28
     34: jump end_if_44
     35: else_43:
     36: end_if_44:
     37: r29 = load bit_pos
     38: r30 = 1
     39: r31 = r29 + r30
     40: store bit_pos, r31
     41: jump loop_41
     42: end_loop_42:
     43: r32 = load i
     44: r33 = 1
     45: r34 = r32 + r33
     46: store i, r34
     47: jump loop_39
     48: end_loop_40:
     49: r35 = load count
     50: return r35

Function mnist_complete.draw_welcome_pattern() -> void
  @smc
  Locals:
    r1 = edge: u8
    r21 = diag: u8
  Instructions:
      0: r2 = 0
      1: store , r2
      2: loop_45:
      3: r3 = load edge
      4: r4 = 16
      5: r5 = r3 < r4
      6: jump_if_not r5, end_loop_46
      7: r6 = load edge
      8: r7 = 0
      9: r8 = call set_pixel
     10: r9 = load edge
     11: r10 = 15
     12: r11 = call set_pixel
     13: r12 = 0
     14: r13 = load edge
     15: r14 = call set_pixel
     16: r15 = 15
     17: r16 = load edge
     18: r17 = call set_pixel
     19: r18 = load edge
     20: r19 = 1
     21: r20 = r18 + r19
     22: store edge, r20
     23: jump loop_45
     24: end_loop_46:
     25: r22 = 2
     26: store , r22
     27: loop_47:
     28: r23 = load diag
     29: r24 = 14
     30: r25 = r23 < r24
     31: jump_if_not r25, end_loop_48
     32: r26 = load diag
     33: r27 = load diag
     34: r28 = call set_pixel
     35: r29 = load diag
     36: r30 = 1
     37: r31 = r29 + r30
     38: store diag, r31
     39: jump loop_47
     40: end_loop_48:
     41: r32 = 7
     42: r33 = 8
     43: r34 = call set_pixel
     44: r35 = 8
     45: r36 = 8
     46: r37 = call set_pixel
     47: r38 = 9
     48: r39 = 8
     49: r40 = call set_pixel
     50: r41 = 8
     51: r42 = 7
     52: r43 = call set_pixel
     53: r44 = 8
     54: r45 = 9
     55: r46 = call set_pixel
     56: return

Function mnist_complete.test_modern_loops() -> void
  @smc
  Locals:
    r1 = i: u8
    r6 = current: u8
  Instructions:
      0: r2 = 0
      1: store , r2
      2: loop_49:
      3: r3 = load i
      4: r4 = 32
      5: r5 = r3 < r4
      6: jump_if_not r5, end_loop_50
      7: r7 = load canvas
      8: r8 = load i
      9: 15 ; Load array element (u8)
     10: store , r9
     11: r10 = load current
     12: r11 = 240
     13: r12 = r10 & r11
     14: r13 = load canvas
     15: r14 = load i
     16: r15 = r13 + r14 ; Calculate array element address
     17: 57 ; Store to array[index] (u8)
     18: r16 = load i
     19: r17 = 1
     20: r18 = r16 + r17
     21: store i, r18
     22: jump loop_49
     23: end_loop_50:
     24: return

Function mnist_complete.delay() -> void
  @smc
  Locals:
    r1 = count: u16
  Instructions:
      0: r2 = 0
      1: store , r2
      2: loop_51:
      3: r3 = load count
      4: r4 = 300
      5: r5 = r3 < r4
      6: jump_if_not r5, end_loop_52
      7: r6 = load count
      8: r7 = 1
      9: r8 = r6 + r7
     10: store count, r8
     11: jump loop_51
     12: end_loop_52:
     13: return

Function mnist_complete.main() -> void
  @smc
  Locals:
    r3 = frame: u16
    r17 = pixel_count: u16
    r40 = final_count: u16
  Instructions:
      0: r1 = call init_editor
      1: r2 = call draw_welcome_pattern
      2: r4 = 0
      3: store , r4
      4: loop_53:
      5: r5 = load frame
      6: r6 = 150
      7: r7 = r5 < r6
      8: jump_if_not r7, end_loop_54
      9: r8 = call render_to_screen
     10: r9 = call render_cursor
     11: r10 = call handle_input
     12: jump_if_not r10, else_55
     13: r11 = call delay
     14: jump end_if_56
     15: else_55:
     16: end_if_56:
     17: r12 = load frame
     18: r13 = 31
     19: r14 = r12 & r13
     20: r15 = 0
     21: r16 = r14 == r15
     22: jump_if_not r16, else_57
     23: r18 = call count_set_pixels
     24: store , r18
     25: r19 = load pixel_count
     26: r20 = 80
     27: r21 = r19 > r20
     28: jump_if_not r21, else_59
     29: r22 = call test_modern_loops
     30: jump end_if_60
     31: else_59:
     32: end_if_60:
     33: jump end_if_58
     34: else_57:
     35: end_if_58:
     36: r23 = call delay
     37: r24 = load frame
     38: r25 = 1
     39: r26 = r24 + r25
     40: store frame, r26
     41: jump loop_53
     42: end_loop_54:
     43: r27 = call clear_canvas
     44: r28 = 5
     45: store cursor_x, r28
     46: r29 = 5
     47: store cursor_y, r29
     48: r30 = call toggle_pixel
     49: r31 = 10
     50: store cursor_x, r31
     51: r32 = 10
     52: store cursor_y, r32
     53: r33 = call toggle_pixel
     54: r34 = 5
     55: store cursor_x, r34
     56: r35 = 10
     57: store cursor_y, r35
     58: r36 = call toggle_pixel
     59: r37 = 10
     60: store cursor_x, r37
     61: r38 = 5
     62: store cursor_y, r38
     63: r39 = call toggle_pixel
     64: r41 = call count_set_pixels
     65: store , r41
     66: return

