; MinZ generated code
; Generated: 2025-08-17 16:56:41


; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.pointer_arithmetic.array_sum$p_u8$u8
p_u8_u8:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r4 = 0
    LD A, 0
    ; Register 4 already in A
    ; store sum, r4
    LD ($F006), HL
    ; r6 = 0
    LD A, 0
    LD B, A         ; Store to physical register B
    ; store i, r6
    LD A, B
    LD ($F00A), A
    ; loop_1:
___examples_pointer_arithmetic_array_sum_p_u8_u8_loop_1:
    ; r7 = load i
    LD A, ($F00A)
    LD D, A         ; Store to physical register D
p_u8_u8_param_count.op:
p_u8_u8_param_count equ p_u8_u8_param_count.op + 1
    LD B, #00      ; Parameter count (gets patched)
    LD A, B
    LD E, A         ; Store to physical register E
    ; r9 = r7 < r8
    ; E already in place
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, ___examples_pointer_arithmetic_array_sum_p_u8_u8_lt_true_0
    LD HL, 0       ; False
    JP ___examples_pointer_arithmetic_array_sum_p_u8_u8_lt_done_0
___examples_pointer_arithmetic_array_sum_p_u8_u8_lt_true_0:
    LD HL, 1       ; True
___examples_pointer_arithmetic_array_sum_p_u8_u8_lt_done_0:
    ; jump_if_not r9, end_loop_2
    EXX               ; Switch to shadow registers
    LD A, C         ; From shadow C' (now active)
    EXX               ; Switch back to main registers
    OR A
    JP Z, ___examples_pointer_arithmetic_array_sum_p_u8_u8_end_loop_2
    ; r10 = load sum
    LD HL, ($F006)
; TSMC reference parameter data
data$immOP:
    LD HL, 0000      ; TSMC ref address for data
data$imm0 EQU data$immOP+1
    LD D, H
    LD E, L
    ; r12 = *r11
    LD H, D
    LD L, E
    LD A, (HL)
    EXX               ; Switch to shadow registers
    LD E, A         ; Store to shadow E' (now active)
    EXX               ; Switch back to main registers
    ; r13 = r10 + r12
    LD D, H
    LD E, L
    ADD HL, DE
    LD B, H
    LD C, L
    ; store sum, r13
    LD H, B
    LD L, C
    LD ($F006), HL
    LD HL, (data$imm0) ; Reload TSMC ref address
    PUSH HL           ; Save current HL
    EXX               ; Switch to shadow registers
    POP HL            ; Load into shadow HL
    EXX               ; Switch back to main registers
    ; r15 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; r16 = r14 + r15
    EXX               ; Switch to shadow registers
    PUSH HL           ; Save shadow HL
    EXX               ; Switch back to main registers
    POP HL            ; Load shadow HL into main HL
    LD D, H
    LD E, L
    ; Register 15 already in HL
    ADD HL, DE
    LD ($F020), HL    ; Virtual register 16 to memory
    ; store data, r16
    LD HL, ($F020)    ; Virtual register 16 from memory
    LD ($F000), HL
    ; r17 = load i
    LD A, ($F00A)
    LD ($F022), A     ; Virtual register 17 to memory
    ; r18 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r19 = r17 + r18
    LD HL, ($F022)    ; Virtual register 17 from memory
    LD D, H
    LD E, L
    ADD HL, DE
    ; store i, r19
    LD A, L
    LD ($F00A), A
    ; jump loop_1
    JP ___examples_pointer_arithmetic_array_sum_p_u8_u8_loop_1
    ; end_loop_2:
___examples_pointer_arithmetic_array_sum_p_u8_u8_end_loop_2:
    ; r20 = load sum
    LD HL, ($F006)
    ; Register 20 already in HL
    ; return r20
    ; Register 20 already in HL
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: ...examples.pointer_arithmetic.find_max$p_u8$u8
p_u8_u8:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
; TSMC reference parameter data
data$immOP:
    LD HL, 0000      ; TSMC ref address for data
data$imm0 EQU data$immOP+1
    ; r5 = *r4
    LD A, (HL)
    LD L, A         ; Store to HL (low byte)
    ; store max, r5
    LD A, L
    LD ($F006), A
    LD HL, (data$imm0) ; Reload TSMC ref address
    LD ($F00C), HL    ; Virtual register 6 to memory
    ; r7 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; r8 = r6 + r7
    LD HL, ($F00C)    ; Virtual register 6 from memory
    LD D, H
    LD E, L
    ; Register 7 already in HL
    ADD HL, DE
    ; store data, r8
    LD ($F000), HL
    ; r10 = 1
    LD A, 1
    LD ($F014), A     ; Virtual register 10 to memory
    ; store i, r10
    LD A, ($F014)     ; Virtual register 10 from memory
    LD ($F012), A
    ; loop_3:
___examples_pointer_arithmetic_find_max_p_u8_u8_loop_3:
    ; r11 = load i
    LD A, ($F012)
    LD L, A         ; Store to physical register L
p_u8_u8_param_count.op:
p_u8_u8_param_count equ p_u8_u8_param_count.op + 1
    LD B, #00      ; Parameter count (gets patched)
    LD A, B
    LD L, A         ; Store to HL (low byte)
    ; r13 = r11 < r12
    LD D, H
    LD E, L
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP M, ___examples_pointer_arithmetic_find_max_p_u8_u8_lt_true_1
    LD HL, 0       ; False
    JP ___examples_pointer_arithmetic_find_max_p_u8_u8_lt_done_1
___examples_pointer_arithmetic_find_max_p_u8_u8_lt_true_1:
    LD HL, 1       ; True
___examples_pointer_arithmetic_find_max_p_u8_u8_lt_done_1:
    ; jump_if_not r13, end_loop_4
    LD A, H
    OR A
    JP Z, ___examples_pointer_arithmetic_find_max_p_u8_u8_end_loop_4
    LD HL, (data$imm0) ; Reload TSMC ref address
    ; r15 = *r14
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; r16 = load max
    LD A, ($F006)
    LD L, A         ; Store to physical register L
    ; r17 = r15 > r16
    LD E, L        ; Load 8-bit value to DE
    LD D, 0        ; Zero extend
    OR A           ; Clear carry
    SBC HL, DE     ; Compare Src1 - Src2
    JP P, ___examples_pointer_arithmetic_find_max_p_u8_u8_gt_check_zero_2
    LD HL, 0       ; False (negative)
    JP ___examples_pointer_arithmetic_find_max_p_u8_u8_gt_done_2
___examples_pointer_arithmetic_find_max_p_u8_u8_gt_check_zero_2:
    LD A, H
    OR L           ; Check if result is zero
    JP Z, ___examples_pointer_arithmetic_find_max_p_u8_u8_gt_false_2
    LD HL, 1       ; True (positive and non-zero)
    JP ___examples_pointer_arithmetic_find_max_p_u8_u8_gt_done_2
___examples_pointer_arithmetic_find_max_p_u8_u8_gt_false_2:
    LD HL, 0       ; False (zero)
___examples_pointer_arithmetic_find_max_p_u8_u8_gt_done_2:
    ; Register 17 already in HL
    ; jump_if_not r17, else_5
    LD A, L
    OR A
    JP Z, ___examples_pointer_arithmetic_find_max_p_u8_u8_else_5
    LD HL, (data$imm0) ; Reload TSMC ref address
    ; r19 = *r18
    LD A, (HL)
    LD L, A         ; Store to HL (low byte)
    ; store max, r19
    LD A, L
    LD ($F006), A
    ; jump end_if_6
    JP ___examples_pointer_arithmetic_find_max_p_u8_u8_end_if_6
    ; else_5:
___examples_pointer_arithmetic_find_max_p_u8_u8_else_5:
    ; end_if_6:
___examples_pointer_arithmetic_find_max_p_u8_u8_end_if_6:
    LD HL, (data$imm0) ; Reload TSMC ref address
    LD ($F028), HL    ; Virtual register 20 to memory
    ; r21 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; r22 = r20 + r21
    LD HL, ($F028)    ; Virtual register 20 from memory
    LD D, H
    LD E, L
    ; Register 21 already in HL
    ADD HL, DE
    ; store data, r22
    LD ($F000), HL
    ; r23 = load i
    LD A, ($F012)
    LD L, A         ; Store to physical register L
    ; r24 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; r25 = r23 + r24
    LD D, H
    LD E, L
    ; Register 24 already in HL
    ADD HL, DE
    ; store i, r25
    LD A, H
    LD ($F012), A
    ; jump loop_3
    JP ___examples_pointer_arithmetic_find_max_p_u8_u8_loop_3
    ; end_loop_4:
___examples_pointer_arithmetic_find_max_p_u8_u8_end_loop_4:
    ; r26 = load max
    LD A, ($F006)
    LD L, A         ; Store to physical register L
    ; return r26
    RET

    END main
