// Demonstration of zero-cost Printable interface and compile-time print!

import std.io_v2;

// Custom type implementing Printable
struct Point {
    x: u8,
    y: u8,
}

impl Printable for Point {
    fun to_string(self) -> *u8 {
        // This will be optimized at compile time!
        @static_buffer(10);
        @format!("({},{})", self.x, self.y);
    }
}

// Game state that can be printed
struct GameState {
    score: u16,
    lives: u8,
    level: u8,
}

impl Printable for GameState {
    fun to_string(self) -> *u8 {
        @static_buffer(32);
        @format!("Score:{} Lives:{} Level:{}", self.score, self.lives, self.level);
    }
}

// Demonstrate zero-cost printing
fun main() -> u8 {
    // Simple printing - no runtime format parsing!
    let x: u8 = 42;
    let y: u8 = 13;
    print!("The answer is {}, not {}\n", x, y);
    
    // Hex formatting
    let address: u16 = 0x8000;
    print!("Code starts at {:04x}\n", address);
    
    // Custom types
    let p = Point { x: 10, y: 20 };
    print!("Player at {}\n", p);
    
    // Complex formatting
    let state = GameState {
        score: 1234,
        lives: 3,
        level: 5,
    };
    print!("Game: {}\n", state);
    
    // Conditional debug printing (removed in release builds)
    @debug {
        print!("[DEBUG] Internal state: x={}, y={}\n", x, y);
    }
    
    // String interpolation at compile time
    let msg = s!("Player at {} with score {}", p, state.score);
    print!("{}\n", msg);
    
    // Platform-specific optimizations
    @platform("zx_spectrum") {
        // This entire block is resolved at compile time!
        print!("Running on ZX Spectrum at {:04x}\n", 0x4000);
    }
    
    // Zero-cost number formatting
    for i in 0..10 {
        // Even this loop's print is optimized!
        print!("{} ", i);
    }
    print!("\n");
    
    // Advanced: Table formatting
    print!("╔══════════════════════╗\n");
    print!("║ {:^20} ║\n", "High Scores");
    print!("╠══════════════════════╣\n");
    print!("║ {:>3}. {:<12} {:>5} ║\n", 1, "Alice", 9999);
    print!("║ {:>3}. {:<12} {:>5} ║\n", 2, "Bob", 8500);
    print!("║ {:>3}. {:<12} {:>5} ║\n", 3, "Charlie", 7200);
    print!("╚══════════════════════╝\n");
    
    return 0;
}

// This compiles to highly optimized assembly with:
// - No format string parsing at runtime
// - Direct calls to type-specific formatters
// - Compile-time string literal optimization
// - Platform-specific output routines
// - Zero heap allocation

// Example of generated code for print!("x = {}", x):
// 
// LD HL, .str1        ; "x = "
// CALL print_string
// LD A, (x)
// CALL print_u8
//
// No format string parsing, no runtime dispatch!