// MNIST Digit Editor for ZX Spectrum
// Interactive 16x16 pixel editor with attribute-based UI
// Controls: Q/A=up/down, O/P=left/right, SPACE=toggle pixel, C=clear

module mnist_editor;

import zx.screen;
import zx.input;

// Editor state
struct Editor {
    cursor_x: u8,     // 0-15
    cursor_y: u8,     // 0-15
    canvas: [bool; 256]  // 16x16 pixel canvas flattened
}

// Initialize editor
fun editor_init() -> Editor {
    let mut editor: Editor;
    
    // TODO: Field assignment not yet implemented, use workaround
    // editor.cursor_x = 8;
    // editor.cursor_y = 8;
    
    // For now, initialize to 0,0
    // Will need to implement field assignment
    
    // Clear canvas
    let mut i: u16 = 0;
    while i < 256 {
        // TODO: Array element assignment
        // editor.canvas[i] = false;
        i = i + 1;
    }
    
    return editor;
}

// Draw the UI frame
fun draw_frame() -> void {
    // Clear screen - white on black
    screen.clear(screen.WHITE, screen.BLACK, false, false);
    
    // Set border to blue
    screen.set_border(screen.BLUE);
    
    // Draw title at top (char position 0,0)
    // TODO: String literals not yet supported
    // draw_text(0, 0, "MNIST DIGIT EDITOR", screen.WHITE, screen.BLUE);
    
    // Draw instructions
    // draw_text(0, 22, "Q/A:UP/DN O/P:L/R SPC:DRAW C:CLR", screen.YELLOW, screen.BLACK);
    
    // Draw 16x16 grid border
    // Grid starts at pixel (64, 48) = char (8, 6)
    let grid_x: u8 = 64;
    let grid_y: u8 = 48;
    
    // Draw border around grid (18x18 to include borders)
    screen.draw_rect(grid_x - 1, grid_y - 1, 18, 18);
}

// Draw the 16x16 canvas
fun draw_canvas(editor: *Editor) -> void {
    let grid_x: u8 = 64;  // Start X pixel
    let grid_y: u8 = 48;  // Start Y pixel
    
    let mut y: u8 = 0;
    while y < 16 {
        let mut x: u8 = 0;
        while x < 16 {
            let px = grid_x + x;
            let py = grid_y + y;
            let idx: u16 = (y as u16) * 16 + (x as u16);
            
            // TODO: Array element access through pointer
            // if editor.canvas[idx] {
            //     screen.set_pixel(px, py);
            // } else {
            //     screen.clear_pixel(px, py);
            // }
            x = x + 1;
        }
        y = y + 1;
    }
}

// Draw cursor (flashing pixel)
fun draw_cursor(editor: *Editor, flash: bool) -> void {
    let grid_x: u8 = 64;
    let grid_y: u8 = 48;
    
    // TODO: Field access through pointer
    // let px = grid_x + editor.cursor_x;
    // let py = grid_y + editor.cursor_y;
    let px = grid_x;
    let py = grid_y;
    
    // Set attribute for cursor position to make it visible
    let char_x = px / 8;
    let char_y = py / 8;
    let attr_addr = screen.attr_addr(char_x, char_y);
    
    if flash {
        // Invert colors for cursor
        asm("
            ld hl, {0}
            ld a, (hl)
            xor $07  ; Invert ink bits
            ld (hl), a
        " : : "r"(attr_addr));
    }
}

// Handle keyboard input
fun handle_input(editor: *Editor) -> bool {
    // Check movement keys
    if input.is_key_pressed(input.KEY_Q) {
        // Move up
        // TODO: Field access/assignment through pointer
        // if editor.cursor_y > 0 {
        //     editor.cursor_y = editor.cursor_y - 1;
        // }
        return true;
    }
    
    if input.is_key_pressed(input.KEY_A) {
        // Move down
        // TODO: Field access/assignment through pointer
        // if editor.cursor_y < 15 {
        //     editor.cursor_y = editor.cursor_y + 1;
        // }
        return true;
    }
    
    if input.is_key_pressed(input.KEY_O) {
        // Move left
        // TODO: Field access/assignment through pointer
        // if editor.cursor_x > 0 {
        //     editor.cursor_x = editor.cursor_x - 1;
        // }
        return true;
    }
    
    if input.is_key_pressed(input.KEY_P) {
        // Move right
        // TODO: Field access/assignment through pointer
        // if editor.cursor_x < 15 {
        //     editor.cursor_x = editor.cursor_x + 1;
        // }
        return true;
    }
    
    if input.is_key_pressed(input.KEY_SPACE) {
        // Toggle pixel
        // TODO: Field access and array element assignment
        // let x = editor.cursor_x;
        // let y = editor.cursor_y;
        // let idx: u16 = (y as u16) * 16 + (x as u16);
        // editor.canvas[idx] = !editor.canvas[idx];
        return true;
    }
    
    if input.is_key_pressed(input.KEY_C) {
        // Clear canvas
        let mut i: u16 = 0;
        while i < 256 {
            // TODO: Array element assignment
            // editor.canvas[i] = false;
            i = i + 1;
        }
        return true;
    }
    
    return false;
}

// Simple delay for key repeat
fun delay() -> void {
    let mut count: u16 = 0;
    while count < 5000 {
        count = count + 1;
    }
}

// Main program
fun main() -> void {
    // Initialize editor
    let mut editor = editor_init();
    
    // Draw initial UI
    draw_frame();
    
    // Main loop
    let mut flash_counter: u8 = 0;
    loop {
        // Draw canvas
        draw_canvas(&editor);
        
        // Draw cursor with flashing
        let flash = (flash_counter & 0x10) != 0;
        draw_cursor(&editor, flash);
        flash_counter = flash_counter + 1;
        
        // Handle input
        if handle_input(&editor) {
            // Debounce delay after key press
            delay();
        }
        
        // Small delay for main loop
        delay();
    }
}