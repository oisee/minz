// MNIST Digit Editor for ZX Spectrum - Simple Version
// Interactive 16x16 pixel editor
// Controls: Q/A=up/down, O/P=left/right, SPACE=toggle pixel

module mnist_editor_simple;

// ZX Spectrum screen constants
const SCREEN_ADDR: u16 = 0x4000;
const ATTR_ADDR: u16 = 0x5800;

// Editor state
struct Editor {
    cursor_x: u8,
    cursor_y: u8,
    canvas: [u8; 32],  // 16x16 bits = 256 bits = 32 bytes
}

// Calculate screen address from pixel coordinates
fun pixel_addr(x: u8, y: u8) -> u16 {
    let y_low: u8 = y & 0x07;
    let y_mid: u8 = (y & 0x38) >> 3;
    let y_high: u8 = (y & 0xC0) >> 6;
    
    let addr: u16 = SCREEN_ADDR;
    addr = addr | ((y_low as u16) << 8);
    addr = addr | ((y_mid as u16) << 5);
    addr = addr | ((y_high as u16) << 11);
    addr = addr | ((x >> 3) as u16);
    
    return addr;
}

// Set pixel at coordinates
fun set_pixel(x: u8, y: u8) -> void {
    let addr = pixel_addr(x, y);
    let bit: u8 = 0x80 >> (x & 0x07);
    
    asm("
        ld hl, {0}
        ld a, (hl)
        or {1}
        ld (hl), a
    " : : "r"(addr), "r"(bit));
}

// Clear pixel at coordinates
fun clear_pixel(x: u8, y: u8) -> void {
    let addr = pixel_addr(x, y);
    let bit: u8 = ~(0x80 >> (x & 0x07));
    
    asm("
        ld hl, {0}
        ld a, (hl)
        and {1}
        ld (hl), a
    " : : "r"(addr), "r"(bit));
}

// Read keyboard port
fun read_keyboard(port: u8) -> u8 {
    let result: u8;
    asm("
        ld a, {0}
        in a, ($fe)
        ld {1}, a
    " : "=r"(result) : "r"(port));
    return result;
}

// Check if a key is pressed (active low)
fun is_key_pressed(port: u8, bit: u8) -> bool {
    let value = read_keyboard(port);
    return (value & (1 << bit)) == 0;
}

// Clear screen
fun clear_screen() -> void {
    // Clear bitmap
    let mut addr: u16 = SCREEN_ADDR;
    let end: u16 = SCREEN_ADDR + 6144;
    
    while addr < end {
        asm("
            xor a
            ld ({0}), a
        " : : "r"(addr));
        addr = addr + 1;
    }
    
    // Set attributes to white on black
    addr = ATTR_ADDR;
    end = ATTR_ADDR + 768;
    
    while addr < end {
        asm("
            ld a, $07
            ld ({0}), a
        " : : "r"(addr));
        addr = addr + 1;
    }
}

// Draw the 16x16 canvas
fun draw_canvas(editor: *Editor) -> void {
    let grid_x: u8 = 64;  // Start X pixel (center of screen)
    let grid_y: u8 = 48;  // Start Y pixel
    
    let mut y: u8 = 0;
    while y < 16 {
        let mut x: u8 = 0;
        while x < 16 {
            // Check if pixel is set in canvas
            let byte_idx = (y * 2) + (x >> 3);
            let bit_idx = x & 0x07;
            let pixel_set = (editor.canvas[byte_idx] & (0x80 >> bit_idx)) != 0;
            
            let px = grid_x + x;
            let py = grid_y + y;
            
            if pixel_set {
                set_pixel(px, py);
            } else {
                clear_pixel(px, py);
            }
            
            x = x + 1;
        }
        y = y + 1;
    }
}

// Draw cursor
fun draw_cursor(editor: *Editor) -> void {
    let grid_x: u8 = 64;
    let grid_y: u8 = 48;
    
    let px = grid_x + editor.cursor_x;
    let py = grid_y + editor.cursor_y;
    
    // Invert pixel at cursor position for visibility
    let addr = pixel_addr(px, py);
    let bit: u8 = 0x80 >> (px & 0x07);
    
    asm("
        ld hl, {0}
        ld a, (hl)
        xor {1}
        ld (hl), a
    " : : "r"(addr), "r"(bit));
}

// Toggle pixel in canvas
fun toggle_pixel(editor: *Editor) -> void {
    let x = editor.cursor_x;
    let y = editor.cursor_y;
    
    let byte_idx = (y * 2) + (x >> 3);
    let bit_idx = x & 0x07;
    let bit_mask: u8 = 0x80 >> bit_idx;
    
    editor.canvas[byte_idx] = editor.canvas[byte_idx] ^ bit_mask;
}

// Simple delay
fun delay() -> void {
    let mut count: u16 = 0;
    while count < 2000 {
        count = count + 1;
    }
}

// Main program
fun main() -> void {
    // Initialize editor
    let mut editor: Editor;
    editor.cursor_x = 8;
    editor.cursor_y = 8;
    
    // Clear canvas
    let mut i: u8 = 0;
    while i < 32 {
        editor.canvas[i] = 0;
        i = i + 1;
    }
    
    // Clear screen
    clear_screen();
    
    // Main loop
    let mut flash_counter: u8 = 0;
    
    while true {
        // Draw canvas
        draw_canvas(&editor);
        
        // Draw cursor with flashing
        if (flash_counter & 0x10) != 0 {
            draw_cursor(&editor);
        }
        flash_counter = flash_counter + 1;
        
        // Check keyboard
        // Q = port 0xFB, bit 0
        if is_key_pressed(0xFB, 0) {
            if editor.cursor_y > 0 {
                editor.cursor_y = editor.cursor_y - 1;
                delay();
            }
        }
        
        // A = port 0xFD, bit 0
        if is_key_pressed(0xFD, 0) {
            if editor.cursor_y < 15 {
                editor.cursor_y = editor.cursor_y + 1;
                delay();
            }
        }
        
        // O = port 0xDF, bit 1
        if is_key_pressed(0xDF, 1) {
            if editor.cursor_x > 0 {
                editor.cursor_x = editor.cursor_x - 1;
                delay();
            }
        }
        
        // P = port 0xDF, bit 0
        if is_key_pressed(0xDF, 0) {
            if editor.cursor_x < 15 {
                editor.cursor_x = editor.cursor_x + 1;
                delay();
            }
        }
        
        // SPACE = port 0x7F, bit 0
        if is_key_pressed(0x7F, 0) {
            toggle_pixel(&editor);
            delay();
        }
        
        // Small delay
        delay();
    }
}