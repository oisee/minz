// Test stack-based local variables with IX+offset addressing
// This will enable proper recursive functions

// Simple function with stack locals
fun test_stack_locals(x: u8, y: u8) -> u8 {
    let a: u8 = x + 10;
    let b: u8 = y + 20;
    let c: u8 = a + b;
    return c;
}

// Recursive factorial - requires stack frame
fun factorial(n: u8) -> u16 {
    if n <= 1 {
        return 1;
    }
    let prev: u16 = factorial(n - 1);
    return n * prev;
}

// Function with many locals to test stack allocation
fun many_locals() -> u8 {
    let a: u8 = 1;
    let b: u8 = 2;
    let c: u8 = 3;
    let d: u8 = 4;
    let e: u8 = 5;
    let f: u8 = 6;
    let g: u8 = 7;
    let h: u8 = 8;
    
    let sum1: u8 = a + b + c + d;
    let sum2: u8 = e + f + g + h;
    return sum1 + sum2;
}

// Nested function calls to test stack preservation
fun outer(x: u8) -> u8 {
    let local1: u8 = x + 1;
    let result: u8 = inner(local1);
    let local2: u8 = result + 1;
    return local2;
}

fun inner(y: u8) -> u8 {
    let temp: u8 = y * 2;
    return temp;
}

fun main() -> void {
    let r1 = test_stack_locals(5, 10);
    let r2 = factorial(5);  // Should be 120
    let r3 = many_locals();  // Should be 36
    let r4 = outer(10);      // Should be 23
}