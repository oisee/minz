// ZX Spectrum Demo - Shows off MinZ text and graphics capabilities
// This demonstrates the 32-character ROM font printing routine

import zx.screen;

fun main() -> u8 {
    // Initialize screen
    zx.screen.clear_screen(zx.screen.WHITE, zx.screen.BLACK);
    zx.screen.init_text();
    
    // Title
    zx.screen.set_text_attr(zx.screen.YELLOW, zx.screen.BLACK, true, false);
    zx.screen.print_at(8, 2, "MinZ on ZX Spectrum");
    
    // Subtitle  
    zx.screen.set_text_attr(zx.screen.CYAN, zx.screen.BLACK, false, false);
    zx.screen.print_at(6, 4, "Zero-Cost Language Features");
    
    // Lambda demonstration
    zx.screen.set_text_attr(zx.screen.GREEN, zx.screen.BLACK, false, false);
    zx.screen.print_at(0, 6, "Lambda Functions (Zero Overhead):");
    
    // Use our zero-cost lambda
    let add = |x: u8, y: u8| => u8 { x + y };
    let multiply = |x: u8, y: u8| => u8 { x * y };
    
    let result1 = add(15, 27);       // 42
    let result2 = multiply(6, 7);    // 42
    
    zx.screen.set_cursor(2, 8);
    zx.screen.print_string("add(15, 27) = ");
    zx.screen.print_number(result1 as u16);
    
    zx.screen.set_cursor(2, 9);
    zx.screen.print_string("multiply(6, 7) = ");
    zx.screen.print_number(result2 as u16);
    
    // Memory usage display
    zx.screen.set_text_attr(zx.screen.MAGENTA, zx.screen.BLACK, false, false);
    zx.screen.print_at(0, 11, "Memory Usage:");
    
    zx.screen.set_cursor(2, 13);
    zx.screen.print_string("Screen: $");
    zx.screen.print_hex16(zx.screen.SCREEN_ADDR);
    zx.screen.print_string(" - $");
    zx.screen.print_hex16(zx.screen.SCREEN_ADDR + 6144);
    
    zx.screen.set_cursor(2, 14);
    zx.screen.print_string("Attrs:  $");
    zx.screen.print_hex16(zx.screen.ATTR_ADDR);
    zx.screen.print_string(" - $");
    zx.screen.print_hex16(zx.screen.ATTR_ADDR + 768);
    
    zx.screen.set_cursor(2, 15);
    zx.screen.print_string("ROM Font: $");
    zx.screen.print_hex16(zx.screen.CHAR_ROM);
    
    // Performance stats
    zx.screen.set_text_attr(zx.screen.RED, zx.screen.BLACK, false, false);
    zx.screen.print_at(0, 17, "Performance:");
    
    zx.screen.set_cursor(2, 19);
    zx.screen.print_string("Lambda calls: ZERO overhead!");
    
    zx.screen.set_cursor(2, 20);
    zx.screen.print_string("ROM font: Direct assembly copy");
    
    // Draw some graphics
    zx.screen.set_text_attr(zx.screen.WHITE, zx.screen.BLUE, false, false);
    zx.screen.print_at(0, 22, "Graphics: ");
    
    // Draw a border around the screen
    zx.screen.draw_rect(0, 0, 255, 191);
    zx.screen.draw_rect(2, 2, 251, 187);
    
    // Draw some lines
    zx.screen.draw_hline(10, 180, 50);
    zx.screen.draw_vline(70, 160, 30);
    
    // Set border color
    zx.screen.set_border(zx.screen.BLUE);
    
    // Return success
    42
}

// Additional demo functions showing zero-cost abstractions

// Interface-like behavior (will be zero-cost when interfaces are implemented)
struct Point {
    x: u8,
    y: u8,
}

fun point_add(p1: Point, p2: Point) -> Point {
    Point { x: p1.x + p2.x, y: p1.y + p2.y }
}

fun point_display(p: Point) {
    zx.screen.print_char('(');
    zx.screen.print_number(p.x as u16);
    zx.screen.print_char(',');
    zx.screen.print_number(p.y as u16);
    zx.screen.print_char(')');
}

// Function composition demo
fun compose_demo() -> u8 {
    let double = |x: u8| => u8 { x * 2 };
    let add_ten = |x: u8| => u8 { x + 10 };
    
    // Function composition: add_ten(double(5)) = add_ten(10) = 20
    let compose = |x: u8| => u8 { add_ten(double(x)) };
    
    compose(5)  // Returns 20
}

// Higher-order function demo  
fun apply_twice<T>(f: fun(T) -> T, x: T) -> T {
    f(f(x))
}

fun increment(x: u8) -> u8 {
    x + 1
}

fun demo_higher_order() -> u8 {
    // This will be monomorphized to apply_twice_u8
    apply_twice(increment, 5)  // Returns 7
}