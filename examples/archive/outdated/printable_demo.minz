// Demonstration of zero-cost Printable interface and compile-time print!
// NEW: Features length-prefixed strings with zero null terminator overhead!

import std.io_v2;

// Custom type implementing Printable
struct Point {
    x: u8,
    y: u8,
}

impl Printable for Point {
    fun to_string(self) -> *u8 {
        // This will be optimized at compile time with length-prefixed storage!
        @static_buffer(10);
        @format!("({ self.x },{ self.y })");  // New { constant } syntax
    }
}

// Game state that can be printed
struct GameState {
    score: u16,
    lives: u8,
    level: u8,
}

impl Printable for GameState {
    fun to_string(self) -> *u8 {
        @static_buffer(32);
        @format!("Score:{ self.score } Lives:{ self.lives } Level:{ self.level }");
    }
}

// Demonstrate zero-cost printing
fun main() -> u8 {
    // Simple printing - no runtime format parsing! Length-prefixed strings!
    let x: u8 = 42;
    let y: u8 = 13;
    print!("The answer is {}, not {}\n", x, y);  // Variables still use old syntax
    
    // Hex formatting
    let address: u16 = 0x8000;
    print!("Code starts at {:04x}\n", address);
    
    // Custom types
    let p = Point { x: 10, y: 20 };
    print!("Player at {}\n", p);
    
    // Complex formatting
    let state = GameState {
        score: 1234,
        lives: 3,
        level: 5,
    };
    print!("Game: {}\n", state);
    
    // Conditional debug printing (removed in release builds)
    @debug {
        print!("[DEBUG] Internal state: x={}, y={}\n", x, y);
    }
    
    // String interpolation at compile time
    let msg = s!("Player at {} with score {}", p, state.score);
    print!("{}\n", msg);
    
    // Platform-specific optimizations
    @platform("zx_spectrum") {
        // This entire block is resolved at compile time!
        print!("Running on ZX Spectrum at { @hex(0x4000) }\n");  // Compile-time hex
    }
    
    // Zero-cost number formatting
    for i in 0..10 {
        // Even this loop's print is optimized!
        print!("{} ", i);
    }
    print!("\n");
    
    // Advanced: Table formatting
    print!("╔══════════════════════╗\n");
    print!("║ {:^20} ║\n", "High Scores");
    print!("╠══════════════════════╣\n");
    print!("║ {:>3}. {:<12} {:>5} ║\n", 1, "Alice", 9999);
    print!("║ {:>3}. {:<12} {:>5} ║\n", 2, "Bob", 8500);
    print!("║ {:>3}. {:<12} {:>5} ║\n", 3, "Charlie", 7200);
    print!("╚══════════════════════╝\n");
    
    return 0;
}

// This compiles to highly optimized assembly with:
// - No format string parsing at runtime
// - Direct calls to type-specific formatters
// - Compile-time string literal optimization
// - Platform-specific output routines
// - Zero heap allocation

// Example of generated code for print!("x = { 42 }"):
// 
// LD HL, .str1        ; DB 6, "x = 42" (length-prefixed, no null terminator)
// CALL print_string   ; DJNZ loop for exactly 6 characters
//
// Single string, single call! Even better than the old approach!