// Test register-based parameter passing optimization

// Simple function with u8 parameters - should use registers
fun add_bytes(a: u8, b: u8) -> u8 {
    return a + b;
}

// Function with u16 parameters - should use HL, DE
fun add_words(x: u16, y: u16) -> u16 {
    return x + y;
}

// Mixed parameter types
fun process(value: u8, ptr: *u8, count: u16) -> u8 {
    // value in A, ptr in HL, count in DE
    let sum: u8 = value;
    for i in 0..count {
        sum = sum + *ptr;
        ptr = ptr + 1;
    }
    return sum;
}

// Too many parameters - should use stack
fun many_params(a: u8, b: u8, c: u8, d: u8, e: u8) -> u8 {
    return a + b + c + d + e;
}

// Recursive function - must use stack
fun recursive_sum(n: u8) -> u16 {
    if n == 0 {
        return 0;
    }
    return n + recursive_sum(n - 1);
}

fun main() -> void {
    // Test register passing
    let r1 = add_bytes(10, 20);        // A=10, E=20
    let r2 = add_words(1000, 2000);    // HL=1000, DE=2000
    
    // Test mixed types
    let data: [5]u8 = [1, 2, 3, 4, 5];
    let r3 = process(100, &data[0], 5); // A=100, HL=&data[0], DE=5
    
    // Test stack passing
    let r4 = many_params(1, 2, 3, 4, 5);
    let r5 = recursive_sum(10);
}