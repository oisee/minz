// Parser State Machine - Compiler/Lexer Pattern Matching Demo
// Shows how elegant parsing becomes with pattern matching

enum ParseState {
    Start,
    InNumber,
    InIdentifier,
    InString,
    InComment,
    Error,
}

enum CharType {
    Digit,
    Letter,
    Quote,
    Slash,
    Star,
    Whitespace,
    Newline,
    Other,
}

enum TokenType {
    Number,
    Identifier,
    String,
    Comment,
    Invalid,
    EOF,
}

// Character classification
fun classify_char(c: u16) -> CharType {
    case c {
        48 => CharType.Digit,  // '0'
        49 => CharType.Digit,  // '1'
        50 => CharType.Digit,  // '2'
        51 => CharType.Digit,  // '3'
        52 => CharType.Digit,  // '4'
        53 => CharType.Digit,  // '5'
        54 => CharType.Digit,  // '6'
        55 => CharType.Digit,  // '7'
        56 => CharType.Digit,  // '8'
        57 => CharType.Digit,  // '9'
        34 => CharType.Quote,  // '"'
        47 => CharType.Slash,  // '/'
        42 => CharType.Star,   // '*'
        32 => CharType.Whitespace, // ' '
        9 => CharType.Whitespace,  // '\t'
        10 => CharType.Newline,    // '\n'
        13 => CharType.Newline,    // '\r'
        _ => {
            // Check if letter (simplified - just a-z, A-Z)
            if (c >= 65 && c <= 90) {   // A-Z
                return CharType.Letter;
            }
            if (c >= 97 && c <= 122) {  // a-z
                return CharType.Letter;
            }
            return CharType.Other;
        },
    }
}

// Parser state transitions
fun parse_transition(state: ParseState, char_type: CharType) -> ParseState {
    case state {
        ParseState.Start => {
            case char_type {
                CharType.Digit => ParseState.InNumber,
                CharType.Letter => ParseState.InIdentifier,
                CharType.Quote => ParseState.InString,
                CharType.Slash => ParseState.InComment,
                CharType.Whitespace => ParseState.Start,
                CharType.Newline => ParseState.Start,
                _ => ParseState.Error,
            }
        },
        ParseState.InNumber => {
            case char_type {
                CharType.Digit => ParseState.InNumber,
                CharType.Whitespace => ParseState.Start,
                CharType.Newline => ParseState.Start,
                _ => ParseState.Error,
            }
        },
        ParseState.InIdentifier => {
            case char_type {
                CharType.Letter => ParseState.InIdentifier,
                CharType.Digit => ParseState.InIdentifier,
                CharType.Whitespace => ParseState.Start,
                CharType.Newline => ParseState.Start,
                _ => ParseState.Error,
            }
        },
        ParseState.InString => {
            case char_type {
                CharType.Quote => ParseState.Start, // End of string
                CharType.Newline => ParseState.Error, // Unclosed string
                _ => ParseState.InString, // Continue in string
            }
        },
        ParseState.InComment => {
            case char_type {
                CharType.Star => ParseState.InComment, // Could be end of comment
                CharType.Newline => ParseState.Start,  // Line comment end
                _ => ParseState.InComment,
            }
        },
        ParseState.Error => ParseState.Error, // Stay in error
    }
}

// Determine what token we just finished
fun get_token_type(state: ParseState) -> TokenType {
    case state {
        ParseState.InNumber => TokenType.Number,
        ParseState.InIdentifier => TokenType.Identifier,
        ParseState.InString => TokenType.String,
        ParseState.InComment => TokenType.Comment,
        ParseState.Start => TokenType.EOF,
        ParseState.Error => TokenType.Invalid,
    }
}

// Get codes for display
fun get_state_code(state: ParseState) -> u16 {
    case state {
        ParseState.Start => 0,
        ParseState.InNumber => 1,
        ParseState.InIdentifier => 2,
        ParseState.InString => 3,
        ParseState.InComment => 4,
        ParseState.Error => 5,
    }
}

fun get_token_code(token: TokenType) -> u16 {
    case token {
        TokenType.Number => 1,
        TokenType.Identifier => 2,
        TokenType.String => 3,
        TokenType.Comment => 4,
        TokenType.Invalid => 5,
        TokenType.EOF => 6,
    }
}

fun get_char_type_code(char_type: CharType) -> u16 {
    case char_type {
        CharType.Digit => 1,
        CharType.Letter => 2,
        CharType.Quote => 3,
        CharType.Slash => 4,
        CharType.Star => 5,
        CharType.Whitespace => 6,
        CharType.Newline => 7,
        CharType.Other => 8,
    }
}

// Simple lexer simulation
fun simulate_lexer() -> void {
    let state = ParseState.Start;
    
    @print("=== Lexer State Machine Demo ===\n");
    @print("Initial state: ");
    @print(get_state_code(state));
    @print("\n");
    
    // Simulate parsing "hello123"
    @print("\nParsing identifier 'hello123':\n");
    
    // 'h' - letter
    let char_type = CharType.Letter;
    state = parse_transition(state, char_type);
    @print("After 'h': state=");
    @print(get_state_code(state));
    @print("\n");
    
    // 'e' - letter
    state = parse_transition(state, char_type);
    @print("After 'e': state=");
    @print(get_state_code(state));
    @print("\n");
    
    // '1' - digit (still valid in identifier)
    char_type = CharType.Digit;
    state = parse_transition(state, char_type);
    @print("After '1': state=");
    @print(get_state_code(state));
    @print("\n");
    
    // End with whitespace
    char_type = CharType.Whitespace;
    state = parse_transition(state, char_type);
    @print("After space: state=");
    @print(get_state_code(state));
    @print("\n");
    
    // Parse a number "456"
    @print("\nParsing number '456':\n");
    char_type = CharType.Digit;
    state = parse_transition(state, char_type);
    @print("After '4': state=");
    @print(get_state_code(state));
    @print("\n");
    
    state = parse_transition(state, char_type);
    @print("After '5': state=");
    @print(get_state_code(state));
    @print("\n");
    
    state = parse_transition(state, char_type);
    @print("After '6': state=");
    @print(get_state_code(state));
    @print("\n");
    
    // Parse a string "hello"
    @print("\nParsing string '\"hello\"':\n");
    char_type = CharType.Quote;
    state = parse_transition(state, char_type);
    @print("After '\"': state=");
    @print(get_state_code(state));
    @print("\n");
    
    char_type = CharType.Letter;
    state = parse_transition(state, char_type);
    @print("Inside string: state=");
    @print(get_state_code(state));
    @print("\n");
    
    char_type = CharType.Quote;
    state = parse_transition(state, char_type);
    @print("After closing '\"': state=");
    @print(get_state_code(state));
    @print("\n");
    
    // Test error case - unclosed string
    @print("\nTesting error case (unclosed string):\n");
    char_type = CharType.Quote;
    state = parse_transition(state, char_type);
    @print("Start string: state=");
    @print(get_state_code(state));
    @print("\n");
    
    char_type = CharType.Newline;
    state = parse_transition(state, char_type);
    @print("Newline in string (ERROR): state=");
    @print(get_state_code(state));
    @print("\n");
}

fun main() -> void {
    simulate_lexer();
}