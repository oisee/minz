// Network Protocol State Machine - Real-world Pattern Matching
// Demonstrates TCP-like connection state management

enum ConnectionState {
    Closed,
    Listen,
    SynSent,
    SynReceived,
    Established,
    FinWait1,
    FinWait2,
    CloseWait,
    Closing,
    LastAck,
    TimeWait,
}

enum Packet {
    Syn,
    SynAck,
    Ack,
    Fin,
    FinAck,
    Reset,
    Timeout,
}

// TCP-like state machine implementation
fun handle_packet(state: ConnectionState, packet: Packet) -> ConnectionState {
    case state {
        ConnectionState.Closed => {
            case packet {
                Packet.Syn => ConnectionState.SynReceived,
                _ => ConnectionState.Closed,
            }
        },
        ConnectionState.Listen => {
            case packet {
                Packet.Syn => ConnectionState.SynReceived,
                _ => ConnectionState.Listen,
            }
        },
        ConnectionState.SynSent => {
            case packet {
                Packet.SynAck => ConnectionState.Established,
                Packet.Reset => ConnectionState.Closed,
                Packet.Timeout => ConnectionState.Closed,
                _ => ConnectionState.SynSent,
            }
        },
        ConnectionState.SynReceived => {
            case packet {
                Packet.Ack => ConnectionState.Established,
                Packet.Reset => ConnectionState.Closed,
                Packet.Timeout => ConnectionState.Closed,
                _ => ConnectionState.SynReceived,
            }
        },
        ConnectionState.Established => {
            case packet {
                Packet.Fin => ConnectionState.CloseWait,
                Packet.Reset => ConnectionState.Closed,
                _ => ConnectionState.Established,
            }
        },
        ConnectionState.FinWait1 => {
            case packet {
                Packet.Ack => ConnectionState.FinWait2,
                Packet.Fin => ConnectionState.Closing,
                Packet.FinAck => ConnectionState.TimeWait,
                _ => ConnectionState.FinWait1,
            }
        },
        ConnectionState.FinWait2 => {
            case packet {
                Packet.Fin => ConnectionState.TimeWait,
                _ => ConnectionState.FinWait2,
            }
        },
        ConnectionState.CloseWait => {
            case packet {
                Packet.Fin => ConnectionState.LastAck, // Active close
                _ => ConnectionState.CloseWait,
            }
        },
        ConnectionState.Closing => {
            case packet {
                Packet.Ack => ConnectionState.TimeWait,
                _ => ConnectionState.Closing,
            }
        },
        ConnectionState.LastAck => {
            case packet {
                Packet.Ack => ConnectionState.Closed,
                _ => ConnectionState.LastAck,
            }
        },
        ConnectionState.TimeWait => {
            case packet {
                Packet.Timeout => ConnectionState.Closed,
                _ => ConnectionState.TimeWait,
            }
        },
    }
}

// State validation - some states can only transition in specific ways
fun is_valid_transition(from: ConnectionState, to: ConnectionState) -> bool {
    case from {
        ConnectionState.Closed => {
            case to {
                ConnectionState.Listen => true,
                ConnectionState.SynSent => true,
                ConnectionState.SynReceived => true,
                _ => false,
            }
        },
        ConnectionState.Established => {
            case to {
                ConnectionState.FinWait1 => true,
                ConnectionState.CloseWait => true,
                ConnectionState.Closed => true, // Reset
                _ => false,
            }
        },
        _ => true, // Simplified for demo
    }
}

// Get state code for display
fun get_state_code(state: ConnectionState) -> u16 {
    case state {
        ConnectionState.Closed => 0,
        ConnectionState.Listen => 1,
        ConnectionState.SynSent => 2,
        ConnectionState.SynReceived => 3,
        ConnectionState.Established => 4,
        ConnectionState.FinWait1 => 5,
        ConnectionState.FinWait2 => 6,
        ConnectionState.CloseWait => 7,
        ConnectionState.Closing => 8,
        ConnectionState.LastAck => 9,
        ConnectionState.TimeWait => 10,
    }
}

fun get_packet_code(packet: Packet) -> u16 {
    case packet {
        Packet.Syn => 1,
        Packet.SynAck => 2,
        Packet.Ack => 3,
        Packet.Fin => 4,
        Packet.FinAck => 5,
        Packet.Reset => 6,
        Packet.Timeout => 7,
    }
}

// Simulate connection lifecycle
fun simulate_connection() -> void {
    let state = ConnectionState.Closed;
    
    @print("=== TCP-like Protocol State Machine ===\n");
    @print("Initial state: ");
    @print(get_state_code(state));
    @print("\n");
    
    // Server listening
    state = ConnectionState.Listen;
    @print("Server listening: ");
    @print(get_state_code(state));
    @print("\n");
    
    // Connection establishment (3-way handshake)
    @print("\n--- Connection Establishment ---\n");
    
    // 1. SYN received
    state = handle_packet(state, Packet.Syn);
    @print("After SYN: ");
    @print(get_state_code(state));
    @print("\n");
    
    // 2. ACK received
    state = handle_packet(state, Packet.Ack);
    @print("After ACK: ");
    @print(get_state_code(state));
    @print("\n");
    
    @print("Connection established!\n");
    
    // Data transfer phase (stays in established)
    state = handle_packet(state, Packet.Ack); // Data packets
    @print("Data transfer: ");
    @print(get_state_code(state));
    @print("\n");
    
    // Connection termination
    @print("\n--- Connection Termination ---\n");
    
    // 1. FIN received (passive close)
    state = handle_packet(state, Packet.Fin);
    @print("After FIN (CloseWait): ");
    @print(get_state_code(state));
    @print("\n");
    
    // 2. Send our FIN
    state = handle_packet(state, Packet.Fin);
    @print("After sending FIN: ");
    @print(get_state_code(state));
    @print("\n");
    
    // 3. Final ACK
    state = handle_packet(state, Packet.Ack);
    @print("After final ACK: ");
    @print(get_state_code(state));
    @print("\n");
    
    @print("Connection closed cleanly!\n");
    
    // Test error case
    @print("\n--- Error Handling ---\n");
    state = ConnectionState.Established;
    state = handle_packet(state, Packet.Reset);
    @print("After RESET: ");
    @print(get_state_code(state));
    @print("\n");
}

fun main() -> void {
    simulate_connection();
}