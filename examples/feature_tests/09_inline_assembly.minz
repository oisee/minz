// Test 09: Inline Assembly and @abi Integration
// Tests: @asm blocks, @abi functions, register constraints

// Test basic inline assembly
fun test_inline_asm() -> bool {
    let mut result: u8 = 0;
    
    @asm {
        LD A, 42
        LD (result), A
    }
    
    if result != 42 { return false; }
    
    // Assembly with local variable access
    let x: u8 = 10;
    let y: u8 = 20;
    
    @asm {
        LD A, (x)
        LD B, (y)
        ADD A, B
        LD (result), A
    }
    
    if result != 30 { return false; }
    
    return true;
}

// Test @abi function declaration
@abi("register: A=char")
extern fun rom_print_char(char: u8) -> void;

@abi("register: HL=addr, A=value, BC=count")
extern fun rom_fill_memory(addr: u16, value: u8, count: u16) -> void;

@abi("register: HL=return")
extern fun rom_get_random() -> u16;

// Test calling @abi functions
fun test_abi_calls() -> bool {
    // Call ROM routine to print character
    rom_print_char(65);  // Print 'A'
    
    // Call ROM routine with multiple parameters
    let buffer: [u8; 10];
    rom_fill_memory(&buffer as u16, 0, 10);
    
    // Call ROM routine with return value
    let random = rom_get_random();
    
    return true;
}

// Test inline assembly with constraints
fun test_asm_constraints() -> bool {
    let a: u8 = 5;
    let b: u8 = 3;
    let result: u8;
    
    @asm {
        LD A, (a)       ; Load first operand
        LD B, (b)       ; Load second operand
        ADD A, B        ; Add them
        LD (result), A  ; Store result
    }
    
    if result != 8 { return false; }
    
    return true;
}

// Test preserving registers in assembly
fun test_register_preservation() -> bool {
    let saved_hl: u16;
    let saved_de: u16;
    
    @asm {
        ; Save current register values
        PUSH HL
        PUSH DE
        
        ; Do some work
        LD HL, 0x1234
        LD DE, 0x5678
        
        ; Store for verification
        LD (saved_hl), HL
        LD (saved_de), DE
        
        ; Restore
        POP DE
        POP HL
    }
    
    if saved_hl != 0x1234 { return false; }
    if saved_de != 0x5678 { return false; }
    
    return true;
}

// Test shadow registers
fun test_shadow_registers() -> bool {
    let primary_a: u8;
    let shadow_a: u8;
    
    @asm {
        ; Work with primary registers
        LD A, 10
        LD (primary_a), A
        
        ; Switch to shadow registers
        EX AF, AF'
        
        ; Work with shadow registers
        LD A, 20
        LD (shadow_a), A
        
        ; Switch back
        EX AF, AF'
    }
    
    if primary_a != 10 { return false; }
    if shadow_a != 20 { return false; }
    
    return true;
}

// Test interrupt handler with shadow registers
@abi("interrupt")
fun interrupt_handler() -> void {
    @asm {
        ; Ultra-fast interrupt using shadow registers
        EXX             ; Switch BC,DE,HL with BC',DE',HL'
        EX AF, AF'      ; Switch AF with AF'
        
        ; Do interrupt work with shadow registers
        ; (No need to save/restore!)
        
        ; Switch back
        EX AF, AF'
        EXX
        
        ; Return from interrupt
        EI
        RETI
    }
}

// Test I/O port access
fun test_io_ports() -> bool {
    // Set border color on ZX Spectrum
    @asm {
        LD A, 2         ; Red border
        OUT (254), A    ; Border port
    }
    
    // Read keyboard
    let key_state: u8;
    @asm {
        LD BC, 0xFEFE   ; Keyboard port
        IN A, (C)       ; Read keyboard
        LD (key_state), A
    }
    
    return true;
}

// Test complex @abi with stack parameters
@abi("stack: 2=x, 4=y, 6=color")
extern fun rom_plot_pixel(x: u16, y: u8, color: u8) -> void;

fun test_stack_abi() -> bool {
    // This tests stack-based parameter passing
    rom_plot_pixel(100, 50, 7);  // White pixel at (100, 50)
    
    return true;
}

fun main() -> u8 {
    if !test_inline_asm() { return 1; }
    if !test_abi_calls() { return 2; }
    if !test_asm_constraints() { return 3; }
    if !test_register_preservation() { return 4; }
    if !test_shadow_registers() { return 5; }
    if !test_io_ports() { return 6; }
    if !test_stack_abi() { return 7; }
    
    return 0;  // All tests passed
}