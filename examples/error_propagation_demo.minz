// Error Propagation System Demo - Document 127 Examples

// Define error types
enum MathError {
    DivideByZero,
    Overflow,
    Underflow,
}

enum IOError {
    FileNotFound,
    PermissionDenied,
    DiskFull,
}

enum AppError {
    Math,
    IO,
    Validation,
    BusinessLogic,
}

// === EXAMPLE 1: Basic Error Throwing ===

fun safe_divide?(a: u8, b: u8) -> u8 ? MathError {
    if b == 0 {
        @error(MathError.DivideByZero);  // Explicit error
    }
    return a / b;
}

fun safe_multiply?(a: u8, b: u8) -> u8 ? MathError {
    // Simplified - would normally check for overflow
    if a > 200 || b > 200 {
        @error(MathError.Overflow);
    }
    return a * b;
}

// === EXAMPLE 2: Same-Type Error Propagation (Zero Overhead) ===

fun math_pipeline?(a: u8, b: u8, c: u8) -> u8 ? MathError {
    let step1 = safe_divide?(a, b) ?? @error;        // Zero overhead propagation!
    let step2 = safe_multiply?(step1, c) ?? @error;  // Zero overhead propagation!
    return step2;
}

// === EXAMPLE 3: Cross-Type Error Propagation (Automatic Conversion) ===

fun process_data?(input: u8) -> u8 ? AppError {
    // MathError automatically converts to AppError
    let divided = safe_divide?(input, 2) ?? @error;
    let multiplied = safe_multiply?(divided, 3) ?? @error;
    
    // Business logic error
    if multiplied == 42 {
        @error(AppError.BusinessLogic);  // Explicit error
    }
    
    return multiplied;
}

// === EXAMPLE 4: Mixed Error Handling ===

fun validate_input?(input: u8) -> u8 ? AppError {
    if input == 0 {
        @error(AppError.Validation);
    }
    if input > 100 {
        @error(AppError.Validation);
    }
    return input;
}

fun business_logic?(input: u8) -> u8 ? AppError {
    // Validate input first
    let validated = validate_input?(input) ?? @error;  // Same type - zero overhead
    
    // Perform math operations with automatic type conversion
    let processed = safe_divide?(validated, 2) ?? @error;  // MathError -> AppError
    
    // More business logic
    if processed < 5 {
        @error(AppError.BusinessLogic);
    }
    
    return processed * 2;
}

// === EXAMPLE 5: Error Chaining ===

fun pipeline_demo?(input: u8) -> u8 ? AppError {
    return input
        |> validate_input?() ?? @error
        |> safe_divide?(2) ?? @error       // Auto conversion MathError -> AppError
        |> safe_multiply?(3) ?? @error     // Auto conversion MathError -> AppError;
}

// === EXAMPLE 6: Usage with Nil Coalescing ===

fun main() -> void {
    @print("=== Error Propagation Demo ===");
    
    // Test successful operations
    let result1 = math_pipeline?(20, 4, 3) ?? 999;
    @print("Math pipeline success: {}", result1);
    
    // Test error propagation
    let result2 = math_pipeline?(20, 0, 3) ?? 999;  // Division by zero
    @print("Math pipeline error: {}", result2);
    
    // Test cross-type conversion
    let result3 = process_data?(10) ?? 888;
    @print("Process data success: {}", result3);
    
    let result4 = process_data?(0) ?? 888;  // Validation error
    @print("Process data validation error: {}", result4);
    
    // Test business logic
    let result5 = business_logic?(50) ?? 777;
    @print("Business logic success: {}", result5);
    
    let result6 = business_logic?(2) ?? 777;  // Business logic error
    @print("Business logic error: {}", result6);
    
    @print("=== Demo Complete ===");
}

// === EXAMPLE 7: Advanced Chaining (User's suggestion) ===

fun advanced_chain?(input: u8) -> u8 ? AppError {
    let result = validate_input?(input) ?? @error;
    let processed = safe_divide?(result, 2) ?? @error;
    let final = safe_multiply?(processed, 3) ?? @error;
    return final;
}

// Or with method chaining (future syntax):
// fun fluent_chain?(input: u8) -> u8 ? AppError {
//     return input
//         .validate?() ?? @error
//         .divide?(2) ?? @error  
//         .multiply?(3) ?? @error;
// }