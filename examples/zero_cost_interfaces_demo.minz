// MinZ Zero-Cost Interfaces Demo
// Shows how interfaces compile to direct calls with ZERO overhead!

import std.error;

// Define a Drawable interface
interface Drawable {
    fun draw(self) -> u8?;  // Can return errors
    fun get_bounds(self) -> (u8, u8, u8, u8);  // x, y, width, height
}

// Simple shapes
struct Circle {
    x: u8,
    y: u8, 
    radius: u8,
}

struct Rectangle {
    x: u8,
    y: u8,
    width: u8,
    height: u8,
}

struct Triangle {
    x1: u8, y1: u8,
    x2: u8, y2: u8,
    x3: u8, y3: u8,
}

// Implement Drawable for each shape
impl Drawable for Circle {
    fun draw(self) -> u8? {
        // Check bounds
        if self.radius > 100 {
            @error(DrawError.TooLarge);
        }
        
        // "Draw" the circle (simulate)
        @asm {
            ; In real code, this would draw to screen
            LD A, (self.radius)
            ADD A, A        ; Diameter
            OR A            ; Clear carry (success)
        }
        return self.radius * 2;  // Return some metric
    }
    
    fun get_bounds(self) -> (u8, u8, u8, u8) {
        let diameter = self.radius * 2;
        return (
            self.x - self.radius,
            self.y - self.radius, 
            diameter,
            diameter
        );
    }
}

impl Drawable for Rectangle {
    fun draw(self) -> u8? {
        // Validate
        if self.width == 0 || self.height == 0 {
            @error(DrawError.InvalidSize);
        }
        
        // "Draw" rectangle
        return self.width + self.height;
    }
    
    fun get_bounds(self) -> (u8, u8, u8, u8) {
        return (self.x, self.y, self.width, self.height);
    }
}

impl Drawable for Triangle {
    fun draw(self) -> u8? {
        // Always succeeds for triangles
        @ok(3);  // Return number of sides
    }
    
    fun get_bounds(self) -> (u8, u8, u8, u8) {
        // Simple bounding box
        let min_x = min3(self.x1, self.x2, self.x3);
        let min_y = min3(self.y1, self.y2, self.y3);
        let max_x = max3(self.x1, self.x2, self.x3);
        let max_y = max3(self.y1, self.y2, self.y3);
        return (min_x, min_y, max_x - min_x, max_y - min_y);
    }
}

// Error codes for drawing
enum DrawError {
    TooLarge = 16,      // ERROR_RANGE_GRAPHICS + 0
    InvalidSize = 17,   // ERROR_RANGE_GRAPHICS + 1
    OutOfBounds = 18,   // ERROR_RANGE_GRAPHICS + 2
}

// Generic function that works with any Drawable
fun render_shape<T: Drawable>(shape: T) -> u8? {
    // This compiles to a DIRECT CALL - no vtable lookup!
    // The compiler knows the exact type at compile time
    
    let bounds = shape.get_bounds();
    
    // Check if in screen bounds (256x192 for ZX Spectrum)
    if bounds.0 + bounds.2 > 255 || bounds.1 + bounds.3 > 192 {
        @error(DrawError.OutOfBounds);
    }
    
    // Draw the shape - ? operator propagates any error
    let result = shape.draw()?;
    
    return result;
}

// Even more impressive - collections of drawables!
fun render_scene(shapes: [Drawable; 3]) -> u8? {
    let mut total: u8 = 0;
    
    // Each call here is STILL direct - no indirection!
    for shape in shapes {
        total = total + render_shape(shape)?;
    }
    
    return total;
}

// Helper functions
fun min3(a: u8, b: u8, c: u8) -> u8 {
    let min_ab = if a < b { a } else { b };
    if min_ab < c { min_ab } else { c }
}

fun max3(a: u8, b: u8, c: u8) -> u8 {
    let max_ab = if a > b { a } else { b };
    if max_ab > c { max_ab } else { c }
}

// Main demonstration
fun main() -> u8 {
    // Create shapes
    let circle = Circle { x: 50, y: 50, radius: 20 };
    let rect = Rectangle { x: 100, y: 100, width: 40, height: 30 };
    let triangle = Triangle { 
        x1: 10, y1: 10,
        x2: 30, y2: 10,
        x3: 20, y3: 30
    };
    
    // Render individual shapes with error handling
    match render_shape(circle) {
        Ok(val) => print("Circle rendered: ", val),
        Err(DrawError.TooLarge) => print("Circle too large!"),
        Err(_) => print("Circle render failed"),
    }
    
    // This is the MAGIC - the compiler generates:
    // - render_shape<Circle> â†’ Circle_draw (direct call)
    // - render_shape<Rectangle> â†’ Rectangle_draw (direct call)
    // - render_shape<Triangle> â†’ Triangle_draw (direct call)
    // NO VTABLES! NO FUNCTION POINTERS! ZERO OVERHEAD!
    
    let shapes: [Drawable; 3] = [circle, rect, triangle];
    
    match render_scene(shapes) {
        Ok(total) => {
            print("Scene rendered successfully: ", total);
            return 0;
        }
        Err(e) => {
            print("Scene render failed with error: ", e);
            return 1;
        }
    }
}

// How this compiles (the secret sauce!):
//
// 1. Interface methods become regular functions:
//    Circle_draw(self: *Circle) -> u8?
//    Rectangle_draw(self: *Rectangle) -> u8?
//
// 2. Generic functions are monomorphized:
//    render_shape<Circle> â†’ render_shape_Circle (calls Circle_draw directly)
//    render_shape<Rectangle> â†’ render_shape_Rectangle (calls Rectangle_draw directly)
//
// 3. Arrays of interfaces use tagged unions:
//    Drawable = { tag: u8, data: union { Circle, Rectangle, Triangle } }
//    But still dispatch to direct calls based on tag!
//
// 4. Error handling is FREE:
//    shape.draw()? â†’ CALL Shape_draw; RET C
//    Just ONE extra instruction for error propagation!
//
// This is why MinZ is revolutionary - modern abstractions with 
// LITERALLY ZERO runtime cost on 8-bit hardware! ðŸš€