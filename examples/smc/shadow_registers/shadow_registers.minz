// Example demonstrating shadow register usage for interrupt handlers

// Interrupt vector table location
const IM2_TABLE: u16 = 0xFE00;

// Interrupt handler using shadow registers
@interrupt
@shadow_registers
fn vblank_handler() -> void {
    // This function automatically uses EXX and EX AF,AF'
    // to save/restore registers, making it very fast
    
    // Increment frame counter
    frame_count = frame_count + 1;
    
    // Update animation timers
    if animation_timer > 0 {
        animation_timer = animation_timer - 1;
    }
    
    // Quick sprite multiplexing
    update_sprites();
}

// Fast memory copy using shadow registers
@shadow_registers
fn fast_memcpy(dst: *mut u8, src: *u8, len: u16) -> void {
    // Main registers: HL = src, DE = dst, BC = len
    // Shadow registers: used for temporary calculations
    
    asm("
        ; Main registers contain parameters
        ld h, {0}       ; src high
        ld l, {1}       ; src low
        ld d, {2}       ; dst high
        ld e, {3}       ; dst low
        ld b, {4}       ; len high
        ld c, {5}       ; len low
        
    .copy_loop:
        ; Use shadow registers for optimization
        exx             ; Switch to shadow set
        
        ; Shadow registers can do calculations
        ; without disturbing the main copy operation
        
        exx             ; Back to main set
        
        ; Efficient block copy
        ldi             ; (DE) = (HL), HL++, DE++, BC--
        
        ; Check if done
        ld a, b
        or c
        jr nz, .copy_loop
    " : : "r"(src >> 8), "r"(src & 0xFF),
          "r"(dst >> 8), "r"(dst & 0xFF),
          "r"(len >> 8), "r"(len & 0xFF));
}

// Coroutine using shadow registers for context switching
struct Coroutine {
    // Saved register state
    af: u16,
    bc: u16,
    de: u16,
    hl: u16,
    sp: u16,
    active: bool,
}

@shadow
fn coroutine_yield(co: *mut Coroutine) -> void {
    // Save current state to shadow registers
    asm("exx");
    asm("ex af, af'");
    
    // Store shadow registers to coroutine struct
    // ... implementation ...
    
    // Switch to another coroutine
    // ... implementation ...
}

// Global state
let mut frame_count: u16 = 0;
let mut animation_timer: u8 = 0;
let mut sprites: [Sprite; 8];

fn update_sprites() -> void {
    // Quick sprite update using shadow registers
    let mut i: u8 = 0;
    while i < 8 {
        // Update sprite position
        sprites[i].x = sprites[i].x + sprites[i].vx;
        sprites[i].y = sprites[i].y + sprites[i].vy;
        i = i + 1;
    }
}

fn setup_interrupts() -> void {
    // Set up interrupt mode 2
    asm("
        di                  ; Disable interrupts
        ld hl, {0}         ; IM2 table address
        ld a, h
        ld i, a            ; Set interrupt vector base
        im 2               ; Enable IM2
        ei                 ; Enable interrupts
    " : : "r"(IM2_TABLE));
    
    // Fill interrupt table to point to our handler
    let mut addr: u16 = IM2_TABLE;
    let handler_addr: u16 = &vblank_handler as u16;
    
    while addr < IM2_TABLE + 257 {
        asm("
            ld ({0}), {1}  ; Store handler low byte
            inc hl
            ld ({0}), {2}  ; Store handler high byte
        " : : "r"(addr), "r"(handler_addr & 0xFF), "r"(handler_addr >> 8));
        addr = addr + 2;
    }
}

fn main() -> void {
    // Set up interrupt handling
    setup_interrupts();
    
    // Initialize sprites
    let mut i: u8 = 0;
    while i < 8 {
        sprites[i].x = i * 32;
        sprites[i].y = 100;
        sprites[i].vx = 1;
        sprites[i].vy = 0;
        i = i + 1;
    }
    
    // Main loop
    loop {
        // Wait for vblank (interrupt will update frame_count)
        let current_frame = frame_count;
        while frame_count == current_frame {
            // Busy wait
        }
        
        // Do main game logic here
        // The interrupt handler runs independently
        // using shadow registers for maximum performance
    }
}