// Example: Loading game assets at compile time with Lua

@lua[[
-- Load binary sprite data from file
function load_sprite_file(filename)
    local file = io.open(filename, "rb")
    if not file then
        error("Cannot open sprite file: " .. filename)
    end
    
    local data = {}
    while true do
        local byte = file:read(1)
        if not byte then break end
        table.insert(data, string.byte(byte))
    end
    file:close()
    
    return data
end

-- Load text configuration file
function load_config(filename)
    local config = {}
    local file = io.open(filename, "r")
    if not file then
        -- Return defaults if config doesn't exist
        return {
            start_lives = 3,
            max_enemies = 8,
            enemy_speed = 2,
            player_speed = 3,
            debug_mode = false
        }
    end
    
    for line in file:lines() do
        -- Parse key=value lines
        local key, value = line:match("^([%w_]+)%s*=%s*(.+)$")
        if key and value then
            -- Convert to appropriate type
            if value == "true" then
                config[key] = true
            elseif value == "false" then
                config[key] = false
            elseif tonumber(value) then
                config[key] = tonumber(value)
            else
                config[key] = value
            end
        end
    end
    file:close()
    
    return config
end

-- Generate enum from CSV file
function generate_items_enum(csv_file)
    local file = io.open(csv_file, "r")
    if not file then
        return "enum Items { NoItems }"
    end
    
    local code = "enum Items {\n"
    local id = 0
    
    -- Skip header
    file:read("*line")
    
    for line in file:lines() do
        local name, value = line:match("^([^,]+),(%d+)")
        if name then
            code = code .. string.format("    %s = %d,\n", name, value or id)
            id = id + 1
        end
    end
    
    code = code .. "}\n"
    file:close()
    
    return code
end

-- Generate optimized sprite blitting code
function generate_sprite_blit(width, height, mask)
    local code = string.format("fun blit_sprite_%dx%d(x: u8, y: u8, data: *u8) -> void {\n", width, height)
    
    for row = 0, height - 1 do
        local addr_calc = string.format("    let addr%d = screen.pixel_addr(x, y + %d);\n", row, row)
        code = code .. addr_calc
    end
    
    code = code .. "    asm(\"\n"
    
    for row = 0, height - 1 do
        if mask then
            -- Masked sprite (AND then OR)
            code = code .. string.format([[
        ld hl, {%d}       ; sprite data + row offset
        ld de, {%d}       ; screen address
        ld a, (de)        ; get screen byte
        and (hl)          ; apply mask
        inc hl            ; next byte (sprite data)
        or (hl)           ; apply sprite
        ld (de), a        ; write back
]], row * 2, row)
        else
            -- Simple overwrite
            code = code .. string.format([[
        ld hl, {%d}       ; sprite data + row offset  
        ld de, {%d}       ; screen address
        ld a, (hl)        ; get sprite byte
        ld (de), a        ; write to screen
]], row, row)
        end
    end
    
    code = code .. "    \" : : "
    
    -- Register constraints
    for row = 0, height - 1 do
        code = code .. string.format("\"r\"(data + %d), \"r\"(addr%d)", row * (mask and 2 or 1), row)
        if row < height - 1 then code = code .. ", " end
    end
    
    code = code .. ");\n}\n"
    
    return code
end

-- Check build environment
build_config = {
    platform = os.getenv("PLATFORM") or "ZX_SPECTRUM",
    optimize = os.getenv("OPTIMIZE") == "1",
    include_music = os.getenv("INCLUDE_MUSIC") == "1",
    debug = os.getenv("DEBUG") == "1"
}
]]

// Load configuration at compile time
const START_LIVES: u8 = @lua(load_config("game.conf").start_lives);
const MAX_ENEMIES: u8 = @lua(load_config("game.conf").max_enemies);
const ENEMY_SPEED: u8 = @lua(load_config("game.conf").enemy_speed);
const PLAYER_SPEED: u8 = @lua(load_config("game.conf").player_speed);

// Generate items enum from CSV (if file exists)
@lua_eval(generate_items_enum("items.csv"))

// Generate optimized sprite blitting functions
@lua_eval(generate_sprite_blit(8, 8, false))   // 8x8 simple
@lua_eval(generate_sprite_blit(8, 8, true))    // 8x8 masked
@lua_eval(generate_sprite_blit(16, 16, false)) // 16x16 simple
@lua_eval(generate_sprite_blit(16, 16, true))  // 16x16 masked

// Conditional compilation based on build config
@lua_if(build_config.debug)
const DEBUG_MODE: bool = true;

fun debug_log(msg: str) -> void {
    // Debug output implementation
    print_string(0, 0, msg);
}
@lua_else
const DEBUG_MODE: bool = false;

fun debug_log(msg: str) -> void {
    // No-op in release
}
@lua_endif

// Platform-specific code
@lua_if(build_config.platform == "ZX_SPECTRUM_128")
import zx.ay_sound;

fun init_sound() -> void {
    ay_sound.init();
}
@lua_else
fun init_sound() -> void {
    // No sound chip on 48K
}
@lua_endif

// Example sprite data (would normally load from file)
const PLAYER_SPRITE: [u8; 8] = [
    0b00111100,
    0b01111110,
    0b11111111,
    0b11111111,
    0b11111111,
    0b01111110,
    0b00111100,
    0b00000000,
];

// Game structure using compile-time configuration
struct Game {
    player_lives: u8,
    enemies: [Enemy; MAX_ENEMIES],
    score: u16,
}

struct Enemy {
    x: u8,
    y: u8,
    active: bool,
}

fun main() -> void {
    // Initialize with compile-time constants
    let mut game = Game {
        player_lives: START_LIVES,
        enemies: [Enemy { x: 0, y: 0, active: false }; MAX_ENEMIES],
        score: 0,
    };
    
    debug_log("Game initialized");
    
    // Use generated sprite functions
    blit_sprite_8x8(128, 96, &PLAYER_SPRITE[0]);
    
    // Game loop...
}