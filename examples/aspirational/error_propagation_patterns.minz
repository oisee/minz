// Error Propagation Patterns - Common Use Cases for Z80 Development

// === HARDWARE-SPECIFIC ERROR TYPES ===

enum HardwareError {
    PortTimeout,
    InvalidAddress,
    BusError,
    InterruptFault,
}

enum MemoryError {
    OutOfBounds,
    SegmentFault,
    BankSwitchFault,
    StackOverflow,
}

enum SystemError {
    Hardware,
    Memory,
    Kernel,
    UserSpace,
}

// === PATTERN 1: HARDWARE OPERATIONS ===

fun read_port?(port: u8) -> u8 ? HardwareError {
    if port > 254 {
        @error(HardwareError.InvalidAddress);
    }
    // Simulate hardware read timeout
    if port == 128 {
        @error(HardwareError.PortTimeout);
    }
    return port + 10;  // Simulated data
}

fun write_port?(port: u8, value: u8) -> void ? HardwareError {
    let check = read_port?(port) ?? @error;  // Propagate hardware errors
    // Write operation (void return with error propagation)
    if value == 255 {
        @error(HardwareError.BusError);
    }
}

// === PATTERN 2: MEMORY MANAGEMENT ===

fun allocate_memory?(size: u8) -> u16 ? MemoryError {
    if size == 0 {
        @error(MemoryError.OutOfBounds);
    }
    if size > 200 {
        @error(MemoryError.StackOverflow);  // Simulate out of memory
    }
    return 0x8000 + size;  // Simulated address
}

fun safe_memory_copy?(src: u16, dest: u16, size: u8) -> void ? MemoryError {
    if src == 0 || dest == 0 {
        @error(MemoryError.SegmentFault);
    }
    
    // Check memory allocation
    let addr = allocate_memory?(size) ?? @error;  // Zero-overhead propagation
    
    // Bank switching validation  
    if addr > 0xC000 {
        @error(MemoryError.BankSwitchFault);
    }
}

// === PATTERN 3: SYSTEM-LEVEL ERROR AGGREGATION ===

fun system_hardware_operation?(port: u8, value: u8) -> u8 ? SystemError {
    // Hardware operations that convert to system errors
    let data = read_port?(port) ?? @error;           // HardwareError -> SystemError
    write_port?(port + 1, data) ?? @error;          // HardwareError -> SystemError (void)
    return data;
}

fun system_memory_operation?(size: u8) -> u16 ? SystemError {
    // Memory operations that convert to system errors
    let addr = allocate_memory?(size) ?? @error;    // MemoryError -> SystemError
    safe_memory_copy?(addr, addr + 100, size) ?? @error;  // MemoryError -> SystemError (void)
    return addr;
}

fun comprehensive_system_call?(port: u8, size: u8) -> u16 ? SystemError {
    // Multi-level error propagation and conversion
    let hw_result = system_hardware_operation?(port, size) ?? @error;  // SystemError propagation
    let mem_result = system_memory_operation?(size) ?? @error;         // SystemError propagation
    
    // Combine results with additional validation
    if hw_result + mem_result > 0x8000 {
        @error(SystemError.Kernel);  // System-specific error
    }
    
    return mem_result;
}

// === PATTERN 4: GRACEFUL DEGRADATION ===

fun robust_hardware_read(port: u8) -> u8 {
    // Try primary port
    let primary = read_port?(port) ?? 0;
    if primary != 0 {
        return primary;
    }
    
    // Fallback to secondary port
    let secondary = read_port?(port + 1) ?? 0;
    if secondary != 0 {
        return secondary;
    }
    
    // Ultimate fallback
    return 255;  // Safe default value
}

fun fault_tolerant_memory_operation(size: u8) -> u16 {
    // Try full allocation
    let full = allocate_memory?(size) ?? 0;
    if full != 0 {
        return full;
    }
    
    // Try half allocation
    let half = allocate_memory?(size / 2) ?? 0;
    if half != 0 {
        return half;
    }
    
    // Minimum allocation
    let min = allocate_memory?(1) ?? 0x8000;  // Default safe address
    return min;
}

// === PATTERN 5: ERROR RECOVERY CHAINS ===

fun recovery_chain_operation?(input: u8) -> u8 ? SystemError {
    // Primary operation
    let result1 = comprehensive_system_call?(input, input) ?? @error;
    
    // Recovery attempt
    if result1 < 0x8000 {
        let result2 = system_memory_operation?(input / 2) ?? @error;
        return result2 as u8;
    }
    
    return result1 as u8;
}

fun advanced_error_handling?(complex_input: u8) -> u8 ? SystemError {
    // Multi-stage pipeline with recovery
    let stage1 = recovery_chain_operation?(complex_input) ?? @error;
    let stage2 = recovery_chain_operation?(stage1) ?? @error;
    let stage3 = recovery_chain_operation?(stage2) ?? @error;
    
    // Final validation
    if stage3 == 0 {
        @error(SystemError.UserSpace);
    }
    
    return stage3;
}

// === MAIN DEMONSTRATION ===

fun main() -> void {
    @print("=== Error Propagation Patterns for Z80 Systems ===");
    @print("");
    
    // Hardware operations
    @print("Hardware Operations:");
    let hw1 = robust_hardware_read(100);  // Should succeed
    let hw2 = robust_hardware_read(128);  // Should use fallback
    @print("Hardware read success: {}", hw1);
    @print("Hardware read with fallback: {}", hw2);
    @print("");
    
    // Memory operations
    @print("Memory Operations:");
    let mem1 = fault_tolerant_memory_operation(50);   // Should succeed
    let mem2 = fault_tolerant_memory_operation(250);  // Should use fallback
    @print("Memory allocation success: {}", mem1);
    @print("Memory allocation with fallback: {}", mem2);
    @print("");
    
    // System-level operations
    @print("System-Level Operations:");
    let sys1 = comprehensive_system_call?(50, 25) ?? 999;   // Should succeed
    let sys2 = comprehensive_system_call?(128, 250) ?? 999; // Should fail
    @print("System call success: {} (expected: non-999)", sys1);
    @print("System call failure: {} (expected: 999)", sys2);
    @print("");
    
    // Advanced error handling
    @print("Advanced Error Handling:");
    let adv1 = advanced_error_handling?(30) ?? 777;   // Should succeed
    let adv2 = advanced_error_handling?(0) ?? 777;    // Should fail
    @print("Advanced success: {} (expected: non-777)", adv1);  
    @print("Advanced failure: {} (expected: 777)", adv2);
    @print("");
    
    @print("=== Pattern Summary ===");
    @print("âœ… Hardware error propagation with automatic retry");
    @print("âœ… Memory management with graceful degradation"); 
    @print("âœ… System-level error aggregation and conversion");
    @print("âœ… Multi-stage recovery chains with fallbacks");
    @print("âœ… Zero-overhead propagation for same-type errors");
    @print("âœ… Automatic type conversion for cross-domain errors");
    @print("");
    @print("Result: Production-ready error handling for Z80 systems! ðŸŽ¯");
}