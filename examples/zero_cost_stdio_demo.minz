// MinZ Zero-Cost stdio Demo
// Demonstrates compile-time print optimization and zero-overhead abstractions

import std.io_optimized;
import std.print;
import std.stream;

// Custom type that implements Printable
struct Player {
    name: *u8,
    score: u16,
    level: u8,
}

impl Printable for Player {
    fun print_to(self, writer: Writer) -> void {
        @print_to(writer, "{} (Level {}, Score: {})", 
                  self.name, self.level, self.score);
    }
}

// Custom formatter for game coordinates
struct Coord {
    x: u8,
    y: u8,
}

impl Printable for Coord {
    fun print_to(self, writer: Writer) -> void {
        writer.write_byte('(');
        self.x.print_to(writer);
        writer.write_byte(',');
        self.y.print_to(writer);
        writer.write_byte(')');
    }
}

fun main() -> u8 {
    // Simple compile-time optimized printing
    @println("=== MinZ Zero-Cost stdio Demo ===");
    
    // Constants are fully optimized at compile time
    @print("Magic number: {}, In hex: 0x{:x}\n", 42, hex(42));
    // Compiles to:
    //   CALL print_literal_14  ; "Magic number: "
    //   CALL print_literal_2   ; "42"
    //   CALL print_literal_9   ; ", In hex: "
    //   CALL print_literal_4   ; "0x2A"
    //   LD A, '\n'
    //   RST 0x10
    
    // Runtime values with zero-cost interface dispatch
    let player = Player {
        name: "Alice",
        score: 1500,
        level: 7,
    };
    
    @println("Player info: {}", player);
    
    // Array printing with zero overhead
    let scores: [u8; 5] = [85, 92, 78, 95, 88];
    @println("Scores: {}", scores);
    
    // Formatted coordinates
    let pos = Coord { x: 100, y: 50 };
    @println("Position: {}", pos);
    
    // Buffered output example
    let buffered = BufferedWriter<128>::new(stdout);
    @print_to(buffered, "This is buffered: {}\n", 12345);
    buffered.flush();
    
    // String building at compile time
    let message = @build_string("Hello, ", "World", "!");
    @println("Built string: {}", message);
    
    // Conditional debug output (zero cost in release)
    @trace("Player {} reached position {}", player.name, pos);
    
    // Type-safe formatted input
    @print("Enter your name: ");
    let name = input_line("");
    
    @print("Enter your age: ");
    let mut age: u8 = 0;
    @scan("{}", &age);
    
    @println("Hello {}, age {}!", name, age);
    
    // Performance monitoring
    let timed = TimedWriter::new(stdout);
    @print_to(timed, "Performance test: ");
    for i in 0..10 {
        @print_to(timed, "{} ", i);
    }
    @println_to(timed, "");
    @println("Took {} cycles", timed.elapsed_cycles());
    
    // Platform-specific optimizations
    @if(platform == "zx") {
        fast_print("ZX Spectrum optimized!\n");
    }
    
    // Error handling with colored output
    if age > 120 {
        @print_error("Invalid age: {}", age);
    }
    
    // Complex formatting example
    @println("┌─────────────────────────┐");
    @println("│ Player: {:10} │", player.name);
    @println("│ Score:  {:10} │", player.score);
    @println("│ Level:  {:10} │", player.level);
    @println("└─────────────────────────┘");
    
    0
}

// This entire program compiles with:
// - Zero format string parsing at runtime
// - No heap allocations
// - Direct interface calls (no vtables)
// - Compile-time string optimization
// - Platform-specific code generation
// - Minimal code size and maximum performance

// Example assembly output for @print("Score: {}", 42):
//
// ; No runtime format parsing!
// LD HL, const_str_score  ; "Score: "
// LD B, 7                 ; Length known at compile time
// CALL write_string_7     ; Optimized for exact length
// LD HL, const_str_42     ; "42" - pre-computed!
// LD B, 2
// CALL write_string_2
//
// Compare to traditional printf:
// ; Traditional approach needs:
// ; - Format string parsing loop
// ; - Type checking
// ; - Dynamic dispatch
// ; - Buffer allocation
// ; - Much more code and cycles!