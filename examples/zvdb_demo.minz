// ZVDB Demo - Vector Database in MinZ
// Demonstrates 1-bit quantized vector search on Z80

module zvdb_demo;

// Vector dimensions (compile-time configuration)
@lua[[
    VECTOR_BITS = 256    -- Scorpion ZS-256 architecture
    VECTOR_BYTES = VECTOR_BITS / 8
    MAX_VECTORS = 64     -- Reduced for demo
]]

const VECTOR_BYTES: u8 = @lua(VECTOR_BYTES);
const MAX_VECTORS: u8 = @lua(MAX_VECTORS);

// Generate popcount lookup table at compile time
@lua[[
function generate_popcount()
    local table = {}
    for i = 0, 255 do
        local count = 0
        local n = i
        while n > 0 do
            count = count + (n & 1)
            n = n >> 1
        end
        table[i + 1] = count
    end
    return table
end
]]

const POPCOUNT: [u8; 256] = @lua(generate_popcount());

// 256-bit vector (32 bytes)
struct Vector256 {
    bits: [u8; 32],
}

// Search result
struct SearchResult {
    index: u8,
    distance: u8,
    similarity: i16,
}

// Vector database
struct VectorDB {
    vectors: [Vector256; 64],  // MAX_VECTORS
    count: u8,
    // Simple hash index
    hash_buckets: [[u8; 8]; 16],  // 16 buckets, 8 items each
    bucket_counts: [u8; 16],
}

// Global database at fixed address
const DB_ADDRESS: u16 = 0x8000;

// Initialize database
fun init_database() -> *mut VectorDB {
    let db = DB_ADDRESS as *mut VectorDB;
    
    // Clear all data
    let ptr = db as *mut u8;
    for i in 0..(sizeof(VectorDB) as u16) {
        ptr[i] = 0;
    }
    
    return db;
}

// Count set bits in XOR result (Hamming distance)
fun hamming_distance(a: *Vector256, b: *Vector256) -> u8 {
    let mut distance: u8 = 0;
    
    // XOR and count differing bits
    for i in 0..32 {
        let xor = a.bits[i] ^ b.bits[i];
        distance = distance + POPCOUNT[xor];
    }
    
    return distance;
}

// Calculate 1-bit dot product similarity
fun dot_product_1bit(a: *Vector256, b: *Vector256) -> i16 {
    let hamming = hamming_distance(a, b) as i16;
    // Similarity = total_bits - 2 * differing_bits
    return 256 - (hamming << 1);
}

// Fast vector address calculation using shift-by-5
@smc_optimize
fun get_vector_ptr(db: *VectorDB, index: u8) -> *Vector256 {
    // Each vector is 32 bytes, so multiply index by 32
    // Using inline assembly for fast shift
    let offset: u16;
    
    asm("
        ld l, {0}
        ld h, 0
        ; Multiply by 32 using shifts
        add hl, hl  ; x2
        add hl, hl  ; x4
        add hl, hl  ; x8
        add hl, hl  ; x16
        add hl, hl  ; x32
    " : "=r"(offset) : "r"(index));
    
    return (&db.vectors[0] as *u8 + offset) as *Vector256;
}

// Simple hash function (sum of first 4 bytes mod 16)
fun compute_hash(vec: *Vector256) -> u8 {
    let mut hash: u8 = 0;
    for i in 0..4 {
        hash = hash + vec.bits[i];
    }
    return hash & 0x0F;  // mod 16
}

// Add vector to database
fun add_vector(db: *mut VectorDB, data: *u8) -> bool {
    if db.count >= MAX_VECTORS {
        return false;  // Database full
    }
    
    let index = db.count;
    let vec = get_vector_ptr(db, index);
    
    // Copy vector data
    for i in 0..32 {
        vec.bits[i] = data[i];
    }
    
    // Update hash index
    let hash = compute_hash(vec);
    let bucket_count = db.bucket_counts[hash];
    if bucket_count < 8 {
        db.hash_buckets[hash][bucket_count] = index;
        db.bucket_counts[hash] = bucket_count + 1;
    }
    
    db.count = db.count + 1;
    return true;
}

// Brute force search
fun search_brute_force(db: *VectorDB, query: *Vector256) -> SearchResult {
    let mut best = SearchResult {
        index: 255,
        distance: 255,
        similarity: -256,
    };
    
    for i in 0..db.count {
        let vec = get_vector_ptr(db, i);
        let dist = hamming_distance(query, vec);
        
        if dist < best.distance {
            best.index = i;
            best.distance = dist;
            best.similarity = 256 - (dist as i16 << 1);
        }
    }
    
    return best;
}

// Hash-accelerated search
fun search_nearest(db: *VectorDB, query: *Vector256) -> SearchResult {
    let hash = compute_hash(query);
    let bucket_count = db.bucket_counts[hash];
    
    // First check vectors in the same hash bucket
    let mut best = SearchResult {
        index: 255,
        distance: 255,
        similarity: -256,
    };
    
    for i in 0..bucket_count {
        let idx = db.hash_buckets[hash][i];
        let vec = get_vector_ptr(db, idx);
        let dist = hamming_distance(query, vec);
        
        if dist < best.distance {
            best.index = idx;
            best.distance = dist;
            best.similarity = 256 - (dist as i16 << 1);
        }
    }
    
    // If no good match in bucket, fall back to brute force
    if best.distance > 64 {  // Threshold
        best = search_brute_force(db, query);
    }
    
    return best;
}

// Demo: Create test vectors and search
fun main() -> void {
    // Initialize database
    let db = init_database();
    
    // Create some test vectors
    let test_data: [u8; 32];
    
    // Vector 1: All zeros (positive)
    for i in 0..32 {
        test_data[i] = 0x00;
    }
    add_vector(db, &test_data[0]);
    
    // Vector 2: All ones (negative)
    for i in 0..32 {
        test_data[i] = 0xFF;
    }
    add_vector(db, &test_data[0]);
    
    // Vector 3: Alternating pattern
    for i in 0..32 {
        test_data[i] = 0xAA;  // 10101010
    }
    add_vector(db, &test_data[0]);
    
    // Vector 4: Random-ish pattern
    for i in 0..32 {
        test_data[i] = ((i * 17 + 5) & 0xFF) as u8;
    }
    add_vector(db, &test_data[0]);
    
    // Create query vector (similar to vector 3)
    let mut query: Vector256;
    for i in 0..32 {
        query.bits[i] = 0xA8;  // 10101000 - slightly different
    }
    
    // Search for nearest vector
    let result = search_nearest(db, &query);
    
    // Display result (would need screen output functions)
    // Expected: Vector 3 (index 2) with small distance
    
    // For demo, just store result at known location
    let result_addr = 0x7F00 as *mut SearchResult;
    *result_addr = result;
}

// Utility: Generate random hyperplane for better hashing
@lua[[
function generate_random_vector()
    local vec = {}
    -- Use fixed seed for reproducibility
    math.randomseed(42)
    for i = 1, 32 do
        vec[i] = math.random(0, 255)
    end
    return vec
end
]]

const HYPERPLANE_1: Vector256 = Vector256 {
    bits: @lua(generate_random_vector()),
};

// Advanced: Use hyperplane for better hash function
fun compute_hyperplane_hash(vec: *Vector256) -> u8 {
    // Dot product with fixed hyperplane
    let dot = dot_product_1bit(vec, &HYPERPLANE_1);
    
    // Map to hash bucket based on sign and magnitude
    if dot > 64 {
        return 0;
    } else if dot > 0 {
        return 1;
    } else if dot > -64 {
        return 2;
    } else {
        return 3;
    }
}