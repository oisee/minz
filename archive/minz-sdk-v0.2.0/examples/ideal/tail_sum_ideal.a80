; MinZ ideal code - tail_sum.minz
; Tail recursive sum with SMC and tail call optimization

    ORG $8000

; Function: sum_tail(n: u16, acc: u16) -> u16
sum_tail:
sum_tail_param_n:
    LD HL, #0000   ; SMC parameter n
    LD A, H        ; Check if n == 0
    OR L
    JR NZ, sum_continue
    
    ; n == 0: return acc
sum_tail_param_acc:
    LD HL, #0000   ; SMC parameter acc
    RET

sum_continue:
    ; Save n for later use
    LD D, H
    LD E, L
    
    ; Load acc
    LD HL, (sum_tail_param_acc + 1)
    
    ; acc = acc + n
    ADD HL, DE
    
    ; Update parameters for tail call
    ; n = n - 1
    DEC DE
    LD (sum_tail_param_n + 1), DE
    
    ; acc = new acc
    LD (sum_tail_param_acc + 1), HL
    
    ; Tail call optimization - jump instead of call
    JR sum_tail

; Function: main() -> void  
main:
    ; Calculate sum_tail(10, 0)
    LD HL, 10
    LD (sum_tail_param_n + 1), HL
    LD HL, 0
    LD (sum_tail_param_acc + 1), HL
    
    CALL sum_tail
    ; Result is in HL = 55 (sum of 1..10)
    RET

    END main