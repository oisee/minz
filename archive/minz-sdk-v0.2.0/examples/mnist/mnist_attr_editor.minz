// MNIST Attribute Editor for ZX Spectrum
// Fill screen with 0xFF, attributes with 0x00, border 0
// Cursor applies XOR 0x04 to attribute under cursor
// SPACE/M toggles pixel, CTRL+SPACE exits

module mnist_attr_editor;

// ZX Spectrum constants
const SCREEN_START: u16 = 0x4000;
const ATTR_START: u16 = 0x5800;
const SCREEN_SIZE: u16 = 6144;
const ATTR_SIZE: u16 = 768;
const BORDER_PORT: u8 = 0xFE;

// Keyboard ports
const KB_PORT_QAOP: u8 = 0xDF;  // O, P keys
const KB_PORT_ASDF: u8 = 0xFD;  // A key
const KB_PORT_QWER: u8 = 0xFB;  // Q key
const KB_PORT_SPACE: u8 = 0x7F; // SPACE, SYM SHIFT, M

// Editor state
struct Editor {
    cursor_x: u8,  // 0-31 (attribute column)
    cursor_y: u8,  // 0-23 (attribute row)
}

// Set border color
fn set_border(color: u8) -> void {
    asm("
        ld a, {0}
        out ($fe), a
    " : : "r"(color));
}

// Fill screen with pattern
fn fill_screen() -> void {
    // Fill with 0xFF
    let mut addr: u16 = SCREEN_START;
    let end: u16 = SCREEN_START + SCREEN_SIZE;
    
    while addr < end {
        asm("
            ld a, $ff
            ld ({0}), a
        " : : "r"(addr));
        addr = addr + 1;
    }
}

// Fill attributes
fn fill_attributes() -> void {
    // Fill with 0x00 (black on black)
    let mut addr: u16 = ATTR_START;
    let end: u16 = ATTR_START + ATTR_SIZE;
    
    while addr < end {
        asm("
            xor a
            ld ({0}), a
        " : : "r"(addr));
        addr = addr + 1;
    }
}

// Calculate attribute address from cursor position
fn get_attr_addr(x: u8, y: u8) -> u16 {
    return ATTR_START + ((y as u16) * 32) + (x as u16);
}

// Update cursor by XORing attribute with 0x04
fn update_cursor(editor: *Editor) -> void {
    let attr_addr = get_attr_addr(editor.cursor_x, editor.cursor_y);
    
    asm("
        ld hl, {0}
        ld a, (hl)
        xor $04        ; Toggle bit 2
        ld (hl), a
    " : : "r"(attr_addr));
}

// Read keyboard port
fn read_port(port: u8) -> u8 {
    let result: u8;
    asm("
        ld a, {0}
        in a, ($fe)
        ld {1}, a
    " : "=r"(result) : "r"(port));
    return result;
}

// Check if key is pressed (active low)
fn is_key_pressed(port: u8, bit: u8) -> bool {
    let value = read_port(port);
    return (value & (1 << bit)) == 0;
}

// Toggle pixel in 16x16 representation (top-left corner)
fn toggle_pixel(editor: *Editor) -> void {
    // Map cursor position to 16x16 grid
    let bit_x = editor.cursor_x & 0x0F;  // 0-15
    let bit_y = editor.cursor_y & 0x0F;  // 0-15
    
    // Calculate screen address for this pixel
    // Simplified for first 16 lines
    let screen_addr = SCREEN_START + ((bit_y as u16) * 32) + ((bit_x >> 3) as u16);
    let bit_mask: u8 = 0x80 >> (bit_x & 7);
    
    asm("
        ld hl, {0}
        ld a, (hl)
        xor {1}
        ld (hl), a
    " : : "r"(screen_addr), "r"(bit_mask));
}

// Simple delay for key repeat
fn delay() -> void {
    let mut count: u16 = 0;
    while count < 1000 {
        count = count + 1;
    }
}

// Handle keyboard input
fn handle_input(editor: *Editor) -> bool {
    // Q - up (port 0xFB, bit 0)
    if is_key_pressed(KB_PORT_QWER, 0) {
        if editor.cursor_y > 0 {
            update_cursor(editor);  // Remove cursor
            editor.cursor_y = editor.cursor_y - 1;
            update_cursor(editor);  // Draw cursor
            delay();
        }
    }
    
    // A - down (port 0xFD, bit 0)
    if is_key_pressed(KB_PORT_ASDF, 0) {
        if editor.cursor_y < 23 {
            update_cursor(editor);  // Remove cursor
            editor.cursor_y = editor.cursor_y + 1;
            update_cursor(editor);  // Draw cursor
            delay();
        }
    }
    
    // O - left (port 0xDF, bit 1)
    if is_key_pressed(KB_PORT_QAOP, 1) {
        if editor.cursor_x > 0 {
            update_cursor(editor);  // Remove cursor
            editor.cursor_x = editor.cursor_x - 1;
            update_cursor(editor);  // Draw cursor
            delay();
        }
    }
    
    // P - right (port 0xDF, bit 0)
    if is_key_pressed(KB_PORT_QAOP, 0) {
        if editor.cursor_x < 31 {
            update_cursor(editor);  // Remove cursor
            editor.cursor_x = editor.cursor_x + 1;
            update_cursor(editor);  // Draw cursor
            delay();
        }
    }
    
    // SPACE - toggle pixel (port 0x7F, bit 0)
    if is_key_pressed(KB_PORT_SPACE, 0) {
        toggle_pixel(editor);
        delay();
        delay();  // Extra delay for toggle
    }
    
    // M - toggle pixel (port 0x7F, bit 2)
    if is_key_pressed(KB_PORT_SPACE, 2) {
        toggle_pixel(editor);
        delay();
        delay();  // Extra delay for toggle
    }
    
    // CTRL+SPACE (Symbol Shift + Space) - exit
    if is_key_pressed(KB_PORT_SPACE, 1) {  // Symbol Shift
        if is_key_pressed(KB_PORT_SPACE, 0) {  // Space
            return true;  // Exit
        }
    }
    
    return false;  // Continue
}

// Main program
fn main() -> void {
    // Initialize
    set_border(0);      // Black border
    fill_screen();      // Fill with 0xFF
    fill_attributes();  // Fill with 0x00
    
    // Initialize editor
    let mut editor: Editor;
    editor.cursor_x = 16;  // Center
    editor.cursor_y = 12;  // Center
    
    // Show initial cursor
    update_cursor(&editor);
    
    // Main loop
    while true {
        if handle_input(&editor) {
            break;  // Exit requested
        }
        
        // Small delay for main loop
        delay();
    }
    
    // Reset on exit
    asm("
        jp 0
    ");
}