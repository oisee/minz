; MinZ generated code - Optimized with lean prologue/epilogue
; Generated: 2024-07-06

; Function: simple_add
; Uses only A register - minimal prologue/epilogue
simple_add:
    ; No need to save any registers - only uses A
    ; Parameters already in registers or on stack
    LD A, (IX+4)      ; Load first parameter
    ADD A, (IX+5)     ; Add second parameter
    ; Result in A
    RET

; Function: complex_calc  
; Uses HL, DE, BC - saves only these registers
complex_calc:
    PUSH BC           ; Save only registers we modify
    PUSH DE
    PUSH HL
    PUSH IX
    LD IX, SP
    
    ; t1 = x + y
    LD L, (IX+12)     ; Load x (low)
    LD H, (IX+13)     ; Load x (high)
    LD E, (IX+14)     ; Load y (low)
    LD D, (IX+15)     ; Load y (high)
    ADD HL, DE        ; t1 = x + y
    PUSH HL           ; Save t1
    
    ; t2 = y + z
    LD L, (IX+14)     ; Load y (low)
    LD H, (IX+15)     ; Load y (high)
    LD E, (IX+16)     ; Load z (low)
    LD D, (IX+17)     ; Load z (high)
    ADD HL, DE        ; t2 = y + z
    PUSH HL           ; Save t2
    
    ; t3 = x + z
    LD L, (IX+12)     ; Load x (low)
    LD H, (IX+13)     ; Load x (high)
    LD E, (IX+16)     ; Load z (low)
    LD D, (IX+17)     ; Load z (high)
    ADD HL, DE        ; t3 = x + z
    
    ; result = t1 + t2 + t3
    POP DE            ; Get t2
    ADD HL, DE        ; t3 + t2
    POP DE            ; Get t1
    ADD HL, DE        ; (t3 + t2) + t1
    
    ; Restore only what we saved
    LD SP, IX
    POP IX
    POP HL            ; Note: result is in HL, so this gets overwritten
    POP DE            ; But we need to maintain stack balance
    POP BC
    RET

; Function: timer_isr
; Interrupt handler - uses EXX for ultra-fast save/restore
timer_isr:
    EX AF, AF'        ; Save AF to shadow (1 cycle)
    EXX               ; Save BC, DE, HL to shadows (1 cycle)
    
    ; Function body
    LD A, 0           ; counter = 0
    INC A             ; counter++
    
    ; Restore registers
    EXX               ; Restore BC, DE, HL (1 cycle)
    EX AF, AF'        ; Restore AF (1 cycle)
    EI                ; Re-enable interrupts
    RETI              ; Return from interrupt

; Function: hamming_distance (from ZVDB)
; High register pressure - uses shadow registers
hamming_distance:
    PUSH IX
    LD IX, SP
    
    ; Switch to shadow registers for extra capacity
    EXX               ; Now have BC', DE', HL' available
    
    ; Main registers for primary computation
    LD HL, (IX+4)     ; Vector A pointer
    LD DE, (IX+6)     ; Vector B pointer
    LD B, 32          ; Loop counter
    XOR A             ; Clear distance counter
    
hamming_loop:
    ; Load bytes and XOR
    LD C, (HL)        ; A[i]
    LD A, (DE)        ; B[i]
    XOR C             ; A[i] ^ B[i]
    
    ; Count bits using shadow registers
    EXX               ; Switch to shadows
    LD B, A           ; Save XOR result
    
    ; Bit counting
    AND 0x55
    LD C, A
    LD A, B
    SRL A
    AND 0x55
    ADD A, C          ; First reduction
    
    LD B, A
    AND 0x33
    LD C, A
    LD A, B
    SRL A
    SRL A
    AND 0x33
    ADD A, C          ; Second reduction
    
    LD B, A
    AND 0x0F
    LD C, A
    LD A, B
    SRL A
    SRL A
    SRL A
    SRL A
    ADD A, C          ; Final count
    
    EXX               ; Back to main registers
    ADD A, D          ; Accumulate distance
    LD D, A
    
    INC HL
    INC DE
    DJNZ hamming_loop
    
    ; Result in D
    LD A, D
    
    POP IX
    RET

; Data section
counter:
    DW 0

    END main