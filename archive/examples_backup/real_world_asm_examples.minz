// Real-World Assembly Integration Examples
// Demonstrates practical use cases for @abi seamless integration

// =============================================================================
// GRAPHICS LIBRARY - ZX SPECTRUM SCREEN ROUTINES
// =============================================================================

// Existing assembly routine for fast pixel plotting
@abi("register: D=x, E=y, A=color")
@extern
fun plot_pixel_asm(x: u8, y: u8, color: u8) -> void;

// Existing assembly routine for drawing lines
@abi("register: B=x1, C=y1, D=x2, E=y2, A=color")
@extern  
fun draw_line_asm(x1: u8, y1: u8, x2: u8, y2: u8, color: u8) -> void;

// High-level graphics functions using assembly
fun draw_rectangle(x: u8, y: u8, width: u8, height: u8, color: u8) {
    // Draw using existing optimized assembly routines
    draw_line_asm(x, y, x + width, y, color);           // Top
    draw_line_asm(x, y + height, x + width, y + height, color); // Bottom  
    draw_line_asm(x, y, x, y + height, color);          // Left
    draw_line_asm(x + width, y, x + width, y + height, color);  // Right
}

// =============================================================================
// SOUND SYSTEM - AY-3-8912 INTEGRATION
// =============================================================================

// Existing assembly AY chip routines
@abi("register: A=reg, C=value")
@extern
fun ay_write_reg(reg: u8, value: u8) -> void;

@abi("register: A=reg") 
@extern
fun ay_read_reg(reg: u8) -> u8;

// High-level sound functions
fun play_note(channel: u8, frequency: u16, volume: u8) {
    let freq_lo = (frequency & 0xFF) as u8;
    let freq_hi = ((frequency >> 8) & 0x0F) as u8;
    
    // Use existing assembly routines for AY chip access
    if channel == 0 {
        ay_write_reg(0, freq_lo);    // Channel A frequency low
        ay_write_reg(1, freq_hi);    // Channel A frequency high  
        ay_write_reg(8, volume);     // Channel A volume
    } else if channel == 1 {
        ay_write_reg(2, freq_lo);    // Channel B frequency low
        ay_write_reg(3, freq_hi);    // Channel B frequency high
        ay_write_reg(9, volume);     // Channel B volume  
    } else if channel == 2 {
        ay_write_reg(4, freq_lo);    // Channel C frequency low
        ay_write_reg(5, freq_hi);    // Channel C frequency high
        ay_write_reg(10, volume);    // Channel C volume
    }
}

// =============================================================================
// FILE SYSTEM - DISK/TAPE ROUTINES  
// =============================================================================

// Existing assembly tape loading routine
@abi("register: HL=buffer, DE=length, A=flag")
@extern
fun tape_load_block(buffer: *u8, length: u16, flag: u8) -> u8;

// Existing assembly tape saving routine  
@abi("register: HL=buffer, DE=length, A=flag")
@extern
fun tape_save_block(buffer: *u8, length: u16, flag: u8) -> u8;

// High-level file operations
fun load_file(filename: *u8, buffer: *u8, max_size: u16) -> u16 {
    // In real implementation, would parse filename and find on tape
    // For now, just load raw block
    let result = tape_load_block(buffer, max_size, 0);
    if result == 0 {
        return max_size;  // Success - return bytes loaded
    } else {
        return 0;         // Error
    }
}

fun save_file(filename: *u8, buffer: *u8, size: u16) -> u8 {
    return tape_save_block(buffer, size, 0);
}

// =============================================================================  
// MEMORY MANAGEMENT - BANK SWITCHING
// =============================================================================

// Existing assembly banking routines
@abi("register: A=bank")
@extern
fun switch_ram_bank(bank: u8) -> void;

@abi("register: A=bank")  
@extern
fun switch_rom_bank(bank: u8) -> void;

@abi("naked")
@extern
fun get_current_bank() -> u8;

// High-level memory management
struct MemoryRegion {
    start: u16,
    size: u16, 
    bank: u8
}

fun allocate_banked_memory(size: u16) -> MemoryRegion {
    let current_bank = get_current_bank();
    
    // Simple allocation strategy - use next bank
    let new_bank = current_bank + 1;
    switch_ram_bank(new_bank);
    
    return MemoryRegion {
        start: 0xC000,  // Banked memory starts at 0xC000
        size: size,
        bank: new_bank
    };
}

// =============================================================================
// INTERRUPT HANDLERS - REAL-TIME SYSTEMS
// =============================================================================

// Existing ultra-fast assembly interrupt handler
@abi("naked")
@extern  
fun timer_interrupt_handler() -> void;

// Existing assembly routine for setting interrupt vector
@abi("register: HL=vector")
@extern
fun set_interrupt_vector(vector: u16) -> void;

// High-level interrupt setup
fun setup_timer_system(frequency_hz: u16) {
    // Calculate timer value for desired frequency
    let timer_value = 3500000 / frequency_hz; // ZX Spectrum CPU frequency
    
    // Set up interrupt vector to point to assembly handler  
    set_interrupt_vector(timer_interrupt_handler as u16);
    
    // Enable interrupts (would be done in assembly)
    asm {
        EI
        IM 2
    }
}

// =============================================================================
// MAIN DEMONSTRATION
// =============================================================================

fun main() {
    // Graphics demonstration
    plot_pixel_asm(50, 50, 1);  // White pixel
    draw_rectangle(10, 10, 20, 15, 1);  // White rectangle
    
    // Sound demonstration  
    play_note(0, 440, 15);  // Play A note on channel 0
    play_note(1, 554, 10);  // Play C# note on channel 1
    
    // File system demonstration
    let buffer = 0x8000 as *u8;
    let bytes_loaded = load_file("data.bin", buffer, 1024);
    if bytes_loaded > 0 {
        save_file("backup.bin", buffer, bytes_loaded);
    }
    
    // Memory management demonstration
    let memory = allocate_banked_memory(16384);  // Allocate 16K
    switch_ram_bank(memory.bank);  // Switch to allocated bank
    
    // Interrupt system demonstration  
    setup_timer_system(50);  // 50Hz timer interrupts
}