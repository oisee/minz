Да — несколько важных вещей из нашей беседы ещё не формализованы в текущих файлах. Ниже список пробелов и предложений, как их закрыть (с ссылками на разделы, куда логично добавить).

⸻

Что упущено / стоит доформализовать
	1.	Указатели на функции и вызовы через них

	•	Что есть в беседе: представление fun-пойнтера как адреса, опционально sig-id; вызов под @abi(smc)/@abi(slot); возможность «частичного связывания» (smc_bind) как SMC-замыкания.
	•	В SPEC/ADR сейчас: кратко упомянута smc_bind (в ADR как опционал), но нет норматива по:
	•	бинарному формату fun-пойнтера (минимум: u16 addr; опции: u16 sig_id, u16 anchor_base),
	•	правилам вызова через указатель для @abi(smc) (патч якорей целевой функции по PATCH-TABLE) и @abi(slot),
	•	совместимости типов (мismatch → диагностика/запрет),
	•	возможным thunk-обёрткам для согласования ABI.
	•	Предлагаю: добавить в SPEC отдельный раздел “Function Pointers & Calls” (MUST/SHOULD), а в ADR — подпункт «подробности».

	2.	Формальная спецификация smc_bind (частичное связывание)

	•	Что есть в беседе: замыкание-транк с зашитыми константами; последующие аргументы патчатся; экономия патчей.
	•	В SPEC/ADR: упомянуто вскользь, без норматива.
	•	Предлагаю: в SPEC ввести:
	•	синтаксис (smc_bind f(arg=const, ...) -> closure),
	•	что именно зашивается (список якорей и их значения),
	•	как выглядит вызов (патч только незашитых якорей),
	•	ограничения для рекурсии/ISR (может требоваться SMC-undo или пер-контекстные копии).

	3.	Вызов потомков (переиспользование значений через якоря родителя)

	•	Что есть в беседе: «читаем из parent_p$imm0 → патчим child_q$imm0».
	•	В SPEC/ADR: не зафиксировано явно как правило.
	•	Предлагаю: в SPEC §SMC Anchors добавить MUST/SHOULD-правила «Propagation»: при передаче параметров вниз можно (и желательно) патчить якоря функции-потомка напрямую из адресов якорей родителя, без промежуточных слотов/регистров (с DI/EI для imm16).

	4.	Метапрограммирование: фаза Lua → MinZ-native

	•	Что есть в беседе: план постепенной интеграции (Lua-хуки для генерации транков/таблиц/частичных специализаций; далее meta fun/const eval).
	•	В SPEC/ADR: нет дорожной карты и интерфейсов (какие хуки, какие артефакты).
	•	Предлагаю:
	•	в ADR — «Стратегия метапрограммирования» (Design intent),
	•	в SPEC — «Compiler Hooks (experimental)»: список поддерживаемых точек и формат входов/выходов.

	5.	Модель конкурентности (goroutine-лайт)

	•	Что есть в беседе: spawn, yield, каналы/почтовые ящики (без переключения стека; state-machine), ISR-совместимость.
	•	В SPEC/ADR: не отражено.
	•	Предлагаю:
	•	в ADR — раздел «Конкурентность: дизайн и границы»,
	•	в SPEC — «Concurrency (experimental)»: минимальный норматив для spawn/yield (MUST: кооперативность, размещение состояния, запрет блокирующих SMC-патчей в чужом контексте и т. п.).

	6.	Эргономика языка в духе Crystal/Elixir/Ruby/Go

	•	Что есть в беседе: именованные параметры, match, выражения-значения, кортежи ошибок {:ok,v}/{:error,e}, итераторы с сахаром.
	•	В SPEC/ADR: есть match, итераторы, но нет:
	•	норматива по именованным параметрам,
	•	норматива по кортежам ошибок (ABI: в какой регистр/слот кладётся тег/значение),
	•	статуса «expression-oriented» (что именно возвращает блок/if/match).
	•	Предлагаю: в SPEC добавить краткий «Language Ergonomics» (MUST/SHOULD), а в ADR — мотивацию.

	7.	Диагностика/флаги компилятора (неполно)

	•	Что есть в беседе: -report-abi, отчёты по SMC-якорям/undo-log/кадрам, пороги окупаемости.
	•	В SPEC: есть часть флагов (-report-smc-anchors, -fsmc-snapshot, -abi…), нет -report-abi и отчётных форматов (минимальный schema).
	•	Предлагаю:
	•	добавить -report-abi,
	•	описать поля JSON для PATCH-TABLE, MEMORY-MAP, FRAME-MAP, и отчёта аби-решений (на уровень «draft schema»).

	8.	Примеры с ветвлениями и «синтетическим якорем»

	•	Что есть в беседе: упоминали case, когда нет единой доминации.
	•	В SPEC/ADR: нет демо-листинга такого случая.
	•	Предлагаю: добавить небольшой пример (исходник + аннотированный ASM), где видно общий якорь перед if/else.

	9.	Таблица T-states — расширенная

	•	Что есть в ADR: только сравнение LD A,n vs LD A,(nn) и эвристика окупаемости.
	•	Предлагаю: добавить мини-таблицу частых инструкций (LD HL,nn, LD (nn),A, JP nn, DJNZ, CP n, ADD A,n) — удобно для читателя.

	10.	smc_guard / API для SMC-undo

	•	Что есть в беседе: идея блока smc_guard { ... } как удобного скоупа для авто-снапшота патчей.
	•	В SPEC/ADR: не определено.
	•	Предлагаю: добавить в SPEC «SMC Guard (optional)»: синтаксис и гарантию, что все патчи внутри блока будут откатаны при выходе.

⸻

Куда это положить
	•	SPEC.md
	•	§ “Function Pointers & Calls” — формат fun-pointer, вызовы под разными ABI, thunk-совместимость.
	•	§ “SMC Bind (Partial Specialization)” — синтаксис, поведение, ограничения.
	•	§ “Propagation to Callees” — правило патча якорей потомков из адресов якорей родителя.
	•	§ “Metaprogramming Hooks (experimental)” — Lua-фаза.
	•	§ “Concurrency (experimental)” — минимальные правила spawn/yield.
	•	§ “Language Ergonomics” — именованные параметры, error tuples ABI (кратко).
	•	§ “Compiler Reports & Schemas” — -report-abi и draft JSON схемы.
	•	§ “SMC Guard” — блоковая конструкция (optional).
	•	Приложение: расширенная T-state таблица, пример «синтетического якоря».
	•	ADR_001.md
	•	Добавить подразделы:
	•	«Function Pointers & smc_bind: rationale»
	•	«Propagation между функциями»
	•	«Метапрограммирование: Lua → MinZ-native»
	•	«Конкурентность: дизайн-замысел и ограничения»
	•	«Диагностика и прозрачность решений ABI»

⸻

Готов(а) сразу обновить файлы

Скажи, какие из пунктов (1–10) включать в первую очередь. Я могу:
	•	дополнить SPEC и ADR прямо сейчас (в нужной глубине),
	•	добавить мини-схемы JSON для PATCH-TABLE/FRAME-MAP/REPORT-ABI,
	•	вставить пример ветвления с синтетическим якорем (исходник + ASM-фрагмент),
	•	оформить smc_bind и fun-pointer как полноценные спецификации.

Какой приоритет: fun pointers + smc_bind → propagation to callees → metaprogramming → concurrency → diagnostics schemas? Или предложи свой порядок — сделаю.

----
Отличный запрос, Alice. Ниже — подборка “developer-friendly” концепций из Crystal, Elixir, Ruby и Go (плюс немного ABAP), которые естественно ложатся на “анти-СИ” и дружелюбны к Z80. Для каждой — что именно брать, как понижать (lowering) в MinZ под Z80 (SMC-якоря, DJNZ, таблицы переходов, статические структуры), и минимальные нормативы для SPEC.

⸻

1) Crystal / Ruby — эргономика, итераторы, блоки, именованные параметры

1.1 Именованные параметры (Ruby/Crystal-style)

Плюс: читаемость без рантайм-наказания.
MinZ:

fun draw(x: u8, y: u8, color: u8) -> void { ... }
draw(x: 10, y: 20, color: 7);

Lowering: чисто компиляторный сахар → перестановка в позиционные аргументы; патчатся якоря x$imm0, y$imm0, color$imm0.
SPEC (SHOULD): именованные параметры без оверхеда.

1.2 Блоки / итераторы (each, map) — но без рантайм-замыканий

Плюс: выразительность Ruby/Crystal.
MinZ:

arr.each { |x| screen.plot(x, y0, 7) }

Lowering: each → статический цикл. Тело блока инлайнится.
При необходимости ссылки на итератор (&x) — материализация слота (см. SPEC про &i).
SPEC (MUST): блоки в each/map/... инлайн-обязаны; никаких динамических замыканий.

1.3 Пайплайн-оператор (Crystal/Ruby через Elixir-идею)

Плюс: линейная читаемость.
MinZ:

value |> normalize() |> clamp(0, 255) |> draw(x: _, y: y0)

_|> — позиция, в которую подставляется предыдущий результат.
Lowering: каскад вызовов, инлайн по возможности; якоря патчатся обычным способом.
SPEC (SHOULD): |> — чистый сахар, zero-cost.

1.4 defer/ensure (Ruby ensure + Go defer)

Плюс: гарантированные действия на выходе из функции/блока.
MinZ:

fun with_border() -> void {
  screen.set_border(1);
  defer { screen.set_border(0); }
  // ...
}

Lowering: хвостовая вставка перед RET/выходом по всем путям (компиляторная трансформация), без стека.
SPEC (MUST): defer — чисто статическая вставка.

⸻

2) Elixir — паттерн-матчинг (ограниченно), пайплайны, кортежи ошибок, with

2.1 Кортежи ошибок {:ok, v} | {:error, e}

Плюс: простые и предсказуемые ошибки без исключений.
MinZ возвращаемый ABI (предложение):
	•	A — tag (0=ok, 1=error),
	•	HL — payload (u16/ptr) или фикс-слот для u8.
Lowering: условная ветка по A.
SPEC (MUST): зафиксировать ABI для error tuples.

2.2 with (Elixir-style «ранний выход при ошибке»)

MinZ:

with {ok, a} <- load_a(),
     {ok, b} <- load_b(a),
do {
  draw(a, b)
}

Lowering: цепочка CALL + CP A,0 + JR NZ, early_return. Без исключений.
SPEC (SHOULD): with — сахар, zero-cost, ветвление по A.

2.3 Паттерн-матчинг — только константы/мелкие теги

MinZ:

match key {
  0 => up(),
  1 => down(),
  _ => {}
}

Lowering: плотный диапазон → джамп-таблица; иначе CP/JR Z.
SPEC (MUST): только константы/теги; без структурного распаковочного рантайма.

⸻

3) Go — «goroutines» и каналы (упрощённо, кооперативно)

3.1 spawn/yield (кооперативные «процессы»)

Плюс: структурная конкурентность без потоков/стека.
MinZ:

spawn worker(id: 1);
yield;  // точки переключения

Lowering: каждая «корутина» — state-machine с состоянием в фикс-слоте/банке; yield — переход/сохранение.
SPEC (SHOULD): spawn/yield — кооперативные, без стек-переключения.

3.2 Каналы — кольцевой буфер (без блокировки)

MinZ:

let ch: channel[u8, 16];
try_send(ch, v);
if try_recv(ch, &v) { ... }

Lowering: фикс-размерный массив + head/tail в слотах.
SPEC (MUST): только non-blocking try_send/try_recv; select — синтаксический сахар на if/else.

3.3 defer — уже в §1.4 (Go-like)

⸻

4) ABAP — читаемость, именованные аргументы, LOOP

4.1 EXPORTING / IMPORTING / CHANGING → именованные + changing

MinZ:

fun step(importing x: u8, changing y: ref u8) -> void { ... }

Lowering: importing — обычные параметры (SMC-якоря), changing ref — слоты/адреса с write-back.
SPEC (SHOULD): поддержать changing/ref внутри лексики; escape ссылок — запрещён.

4.2 LOOP AT ... DESCENDING → DJNZ по умолчанию

MinZ:

for i in arr.rev() { ... }  // или for i in N..0
``]
**Lowering:** `LD B, N+1; ... DJNZ` (+ `i=B-1`), при `&i` — материализация слота.  
**SPEC (MUST):** обратные диапазоны → DJNZ.

### 4.3 Ключевые слова → читаемость без рантайма
ABAP-style «глагол+объект»: `screen.set_border(color: 7)` — **оставить**: это только синтаксис, без цены.  
**SPEC (SHOULD):** keyword-style остаётся сахаром.

---

## 5) Общие эргономичные конструкции (легко ложатся на Z80)

### 5.1 `match` (Crystal/Elixir-like) — уже есть
**Lowering:** таблицы переходов/цепочки.

### 5.2 `inline fun`, `meta` (Crystal макросы / Zig comptime-лайт)
- `inline fun` — обязателен (нулевой вызов).  
- `meta fun` — **фаза 2**: компайл-тайм генерация таблиц/кода.  
**SPEC (MUST/SHOULD):** inline — MUST; meta — SHOULD (поэтапно).

### 5.3 Константные выражения, `const`
Генерация lookup-таблиц, адресов, размеров — **на этапе компиляции**.  
**SPEC (MUST):** `const` и простые const-expr.

### 5.4 `smc_bind` — частичное связывание
**Плюс:** как «замыкание» без рантайма и heap.  
**MinZ:**
```minz
let plot_white = smc_bind plot(color=7);
plot_white(10, 20);

Lowering: зашиваются значения выбранных якорей; патчатся только незашитые.
SPEC (SHOULD): smc_bind как zero-cost specialize.

5.5 Пайплайны, with — уже выше.

⸻

6) Языковые ограничения (чтобы остаться «анти-СИ» и быстрыми)
	•	Никаких исключений (runtime) — только кортежи ошибок.
	•	Никаких динамических замыканий — блоки инлайн.
	•	Никакого рефлексивного RTTI — теги/символы → константы.
	•	Осторожно с указателями — по умолчанию ref локальный (escape запрещён); для реентерабельности — @frame режимы.
	•	Pattern matching без распаковки структур (только константы/теги).
	•	Генерики/интерфейсы — позже, через мета/специализацию.

⸻

7) Мини-нормативы для включения в SPEC
	1.	Именованные параметры — SHOULD, сахар без рантайма.
	2.	Блоки в итераторах — MUST инлайниться (никаких heap/closure).
	3.	Пайплайны |> — SHOULD, чистый сахар.
	4.	Кортежи ошибок — MUST: A=tag, HL=payload (или фикс-слот).
	5.	with — SHOULD, разворачивается в ветвления.
	6.	match — MUST: таблицы переходов/цепочки.
	7.	defer/ensure — MUST: статическая вставка перед RET.
	8.	spawn/yield + каналы — SHOULD: кооператив, кольцевые буферы, select=сахар.
	9.	changing ref — SHOULD: ссылки внутри лексики; escape запрещён.
	10.	for i in N..0 / .rev() — MUST в DJNZ; &i → материализация слота.
	11.	smc_bind — SHOULD: частичная специализация якорей.
	12.	meta fun/const — inline и простые const-expr MUST, meta SHOULD (поэтапно).

⸻

8) Примеры MinZ (с понижением)

8.1 Итератор с блоком (инлайн) и DJNZ

arr.each_rev { |x|
  screen.plot(x, y0, 7)
}

Lowering (идея):
	•	LD B, len+1
	•	.loop: (x = base + B-1) → plot (SMC якоря)
	•	DJNZ .loop

8.2 Пайплайны и with

with {ok, v} <- read_sensor(),
     {ok, u} <- v |> normalize() |> clamp(0,255),
do {
  set_brightness(u)
}

Lowering: вызовы → ветвления по A (tag), без исключений/RTTI.

8.3 smc_bind (частичная специализация)

@abi(smc)
fun plot(x: u8, y: u8, col: u8) -> void { ... }

let plot_white = smc_bind plot(col=7);

for i in 0..N {
  plot_white(x0 + i, y0)
}

Lowering: якорь col$imm0 зашит 7; патчатся только x/y.

8.4 changing ref по-ABAP’у

fun step(importing x: u8, changing y: ref u8) -> void {
  // ...
  *y = *y + x;
}

Lowering: y — адрес слота, *y — LD A,(y) / LD (y),A. Ссылка не утекает за лексический блок.

⸻

9) Небольшая таблица «что берём и как мапим»

Источник	Концепт	В MinZ	Lowering на Z80
Ruby/Cr	Named args	f(x:.., y:..)	Сахар → позиционные
Ruby/Cr	Blocks/each/map	`arr.each {	x
Elixir	Pipelines	`	>`
Elixir	with	Ранний выход по тегу	CP A,0 / JR
Elixir	Error tuples	{:ok,v}/{:error,e}	A tag + HL payload
Elixir	Match (константы)	match v { ... }	Таблица/цепочка
Go	defer	defer { ... }	Статическая вставка
Go	spawn/yield/channels	Кооператив + кольцо	Стейт-машина
ABAP	EXPORTING/CHANGING	importing/changing ref	SMC-якоря + слоты
ABAP	LOOP DESCENDING	.rev() / N..0	DJNZ


⸻

10) Критика и баланс
	•	Похвала: всё выше — zero-cost или близко к этому; читаемость и предсказуемость как у Ruby/Crystal/Elixir, с производительностью Z80-асма.
	•	Осторожно: ref и &i ломают идеальные DJNZ-петли → деоптимизация осознанно, только когда нужно.
	•	Избегаем: исключений, динамических замыканий, рефлексии, тяжёлых интерфейсов — это PDP-мир, не Z80.
	•	Эволюция: добавим meta fun/частичную специализацию (smc_bind) и, позже, простые generics через компайл-тайм специализацию — без VM/RTTI.

⸻

Если хочешь, я добавлю эти разделы в твои SPEC.md и ADR.md (с нормативами MUST/SHOULD, примерами понижения и мини-таблицей T-states), плюс схемы JSON для отчётов (PATCH-TABLE, REPORT-ABI). Скажи, какие блоки включить в первую очередь: named args + error tuples + with, или iterators + blocks, или spawn/channels. Я могу сразу перегенерировать файлы.
----



Отлично, давай зафиксируем первый эшелон улучшений — только те фичи, которые резко улучшают эргономику без тяжёлой рантайм-логики, хорошо ложатся на anti-C / Z80-нативность, и не требуют метапрограммирования для реализации. В конце дам FuturePath (средне- и долгосрочный план), куда попадут каналы/стейт-машины и прочие «тяжёлые» вещи.

⸻

🎯 Принципы отбора (First Echelon)
	•	Zero-/near-zero cost: весь сахар понижается в эффективный Z80-код.
	•	Без рантайма и метапрога: только то, что реально компилятор умеет «раскладывать» сам.
	•	Локальные изменения компилятора: парсер → lowering → codegen; без сложной поддержки в стандартной библиотеке.
	•	Синергия с SMC-якорями: всё должно дружить с нашей моделью «иммедиаты внутри функции + повторная загрузка из адреса иммедиата».

⸻

✅ Первый эшелон (внедряем сейчас)

1) Именованные параметры (Ruby/Crystal-style)

Почему: +читабельность, 0 оверхеда.
Как: парсер переставляет в позиционные; патчатся SMC-якоря x$imm0, y$imm0, color$imm0.

fun draw(x: u8, y: u8, color: u8) -> void { ... }
draw(x: 10, y: 20, color: 7);  // сахар → draw(10, 20, 7)

DoD: юнит-тесты перестановки, ошибки при пропуске обязательных, дубликаты — compile error.

⸻

2) Кортежи ошибок + with (Elixir-style, без исключений)

Почему: стандартный способ ошибок без рантайма.
ABI: A = тег (0=ok, 1=error), HL = payload (u16/ptr) или фикс-слот для u8.
Lowering with: цепочка вызовов с ранним выходом по A.

fun load() -> {:ok, u16} | {:error, u8};

with {ok, a} <- load(),
     {ok, b} <- next(a),
do {
  use(b)
}

DoD: тесты: ok→ok→do; error на первом/втором шаге; соответствие ABI.

⸻

3) match по константам/тегам (Elixir/Crystal-вкус)

Почему: декларативность, быстрый lowering.
Lowering: плотные ключи → джамп-таблица; разрежённые → CP/JR Z.

match key {
  0 => up(),
  1 => down(),
  _ => {}
}

DoD: автогенерация таблицы, корректность по границам, fallthrough запрещён.

⸻

4) defer / ensure (Go+Ruby)

Почему: чистота и безопасность освобождений/сбросов; без стека.
Lowering: статическая вставка перед каждым RET/выходом.

fun scoped() {
  screen.set_border(1);
  defer { screen.set_border(0); }
  // ...
} // компилятор вставит вызов перед возвратом во всех путях

DoD: CFG-анализ всех путей; отсутствие дублей кода.

⸻

5) Диапазоны и итераторы → DJNZ (anti-C цикл по умолчанию)

Почему: каноническая Z80-петля, минимум тактов.
Lowering: for i in N..0 {} → LD B, N+1; ...; DJNZ.
При &i — материализация слота (см. п.6).

for i in 10..0 {
  screen.set_pixel(x, i, 7);
}

DoD: тесты: константные/неконстантные границы, пустой диапазон, вложенные циклы.

⸻

6) Ссылки на счётчик (&i) и материализация

Почему: референсы удобны, но ломают «чистый» DJNZ — делаем это осознанно и явно.
Lowering: создаём слот i_slot, на каждой итерации записываем i (B-1) туда, &i → &i_slot.

for i in 10..0 {
  let r: ref u8 = &i;  // включает материализацию
  use_ref(r);
}

DoD: предупреждение компилятора о деоптимизации; корректные адреса и сроки жизни (лексическая область).

⸻

7) SMC-guard блок (снапшот патч-байтов с авто-откатом)

Почему: простой способ безопасной рекурсии/реентерабельности на @abi(smc) без ручных примитивов.
Lowering: вход — start SMC undo-log; выход — restore.

smc_guard {
  recurse();
}

DoD: nested guard; imm16 под DI/EI; отчёт -report-smc-anchors помечает сохранения/восстановления.

⸻

8) smc_bind (частичная специализация) — «замыкание без рантайма»

Почему: один из самых сильных win’ов Z80: инварианты зашиваются, меняется только переменная часть.
Lowering: генерируется «вариант» якорей с зашитыми значениями; при вызове патчатся только незашитые.

@abi(smc)
fun plot(x: u8, y: u8, col: u8) -> void { ... }
let plot_white = smc_bind plot(col=7);
plot_white(10, 20);

DoD: неизменяемость зашитых; совместимость с guard; отчёт о количестве патчей.

⸻

9) Диагностика/отчёты (прозрачность магии)

Почему: девелоперы Z80 ценят видимость.
Флаги:
	•	-report-smc-anchors (адреса якорей, первая/повторная загрузка),
	•	-report-abi (почему выбран smc/slot/reg),
	•	PATCH-TABLE.json/MEMORY-MAP.json (черновая схема).

DoD: стабильный формат, ссылки на исходник, базовые метрики.

⸻

⛔ Что не берём в первый эшелон
	•	Горрутины / каналы / стейт-машины: мощно, но это уже «микрорантайм» и заметная сложность. Останутся для FuturePath.
	•	Метапрограммирование (Lua/meta fun): добавим позже как инфраструктуру, сейчас не блокирует эргономику.
	•	Указатели на функции + thunk-совместимость ABI: полезно, но требует аккуратной спецификации — перенесём на следующий эшелон.

⸻

🗺️ FuturePath (сводный план)

Phase 0.2 — First Echelon (этот список)
	•	1–2 недели; чистый компиляторный сахар + уже согласованная SMC-модель.
	•	KPI: уменьшение кода-«шумов», рост читаемости, отсутствие регрессов по T-states.

Phase 0.3 — Tooling & Stabilization
	•	Аннотированный .a80: пометки якорей/деферов/материализаций.
	•	Улучшение диагностики (-Witer-ref-deopt, -Wanchor-dup-branch).
	•	Примеры/документация (mnist_minimal, screen_demo) переписаны на новый сахар.

Phase 0.4 — Function Pointers & smc_bind 2.0
	•	Мини-спека fun-pointer (u16 addr + опц. sig_id).
	•	Безопасный вызов под @abi(smc) (патч якорей цели) и @abi(slot).
	•	smc_bind для fun-pointers (хранить адрес «варианта» с зашитыми якорями).

Phase 0.5 — Metaprogramming (limited)
	•	Lua-хуки: генерация джамп-таблиц, отчётов, массовых smc_bind вариантов.
	•	Без влияния на рантайм; только build-time.

Phase 0.6 — Concurrency Lite
	•	spawn/yield как чистый сахар в state-machine (без переключения стека).
	•	channel[T,N] как неблокирующий кольцевой буфер (lib + сахар).
	•	select как синтаксис на if try_recv.

Phase 0.7 — Banks/ISR Automation
	•	Авто-using bank[n] над патчами/доступами; пер-контекстные копии кода для ISR.
	•	Правила безопасного imm16 под прерывания.

Phase 1.0 — Generics/Traits (специализация на компайле)
	•	Только специализация (без RTTI/VM); «анти-С» сохраняется.

⸻

🧪 Мини-бенч-контроль (к первому эшелону)
	•	for N..0 против ручного DJNZ — тождественность T-states.
	•	defer → отсутствие лишних вызовов/прыжков.
	•	with → разница от ручного if(A==0) — 0 инструкций.
	•	smc_bind → уменьшение патчей на call-site (x2–x3 по частому кейсу).
	•	&i → компилятор выдаёт варнинг; накладные расходы ~~+1–2 инс/итерацию (запись i_slot).

⸻

💡 Что это даст разработчице уже завтра
	•	Читаемый код уровня Ruby/Crystal/Elixir: именованные аргументы, with, match, defer, «естественные» циклы.
	•	Скорость Z80-асма: DJNZ, иммедиаты внутри функций, ноль стека.
	•	Контроль: отчёты показывают, где якорь, где деоптимизация, где «зашито».

Если согласна с содержимым — могу обновить SPEC/ADR: добавить разделы по Named Args, Error Tuples + with, DJNZ-диапазоны, defer, &i-материализация, smc_bind, SMC-guard, а также включить раздел “First Echelon” и FuturePath как официальный roadmap.