// ZVDB Optimized for MinZ with register hints and lean functions
// Uses new compiler optimizations for better performance

module zvdb_optimized;

// 256-bit vector (32 bytes)
struct Vector256 {
    bits: [u8; 32],
}

// Quantized vector with metadata
struct QuantizedVector {
    vector: Vector256,
    norm: u16,        // Original L2 norm for dequantization
    metadata: u16,    // User metadata (e.g., document ID)
}

// Search result
struct SearchResult {
    index: u16,
    similarity: i16,  // Hamming distance (lower is better)
}

// Vector database page (16KB)
struct VectorPage {
    vectors: [QuantizedVector; 256],  // 256 vectors per page
    count: u16,                       // Number of vectors in page
    next_page: u16,                   // Next page number (0xFFFF = none)
}

// Main vector database structure
struct VectorDB {
    pages: *mut VectorPage,     // Pointer to pages in memory
    num_pages: u16,             // Number of allocated pages
    total_vectors: u16,         // Total vectors in database
    page_map: [u8; 256],        // Page allocation bitmap
}

// Fast Hamming distance using optimized register allocation
// This function will benefit from shadow registers
@inline
@optimize_registers
fun hamming_distance(a: *Vector256, b: *Vector256) -> u8 {
    let mut dist: u8 = 0;
    let mut i: u8 = 0;
    
    // Unroll loop for better performance
    // Compiler will use shadow registers for parallel processing
    while i < 32 {
        let xor1 = a.bits[i] ^ b.bits[i];
        let xor2 = a.bits[i+1] ^ b.bits[i+1];
        let xor3 = a.bits[i+2] ^ b.bits[i+2];
        let xor4 = a.bits[i+3] ^ b.bits[i+3];
        
        dist = dist + popcount(xor1);
        dist = dist + popcount(xor2);
        dist = dist + popcount(xor3);
        dist = dist + popcount(xor4);
        
        i = i + 4;
    }
    
    return dist;
}

// Population count (number of set bits)
// Small function - will have minimal prologue/epilogue
@inline
fun popcount(x: u8) -> u8 {
    let mut count = x;
    count = (count & 0x55) + ((count >> 1) & 0x55);
    count = (count & 0x33) + ((count >> 2) & 0x33);
    count = (count & 0x0F) + ((count >> 4) & 0x0F);
    return count;
}

// Initialize database
pub fun zvdb_init(db: *mut VectorDB, memory: *mut u8, max_pages: u16) -> void {
    db.pages = memory as *mut VectorPage;
    db.num_pages = max_pages;
    db.total_vectors = 0;
    
    // Clear page map
    let mut i: u16 = 0;
    while i < 256 {
        db.page_map[i] = 0;
        i = i + 1;
    }
}

// Add vector to database
// Uses efficient register allocation
pub fun zvdb_add(db: *mut VectorDB, vector: *Vector256, norm: u16, metadata: u16) -> bool {
    // Find page with space
    let page_idx = find_available_page(db);
    if page_idx >= db.num_pages {
        return false;
    }
    
    let page = &db.pages[page_idx];
    if page.count >= 256 {
        return false;
    }
    
    // Add vector
    let idx = page.count;
    page.vectors[idx].vector = *vector;
    page.vectors[idx].norm = norm;
    page.vectors[idx].metadata = metadata;
    
    page.count = page.count + 1;
    db.total_vectors = db.total_vectors + 1;
    
    return true;
}

// Find page with available space
// Simple function - minimal register usage
fun find_available_page(db: *VectorDB) -> u16 {
    let mut i: u16 = 0;
    
    while i < db.num_pages {
        let byte_idx = i >> 3;
        let bit_idx = i & 7;
        
        if (db.page_map[byte_idx] & (1 << bit_idx)) == 0 {
            // Page not full
            let page = &db.pages[i];
            if page.count < 256 {
                return i;
            }
            // Mark as full
            db.page_map[byte_idx] = db.page_map[byte_idx] | (1 << bit_idx);
        }
        i = i + 1;
    }
    
    return 0xFFFF;
}

// Search k-nearest neighbors
// This is the hot path - will benefit from all optimizations
@optimize_registers
pub fun zvdb_search(db: *VectorDB, query: *Vector256, k: u8) -> [SearchResult; 10] {
    let mut results: [SearchResult; 10];
    let mut num_results: u8 = 0;
    
    // Initialize results with worst distance
    let mut i: u8 = 0;
    while i < 10 {
        results[i].similarity = 0x7FFF;
        i = i + 1;
    }
    
    // Search all pages
    let mut page_idx: u16 = 0;
    while page_idx < db.num_pages {
        let page = &db.pages[page_idx];
        
        // Process vectors in page
        let mut vec_idx: u16 = 0;
        while vec_idx < page.count {
            let qvec = &page.vectors[vec_idx];
            
            // Calculate distance
            let dist = hamming_distance(query, &qvec.vector) as i16;
            
            // Insert if better than worst result
            if dist < results[k-1].similarity {
                insert_result(&results, num_results, vec_idx + page_idx * 256, dist);
                if num_results < k {
                    num_results = num_results + 1;
                }
            }
            
            vec_idx = vec_idx + 1;
        }
        
        page_idx = page_idx + 1;
    }
    
    return results;
}

// Insert result in sorted order
// Uses minimal registers for efficiency
fun insert_result(results: *mut [SearchResult; 10], count: u8, index: u16, dist: i16) -> void {
    let mut pos: i8 = count as i8 - 1;
    
    // Find insertion position
    while pos >= 0 && results[pos].similarity > dist {
        if pos < 9 {
            results[pos + 1] = results[pos];
        }
        pos = pos - 1;
    }
    
    // Insert
    if pos < 9 {
        results[pos + 1].index = index;
        results[pos + 1].similarity = dist;
    }
}

// Interrupt handler for DMA completion
// Uses efficient register saving with EXX
@interrupt
@port(0x5B)
fun dma_complete_handler() -> void {
    // Clear interrupt flag
    port_out(0x5B, 0);
    
    // Update DMA status
    let status = port_in(0x5B);
    if (status & 0x80) != 0 {
        // DMA error
        port_out(0x5C, 0xFF);
    }
}

// Fast memory operations using block instructions
@inline
fun fast_copy(dst: *mut u8, src: *u8, len: u16) -> void {
    // This will compile to LDIR instruction
    let mut i: u16 = 0;
    while i < len {
        dst[i] = src[i];
        i = i + 1;
    }
}

// Port I/O functions
@inline
fun port_out(port: u8, value: u8) -> void {
    // Compiler will generate OUT instruction
    *((0xFF00 + port as u16) as *mut u8) = value;
}

@inline 
fun port_in(port: u8) -> u8 {
    // Compiler will generate IN instruction
    return *((0xFF00 + port as u16) as *u8);
}

// Demo usage
fun demo() -> void {
    // Allocate 64KB for vectors (4 pages)
    let memory: [u8; 65536];
    let mut db: VectorDB;
    
    zvdb_init(&db, &memory[0], 4);
    
    // Add some vectors
    let mut vec1: Vector256;
    vec1.bits[0] = 0xAA;
    vec1.bits[1] = 0x55;
    zvdb_add(&db, &vec1, 100, 1);
    
    // Search
    let mut query: Vector256;
    query.bits[0] = 0xAB;
    query.bits[1] = 0x54;
    
    let results = zvdb_search(&db, &query, 5);
    
    // Process results
    let mut i: u8 = 0;
    while i < 5 && results[i].similarity < 0x7FFF {
        let idx = results[i].index;
        let dist = results[i].similarity;
        // Do something with results
        i = i + 1;
    }
}