; MinZ Intermediate Representation (MIR)
; Module: main

Function math.square$u8(x: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r4 = r2 * r3
      3: return r4

Function math.square$u16(x: u16) -> u16
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r4 = r2 * r3
      3: return r4

Function math.cube$u8(x: u8) -> u16
  @smc
  Locals:
    r2 = result: u16
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r5 = r3 * r4
      3: LOAD_PARAM
      4: r7 = r5 * r6
      5: store result, r7
      6: r8 = load result
      7: return r8

Function math.is_even$u8(x: u8) -> bool
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r3 = 1
      2: r4 = r2 & r3
      3: r5 = 0
      4: r6 = r4 == r5
      5: return r6

Function math.is_odd$u8(x: u8) -> bool
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r3 = 1
      2: r4 = r2 & r3
      3: r5 = 1
      4: r6 = r4 == r5
      5: return r6

Function math.clamp$u8$u8$u8(value: u8, min: u8, max: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r6 = r4 < r5
      3: jump_if_not r6, else_1
      4: LOAD_PARAM
      5: return r7
      6: jump end_if_2
      7: else_1:
      8: end_if_2:
      9: LOAD_PARAM
     10: LOAD_PARAM
     11: r10 = r8 > r9
     12: jump_if_not r10, else_3
     13: LOAD_PARAM
     14: return r11
     15: jump end_if_4
     16: else_3:
     17: end_if_4:
     18: LOAD_PARAM
     19: return r12

Function math.gcd$u8$u8(a: u8, b: u8) -> u8
  @smc
  Locals:
    r3 = x: u16
    r5 = y: u16
    r10 = temp: u16
  Instructions:
      0: LOAD_PARAM
      1: store x, r4
      2: LOAD_PARAM
      3: store y, r6
      4: loop_5:
      5: r7 = load y
      6: r8 = 0
      7: r9 = r7 != r8
      8: jump_if_not r9, end_loop_6
      9: r11 = load y
     10: store temp, r11
     11: r12 = load x
     12: r13 = load y
     13: MOD
     14: store y, r14
     15: r15 = load temp
     16: store x, r15
     17: jump loop_5
     18: end_loop_6:
     19: r16 = load x
     20: return r16

Function math.lcm$u8$u8(a: u8, b: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r4 = 0
      2: r5 = r3 == r4
      3: LOAD_PARAM
      4: r7 = 0
      5: r8 = r6 == r7
      6: UNKNOWN_OP_61
      7: jump_if_not r9, else_7
      8: r10 = 0
      9: return r10
     10: jump end_if_8
     11: else_7:
     12: end_if_8:
     13: LOAD_PARAM
     14: LOAD_PARAM
     15: r13 = r11 * r12
     16: LOAD_PARAM
     17: LOAD_PARAM
     18: PATCH_TEMPLATE
     19: PATCH_TARGET
     20: PATCH_PARAM
     21: PATCH_PARAM
     22: r16 = call math.gcd
     23: DIV
     24: return r17

Function math.square$u8(x: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r4 = r2 * r3
      3: return r4

Function math.square$u16(x: u16) -> u16
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r4 = r2 * r3
      3: return r4

Function math.cube$u8(x: u8) -> u16
  @smc
  Locals:
    r2 = result: u16
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r5 = r3 * r4
      3: LOAD_PARAM
      4: r7 = r5 * r6
      5: store result, r7
      6: r8 = load result
      7: return r8

Function math.is_even$u8(x: u8) -> bool
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r3 = 1
      2: r4 = r2 & r3
      3: r5 = 0
      4: r6 = r4 == r5
      5: return r6

Function math.is_odd$u8(x: u8) -> bool
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r3 = 1
      2: r4 = r2 & r3
      3: r5 = 1
      4: r6 = r4 == r5
      5: return r6

Function math.clamp$u8$u8$u8(value: u8, min: u8, max: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: LOAD_PARAM
      2: r6 = r4 < r5
      3: jump_if_not r6, else_9
      4: LOAD_PARAM
      5: return r7
      6: jump end_if_10
      7: else_9:
      8: end_if_10:
      9: LOAD_PARAM
     10: LOAD_PARAM
     11: r10 = r8 > r9
     12: jump_if_not r10, else_11
     13: LOAD_PARAM
     14: return r11
     15: jump end_if_12
     16: else_11:
     17: end_if_12:
     18: LOAD_PARAM
     19: return r12

Function math.gcd$u8$u8(a: u8, b: u8) -> u8
  @smc
  Locals:
    r3 = x: u16
    r5 = y: u16
    r10 = temp: u16
  Instructions:
      0: LOAD_PARAM
      1: store x, r4
      2: LOAD_PARAM
      3: store y, r6
      4: loop_13:
      5: r7 = load y
      6: r8 = 0
      7: r9 = r7 != r8
      8: jump_if_not r9, end_loop_14
      9: r11 = load y
     10: store temp, r11
     11: r12 = load x
     12: r13 = load y
     13: MOD
     14: store y, r14
     15: r15 = load temp
     16: store x, r15
     17: jump loop_13
     18: end_loop_14:
     19: r16 = load x
     20: return r16

Function math.lcm$u8$u8(a: u8, b: u8) -> u8
  @smc
  Instructions:
      0: LOAD_PARAM
      1: r4 = 0
      2: r5 = r3 == r4
      3: LOAD_PARAM
      4: r7 = 0
      5: r8 = r6 == r7
      6: UNKNOWN_OP_61
      7: jump_if_not r9, else_15
      8: r10 = 0
      9: return r10
     10: jump end_if_16
     11: else_15:
     12: end_if_16:
     13: LOAD_PARAM
     14: LOAD_PARAM
     15: r13 = r11 * r12
     16: LOAD_PARAM
     17: LOAD_PARAM
     18: PATCH_TEMPLATE
     19: PATCH_TARGET
     20: PATCH_PARAM
     21: PATCH_PARAM
     22: r16 = call math.gcd
     23: DIV
     24: return r17

Function ...test_module_alias.main() -> void
  @smc
  Locals:
    r2 = x: u8
    r4 = squared: u16
  Instructions:
      0: r0 = call cls ; Clear screen
      1: LOAD_LABEL ; Load string "Module Aliasing Test!"
      2: PRINT ; Print value
      3: r0 = call print_newline ; Print newline
      4: r3 = 7
      5: store x, r3
      6: r5 = load x
      7: PATCH_TEMPLATE
      8: PATCH_TARGET
      9: PATCH_PARAM
     10: r6 = call math.square
     11: store squared, r6
     12: LOAD_LABEL ; Load string "Square of "
     13: PRINT ; Built-in print function
     14: r8 = load x
     15: PRINT ; Built-in print function
     16: LOAD_LABEL ; Load string " = "
     17: PRINT ; Built-in print function
     18: r10 = load squared
     19: PRINT ; Print value
     20: r0 = call print_newline ; Print newline
     21: r11 = 2
     22: r0 = call zx_set_border ; Set border color
     23: LOAD_LABEL ; Load string "PI * 100 = "
     24: PRINT ; Built-in print function
     25: r13 = 0 ; Load constant m.PI_TIMES_100 = 0
     26: PRINT ; Print value
     27: r0 = call print_newline ; Print newline
     28: r14 = 10
     29: r15 = call math.is_even
     30: jump_if_not r15, else_17
     31: LOAD_LABEL ; Load string "10 is even"
     32: PRINT ; Print value
     33: r0 = call print_newline ; Print newline
     34: jump end_if_18
     35: else_17:
     36: end_if_18:
     37: LOAD_LABEL ; Load string "Aliases work perfectly!"
     38: PRINT ; Print value
     39: r0 = call print_newline ; Print newline
     40: return

