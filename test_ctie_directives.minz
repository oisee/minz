// Test Compile-Time Interface Execution directives

// Interface with @execute directive
@execute when const
interface Calculator {
    fun calculate(x: u8, y: u8) -> u16;
}

// Interface with @proof directive
@proof {
    reflexive: compare(a, a) == 0,
    antisymmetric: compare(a, b) == -compare(b, a),
    transitive: compare(a,b) < 0 && compare(b,c) < 0 => compare(a,c) < 0,
}
interface Comparable {
    fun compare(other: Self) -> i8;
}

// Interface with @specialize directive
@specialize for ["Circle", "Rectangle"] threshold: 10
interface Drawable {
    fun draw() -> void;
    fun get_area() -> u16;
}

// Struct with @derive directive
@derive(Serializable) for User {
    strategy: from_fields,
    fields: ["id", "name"],
}
struct User {
    id: u32,
    name: String,
    password: String,  // Not serialized
}

// Function with @execute directive
@execute when const
fun factorial(n: u8) -> u16 {
    if n <= 1 {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

// Interface with @analyze_usage
@analyze_usage {
    if const_ratio > 0.8 -> @execute,
    if type_count <= 2 -> @specialize,
}
interface DataProcessor {
    fun process(data: []u8) -> []u8;
}

// Interface with @compile_time_vtable
@compile_time_vtable {
    when is_const -> execute_now,
    when is_known_type -> inline_always,
    when type_count <= 3 -> generate_switch,
}
interface FastDispatch {
    fun dispatch() -> void;
}

// Test compile-time execution
fun main() -> void {
    // This should be executed at compile time!
    const result = factorial(5);  // Should become: const result = 120
    
    @print("CTIE directives parsed successfully!");
}