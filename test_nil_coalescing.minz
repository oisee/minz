// Test Swift-style nil coalescing operator (??)
// Semantic: function? returns CY flag, ?? provides default for non-CY cases

// Function that might "fail" (return CY flag)
fun try_divide(a: u8, b: u8) -> u8? {
    if b == 0 {
        return Error.DivideByZero;  // CY flag set
    }
    return a / b;  // Normal return, CY flag clear
}

// Function that always succeeds
fun safe_value() -> u8 {
    return 42;
}

fun main() -> void {
    // Traditional approach
    let result1 = try_divide(10, 2);  // Returns 5, CY clear
    let result2 = try_divide(10, 0);  // Returns error, CY set
    
    // With nil coalescing - only applies default when CY is set!
    let safe_result1 = try_divide(10, 2) ?? 0;   // Returns 5 (CY was clear)
    let safe_result2 = try_divide(10, 0) ?? 0;   // Returns 0 (CY was set)
    
    // Can chain with complex expressions
    let complex = try_divide(10, safe_value()) ?? try_divide(20, 4) ?? 99;
    
    // Python-style conditional + nil coalescing
    let smart = (try_divide(a, b) if a > 0 else try_divide(20, 4)) ?? 1;
    
    @print("Safe results: {} {}", safe_result1, safe_result2);
    @print("Complex result: {}", complex);
}